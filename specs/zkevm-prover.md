# zkEVM Prover

<!-- All glossary references in this file. -->

[g-state]: glossary.md#state
[g-zk-fault-proof]: glossary.md#zk-fault-proof

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**

- [Overview](#overview)
- [zkEVM Proof for Target BLocks](#zkevm-proofs-for-target-blocks)
- [the ZK Verifier Contract](#the-zk-verifier-contract)
- [Prover as an RPC](#prover-as-an-rpc-server-)
  - [Protobuf](#protobuf)
- [Summary of Definitions](#summary-of-definitions)
  - [Constants](#constants)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Overview
The Prover is responsible for generating proofs using the [Halo2 proving scheme](https://zcash.github.io/halo2/) 
for target blocks. These proofs provide claims regarding the legitimacy of block data and state transitions. 
And the prover is main feature of the challenge process as a component of challenger.

[ZK fault proof][g-zk-fault-proof] that states that a [state][g-state] transition from `S` to
`S'` is valid. It sounds like there are no big differences from validity proofs. That's true. But the point is this is used
to prove the state transition `S` to `S''` is wrong by showing a valid state transition `S` to `S'`.


## ZKEVM Proofs for Target Blocks:
In the context of the EVM, which is regarded as a Turing machine, the generation of proofs requires demonstrating the 
execution of Opcode operations in arbitrary order. These proofs serve as evidence of computation for the EVM. 
Additionally, validating the block data's integrity involves proving sub-operations such as Merkle Patricia Trie 
and ECDSA verification.
To support the proof generation process for target blocks, [zkevm-circuits](https://github.com/kroma-network/zkevm-circuits) 
offer circuits capable of proving the required sub-operations. These circuits provide the means to prove the integrity 
and validity of the block data. By combining these circuits, the Prover completes the overall validity proof for the 
target block.  
See [zkevm-specs](https://github.com/kroma-network/zkevm-specs) for details about the statements claimed by the zk-proof.

## The ZK Verifier Contract
The proofs generated by the Prover can be verified through a Verifier contract that includes the following interface. 
The challenge process is implemented using the `verify` function provided by the Verifier contract.

```solidity
interface ZKVerifier {
    function verify(
        uint256[] calldata proof,
        uint256[] calldata target_circuit_final_pair
    ) public view returns (bool);
}
```

## Prover as an RPC Server 

[kroma-prover](https://github.com/kroma-network/kroma-prover) is implemented as a gRPC server that generates zkevm 
proofs for the requested height block. It can be utilized as a local component on the Challenger's machine 
or as a remote [gRPC](https://grpc.io/) server (prover as a service).
- Step 1:  The user (e.g., Challenger) requests a zkevm-proof for a block of specific height to kroma-prover with 
desired block height value. 
- Step 2: The kroma-prover obtains the trace of the corresponding block from kroma-geth RPC.  
- Step 3: And then the kroma-prover generates zkevm-proof for target block, and return it to the User.    

Operating the grpc-kroma-prover, which is launched only when necessary, can alleviate the situation where 
regular validators and challengers need to allocate excessive system resources due to the proof generation process 
that is occasionally executed (perhaps rarely executed)

### Protobuf
The detailed gRPC specification can be available at [prover-grpc-proto](https://github.com/kroma-network/prover-grpc-proto).

## Summary of Definitions

### Constants

| Name               | Value | Unit    |
| ------------------ | ----- | ------- |
| `FETCHING_TIMEOUT` | TBD   | seconds |
