// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

/**
 * @title Types
 * @notice Contains various types used throughout the Kroma contract system.
 */
library Types {
    /**
     * @notice CheckpointOutput represents a commitment to the state of L2 checkpoint. The timestamp
     *         is the L1 timestamp that the output root is posted. This timestamp is used to verify
     *         that the finalization period has passed since the output root was submitted.
     *
     * @custom:field submitter     Address of the output submitter.
     * @custom:field outputRoot    Hash of the L2 output.
     * @custom:field timestamp     Timestamp of the L1 block that the output root was submitted in.
     * @custom:field l2BlockNumber L2 block number that the output corresponds to.
     */
    struct CheckpointOutput {
        address submitter;
        bytes32 outputRoot;
        uint128 timestamp;
        uint128 l2BlockNumber;
    }

    /**
     * @notice Struct representing the elements that are hashed together to generate an output root
     *         which itself represents a snapshot of the L2 state.
     *
     * @custom:field version                  Version of the output root.
     * @custom:field stateRoot                Root of the state trie at the block of this output.
     * @custom:field messagePasserStorageRoot Root of the message passer storage trie.
     * @custom:field latestBlockhash          Hash of the block this output was generated from.
     * @custom:field nextBlockHash            Hash of the next block. Note that it is only included in KromaOutputV0.
     */
    struct OutputRootProof {
        bytes32 version;
        bytes32 stateRoot;
        bytes32 messagePasserStorageRoot;
        bytes32 latestBlockhash;
        bytes32 nextBlockHash;
    }

    /**
     * @notice Struct representing the elements that are hashed together to generate a public input
     *         for zkEVM proof.
     *
     * @custom:field blockHash        The hash of the block.
     * @custom:field parentHash       The hash of the previous block.
     * @custom:field timestamp        The block time.
     * @custom:field number           The block number.
     * @custom:field gasLimit         Maximum gas allowed.
     * @custom:field baseFee          The base fee per gas.
     * @custom:field transactionsRoot Root hash of the transactions.
     * @custom:field stateRoot        Root hash of the state trie.
     * @custom:field withdrawalsRoot  Root hash of the withdrawals.
     * @custom:field txHashes         Array of hash of the transaction.
     * @custom:field blobGasUsed      The total amount of blob gas consumed by the transactions within the block.
     * @custom:field excessBlobGas    A total of blob gas consumed in excess of the target, prior to the block.
     * @custom:field parentBeaconRoot Root hash of the parent beacon block.
     */
    struct PublicInput {
        bytes32 blockHash;
        bytes32 parentHash;
        uint64 timestamp;
        uint64 number;
        uint64 gasLimit;
        uint256 baseFee;
        bytes32 transactionsRoot;
        bytes32 stateRoot;
        bytes32 withdrawalsRoot;
        bytes32[] txHashes;
        uint64 blobGasUsed;
        uint64 excessBlobGas;
        bytes32 parentBeaconRoot;
    }

    /**
     * @notice Struct representing the elements that are hashed together to generate a block hash.
     *         Some of fields that are contained in PublicInput are omitted.
     *
     * @custom:field uncleHash    RLP encoded uncle hash.
     * @custom:field coinbase     RLP encoded coinbase.
     * @custom:field receiptsRoot RLP encoded receipts root.
     * @custom:field logsBloom    RLP encoded logs bloom.
     * @custom:field difficulty   RLP encoded difficulty.
     * @custom:field gasUsed      RLP encoded gas used.
     * @custom:field extraData    RLP encoded extra data.
     * @custom:field mixHash      RLP encoded mix hash.
     * @custom:field nonce        RLP encoded nonce.
     */
    struct BlockHeaderRLP {
        bytes uncleHash;
        bytes coinbase;
        bytes receiptsRoot;
        bytes logsBloom;
        bytes difficulty;
        bytes gasUsed;
        bytes extraData;
        bytes mixHash;
        bytes nonce;
    }

    /**
     * @notice Struct representing a deposit transaction (L1 => L2 transaction) created by an end
     *         user (as opposed to a system deposit transaction generated by the system).
     *
     * @custom:field from        Address of the sender of the transaction.
     * @custom:field to          Address of the recipient of the transaction.
     * @custom:field isCreation  True if the transaction is a contract creation.
     * @custom:field value       Value to send to the recipient.
     * @custom:field mint        Amount of ETH to mint.
     * @custom:field gasLimit    Gas limit of the transaction.
     * @custom:field data        Data of the transaction.
     * @custom:field l1BlockHash Hash of the block the transaction was submitted in.
     * @custom:field logIndex    Index of the log in the block the transaction was submitted in.
     */
    struct UserDepositTransaction {
        address from;
        address to;
        bool isCreation;
        uint256 value;
        uint256 mint;
        uint64 gasLimit;
        bytes data;
        bytes32 l1BlockHash;
        uint64 logIndex;
    }

    /**
     * @notice Struct representing a withdrawal transaction.
     *
     * @custom:field nonce    Nonce of the withdrawal transaction
     * @custom:field sender   Address of the sender of the transaction.
     * @custom:field target   Address of the recipient of the transaction.
     * @custom:field value    Value to send to the recipient.
     * @custom:field gasLimit Gas limit of the transaction.
     * @custom:field data     Data of the transaction.
     */
    struct WithdrawalTransaction {
        uint256 nonce;
        address sender;
        address target;
        uint256 value;
        uint256 gasLimit;
        bytes data;
    }

    /**
     * @notice Struct representing a challenge.
     *
     * @custom:field turn       The current turn.
     * @custom:field timeoutAt  Timeout timestamp of the next turn.
     * @custom:field asserter   Address of the asserter.
     * @custom:field challenger Address of the challenger.
     * @custom:field segments   Array of the segment.
     * @custom:field segStart   The L2 block number of the first segment.
     * @custom:field segSize    The number of L2 blocks.
     * @custom:field l1Head     Parent L1 block hash at the challenge creation time.
     */
    struct Challenge {
        uint8 turn;
        uint64 timeoutAt;
        address asserter;
        address challenger;
        bytes32[] segments;
        uint256 segSize;
        uint256 segStart;
        bytes32 l1Head;
    }

    /**
     * @notice Struct representing a validator's bond.
     *
     * @custom:field amount    Amount of the lock.
     * @custom:field expiresAt The expiration timestamp of bond.
     */
    struct Bond {
        uint128 amount;
        uint128 expiresAt;
    }

    /**
     * @notice Struct representing multisig transaction data.
     *
     * @custom:field target   The destination address to run the transaction.
     * @custom:field executed Record whether a transaction was executed or not.
     * @custom:field value    The value passed in while executing the transaction.
     * @custom:field data     Calldata for transaction.
     */
    struct MultiSigTransaction {
        address target;
        bool executed;
        uint256 value;
        bytes data;
    }

    /**
     * @notice Struct representing multisig confirmation data.
     *
     * @custom:field confirmationCount The sum of confirmations.
     * @custom:field confirmedBy       Map data that stores whether confirmation is performed by account.
     */
    struct MultiSigConfirmation {
        uint256 confirmationCount;
        mapping(address => bool) confirmedBy;
    }

    /**
     * @notice Struct representing the data for verifying the public input of zkEVM proof.
     *
     * @custom:field srcOutputRootProof          Proof of the source output root.
     * @custom:field dstOutputRootProof          Proof of the destination output root.
     * @custom:field publicInput                 Ingredients to compute the public input used by
     *                                           zkEVM proof verification.
     * @custom:field rlps                        Pre-encoded RLPs to compute the next block hash
     *                                           of the source output root proof.
     * @custom:field l2ToL1MessagePasserBalance  Balance of the L2ToL1MessagePasser account.
     * @custom:field l2ToL1MessagePasserCodeHash Codehash of the L2ToL1MessagePasser account.
     * @custom:field merkleProof                 Merkle proof of L2ToL1MessagePasser account against the state root.
     */
    struct PublicInputProof {
        OutputRootProof srcOutputRootProof;
        OutputRootProof dstOutputRootProof;
        PublicInput publicInput;
        BlockHeaderRLP rlps;
        bytes32 l2ToL1MessagePasserBalance;
        bytes32 l2ToL1MessagePasserCodeHash;
        bytes[] merkleProof;
    }

    /**
     * @notice Struct representing zkEVM public input and proof.
     *
     * @param publicInputProof Data for verifying the public input.
     * @param proof            Halo2 proofs composed of points and scalars.
     *                         See https://zcash.github.io/halo2/design/implementation/proofs.html.
     * @param pair             Aggregated multi-opening proofs and public inputs.
     *                         (Currently only 2 public inputs)
     */
    struct ZkEvmProof {
        PublicInputProof publicInputProof;
        uint256[] proof;
        uint256[] pair;
    }

    /**
     * @notice Struct representing zkVM public input and proof.
     *
     * @param zkVmProgramVKey The verification key for the zkVM program.
     * @param publicValues    The public values concatenated.
     *                        (Currently 3 public inputs: bytes32 srcOutputRoot, bytes32 dstOutputRoot, bytes32 l1Head)
     * @param proofBytes      The proof of the program execution the SP1 zkVM encoded as bytes.
     */
    struct ZkVmProof {
        bytes32 zkVmProgramVKey;
        bytes publicValues;
        bytes proofBytes;
    }
}
