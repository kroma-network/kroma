{
  "language": "Solidity",
  "sources": {
    "contracts/L1/Colosseum.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { IZKMerkleTrie } from \"./IZKMerkleTrie.sol\";\nimport { L2OutputOracle } from \"./L2OutputOracle.sol\";\nimport { SecurityCouncil } from \"./SecurityCouncil.sol\";\nimport { ZKVerifier } from \"./ZKVerifier.sol\";\n\ncontract Colosseum is Initializable, Semver {\n    /**\n     * @notice The constant value for the first turn.\n     */\n    uint8 internal constant TURN_INIT = 1;\n\n    /**\n     * @notice The constant value for the delete output root.\n     */\n    bytes32 internal constant DELETED_OUTPUT_ROOT = bytes32(0);\n\n    /**\n     * @notice Enum of the challenge status.\n     *\n     * See the https://github.com/kroma-network/kroma/blob/dev/specs/challenge.md#state-diagram\n     * for more details.\n     *\n     * Belows are possible state transitions at current implementation.\n     *\n     *  1) NONE               → createChallenge()                   → ASSERTER_TURN\n     *  2) ASSERTER_TURN      → bisect()                            → CHALLENGER_TURN\n     *  3) ASSERTER_TURN      → on bisection timeout                → ASSERTER_TIMEOUT\n     *  4) CHALLENGER_TURN    → bisect()                            → ASSERTER_TURN\n     *  5) CHALLENGER_TURN    → when isAbleToBisect() returns false → READY_TO_PROVE\n     *  6) CHALLENGER_TURN    → on bisection timeout                → CHALLENGER_TIMEOUT\n     *  7) ASSERTER_TIMEOUT   → when proveFault() succeeds          → NONE\n     *  8) ASSERTER_TIMEOUT   → on proving timeout                  → CHALLENGER_TIMEOUT\n     *  9) READY_TO_PROVE     → when proveFault() succeeds          → NONE\n     * 10) READY_TO_PROVE     → on proving timeout                  → CHALLENGER_TIMEOUT\n     * 11) CHALLENGER_TIMEOUT → challengerTimeout()                 → NONE\n     */\n    enum ChallengeStatus {\n        NONE,\n        CHALLENGER_TURN,\n        ASSERTER_TURN,\n        CHALLENGER_TIMEOUT,\n        ASSERTER_TIMEOUT,\n        READY_TO_PROVE\n    }\n\n    /**\n     * @notice Address of the L2OutputOracle.\n     */\n    L2OutputOracle public immutable L2_ORACLE;\n\n    /**\n     * @notice Address of the ZKVerifier.\n     */\n    ZKVerifier public immutable ZK_VERIFIER;\n\n    /**\n     * @notice The period seconds for which challenges can be created per each output.\n     */\n    uint256 public immutable CREATION_PERIOD_SECONDS;\n\n    /**\n     * @notice Timeout seconds for the bisection.\n     */\n    uint256 public immutable BISECTION_TIMEOUT;\n\n    /**\n     * @notice Timeout seconds for the proving.\n     */\n    uint256 public immutable PROVING_TIMEOUT;\n\n    /**\n     * @notice The interval in L2 blocks at which checkpoints must be\n     *         submitted on L2OutputOracle contract.\n     */\n    uint256 public immutable L2_ORACLE_SUBMISSION_INTERVAL;\n\n    /**\n     * @notice The dummy transaction hash. This is used to pad if the\n     *         number of transactions is less than MAX_TXS. This is same as:\n     *         unsignedTx = {\n     *           nonce: 0,\n     *           gasLimit: 0,\n     *           gasPrice: 0,\n     *           to: address(0),\n     *           value: 0,\n     *           data: '0x',\n     *           chainId: CHAIN_ID,\n     *         }\n     *         signature = sign(unsignedTx, 0x1)\n     *         dummyHash = keccak256(rlp({\n     *           ...unsignedTx,\n     *           signature,\n     *         }))\n     */\n    bytes32 public immutable DUMMY_HASH;\n\n    /**\n     * @notice The maximum number of transactions\n     */\n    uint256 public immutable MAX_TXS;\n\n    /**\n     * @notice Address that has the ability to approve the challenge.\n     */\n    address public immutable SECURITY_COUNCIL;\n\n    /**\n     * @notice Address that has the ability to verify the merkle proof.\n     */\n    address public immutable ZK_MERKLE_TRIE;\n\n    /**\n     * @notice Length of segment array for each turn.\n     */\n    mapping(uint256 => uint256) internal segmentsLengths;\n\n    /**\n     * @notice A mapping of the challenge.\n     */\n    mapping(uint256 => mapping(address => Types.Challenge)) public challenges;\n\n    /**\n     * @notice A mapping indicating whether a public input is verified or not.\n     */\n    mapping(bytes32 => bool) public verifiedPublicInputs;\n\n    /**\n     * @notice Emitted when the challenge is created.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param asserter    Address of the asserter.\n     * @param challenger  Address of the challenger.\n     * @param timestamp   The timestamp when created.\n     */\n    event ChallengeCreated(\n        uint256 indexed outputIndex,\n        address indexed asserter,\n        address indexed challenger,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Emitted when segments are bisected.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param challenger  Address of the challenger.\n     * @param turn        The current turn.\n     * @param timestamp   The timestamp when bisected.\n     */\n    event Bisected(\n        uint256 indexed outputIndex,\n        address indexed challenger,\n        uint8 turn,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Emitted when it is ready to be proved.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param challenger  Address of the challenger.\n     */\n    event ReadyToProve(uint256 indexed outputIndex, address indexed challenger);\n\n    /**\n     * @notice Emitted when proven fault.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param challenger  Address of the challenger.\n     * @param timestamp   The timestamp when proven.\n     */\n    event Proven(uint256 indexed outputIndex, address indexed challenger, uint256 timestamp);\n\n    /**\n     * @notice Emitted when challenge is dismissed.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param challenger  Address of the challenger.\n     * @param timestamp   The timestamp when dismissed.\n     */\n    event ChallengeDismissed(\n        uint256 indexed outputIndex,\n        address indexed challenger,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Emitted when challenge is canceled.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param challenger  Address of the challenger.\n     * @param timestamp   The timestamp when canceled.\n     */\n    event ChallengeCanceled(\n        uint256 indexed outputIndex,\n        address indexed challenger,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Emitted when challenger timed out.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param challenger  Address of the challenger.\n     * @param timestamp   The timestamp when deleted.\n     */\n    event ChallengerTimedOut(\n        uint256 indexed outputIndex,\n        address indexed challenger,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice A modifier that only allows the security council to call\n     */\n    modifier onlySecurityCouncil() {\n        require(msg.sender == SECURITY_COUNCIL, \"Colosseum: sender is not the security council\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the output of given index is already finalized.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     */\n    modifier outputNotFinalized(uint256 _outputIndex) {\n        require(\n            !L2_ORACLE.isFinalized(_outputIndex),\n            \"Colosseum: cannot progress challenge process about already finalized output\"\n        );\n        _;\n    }\n\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _l2Oracle              Address of the L2OutputOracle contract.\n     * @param _zkVerifier            Address of the ZKVerifier contract.\n     * @param _submissionInterval    Interval in blocks at which checkpoints must be submitted.\n     * @param _creationPeriodSeconds Seconds The period seconds for which challenges can be created per each output.\n     * @param _bisectionTimeout      Timeout seconds for the bisection.\n     * @param _provingTimeout        Timeout seconds for the proving.\n     * @param _dummyHash             Dummy hash.\n     * @param _maxTxs                Number of max transactions per block.\n     * @param _segmentsLengths       Lengths of segments.\n     * @param _securityCouncil       Address of security council.\n     * @param _zkMerkleTrie          Address of zk merkle trie.\n     */\n    constructor(\n        L2OutputOracle _l2Oracle,\n        ZKVerifier _zkVerifier,\n        uint256 _submissionInterval,\n        uint256 _creationPeriodSeconds,\n        uint256 _bisectionTimeout,\n        uint256 _provingTimeout,\n        bytes32 _dummyHash,\n        uint256 _maxTxs,\n        uint256[] memory _segmentsLengths,\n        address _securityCouncil,\n        address _zkMerkleTrie\n    ) Semver(0, 1, 0) {\n        L2_ORACLE = _l2Oracle;\n        ZK_VERIFIER = _zkVerifier;\n        CREATION_PERIOD_SECONDS = _creationPeriodSeconds;\n        BISECTION_TIMEOUT = _bisectionTimeout;\n        PROVING_TIMEOUT = _provingTimeout;\n        L2_ORACLE_SUBMISSION_INTERVAL = _submissionInterval;\n        DUMMY_HASH = _dummyHash;\n        MAX_TXS = _maxTxs;\n        SECURITY_COUNCIL = _securityCouncil;\n        ZK_MERKLE_TRIE = _zkMerkleTrie;\n        initialize(_segmentsLengths);\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize(uint256[] memory _segmentsLengths) public initializer {\n        _setSegmentsLengths(_segmentsLengths);\n    }\n\n    /**\n     * @notice Creates a challenge against an invalid output.\n     *\n     * @param _outputIndex   Index of the invalid L2 checkpoint output.\n     * @param _l1BlockHash   The block hash of L1 at the time the output L2 block was created.\n     * @param _l1BlockNumber The block number of L1 with the specified L1 block hash.\n     * @param _segments      Array of the segment. A segment is the first output root of a specific range.\n     */\n    function createChallenge(\n        uint256 _outputIndex,\n        bytes32 _l1BlockHash,\n        uint256 _l1BlockNumber,\n        bytes32[] calldata _segments\n    ) external outputNotFinalized(_outputIndex) {\n        require(_outputIndex > 0, \"Colosseum: challenge for genesis output is not allowed\");\n\n        Types.Challenge storage challenge = challenges[_outputIndex][msg.sender];\n\n        if (challenge.turn >= TURN_INIT) {\n            ChallengeStatus status = _challengeStatus(challenge);\n            require(\n                status == ChallengeStatus.CHALLENGER_TIMEOUT,\n                \"Colosseum: the challenge for given output index is already in progress\"\n            );\n\n            _challengerTimeout(_outputIndex, msg.sender);\n        }\n\n        Types.CheckpointOutput memory targetOutput = L2_ORACLE.getL2Output(_outputIndex);\n\n        require(\n            targetOutput.timestamp + CREATION_PERIOD_SECONDS >= block.timestamp,\n            \"Colosseum: cannot create a challenge after the creation period\"\n        );\n\n        require(\n            targetOutput.outputRoot != DELETED_OUTPUT_ROOT,\n            \"Colosseum: challenge for deleted output is not allowed\"\n        );\n\n        require(\n            msg.sender != targetOutput.submitter,\n            \"Colosseum: the asserter and challenger must be different\"\n        );\n\n        if (_l1BlockHash != bytes32(0) && blockhash(_l1BlockNumber) != bytes32(0)) {\n            // Like L2OutputOracle, it reverts transactions when L1 reorged.\n            require(\n                blockhash(_l1BlockNumber) == _l1BlockHash,\n                \"Colosseum: block hash does not match the hash at the expected height\"\n            );\n        }\n\n        Types.CheckpointOutput memory prevOutput = L2_ORACLE.getL2Output(_outputIndex - 1);\n\n        // If the previous output has been deleted, the first segment will not be compared with the previous output.\n        if (prevOutput.outputRoot == DELETED_OUTPUT_ROOT) {\n            _validateSegments(TURN_INIT, _segments[0], targetOutput.outputRoot, _segments);\n        } else {\n            _validateSegments(TURN_INIT, prevOutput.outputRoot, targetOutput.outputRoot, _segments);\n        }\n\n        L2_ORACLE.VALIDATOR_POOL().addPendingBond(_outputIndex, msg.sender);\n\n        _updateSegments(\n            challenge,\n            _segments,\n            targetOutput.l2BlockNumber - L2_ORACLE_SUBMISSION_INTERVAL,\n            L2_ORACLE_SUBMISSION_INTERVAL\n        );\n        challenge.turn = TURN_INIT;\n        challenge.asserter = targetOutput.submitter;\n        challenge.challenger = msg.sender;\n        _updateTimeout(challenge);\n\n        emit ChallengeCreated(_outputIndex, targetOutput.submitter, msg.sender, block.timestamp);\n    }\n\n    /**\n     * @notice Selects an invalid section and submit segments of that section.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _challenger  Address of the challenger.\n     * @param _pos         Position of the last valid segment.\n     * @param _segments    Array of the segment. A segment is the first output root of a specific range.\n     */\n    function bisect(\n        uint256 _outputIndex,\n        address _challenger,\n        uint256 _pos,\n        bytes32[] calldata _segments\n    ) external outputNotFinalized(_outputIndex) {\n        Types.Challenge storage challenge = challenges[_outputIndex][_challenger];\n        ChallengeStatus status = _challengeStatus(challenge);\n\n        if (_cancelIfOutputDeleted(_outputIndex, challenge.challenger, status)) {\n            return;\n        }\n\n        address expectedSender;\n        if (status == ChallengeStatus.CHALLENGER_TURN) {\n            expectedSender = challenge.challenger;\n        } else if (status == ChallengeStatus.ASSERTER_TURN) {\n            expectedSender = challenge.asserter;\n        }\n        require(msg.sender == expectedSender, \"Colosseum: not your turn\");\n\n        uint8 newTurn = challenge.turn + 1;\n\n        _validateSegments(\n            newTurn,\n            challenge.segments[_pos],\n            challenge.segments[_pos + 1],\n            _segments\n        );\n\n        uint256 segSize = _nextSegSize(challenge);\n        uint256 segStart = challenge.segStart + _pos * segSize;\n\n        _updateSegments(challenge, _segments, segStart, segSize);\n\n        challenge.turn = newTurn;\n        _updateTimeout(challenge);\n\n        emit Bisected(_outputIndex, _challenger, newTurn, block.timestamp);\n\n        if (!_isAbleToBisect(challenge)) {\n            emit ReadyToProve(_outputIndex, _challenger);\n        }\n    }\n\n    /**\n     * @notice Proves that a specific output is invalid using ZKP.\n     *         This function can only be called in the READY_TO_PROVE and ASSERTER_TIMEOUT states.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _pos         Position of the last valid segment.\n     * @param _proof       Proof for public input validation.\n     * @param _zkproof     Halo2 proofs composed of points and scalars.\n     *                     See https://zcash.github.io/halo2/design/implementation/proofs.html.\n     * @param _pair        Aggregated multi-opening proofs and public inputs. (Currently only 2 public inputs)\n     */\n    function proveFault(\n        uint256 _outputIndex,\n        uint256 _pos,\n        Types.PublicInputProof calldata _proof,\n        uint256[] calldata _zkproof,\n        uint256[] calldata _pair\n    ) external outputNotFinalized(_outputIndex) {\n        Types.Challenge storage challenge = challenges[_outputIndex][msg.sender];\n        ChallengeStatus status = _challengeStatus(challenge);\n\n        if (_cancelIfOutputDeleted(_outputIndex, challenge.challenger, status)) {\n            return;\n        }\n\n        require(\n            status == ChallengeStatus.READY_TO_PROVE || status == ChallengeStatus.ASSERTER_TIMEOUT,\n            \"Colosseum: impossible to prove the fault in current status\"\n        );\n\n        bytes32 srcOutputRoot = Hashing.hashOutputRootProof(_proof.srcOutputRootProof);\n        bytes32 dstOutputRoot = Hashing.hashOutputRootProof(_proof.dstOutputRootProof);\n\n        _validateOutputRootProof(\n            _pos,\n            challenge,\n            srcOutputRoot,\n            dstOutputRoot,\n            _proof.srcOutputRootProof,\n            _proof.dstOutputRootProof\n        );\n        _validatePublicInput(\n            _proof.srcOutputRootProof,\n            _proof.dstOutputRootProof,\n            _proof.publicInput,\n            _proof.rlps\n        );\n        _validateWithdrawalStorageRoot(\n            _proof.merkleProof,\n            _proof.l2ToL1MessagePasserBalance,\n            _proof.l2ToL1MessagePasserCodeHash,\n            _proof.dstOutputRootProof.messagePasserStorageRoot,\n            _proof.dstOutputRootProof.stateRoot\n        );\n\n        bytes32 publicInputHash = _hashPublicInput(\n            _proof.srcOutputRootProof.stateRoot,\n            _proof.publicInput\n        );\n\n        require(\n            !verifiedPublicInputs[publicInputHash],\n            \"Colosseum: public input that has already been validated cannot be used again\"\n        );\n\n        require(ZK_VERIFIER.verify(_zkproof, _pair, publicInputHash), \"Colosseum: invalid proof\");\n        emit Proven(_outputIndex, msg.sender, block.timestamp);\n\n        // Scope to call the security council, to avoid stack too deep.\n        {\n            Types.CheckpointOutput memory output = L2_ORACLE.getL2Output(_outputIndex);\n\n            bytes memory callbackData = abi.encodeWithSelector(\n                this.dismissChallenge.selector,\n                _outputIndex,\n                msg.sender,\n                challenge.asserter,\n                output.outputRoot,\n                publicInputHash\n            );\n\n            // Request outputRoot validation to security council\n            SecurityCouncil(SECURITY_COUNCIL).requestValidation(\n                output.outputRoot,\n                output.l2BlockNumber,\n                callbackData\n            );\n        }\n\n        verifiedPublicInputs[publicInputHash] = true;\n        delete challenges[_outputIndex][msg.sender];\n\n        // Delete output root.\n        L2_ORACLE.replaceL2Output(_outputIndex, DELETED_OUTPUT_ROOT, msg.sender);\n        // The challenger's bond is also included in the bond for that output.\n        L2_ORACLE.VALIDATOR_POOL().increaseBond(_outputIndex, msg.sender);\n    }\n\n    /**\n     * @notice Calls a private function that deletes the challenge because the challenger has timed out.\n     *         Reverts if the challenger hasn't timed out.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _challenger  Address of the challenger.\n     */\n    function challengerTimeout(uint256 _outputIndex, address _challenger) external {\n        Types.Challenge storage challenge = challenges[_outputIndex][_challenger];\n        ChallengeStatus status = _challengeStatus(challenge);\n\n        require(\n            status == ChallengeStatus.CHALLENGER_TIMEOUT,\n            \"Colosseum: can only be called if the challenger is in timout\"\n        );\n\n        _challengerTimeout(_outputIndex, _challenger);\n    }\n\n    /**\n     * @notice Cancels the challenge.\n     *         Reverts if is not possible to cancel the sender's challenge for the given output index.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     */\n    function cancelChallenge(uint256 _outputIndex) external {\n        Types.Challenge storage challenge = challenges[_outputIndex][msg.sender];\n        ChallengeStatus status = _challengeStatus(challenge);\n\n        require(status != ChallengeStatus.NONE, \"Colosseum: the challenge does not exist\");\n\n        require(\n            _cancelIfOutputDeleted(_outputIndex, challenge.challenger, status),\n            \"Colosseum: challenge cannot be cancelled\"\n        );\n    }\n\n    /**\n     * @notice Dismisses the challenge and rollback l2 output.\n     *         This function can only be called by Security Council contract.\n     *\n     * @param _outputIndex      Index of the L2 checkpoint output.\n     * @param _challenger       Address of the challenger.\n     * @param _asserter         Address of the asserter.\n     * @param _outputRoot       The L2 output root to rollback.\n     * @param _publicInputHash  Hash of public input.\n     */\n    function dismissChallenge(\n        uint256 _outputIndex,\n        address _challenger,\n        address _asserter,\n        bytes32 _outputRoot,\n        bytes32 _publicInputHash\n    ) external onlySecurityCouncil {\n        require(\n            _outputRoot != DELETED_OUTPUT_ROOT,\n            \"Colosseum: cannot rollback output to zero hash\"\n        );\n        require(\n            L2_ORACLE.getL2Output(_outputIndex).outputRoot == DELETED_OUTPUT_ROOT,\n            \"Colosseum: only can rollback if the output has been deleted\"\n        );\n        verifiedPublicInputs[_publicInputHash] = false;\n\n        // Rollback output root.\n        L2_ORACLE.replaceL2Output(_outputIndex, _outputRoot, _asserter);\n\n        emit ChallengeDismissed(_outputIndex, _challenger, block.timestamp);\n    }\n\n    /**\n     * @notice Deletes the L2 output root forcefully by the Security Council\n     *         when zk-proving is not possible due to an undeniable bug.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     */\n    function forceDeleteOutput(uint256 _outputIndex)\n        external\n        onlySecurityCouncil\n        outputNotFinalized(_outputIndex)\n    {\n        // Check if the output is deleted.\n        Types.CheckpointOutput memory output = L2_ORACLE.getL2Output(_outputIndex);\n        require(\n            output.outputRoot != DELETED_OUTPUT_ROOT,\n            \"Colosseum: the output has already been deleted\"\n        );\n\n        // Delete output root.\n        L2_ORACLE.replaceL2Output(_outputIndex, DELETED_OUTPUT_ROOT, SECURITY_COUNCIL);\n    }\n\n    /**\n     * @notice Reverts if the given segments are invalid.\n     *\n     * @param _turn      The current turn.\n     * @param _prevFirst The first segment of previous turn.\n     * @param _prevLast  The last segment of previous turn.\n     * @param _segments  Array of the segment.\n     */\n    function _validateSegments(\n        uint8 _turn,\n        bytes32 _prevFirst,\n        bytes32 _prevLast,\n        bytes32[] memory _segments\n    ) private view {\n        uint256 segLen = _segments.length;\n\n        require(getSegmentsLength(_turn) == segLen, \"Colosseum: invalid segments length\");\n        require(_prevFirst == _segments[0], \"Colosseum: the first segment must be matched\");\n        require(\n            _prevLast != _segments[segLen - 1],\n            \"Colosseum: the last segment must not be matched\"\n        );\n    }\n\n    /**\n     * @notice Updates the segment information for a given challenge.\n     *\n     * @param _challenge The challenge data.\n     * @param _segments  Array of the segment.\n     * @param _segStart  The L2 block number of the first segment.\n     * @param _segSize   The number of L2 blocks.\n     */\n    function _updateSegments(\n        Types.Challenge storage _challenge,\n        bytes32[] memory _segments,\n        uint256 _segStart,\n        uint256 _segSize\n    ) private {\n        _challenge.segments = _segments;\n        _challenge.segStart = _segStart;\n        _challenge.segSize = _segSize;\n    }\n\n    /**\n     * @notice Updates timestamp of the challenge timeout.\n     *\n     * @param _challenge The challenge data to update.\n     */\n    function _updateTimeout(Types.Challenge storage _challenge) private {\n        if (!_isAbleToBisect(_challenge)) {\n            _challenge.timeoutAt = uint64(block.timestamp + PROVING_TIMEOUT);\n        } else {\n            _challenge.timeoutAt = uint64(block.timestamp + BISECTION_TIMEOUT);\n        }\n    }\n\n    /**\n     * @notice Validates and updates the lengths of segments.\n     *\n     * @param _segmentsLengths Lengths of segments.\n     */\n    function _setSegmentsLengths(uint256[] memory _segmentsLengths) private {\n        // _segmentsLengths length should be an even number in order to let challenger submit\n        // invalidity proof at the last turn.\n        require(\n            _segmentsLengths.length % 2 == 0,\n            \"Colosseum: length of segments lengths cannot be odd number\"\n        );\n\n        uint256 sum = 1;\n        for (uint256 i = 0; i < _segmentsLengths.length; ) {\n            segmentsLengths[i] = _segmentsLengths[i];\n            sum = sum * (_segmentsLengths[i] - 1);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        require(sum == L2_ORACLE_SUBMISSION_INTERVAL, \"Colosseum: invalid segments lengths\");\n    }\n\n    /**\n     * @notice Checks if the L2ToL1MesagePasser account is included in the given state root.\n     *\n     * @param _merkleProof                 Merkle proof of L2ToL1MessagePasser account against the state root.\n     * @param _l2ToL1MessagePasserBalance  Balance of the L2ToL1MessagePasser account.\n     * @param _l2ToL1MessagePasserCodeHash Codehash of the L2ToL1MessagePasser account.\n     * @param _messagePasserStorageRoot    Storage root of the L2ToL1MessagePasser account.\n     * @param _stateRoot                   State root.\n     */\n    function _validateWithdrawalStorageRoot(\n        bytes[] calldata _merkleProof,\n        bytes32 _l2ToL1MessagePasserBalance,\n        bytes32 _l2ToL1MessagePasserCodeHash,\n        bytes32 _messagePasserStorageRoot,\n        bytes32 _stateRoot\n    ) private view {\n        // TODO(chokobole): Can we fix the codeHash?\n        bytes memory l2ToL1MessagePasserAccount = abi.encodePacked(\n            uint256(0), // nonce\n            _l2ToL1MessagePasserBalance, // balance,\n            _l2ToL1MessagePasserCodeHash, // codeHash,\n            _messagePasserStorageRoot // storage root\n        );\n\n        require(\n            IZKMerkleTrie(ZK_MERKLE_TRIE).verifyInclusionProof(\n                bytes32(bytes20(Predeploys.L2_TO_L1_MESSAGE_PASSER)),\n                l2ToL1MessagePasserAccount,\n                _merkleProof,\n                _stateRoot\n            ),\n            \"Colosseum: invalid L2ToL1MessagePasser inclusion proof\"\n        );\n    }\n\n    /**\n     * @notice Validates the output root proofs.\n     *\n     * @param _pos                Position of the last valid segment.\n     * @param _challenge          The challenge data.\n     * @param _srcOutputRoot      The source output root.\n     * @param _dstOutputRoot      The destination output root.\n     * @param _srcOutputRootProof Proof of the source output root.\n     * @param _dstOutputRootProof Proof of the destination output root.\n     */\n    function _validateOutputRootProof(\n        uint256 _pos,\n        Types.Challenge storage _challenge,\n        bytes32 _srcOutputRoot,\n        bytes32 _dstOutputRoot,\n        Types.OutputRootProof calldata _srcOutputRootProof,\n        Types.OutputRootProof calldata _dstOutputRootProof\n    ) private view {\n        require(\n            _challenge.segments[_pos] == _srcOutputRoot,\n            \"Colosseum: the source segment must be matched\"\n        );\n\n        // If asserter timeout, the bisection of segments may not have ended.\n        // Therefore, segment validation only proceeds when bisection is not possible.\n        if (!_isAbleToBisect(_challenge)) {\n            require(\n                _challenge.segments[_pos + 1] != _dstOutputRoot,\n                \"Colosseum: the destination segment must not be matched\"\n            );\n        }\n\n        require(\n            _srcOutputRootProof.nextBlockHash == _dstOutputRootProof.blockHash,\n            \"Colosseum: the block hash must be matched\"\n        );\n    }\n\n    /**\n     * @notice Checks if the public input is valid.\n     *         Reverts if public input is invalid.\n     *\n     * @param _srcOutputRootProof Proof of the source output root.\n     * @param _dstOutputRootProof Proof of the destination output root.\n     * @param _publicInput        Ingredients to compute the public input used by ZK proof verification.\n     * @param _rlps               Pre-encoded RLPs to compute the next block hash of the source output root proof.\n     */\n    function _validatePublicInput(\n        Types.OutputRootProof calldata _srcOutputRootProof,\n        Types.OutputRootProof calldata _dstOutputRootProof,\n        Types.PublicInput calldata _publicInput,\n        Types.BlockHeaderRLP calldata _rlps\n    ) private pure {\n        // TODO(chokobole): check withdrawal storage root of _dstOutputRootProof against state root of _dstOutputRootProof.\n        require(\n            _publicInput.stateRoot == _dstOutputRootProof.stateRoot,\n            \"Colosseum: the state root must be matched\"\n        );\n\n        bytes32 blockHash = Hashing.hashBlockHeader(_publicInput, _rlps);\n        require(\n            _srcOutputRootProof.nextBlockHash == blockHash,\n            \"Colosseum: the block hash must be matched\"\n        );\n    }\n\n    /**\n     * @notice Cancels the challenge if the output root to be challenged has already been deleted.\n     *         If the output root has been deleted, delete the challenge and refund the challenger's pending bond.\n     *         Reverts when challenger is timed out or called by non-challenger.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _challenger  Address of the challenger.\n     * @param _status      Current status of the challenge.\n     *\n     * @return Whether the challenge was canceled.\n     */\n    function _cancelIfOutputDeleted(\n        uint256 _outputIndex,\n        address _challenger,\n        ChallengeStatus _status\n    ) private returns (bool) {\n        bytes32 outputRoot = L2_ORACLE.getL2Output(_outputIndex).outputRoot;\n        if (outputRoot != DELETED_OUTPUT_ROOT) {\n            return false;\n        }\n\n        // If the output is deleted, the asserter does not need to do anything further.\n        require(msg.sender == _challenger, \"Colosseum: sender is not a challenger\");\n\n        require(\n            _status != ChallengeStatus.CHALLENGER_TIMEOUT,\n            \"Colosseum: challenge cannot be cancelled if challenger timed out\"\n        );\n\n        delete challenges[_outputIndex][msg.sender];\n        emit ChallengeCanceled(_outputIndex, msg.sender, block.timestamp);\n\n        L2_ORACLE.VALIDATOR_POOL().releasePendingBond(_outputIndex, msg.sender, msg.sender);\n\n        return true;\n    }\n\n    /**\n     * @notice Deletes the challenge because the challenger timed out.\n     *         The winner is the asserter, and challenger loses the bond.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _challenger  Address of the challenger.\n     */\n    function _challengerTimeout(uint256 _outputIndex, address _challenger) private {\n        delete challenges[_outputIndex][_challenger];\n        emit ChallengerTimedOut(_outputIndex, _challenger, block.timestamp);\n\n        // After output is finalized, the challenger's bond is included in the balance of output submitter.\n        if (L2_ORACLE.isFinalized(_outputIndex)) {\n            Types.CheckpointOutput memory targetOutput = L2_ORACLE.getL2Output(_outputIndex);\n            L2_ORACLE.VALIDATOR_POOL().releasePendingBond(\n                _outputIndex,\n                _challenger,\n                targetOutput.submitter\n            );\n        } else {\n            // Because the challenger lost, the challenger's bond is included in the bond for that output.\n            L2_ORACLE.VALIDATOR_POOL().increaseBond(_outputIndex, _challenger);\n        }\n    }\n\n    /**\n     * @notice Hashes the public input with padding dummy transactions.\n     *\n     * @param _prevStateRoot Previous state root.\n     * @param _publicInput   Ingredients to compute the public input used by ZK proof verification.\n     *\n     * @return Hash of public input.\n     */\n    function _hashPublicInput(bytes32 _prevStateRoot, Types.PublicInput calldata _publicInput)\n        private\n        view\n        returns (bytes32)\n    {\n        bytes32[] memory dummyHashes;\n        if (_publicInput.txHashes.length < MAX_TXS) {\n            dummyHashes = Hashing.generateDummyHashes(\n                DUMMY_HASH,\n                MAX_TXS - _publicInput.txHashes.length\n            );\n        }\n\n        // NOTE(chokobole): We cannot calculate the Ethereum transaction root solely\n        // based on transaction hashes. It is necessary to have access to the original\n        // transactions. Considering the imposed constraints and the difficulty\n        // of providing a preimage that would generate the desired public input hash\n        // from an attacker's perspective, we have decided to omit the verification\n        // using the transaction root.\n        return Hashing.hashPublicInput(_prevStateRoot, _publicInput, dummyHashes);\n    }\n\n    /**\n     * @notice Returns the number of L2 blocks for the next turn.\n     *\n     * @param _challenge The current challenge data.\n     *\n     * @return The number of L2 blocks for the next turn.\n     */\n    function _nextSegSize(Types.Challenge storage _challenge) private view returns (uint256) {\n        uint8 turn = _challenge.turn;\n        return _challenge.segSize / (getSegmentsLength(turn) - 1);\n    }\n\n    /**\n     * @notice Determines whether a given timestamp is past.\n     *\n     * @param _sec The timestamp to check.\n     *\n     * @return Whether it's in the past.\n     */\n    function _isPast(uint256 _sec) private view returns (bool) {\n        return block.timestamp > _sec;\n    }\n\n    /**\n     * @notice Determines if bisection is possible.\n     *\n     * @param _challenge The current challenge data.\n     *\n     * @return Whether bisection is possible.\n     */\n    function _isAbleToBisect(Types.Challenge storage _challenge) private view returns (bool) {\n        return _nextSegSize(_challenge) > 1;\n    }\n\n    /**\n     * @notice Determines if the next turn is the challenger's turn.\n     *         Note that challenger turns are odd numbers and asserter turns are even numbers.\n     *\n     * @param _turn The current turn.\n     *\n     * @return Whether the next turn is the challenger's turn.\n     */\n    function _isNextForChallenger(uint8 _turn) private pure returns (bool) {\n        // If the _turn value is even, it means that the asserter has completed its turn,\n        // so the next turn will be the challenger's turn.\n        return _turn % 2 == 0;\n    }\n\n    /**\n     * @notice Returns status of a given challenge.\n     *\n     * @param _challenge The challenge data.\n     *\n     * @return The status of the challenge.\n     */\n    function _challengeStatus(Types.Challenge storage _challenge)\n        private\n        view\n        returns (ChallengeStatus)\n    {\n        if (_challenge.turn < TURN_INIT) {\n            return ChallengeStatus.NONE;\n        }\n\n        bool isChallengerTurn = _isNextForChallenger(_challenge.turn);\n\n        // Check if it's a timed out challenge.\n        if (_isPast(_challenge.timeoutAt)) {\n            // timeout on challenger turn\n            if (isChallengerTurn) {\n                return ChallengeStatus.CHALLENGER_TIMEOUT;\n            }\n\n            // If the asserter times out and the challenger does not prove fault,\n            // the challenger is assumed to have timed out.\n            if (_isPast(_challenge.timeoutAt + PROVING_TIMEOUT)) {\n                return ChallengeStatus.CHALLENGER_TIMEOUT;\n            }\n\n            // timeout on asserter turn\n            return ChallengeStatus.ASSERTER_TIMEOUT;\n        }\n\n        // If bisection is not possible, the Challenger must execute the fault proof.\n        if (!_isAbleToBisect(_challenge)) {\n            return ChallengeStatus.READY_TO_PROVE;\n        }\n\n        return isChallengerTurn ? ChallengeStatus.CHALLENGER_TURN : ChallengeStatus.ASSERTER_TURN;\n    }\n\n    /**\n     * @notice Returns the challenge corresponding to the given L2 output index.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _challenger  Address of the challenger.\n     *\n     * @return The challenge data.\n     */\n    function getChallenge(uint256 _outputIndex, address _challenger)\n        external\n        view\n        returns (Types.Challenge memory)\n    {\n        return challenges[_outputIndex][_challenger];\n    }\n\n    /**\n     * @notice Returns the challenge status corresponding to the given L2 output index.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _challenger  Address of the challenger.\n     *\n     * @return The status of the challenge.\n     */\n    function getStatus(uint256 _outputIndex, address _challenger)\n        external\n        view\n        returns (ChallengeStatus)\n    {\n        Types.Challenge storage challenge = challenges[_outputIndex][_challenger];\n        return _challengeStatus(challenge);\n    }\n\n    /**\n     * @notice Returns the segment length required for that turn.\n     *\n     * @param _turn The challenge turn.\n     *\n     * @return The segments length.\n     */\n    function getSegmentsLength(uint8 _turn) public view returns (uint256) {\n        require(_turn >= TURN_INIT, \"Colosseum: invalid turn\");\n        return segmentsLengths[_turn - 1];\n    }\n\n    /**\n     * @notice Determines whether bisection is possible in the challenge corresponding to the given\n     *         L2 output index.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _challenger  Address of the challenger.\n     *\n     * @return Whether bisection is possible.\n     */\n    function isAbleToBisect(uint256 _outputIndex, address _challenger) public view returns (bool) {\n        Types.Challenge storage challenge = challenges[_outputIndex][_challenger];\n        return _isAbleToBisect(challenge);\n    }\n\n    /**\n     * @notice Determines whether current timestamp is in challenge creation period corresponding to the given L2 output index.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     *\n     * @return Whether current timestamp is in challenge creation period.\n     */\n    function isInCreationPeriod(uint256 _outputIndex) external view returns (bool) {\n        Types.CheckpointOutput memory targetOutput = L2_ORACLE.getL2Output(_outputIndex);\n        return targetOutput.timestamp + CREATION_PERIOD_SECONDS >= block.timestamp;\n    }\n}\n"
    },
    "contracts/L1/IZKMerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title IZKMerkleTrie\n */\ninterface IZKMerkleTrie {\n    /**\n     * @notice Verifies a proof that a given key/value pair is present in the trie.\n     *\n     * @param _key    Key of the node to search for, as a hex string.\n     * @param _value  Value of the node to search for, as a hex string.\n     * @param _proofs Merkle trie inclusion proof for the desired node.\n     * @param _root   Known root of the Merkle trie. Used to verify that the included proof is\n     *                correctly constructed.\n     *\n     * @return Whether or not the proof is valid.\n     */\n    function verifyInclusionProof(\n        bytes32 _key,\n        bytes memory _value,\n        bytes[] memory _proofs,\n        bytes32 _root\n    ) external view returns (bool);\n}\n"
    },
    "contracts/L1/KromaPortal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { L2OutputOracle } from \"./L2OutputOracle.sol\";\nimport { ResourceMetering } from \"./ResourceMetering.sol\";\nimport { SystemConfig } from \"./SystemConfig.sol\";\nimport { ZKMerkleTrie } from \"./ZKMerkleTrie.sol\";\n\n/**\n * @custom:proxied\n * @title KromaPortal\n * @notice The KromaPortal is a low-level contract responsible for passing messages between L1\n *         and L2. Messages sent directly to the KromaPortal have no form of replayability.\n *         Users are encouraged to use the L1CrossDomainMessenger for a higher-level interface.\n */\ncontract KromaPortal is Initializable, ResourceMetering, Semver {\n    /**\n     * @notice Represents a proven withdrawal.\n     *\n     * @custom:field outputRoot    Root of the L2 output this was proven against.\n     * @custom:field timestamp     Timestamp at whcih the withdrawal was proven.\n     * @custom:field l2OutputIndex Index of the output this was proven against.\n     */\n    struct ProvenWithdrawal {\n        bytes32 outputRoot;\n        uint128 timestamp;\n        uint128 l2OutputIndex;\n    }\n\n    /**\n     * @notice Version of the deposit event.\n     */\n    uint256 internal constant DEPOSIT_VERSION = 0;\n\n    /**\n     * @notice The L2 gas limit set when eth is deposited using the receive() function.\n     */\n    uint64 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;\n\n    /**\n     * @notice Address of the L2OutputOracle contract.\n     */\n    L2OutputOracle public immutable L2_ORACLE;\n\n    /**\n     * @notice Address of the ValidatorPool contract.\n     */\n    address public immutable VALIDATOR_POOL;\n\n    /**\n    /**\n     * @notice Address of the SystemConfig contract.\n     */\n    SystemConfig public immutable SYSTEM_CONFIG;\n\n    /**\n     * @notice MultiSig wallet address that has the ability to pause and unpause withdrawals.\n     */\n    address public immutable GUARDIAN;\n\n    /**\n     * @notice Address of the ZKMerkleTrie.\n     */\n    ZKMerkleTrie public immutable ZK_MERKLE_TRIE;\n\n    /**\n     * @notice Address of the L2 account which initiated a withdrawal in this transaction. If the\n     *         of this variable is the default L2 sender address, then we are NOT inside of a call\n     *         to finalizeWithdrawalTransaction.\n     */\n    address public l2Sender;\n\n    /**\n     * @notice A list of withdrawal hashes which have been successfully finalized.\n     */\n    mapping(bytes32 => bool) public finalizedWithdrawals;\n\n    /**\n     * @notice A mapping of withdrawal hashes to `ProvenWithdrawal` data.\n     */\n    mapping(bytes32 => ProvenWithdrawal) public provenWithdrawals;\n\n    /**\n     * @notice Determines if cross domain messaging is paused. When set to true,\n     *         withdrawals are paused. This may be removed in the future.\n     */\n    bool public paused;\n\n    /**\n     * @notice Emitted when a transaction is deposited from L1 to L2. The parameters of this event\n     *         are read by the rollup node and used to derive deposit transactions on L2.\n     *\n     * @param from       Address that triggered the deposit transaction.\n     * @param to         Address that the deposit transaction is directed to.\n     * @param version    Version of this deposit transaction event.\n     * @param opaqueData ABI encoded deposit data to be parsed off-chain.\n     */\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 indexed version,\n        bytes opaqueData\n    );\n\n    /**\n     * @notice Emitted when a withdrawal transaction is proven.\n     *\n     * @param withdrawalHash Hash of the withdrawal transaction.\n     */\n    event WithdrawalProven(\n        bytes32 indexed withdrawalHash,\n        address indexed from,\n        address indexed to\n    );\n\n    /**\n     * @notice Emitted when a withdrawal transaction is finalized.\n     *\n     * @param withdrawalHash Hash of the withdrawal transaction.\n     * @param success        Whether the withdrawal transaction was successful.\n     */\n    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);\n\n    /**\n     * @notice Emitted when the pause is triggered.\n     *\n     * @param account Address of the account triggering the pause.\n     */\n    event Paused(address account);\n\n    /**\n     * @notice Emitted when the pause is lifted.\n     *\n     * @param account Address of the account triggering the unpause.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @notice Reverts when paused.\n     */\n    modifier whenNotPaused() {\n        require(paused == false, \"KromaPortal: paused\");\n        _;\n    }\n\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _l2Oracle                  Address of the L2OutputOracle contract.\n     * @param _validatorPool             Address of the ValidatorPool contract.\n     * @param _guardian                  MultiSig wallet address that can pause deposits and withdrawals.\n     * @param _paused                    Sets the contract's pausability state.\n     * @param _config                    Address of the SystemConfig contract.\n     * @param _zkMerkleTrie              Address of the ZKMerkleTrie contract.\n     */\n    constructor(\n        L2OutputOracle _l2Oracle,\n        address _validatorPool,\n        address _guardian,\n        bool _paused,\n        SystemConfig _config,\n        ZKMerkleTrie _zkMerkleTrie\n    ) Semver(0, 1, 0) {\n        L2_ORACLE = _l2Oracle;\n        VALIDATOR_POOL = _validatorPool;\n        GUARDIAN = _guardian;\n        SYSTEM_CONFIG = _config;\n        ZK_MERKLE_TRIE = _zkMerkleTrie;\n        initialize(_paused);\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize(bool _paused) public initializer {\n        l2Sender = Constants.DEFAULT_L2_SENDER;\n        paused = _paused;\n        __ResourceMetering_init();\n    }\n\n    /**\n     * @notice Pause deposits and withdrawals.\n     */\n    function pause() external {\n        require(msg.sender == GUARDIAN, \"KromaPortal: only guardian can pause\");\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @notice Unpause deposits and withdrawals.\n     */\n    function unpause() external {\n        require(msg.sender == GUARDIAN, \"KromaPortal: only guardian can unpause\");\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    /**\n     * @notice Accepts value so that users can send ETH directly to this contract and have the\n     *         funds be deposited to their address on L2. This is intended as a convenience\n     *         function for EOAs. Contracts should call the depositTransaction() function directly\n     *         otherwise any deposited funds will be lost due to address aliasing.\n     */\n    // solhint-disable-next-line ordering\n    receive() external payable {\n        depositTransaction(msg.sender, msg.value, RECEIVE_DEFAULT_GAS_LIMIT, false, bytes(\"\"));\n    }\n\n    /**\n     * @notice Getter for the resource config. Used internally by the ResourceMetering\n     *         contract. The SystemConfig is the source of truth for the resource config.\n     *\n     * @return ResourceMetering.ResourceConfig\n     */\n    function _resourceConfig()\n        internal\n        view\n        override\n        returns (ResourceMetering.ResourceConfig memory)\n    {\n        return SYSTEM_CONFIG.resourceConfig();\n    }\n\n    /**\n     * @notice Proves a withdrawal transaction.\n     *\n     * @param _tx              Withdrawal transaction to finalize.\n     * @param _l2OutputIndex   L2 output index to prove against.\n     * @param _outputRootProof Inclusion proof of the L2ToL1MessagePasser contract's storage root.\n     * @param _withdrawalProof Inclusion proof of the withdrawal in L2ToL1MessagePasser contract.\n     */\n    function proveWithdrawalTransaction(\n        Types.WithdrawalTransaction memory _tx,\n        uint256 _l2OutputIndex,\n        Types.OutputRootProof calldata _outputRootProof,\n        bytes[] calldata _withdrawalProof\n    ) external whenNotPaused {\n        // Prevent users from creating a deposit transaction where this address is the message\n        // sender on L2. Because this is checked here, we do not need to check again in\n        // `finalizeWithdrawalTransaction`.\n        require(\n            _tx.target != address(this),\n            \"KromaPortal: you cannot send messages to the portal contract\"\n        );\n\n        // Get the output root and load onto the stack to prevent multiple mloads. This will\n        // revert if there is no output root for the given block number.\n        bytes32 outputRoot = L2_ORACLE.getL2Output(_l2OutputIndex).outputRoot;\n\n        // Verify that the output root can be generated with the elements in the proof.\n        require(\n            outputRoot == Hashing.hashOutputRootProof(_outputRootProof),\n            \"KromaPortal: invalid output root proof\"\n        );\n\n        // Load the ProvenWithdrawal into memory, using the withdrawal hash as a unique identifier.\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];\n\n        // We generally want to prevent users from proving the same withdrawal multiple times\n        // because each successive proof will update the timestamp. A malicious user can take\n        // advantage of this to prevent other users from finalizing their withdrawal. However,\n        // since withdrawals are proven before an output root is finalized, we need to allow users\n        // to re-prove their withdrawal only in the case that the output root for their specified\n        // output index has been updated.\n        require(\n            provenWithdrawal.timestamp == 0 ||\n                L2_ORACLE.getL2Output(provenWithdrawal.l2OutputIndex).outputRoot !=\n                provenWithdrawal.outputRoot,\n            \"KromaPortal: withdrawal hash has already been proven\"\n        );\n\n        // Compute the storage slot of the withdrawal hash in the L2ToL1MessagePasser contract.\n        // Refer to the Solidity documentation for more information on how storage layouts are\n        // computed for mappings.\n        bytes32 storageKey = keccak256(\n            abi.encode(\n                withdrawalHash,\n                uint256(0) // The withdrawals mapping is at the first slot in the layout.\n            )\n        );\n\n        // Verify that the hash of this withdrawal was stored in the L2toL1MessagePasser contract\n        // on L2. If this is true, under the assumption that the ZKMerkleTrie contract does not have\n        // bugs, then we know that this withdrawal was actually triggered on L2 and can therefore\n        // be relayed on L1.\n        require(\n            ZK_MERKLE_TRIE.verifyInclusionProof(\n                storageKey,\n                hex\"0000000000000000000000000000000000000000000000000000000000000001\",\n                _withdrawalProof,\n                _outputRootProof.messagePasserStorageRoot\n            ),\n            \"KromaPortal: invalid withdrawal inclusion proof\"\n        );\n\n        // Designate the withdrawalHash as proven by storing the `outputRoot`, `timestamp`, and\n        // `l2OutputIndex` in the `provenWithdrawals` mapping. A `withdrawalHash` can only be\n        // proven once unless it is submitted again with a different outputRoot.\n        provenWithdrawals[withdrawalHash] = ProvenWithdrawal({\n            outputRoot: outputRoot,\n            timestamp: uint128(block.timestamp),\n            l2OutputIndex: uint128(_l2OutputIndex)\n        });\n\n        // Emit a `WithdrawalProven` event.\n        emit WithdrawalProven(withdrawalHash, _tx.sender, _tx.target);\n    }\n\n    /**\n     * @notice Finalizes a withdrawal transaction.\n     *\n     * @param _tx Withdrawal transaction to finalize.\n     */\n    function finalizeWithdrawalTransaction(Types.WithdrawalTransaction memory _tx)\n        external\n        whenNotPaused\n    {\n        // Make sure that the l2Sender has not yet been set. The l2Sender is set to a value other\n        // than the default value when a withdrawal transaction is being finalized. This check is\n        // a defacto reentrancy guard.\n        require(\n            l2Sender == Constants.DEFAULT_L2_SENDER,\n            \"KromaPortal: can only trigger one withdrawal per transaction\"\n        );\n\n        // Grab the proven withdrawal from the `provenWithdrawals` map.\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];\n\n        // A withdrawal can only be finalized if it has been proven. We know that a withdrawal has\n        // been proven at least once when its timestamp is non-zero. Unproven withdrawals will have\n        // a timestamp of zero.\n        require(provenWithdrawal.timestamp != 0, \"KromaPortal: withdrawal has not been proven yet\");\n\n        // As a sanity check, we make sure that the proven withdrawal's timestamp is greater than\n        // starting timestamp inside the L2OutputOracle. Not strictly necessary but extra layer of\n        // safety against weird bugs in the proving step.\n        require(\n            provenWithdrawal.timestamp >= L2_ORACLE.startingTimestamp(),\n            \"KromaPortal: withdrawal timestamp less than L2 Oracle starting timestamp\"\n        );\n\n        // A proven withdrawal must wait at least the finalization period before it can be\n        // finalized. This waiting period can elapse in parallel with the waiting period for the\n        // output the withdrawal was proven against. In effect, this means that the minimum\n        // withdrawal time is l2 output submission time + finalization period.\n        require(\n            _isFinalizationPeriodElapsed(provenWithdrawal.timestamp),\n            \"KromaPortal: proven withdrawal finalization period has not elapsed\"\n        );\n\n        // Grab the CheckpointOutput from the L2OutputOracle, will revert if the output that\n        // corresponds to the given index has not been submitted yet.\n        Types.CheckpointOutput memory checkpointOutput = L2_ORACLE.getL2Output(\n            provenWithdrawal.l2OutputIndex\n        );\n\n        // Check that the output root that was used to prove the withdrawal is the same as the\n        // current output root for the given output index. An output root may change if it is\n        // deleted by the challenger address and then re-submitted.\n        require(\n            checkpointOutput.outputRoot == provenWithdrawal.outputRoot,\n            \"KromaPortal: output root proven is not the same as current output root\"\n        );\n\n        // Check that the checkpoint output has also been finalized.\n        require(\n            _isFinalizationPeriodElapsed(checkpointOutput.timestamp),\n            \"KromaPortal: checkpoint output finalization period has not elapsed\"\n        );\n\n        // Check that this withdrawal has not already been finalized, this is replay protection.\n        require(\n            finalizedWithdrawals[withdrawalHash] == false,\n            \"KromaPortal: withdrawal has already been finalized\"\n        );\n\n        // Mark the withdrawal as finalized so it can't be replayed.\n        finalizedWithdrawals[withdrawalHash] = true;\n\n        // Set the l2Sender so contracts know who triggered this withdrawal on L2.\n        l2Sender = _tx.sender;\n\n        // Trigger the call to the target contract. We use a custom low level method\n        // SafeCall.callWithMinGas to ensure two key properties\n        //   1. Target contracts cannot force this call to run out of gas by returning a very large\n        //      amount of data (and this is OK because we don't care about the returndata here).\n        //   2. The amount of gas provided to the execution context of the target is at least the\n        //      gas limit specified by the user. If there is not enough gas in the current context\n        //      to accomplish this, `callWithMinGas` will revert.\n        bool success = SafeCall.callWithMinGas(_tx.target, _tx.gasLimit, _tx.value, _tx.data);\n\n        // Reset the l2Sender back to the default value.\n        l2Sender = Constants.DEFAULT_L2_SENDER;\n\n        // All withdrawals are immediately finalized. Replayability can\n        // be achieved through contracts built on top of this contract\n        emit WithdrawalFinalized(withdrawalHash, success);\n\n        // Reverting here is useful for determining the exact gas cost to successfully execute the\n        // sub call to the target contract if the minimum gas limit specified by the user would not\n        // be sufficient to execute the sub call.\n        if (success == false && tx.origin == Constants.ESTIMATION_ADDRESS) {\n            revert(\"KromaPortal: withdrawal failed\");\n        }\n    }\n\n    /**\n     * @notice Accepts deposits of ETH and data, and emits a TransactionDeposited event for use in\n     *         deriving deposit transactions. Note that if a deposit is made by a contract, its\n     *         address will be aliased when retrieved using `tx.origin` or `msg.sender`. Consider\n     *         using the CrossDomainMessenger contracts for a simpler developer experience.\n     *\n     * @param _to         Target address on L2.\n     * @param _value      ETH value to send to the recipient.\n     * @param _gasLimit   Minimum L2 gas limit (can be greater than or equal to this value).\n     * @param _isCreation Whether or not the transaction is a contract creation.\n     * @param _data       Data to trigger the recipient with.\n     */\n    function depositTransaction(\n        address _to,\n        uint256 _value,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    ) public payable metered(_gasLimit) {\n        // Just to be safe, make sure that people specify address(0) as the target when doing\n        // contract creations.\n        if (_isCreation) {\n            require(\n                _to == address(0),\n                \"KromaPortal: must send to address(0) when creating a contract\"\n            );\n        }\n\n        // Prevent depositing transactions that have too small of a gas limit.\n        require(_gasLimit >= 21_000, \"KromaPortal: gas limit must cover instrinsic gas cost\");\n\n        // Transform the from-address to its alias if the caller is a contract.\n        address from = msg.sender;\n        if (msg.sender != tx.origin) {\n            from = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        // Compute the opaque data that will be emitted as part of the TransactionDeposited event.\n        // We use opaque data so that we can update the TransactionDeposited event in the future\n        // without breaking the current interface.\n        bytes memory opaqueData = abi.encodePacked(\n            msg.value,\n            _value,\n            _gasLimit,\n            _isCreation,\n            _data\n        );\n\n        // Emit a TransactionDeposited event so that the rollup node can derive a deposit\n        // transaction for this deposit.\n        emit TransactionDeposited(from, _to, DEPOSIT_VERSION, opaqueData);\n    }\n\n    /**\n     * @notice Accepts deposits of data from ValidatorPool contract, and emits a TransactionDeposited event for use in\n     *         deriving deposit transactions on L2.\n     *\n     * @param _to         Target address on L2.\n     * @param _gasLimit   Minimum L2 gas limit (can be greater than or equal to this value).\n     * @param _data       Data to trigger the recipient with.\n     */\n    function depositTransactionByValidatorPool(\n        address _to,\n        uint64 _gasLimit,\n        bytes memory _data\n    ) public {\n        require(\n            msg.sender == VALIDATOR_POOL,\n            \"KromaPortal: function can only be called from the ValidatorPool\"\n        );\n\n        // Transform the from-address to its alias.\n        address from = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n\n        // Compute the opaque data that will be emitted as part of the TransactionDeposited event.\n        bytes memory opaqueData = abi.encodePacked(uint256(0), uint256(0), _gasLimit, false, _data);\n\n        // Emit a TransactionDeposited event so that the rollup node can derive a deposit\n        // transaction for this deposit.\n        emit TransactionDeposited(from, _to, DEPOSIT_VERSION, opaqueData);\n    }\n\n    /**\n     * @notice Determines if the output at the given index is finalized. Reverts if the call to\n     *         L2_ORACLE.getL2Output reverts. Returns a boolean otherwise.\n     *\n     * @param _l2OutputIndex Index of the L2 output to check.\n     *\n     * @return Whether or not the output is finalized.\n     */\n    function isOutputFinalized(uint256 _l2OutputIndex) external view returns (bool) {\n        return _isFinalizationPeriodElapsed(L2_ORACLE.getL2Output(_l2OutputIndex).timestamp);\n    }\n\n    /**\n     * @notice Determines whether the finalization period has elapsed w/r/t a given timestamp.\n     *\n     * @param _timestamp Timestamp to check.\n     *\n     * @return Whether or not the finalization period has elapsed.\n     */\n    function _isFinalizationPeriodElapsed(uint256 _timestamp) internal view returns (bool) {\n        return block.timestamp > _timestamp + L2_ORACLE.FINALIZATION_PERIOD_SECONDS();\n    }\n}\n"
    },
    "contracts/L1/L1CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { KromaPortal } from \"./KromaPortal.sol\";\n\n/**\n * @custom:proxied\n * @title L1CrossDomainMessenger\n * @notice The L1CrossDomainMessenger is a message passing interface between L1 and L2 responsible\n *         for sending and receiving data on the L1 side. Users are encouraged to use this\n *         interface instead of interacting with lower-level contracts directly.\n */\ncontract L1CrossDomainMessenger is CrossDomainMessenger, Semver {\n    /**\n     * @notice Address of the KromaPortal.\n     */\n    KromaPortal public immutable PORTAL;\n\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _portal Address of the KromaPortal contract on this network.\n     */\n    constructor(KromaPortal _portal)\n        Semver(0, 1, 0)\n        CrossDomainMessenger(Predeploys.L2_CROSS_DOMAIN_MESSENGER)\n    {\n        PORTAL = _portal;\n        initialize();\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize() public initializer {\n        __CrossDomainMessenger_init();\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal override {\n        PORTAL.depositTransaction{ value: _value }(_to, _value, _gasLimit, false, _data);\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _isOtherMessenger() internal view override returns (bool) {\n        return msg.sender == address(PORTAL) && PORTAL.l2Sender() == OTHER_MESSENGER;\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _isUnsafeTarget(address _target) internal view override returns (bool) {\n        return _target == address(this) || _target == address(PORTAL);\n    }\n}\n"
    },
    "contracts/L1/L1ERC721Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport { L2ERC721Bridge } from \"../L2/L2ERC721Bridge.sol\";\nimport { ERC721Bridge } from \"../universal/ERC721Bridge.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @title L1ERC721Bridge\n * @notice The L1 ERC721 bridge is a contract which works together with the L2 ERC721 bridge to\n *         make it possible to transfer ERC721 tokens from Ethereum to Kroma. This contract\n *         acts as an escrow for ERC721 tokens deposited into L2.\n */\ncontract L1ERC721Bridge is ERC721Bridge, Semver {\n    /**\n     * @notice Mapping of L1 token to L2 token to ID to boolean, indicating if the given L1 token\n     *         by ID was deposited for a given L2 token.\n     */\n    mapping(address => mapping(address => mapping(uint256 => bool))) public deposits;\n\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _messenger   Address of the CrossDomainMessenger on this network.\n     * @param _otherBridge Address of the ERC721 bridge on the other network.\n     */\n    constructor(address _messenger, address _otherBridge)\n        Semver(0, 1, 0)\n        ERC721Bridge(_messenger, _otherBridge)\n    {}\n\n    /**\n     * @notice Completes an ERC721 bridge from the other domain and sends the ERC721 token to the\n     *         recipient on this domain.\n     *\n     * @param _localToken  Address of the ERC721 token on this domain.\n     * @param _remoteToken Address of the ERC721 token on the other domain.\n     * @param _from        Address that triggered the bridge on the other domain.\n     * @param _to          Address to receive the token on this domain.\n     * @param _tokenId     ID of the token being deposited.\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\n     *                     execute any code on L2 and is only emitted as extra data for the\n     *                     convenience of off-chain tooling.\n     */\n    function finalizeBridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes calldata _extraData\n    ) external onlyOtherBridge {\n        require(_localToken != address(this), \"L1ERC721Bridge: local token cannot be self\");\n\n        // Checks that the L1/L2 NFT pair has a token ID that is escrowed in the L1 Bridge.\n        require(\n            deposits[_localToken][_remoteToken][_tokenId] == true,\n            \"L1ERC721Bridge: Token ID is not escrowed in the L1 Bridge\"\n        );\n\n        // Mark that the token ID for this L1/L2 token pair is no longer escrowed in the L1\n        // Bridge.\n        deposits[_localToken][_remoteToken][_tokenId] = false;\n\n        // When a withdrawal is finalized on L1, the L1 Bridge transfers the NFT to the\n        // withdrawer.\n        IERC721(_localToken).safeTransferFrom(address(this), _to, _tokenId);\n\n        // slither-disable-next-line reentrancy-events\n        emit ERC721BridgeFinalized(_localToken, _remoteToken, _from, _to, _tokenId, _extraData);\n    }\n\n    /**\n     * @inheritdoc ERC721Bridge\n     */\n    function _initiateBridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) internal override {\n        require(_remoteToken != address(0), \"L1ERC721Bridge: remote token cannot be address(0)\");\n\n        // Construct calldata for _l2Token.finalizeBridgeERC721(_to, _tokenId)\n        bytes memory message = abi.encodeWithSelector(\n            L2ERC721Bridge.finalizeBridgeERC721.selector,\n            _remoteToken,\n            _localToken,\n            _from,\n            _to,\n            _tokenId,\n            _extraData\n        );\n\n        // Lock token into bridge\n        deposits[_localToken][_remoteToken][_tokenId] = true;\n        IERC721(_localToken).transferFrom(_from, address(this), _tokenId);\n\n        // Send calldata into L2\n        MESSENGER.sendMessage(OTHER_BRIDGE, message, _minGasLimit);\n        emit ERC721BridgeInitiated(_localToken, _remoteToken, _from, _to, _tokenId, _extraData);\n    }\n}\n"
    },
    "contracts/L1/L1StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\n\n/**\n * @custom:proxied\n * @title L1StandardBridge\n * @notice The L1StandardBridge is responsible for transfering ETH and ERC20 tokens between L1 and\n *         L2. In the case that an ERC20 token is native to L1, it will be escrowed within this\n *         contract. If the ERC20 token is native to L2, it will be burnt. ETH is instead stored\n *         inside the KromaPortal contract.\n *         NOTE: this contract is not intended to support all variations of ERC20 tokens. Examples\n *         of some token types that may not be properly supported by this contract include, but are\n *         not limited to: tokens with transfer fees, rebasing tokens, and tokens with blocklists.\n */\ncontract L1StandardBridge is StandardBridge, Semver {\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _messenger Address of the L1CrossDomainMessenger.\n     */\n    constructor(address payable _messenger)\n        Semver(0, 1, 0)\n        StandardBridge(_messenger, payable(Predeploys.L2_STANDARD_BRIDGE))\n    {}\n\n    /**\n     * @notice Allows EOAs to bridge ETH by sending directly to the bridge.\n     */\n    receive() external payable override onlyEOA {\n        _initiateBridgeETH(msg.sender, msg.sender, msg.value, RECEIVE_DEFAULT_GAS_LIMIT, bytes(\"\"));\n    }\n}\n"
    },
    "contracts/L1/L2OutputOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { ValidatorPool } from \"./ValidatorPool.sol\";\n\n/**\n * @custom:proxied\n * @title L2OutputOracle\n * @notice The L2OutputOracle contains an array of L2 state outputs, where each output is a\n *         commitment to the state of the L2 chain. Other contracts like the KromaPortal use\n *         these outputs to verify information about the state of L2.\n */\ncontract L2OutputOracle is Initializable, Semver {\n    /**\n     * @notice The address of the validator pool contract. Can be updated via upgrade.\n     */\n    ValidatorPool public immutable VALIDATOR_POOL;\n\n    /**\n     * @notice The address of the colosseum contract. Can be updated via upgrade.\n     */\n    address public immutable COLOSSEUM;\n\n    /**\n     * @notice The interval in L2 blocks at which checkpoints must be submitted. Although this is\n     *         immutable, it can be modified by upgrading the implementation contract.\n     *         Note that nodes that fetch and use this value need to restart when it is modified.\n     */\n    uint256 public immutable SUBMISSION_INTERVAL;\n\n    /**\n     * @notice The time between L2 blocks in seconds. Once set, this value MUST NOT be modified.\n     */\n    uint256 public immutable L2_BLOCK_TIME;\n\n    /**\n     * @notice Minimum time (in seconds) that must elapse before a withdrawal can be finalized.\n     */\n    uint256 public immutable FINALIZATION_PERIOD_SECONDS;\n\n    /**\n     * @notice The number of the first L2 block recorded in this contract.\n     */\n    uint256 public startingBlockNumber;\n\n    /**\n     * @notice The timestamp of the first L2 block recorded in this contract.\n     */\n    uint256 public startingTimestamp;\n\n    /**\n     * @notice Array of L2 checkpoint outputs.\n     */\n    Types.CheckpointOutput[] internal l2Outputs;\n\n    /**\n     * @notice Emitted when an output is submitted.\n     *\n     * @param outputRoot    The output root.\n     * @param l2OutputIndex The index of the output in the l2Outputs array.\n     * @param l2BlockNumber The L2 block number of the output root.\n     * @param l1Timestamp   The L1 timestamp when submitted.\n     */\n    event OutputSubmitted(\n        bytes32 indexed outputRoot,\n        uint256 indexed l2OutputIndex,\n        uint256 indexed l2BlockNumber,\n        uint256 l1Timestamp\n    );\n\n    /**\n     * @notice Emitted when an output is replaced.\n     *\n     * @param outputIndex   Replaced L2 output index.\n     * @param newOutputRoot L2 output root after replacement.\n     */\n    event OutputReplaced(uint256 indexed outputIndex, bytes32 newOutputRoot);\n\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _validatorPool             The address of the ValidatorPool contract.\n     * @param _colosseum                 The address of the Colosseum contract.\n     * @param _submissionInterval        Interval in blocks at which checkpoints must be submitted.\n     * @param _l2BlockTime               The time per L2 block, in seconds.\n     * @param _startingBlockNumber       The number of the first L2 block.\n     * @param _startingTimestamp         The timestamp of the first L2 block.\n     * @param _finalizationPeriodSeconds Output finalization time in seconds.\n     */\n    constructor(\n        ValidatorPool _validatorPool,\n        address _colosseum,\n        uint256 _submissionInterval,\n        uint256 _l2BlockTime,\n        uint256 _startingBlockNumber,\n        uint256 _startingTimestamp,\n        uint256 _finalizationPeriodSeconds\n    ) Semver(0, 1, 0) {\n        require(_l2BlockTime > 0, \"L2OutputOracle: L2 block time must be greater than 0\");\n        require(\n            _submissionInterval > 0,\n            \"L2OutputOracle: submission interval must be greater than 0\"\n        );\n\n        VALIDATOR_POOL = _validatorPool;\n        COLOSSEUM = _colosseum;\n        SUBMISSION_INTERVAL = _submissionInterval;\n        L2_BLOCK_TIME = _l2BlockTime;\n        FINALIZATION_PERIOD_SECONDS = _finalizationPeriodSeconds;\n\n        initialize(_startingBlockNumber, _startingTimestamp);\n    }\n\n    /**\n     * @notice Initializer.\n     *\n     * @param _startingBlockNumber Block number for the first recorded L2 block.\n     * @param _startingTimestamp   Timestamp for the first recorded L2 block.\n     */\n    function initialize(uint256 _startingBlockNumber, uint256 _startingTimestamp)\n        public\n        initializer\n    {\n        require(\n            _startingTimestamp <= block.timestamp,\n            \"L2OutputOracle: starting L2 timestamp must be less than current time\"\n        );\n\n        startingTimestamp = _startingTimestamp;\n        startingBlockNumber = _startingBlockNumber;\n    }\n\n    /**\n     * @notice Replaces the output that corresponds to the given output index.\n     *         Only the Colosseum contract can replace an output.\n     *\n     * @param _l2OutputIndex Index of the L2 output to be replaced.\n     * @param _newOutputRoot The L2 output root to replace the existing one.\n     * @param _submitter     Address of the L2 output submitter.\n     */\n    function replaceL2Output(\n        uint256 _l2OutputIndex,\n        bytes32 _newOutputRoot,\n        address _submitter\n    ) external {\n        require(\n            msg.sender == COLOSSEUM,\n            \"L2OutputOracle: only the colosseum contract can replace an output\"\n        );\n\n        require(_submitter != address(0), \"L2OutputOracle: submitter address cannot be zero\");\n\n        // Make sure we're not *increasing* the length of the array.\n        require(\n            _l2OutputIndex < l2Outputs.length,\n            \"L2OutputOracle: cannot replace an output after the latest output index\"\n        );\n\n        Types.CheckpointOutput storage output = l2Outputs[_l2OutputIndex];\n        // Do not allow replacing any outputs that have already been finalized.\n        require(\n            block.timestamp - output.timestamp < FINALIZATION_PERIOD_SECONDS,\n            \"L2OutputOracle: cannot replace an output that has already been finalized\"\n        );\n\n        output.outputRoot = _newOutputRoot;\n        output.submitter = _submitter;\n\n        emit OutputReplaced(_l2OutputIndex, _newOutputRoot);\n    }\n\n    /**\n     * @notice Accepts an outputRoot and the block number of the corresponding L2 block.\n     *         The block number must be equal to the current value returned by `nextBlockNumber()`\n     *         in order to be accepted. This function may only be called by the validator.\n     *\n     * @param _outputRoot    The L2 output of the checkpoint block.\n     * @param _l2BlockNumber The L2 block number that resulted in _outputRoot.\n     * @param _l1BlockHash   A block hash which must be included in the current chain.\n     * @param _l1BlockNumber The block number with the specified block hash.\n     */\n    function submitL2Output(\n        bytes32 _outputRoot,\n        uint256 _l2BlockNumber,\n        bytes32 _l1BlockHash,\n        uint256 _l1BlockNumber\n    ) external payable {\n        address nextValidator = VALIDATOR_POOL.nextValidator();\n        // If it's not a public round, only selected validators can submit output.\n        if (nextValidator != Constants.VALIDATOR_PUBLIC_ROUND_ADDRESS) {\n            require(\n                msg.sender == nextValidator,\n                \"L2OutputOracle: only the next selected validator can submit output\"\n            );\n        }\n\n        require(\n            _l2BlockNumber == nextBlockNumber(),\n            \"L2OutputOracle: block number must be equal to next expected block number\"\n        );\n\n        require(\n            computeL2Timestamp(_l2BlockNumber) < block.timestamp,\n            \"L2OutputOracle: cannot submit L2 output in the future\"\n        );\n\n        require(\n            _outputRoot != bytes32(0),\n            \"L2OutputOracle: L2 checkpoint output cannot be the zero hash\"\n        );\n\n        if (_l1BlockHash != bytes32(0) && blockhash(_l1BlockNumber) != bytes32(0)) {\n            // This check allows the validator to submit an output based on a given L1 block,\n            // without fear that it will be reorged out.\n            // It will be skipped if the blockheight provided is more than 256 blocks behind the\n            // chain tip (as the hash will return as zero).\n            require(\n                blockhash(_l1BlockNumber) == _l1BlockHash,\n                \"L2OutputOracle: block hash does not match the hash at the expected height\"\n            );\n        }\n\n        uint256 outputIndex = nextOutputIndex();\n\n        l2Outputs.push(\n            Types.CheckpointOutput({\n                submitter: msg.sender,\n                outputRoot: _outputRoot,\n                timestamp: uint128(block.timestamp),\n                l2BlockNumber: uint128(_l2BlockNumber)\n            })\n        );\n\n        emit OutputSubmitted(_outputRoot, outputIndex, _l2BlockNumber, block.timestamp);\n\n        VALIDATOR_POOL.createBond(\n            outputIndex,\n            uint128(block.timestamp + FINALIZATION_PERIOD_SECONDS)\n        );\n    }\n\n    /**\n     * @notice Returns an output by index. Reverts if output is not found at the given index.\n     *\n     * @param _l2OutputIndex Index of the output to return.\n     *\n     * @return The output at the given index.\n     */\n    function getL2Output(uint256 _l2OutputIndex)\n        external\n        view\n        returns (Types.CheckpointOutput memory)\n    {\n        return l2Outputs[_l2OutputIndex];\n    }\n\n    /**\n     * @notice Returns the index of the L2 output that checkpoints a given L2 block number. Uses a\n     *         binary search to find the first output greater than or equal to the given block.\n     *\n     * @param _l2BlockNumber L2 block number to find a checkpoint for.\n     *\n     * @return Index of the first checkpoint that commits to the given L2 block number.\n     */\n    function getL2OutputIndexAfter(uint256 _l2BlockNumber) public view returns (uint256) {\n        // Make sure an output for this block number has actually been submitted.\n        require(\n            _l2BlockNumber <= latestBlockNumber(),\n            \"L2OutputOracle: cannot get output for a block that has not been submitted\"\n        );\n\n        // Make sure there's at least one output submitted.\n        require(\n            l2Outputs.length > 0,\n            \"L2OutputOracle: cannot get output as no outputs have been submitted yet\"\n        );\n\n        // Find the output via binary search, guaranteed to exist.\n        uint256 lo = 0;\n        uint256 hi = l2Outputs.length;\n        while (lo < hi) {\n            uint256 mid = (lo + hi) / 2;\n            if (l2Outputs[mid].l2BlockNumber < _l2BlockNumber) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n\n        return lo;\n    }\n\n    /**\n     * @notice Returns the L2 checkpoint output that checkpoints a given L2 block number.\n     *\n     * @param _l2BlockNumber L2 block number to find a checkpoint for.\n     *\n     * @return First checkpoint that commits to the given L2 block number.\n     */\n    function getL2OutputAfter(uint256 _l2BlockNumber)\n        external\n        view\n        returns (Types.CheckpointOutput memory)\n    {\n        return l2Outputs[getL2OutputIndexAfter(_l2BlockNumber)];\n    }\n\n    /**\n     * @notice Returns the index of the latest submitted output. Will revert if no outputs\n     *         have been submitted yet.\n     *\n     * @return The index of the latest submitted output.\n     */\n    function latestOutputIndex() external view returns (uint256) {\n        return l2Outputs.length - 1;\n    }\n\n    /**\n     * @notice Returns the index of the next output to be submitted.\n     *\n     * @return The index of the next output to be submitted.\n     */\n    function nextOutputIndex() public view returns (uint256) {\n        return l2Outputs.length;\n    }\n\n    /**\n     * @notice Returns the block number of the latest submitted L2 checkpoint output. If no outputs\n     *         have been submitted yet then this function will return the starting block number.\n     *\n     * @return Latest submitted L2 block number.\n     */\n    function latestBlockNumber() public view returns (uint256) {\n        return\n            l2Outputs.length == 0\n                ? startingBlockNumber\n                : l2Outputs[l2Outputs.length - 1].l2BlockNumber;\n    }\n\n    /**\n     * @notice Computes the block number of the next L2 block that needs to be checkpointed. If no\n     *         outputs have been submitted yet then this function will return the latest block\n     *         number, which is the starting block number.\n     *\n     * @return Next L2 block number.\n     */\n    function nextBlockNumber() public view returns (uint256) {\n        return\n            l2Outputs.length == 0 ? latestBlockNumber() : latestBlockNumber() + SUBMISSION_INTERVAL;\n    }\n\n    /**\n     * @notice Returns the L2 timestamp corresponding to a given L2 block number.\n     *\n     * @param _l2BlockNumber The L2 block number of the target block.\n     *\n     * @return L2 timestamp of the given block.\n     */\n    function computeL2Timestamp(uint256 _l2BlockNumber) public view returns (uint256) {\n        return startingTimestamp + ((_l2BlockNumber - startingBlockNumber) * L2_BLOCK_TIME);\n    }\n\n    /**\n     * @notice Returns the address of the L2 output submitter.\n     *\n     * @param _outputIndex Index of an output.\n     *\n     * @return Address of the submitter.\n     */\n    function getSubmitter(uint256 _outputIndex) external view returns (address) {\n        return l2Outputs[_outputIndex].submitter;\n    }\n\n    /**\n     * @notice Returns if the output of given index is finalized.\n     *\n     * @param _outputIndex Index of an output.\n     *\n     * @return If the given output is finalized or not.\n     */\n    function isFinalized(uint256 _outputIndex) external view returns (bool) {\n        return l2Outputs[_outputIndex].timestamp + FINALIZATION_PERIOD_SECONDS < block.timestamp;\n    }\n\n    /**\n     * @notice Returns the finalization time of given output index.\n     *\n     * @param _outputIndex Index of an output.\n     *\n     * @return The finalization time of given output index.\n     */\n    function finalizedAt(uint256 _outputIndex) external view returns (uint256) {\n        return l2Outputs[_outputIndex].timestamp + FINALIZATION_PERIOD_SECONDS;\n    }\n}\n"
    },
    "contracts/L1/ResourceMetering.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { Arithmetic } from \"../libraries/Arithmetic.sol\";\nimport { Burn } from \"../libraries/Burn.sol\";\n\n/**\n * @custom:upgradeable\n * @title ResourceMetering\n * @notice ResourceMetering implements an EIP-1559 style resource metering system where pricing\n *         updates automatically based on current demand.\n */\nabstract contract ResourceMetering is Initializable {\n    /**\n     * @notice Represents the various parameters that control the way in which resources are\n     *         metered. Corresponds to the EIP-1559 resource metering system.\n     *\n     * @custom:field prevBaseFee   Base fee from the previous block(s).\n     * @custom:field prevBoughtGas Amount of gas bought so far in the current block.\n     * @custom:field prevBlockNum  Last block number that the base fee was updated.\n     */\n    struct ResourceParams {\n        uint128 prevBaseFee;\n        uint64 prevBoughtGas;\n        uint64 prevBlockNum;\n    }\n\n    /**\n     * @notice Represents the configuration for the EIP-1559 based curve for the deposit gas\n     *         market. These values should be set with care as it is possible to set them in\n     *         a way that breaks the deposit gas market. The target resource limit is defined as\n     *         maxResourceLimit / elasticityMultiplier. This struct was designed to fit within a\n     *         single word. There is additional space for additions in the future.\n     *\n     * @custom:field maxResourceLimit             Represents the maximum amount of deposit gas that\n     *                                            can be purchased per block.\n     * @custom:field elasticityMultiplier         Determines the target resource limit along with\n     *                                            the resource limit.\n     * @custom:field baseFeeMaxChangeDenominator  Determines max change on fee per block.\n     * @custom:field minimumBaseFee               The min deposit base fee, it is clamped to this\n     *                                            value.\n     * @custom:field systemTxMaxGas               The amount of gas supplied to the system\n     *                                            transaction. This should be set to the same number\n     *                                            that the kroma-node sets as the gas limit for the\n     *                                            system transaction.\n     * @custom:field maximumBaseFee               The max deposit base fee, it is clamped to this\n     *                                            value.\n     */\n    struct ResourceConfig {\n        uint32 maxResourceLimit;\n        uint8 elasticityMultiplier;\n        uint8 baseFeeMaxChangeDenominator;\n        uint32 minimumBaseFee;\n        uint32 systemTxMaxGas;\n        uint128 maximumBaseFee;\n    }\n\n    /**\n     * @notice EIP-1559 style gas parameters.\n     */\n    ResourceParams public params;\n\n    /**\n     * @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\n     */\n    uint256[48] private __gap;\n\n    /**\n     * @notice Meters access to a function based an amount of a requested resource.\n     *\n     * @param _amount Amount of the resource requested.\n     */\n    modifier metered(uint64 _amount) {\n        // Record initial gas amount so we can refund for it later.\n        uint256 initialGas = gasleft();\n\n        // Run the underlying function.\n        _;\n\n        // Run the metering function.\n        _metered(_amount, initialGas);\n    }\n\n    /**\n     * @notice An internal function that holds all of the logic for metering a resource.\n     *\n     * @param _amount     Amount of the resource requested.\n     * @param _initialGas The amount of gas before any modifier execution.\n     */\n    function _metered(uint64 _amount, uint256 _initialGas) internal {\n        // Update block number and base fee if necessary.\n        uint256 blockDiff = block.number - params.prevBlockNum;\n\n        ResourceConfig memory config = _resourceConfig();\n        int256 targetResourceLimit = int256(uint256(config.maxResourceLimit)) /\n            int256(uint256(config.elasticityMultiplier));\n\n        if (blockDiff > 0) {\n            // Handle updating EIP-1559 style gas parameters. We use EIP-1559 to restrict the rate\n            // at which deposits can be created and therefore limit the potential for deposits to\n            // spam the L2 system. Fee scheme is very similar to EIP-1559 with minor changes.\n            int256 gasUsedDelta = int256(uint256(params.prevBoughtGas)) - targetResourceLimit;\n            int256 baseFeeDelta = (int256(uint256(params.prevBaseFee)) * gasUsedDelta) /\n                (targetResourceLimit * int256(uint256(config.baseFeeMaxChangeDenominator)));\n\n            // Update base fee by adding the base fee delta and clamp the resulting value between\n            // min and max.\n            int256 newBaseFee = Arithmetic.clamp({\n                _value: int256(uint256(params.prevBaseFee)) + baseFeeDelta,\n                _min: int256(uint256(config.minimumBaseFee)),\n                _max: int256(uint256(config.maximumBaseFee))\n            });\n\n            // If we skipped more than one block, we also need to account for every empty block.\n            // Empty block means there was no demand for deposits in that block, so we should\n            // reflect this lack of demand in the fee.\n            if (blockDiff > 1) {\n                // Update the base fee by repeatedly applying the exponent 1-(1/change_denominator)\n                // blockDiff - 1 times. Simulates multiple empty blocks. Clamp the resulting value\n                // between min and max.\n                newBaseFee = Arithmetic.clamp({\n                    _value: Arithmetic.cdexp({\n                        _coefficient: newBaseFee,\n                        _denominator: int256(uint256(config.baseFeeMaxChangeDenominator)),\n                        _exponent: int256(blockDiff - 1)\n                    }),\n                    _min: int256(uint256(config.minimumBaseFee)),\n                    _max: int256(uint256(config.maximumBaseFee))\n                });\n            }\n\n            // Update new base fee, reset bought gas, and update block number.\n            params.prevBaseFee = uint128(uint256(newBaseFee));\n            params.prevBoughtGas = 0;\n            params.prevBlockNum = uint64(block.number);\n        }\n\n        // Make sure we can actually buy the resource amount requested by the user.\n        params.prevBoughtGas += _amount;\n        require(\n            int256(uint256(params.prevBoughtGas)) <= int256(uint256(config.maxResourceLimit)),\n            \"ResourceMetering: cannot buy more gas than available gas limit\"\n        );\n\n        // Determine the amount of ETH to be paid.\n        uint256 resourceCost = uint256(_amount) * uint256(params.prevBaseFee);\n\n        // We currently charge for this ETH amount as an L1 gas burn, so we convert the ETH amount\n        // into gas by dividing by the L1 base fee. We assume a minimum base fee of 1 gwei to avoid\n        // division by zero for L1s that don't support 1559 or to avoid excessive gas burns during\n        // periods of extremely low L1 demand. One-day average gas fee hasn't dipped below 1 gwei\n        // during any 1 day period in the last 5 years, so should be fine.\n        uint256 gasCost = resourceCost / Math.max(block.basefee, 1 gwei);\n\n        // Give the user a refund based on the amount of gas they used to do all of the work up to\n        // this point. Since we're at the end of the modifier, this should be pretty accurate. Acts\n        // effectively like a dynamic stipend (with a minimum value).\n        uint256 usedGas = _initialGas - gasleft();\n        if (gasCost > usedGas) {\n            Burn.gas(gasCost - usedGas);\n        }\n    }\n\n    /**\n     * @notice Virtual function that returns the resource config. Contracts that inherit this\n     *         contract must implement this function.\n     *\n     * @return ResourceConfig\n     */\n    function _resourceConfig() internal virtual returns (ResourceConfig memory);\n\n    /**\n     * @notice Sets initial resource parameter values. This function must either be called by the\n     *         initializer function of an upgradeable child contract.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __ResourceMetering_init() internal onlyInitializing {\n        params = ResourceParams({\n            prevBaseFee: 1 gwei,\n            prevBoughtGas: 0,\n            prevBlockNum: uint64(block.number)\n        });\n    }\n}\n"
    },
    "contracts/L1/SecurityCouncil.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { MultiSigWallet } from \"../universal/MultiSigWallet.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { Colosseum } from \"./Colosseum.sol\";\n\n/**\n * @custom:proxied\n * @title SecurityCouncil\n * @notice SecurityCouncil receives validation requests for specific output data,\n *         and allows security council parties to validate & agree on transactions before execution.\n */\ncontract SecurityCouncil is MultiSigWallet, Semver {\n    /**\n     * @notice The address of the colosseum contract. Can be updated via upgrade.\n     */\n    address public immutable COLOSSEUM;\n\n    /**\n     * @notice A mapping of outputs requested to be deleted.\n     */\n    mapping(uint256 => bool) public outputsDeleteRequested;\n\n    /**\n     * @notice Emitted when a validation request is submitted.\n     *\n     * @param transactionId Index of the submitted transaction.\n     * @param outputRoot    The L2 output of the checkpoint block to be validated.\n     * @param l2BlockNumber The L2 block number to be validated.\n     */\n    event ValidationRequested(\n        uint256 indexed transactionId,\n        bytes32 outputRoot,\n        uint256 l2BlockNumber\n    );\n\n    /**\n     * @notice Emitted when an output is requested to be deleted.\n     *\n     * @param transactionId Index of the requested transaction.\n     * @param outputIndex   Index of output to be deleted.\n     */\n    event DeletionRequested(uint256 indexed transactionId, uint256 indexed outputIndex);\n\n    /**\n     * @notice Disallow calls from anyone except Colosseum.\n     */\n    modifier onlyColosseum() {\n        require(\n            msg.sender == COLOSSEUM,\n            \"SecurityCouncil: only the colosseum contract can be a sender\"\n        );\n        _;\n    }\n\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _colosseum Address of the Colosseum contract.\n     */\n    constructor(address _colosseum) Semver(0, 1, 0) {\n        COLOSSEUM = _colosseum;\n    }\n\n    /**\n     * @notice Initializer.\n     *\n     * @param ``                        Not used. Dummy parameter to prevent override.\n     * @param _owners                   List of initial owners.\n     * @param _numConfirmationsRequired Number of required confirmations.\n     *\n     */\n    function initialize(\n        bool,\n        address[] memory _owners,\n        uint256 _numConfirmationsRequired\n    ) public initializer {\n        MultiSigWallet.initialize(_owners, _numConfirmationsRequired);\n    }\n\n    /**\n     * @notice Allows the Colosseum to request for validate output data.\n     *\n     * @param _outputRoot    The L2 output of the checkpoint block to be validated.\n     * @param _l2BlockNumber The L2 block number to be validated.\n     * @param _data          Calldata for callback purpose.\n     */\n    function requestValidation(\n        bytes32 _outputRoot,\n        uint256 _l2BlockNumber,\n        bytes memory _data\n    ) public onlyColosseum {\n        uint256 transactionId = _addTransaction(msg.sender, 0, _data);\n        emit ValidationRequested(transactionId, _outputRoot, _l2BlockNumber);\n    }\n\n    /**\n     * @notice Requests to delete an output to Colosseum forcefully.\n     *         This should only be called by one of the Security Council when undeniable bugs occur.\n     *\n     * @param _outputIndex Index of output to be deleted.\n     * @param _force       Option to forcibly make a request to delete the output.\n     */\n    function requestDeletion(uint256 _outputIndex, bool _force) public ownerExists(msg.sender) {\n        require(\n            !outputsDeleteRequested[_outputIndex] || _force,\n            \"SecurityCouncil: the output has already been requested to be deleted\"\n        );\n        bytes memory message = abi.encodeWithSelector(\n            Colosseum.forceDeleteOutput.selector,\n            _outputIndex\n        );\n        uint256 transactionId = submitTransaction(COLOSSEUM, 0, message);\n        outputsDeleteRequested[_outputIndex] = true;\n        emit DeletionRequested(transactionId, _outputIndex);\n    }\n}\n"
    },
    "contracts/L1/SystemConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { ResourceMetering } from \"./ResourceMetering.sol\";\n\n/**\n * @title SystemConfig\n * @notice The SystemConfig contract is used to manage configuration of a Kroma network. All\n *         configuration is stored on L1 and picked up by L2 as part of the derivation of the L2\n *         chain.\n */\ncontract SystemConfig is OwnableUpgradeable, Semver {\n    /**\n     * @notice Enum representing different types of updates.\n     *\n     * @custom:value BATCHER                 Represents an update to the batcher hash.\n     * @custom:value GAS_CONFIG              Represents an update to txn fee config on L2.\n     * @custom:value GAS_LIMIT               Represents an update to gas limit on L2.\n     * @custom:value UNSAFE_BLOCK_SIGNER     Represents an update to the signer key for unsafe\n     *                                       block distribution.\n     * @custom:value VALIDATOR_REWARD_SCALAR Represents an update to validator reward scalar.\n     */\n    enum UpdateType {\n        BATCHER,\n        GAS_CONFIG,\n        GAS_LIMIT,\n        UNSAFE_BLOCK_SIGNER,\n        VALIDATOR_REWARD_SCALAR\n    }\n\n    /**\n     * @notice Version identifier, used for upgrades.\n     */\n    uint256 public constant VERSION = 0;\n\n    /**\n     * @notice Storage slot that the unsafe block signer is stored at. Storing it at this\n     *         deterministic storage slot allows for decoupling the storage layout from the way\n     *         that `solc` lays out storage. The `kroma-node` uses a storage proof to fetch this value.\n     */\n    bytes32 public constant UNSAFE_BLOCK_SIGNER_SLOT = keccak256(\"systemconfig.unsafeblocksigner\");\n\n    /**\n     * @notice Fixed L2 gas overhead. Used as part of the L2 fee calculation.\n     */\n    uint256 public overhead;\n\n    /**\n     * @notice Dynamic L2 gas overhead. Used as part of the L2 fee calculation.\n     */\n    uint256 public scalar;\n\n    /**\n     * @notice Identifier for the batcher. For version 1 of this configuration, this is represented\n     *         as an address left-padded with zeros to 32 bytes.\n     */\n    bytes32 public batcherHash;\n\n    /**\n     * @notice L2 block gas limit.\n     */\n    uint64 public gasLimit;\n\n    /**\n     * @notice The configuration for the deposit fee market. Used by the KromaPortal\n     *         to meter the cost of buying L2 gas on L1. Set as internal and wrapped with a getter\n     *         so that the struct is returned instead of a tuple.\n     */\n    ResourceMetering.ResourceConfig internal _resourceConfig;\n\n    /**\n     * @notice The scalar value to distribute transaction fees as validator reward.\n     *         The denominator is 10000, so the ratio is expressed in 4 decimal places.\n     */\n    uint256 public validatorRewardScalar;\n\n    /**\n     * @notice Emitted when configuration is updated\n     *\n     * @param version    SystemConfig version.\n     * @param updateType Type of update.\n     * @param data       Encoded update data.\n     */\n    event ConfigUpdate(uint256 indexed version, UpdateType indexed updateType, bytes data);\n\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _owner                 Initial owner of the contract.\n     * @param _overhead              Initial overhead value.\n     * @param _scalar                Initial scalar value.\n     * @param _batcherHash           Initial batcher hash.\n     * @param _gasLimit              Initial gas limit.\n     * @param _unsafeBlockSigner     Initial unsafe block signer address.\n     * @param _config                Initial resource config.\n     * @param _validatorRewardScalar Initial validator reward scalar.\n     */\n    constructor(\n        address _owner,\n        uint256 _overhead,\n        uint256 _scalar,\n        bytes32 _batcherHash,\n        uint64 _gasLimit,\n        address _unsafeBlockSigner,\n        ResourceMetering.ResourceConfig memory _config,\n        uint256 _validatorRewardScalar\n    ) Semver(0, 1, 0) {\n        initialize(\n            _owner,\n            _overhead,\n            _scalar,\n            _batcherHash,\n            _gasLimit,\n            _unsafeBlockSigner,\n            _config,\n            _validatorRewardScalar\n        );\n    }\n\n    /**\n     * @notice Initializer. The resource config must be set before the\n     *         require check.\n     *\n     * @param _owner                 Initial owner of the contract.\n     * @param _overhead              Initial overhead value.\n     * @param _scalar                Initial scalar value.\n     * @param _batcherHash           Initial batcher hash.\n     * @param _gasLimit              Initial gas limit.\n     * @param _unsafeBlockSigner     Initial unsafe block signer address.\n     * @param _config                Initial ResourceConfig.\n     * @param _validatorRewardScalar Initial validator reward scalar.\n     */\n    function initialize(\n        address _owner,\n        uint256 _overhead,\n        uint256 _scalar,\n        bytes32 _batcherHash,\n        uint64 _gasLimit,\n        address _unsafeBlockSigner,\n        ResourceMetering.ResourceConfig memory _config,\n        uint256 _validatorRewardScalar\n    ) public initializer {\n        __Ownable_init();\n        transferOwnership(_owner);\n        overhead = _overhead;\n        scalar = _scalar;\n        batcherHash = _batcherHash;\n        gasLimit = _gasLimit;\n        _setUnsafeBlockSigner(_unsafeBlockSigner);\n        _setResourceConfig(_config);\n        require(_gasLimit >= minimumGasLimit(), \"SystemConfig: gas limit too low\");\n        validatorRewardScalar = _validatorRewardScalar;\n    }\n\n    /**\n     * @notice Returns the minimum L2 gas limit that can be safely set for the system to\n     *         operate. The L2 gas limit must be larger than or equal to the amount of\n     *         gas that is allocated for deposits per block plus the amount of gas that\n     *         is allocated for the system transaction.\n     *         This function is used to determine if changes to parameters are safe.\n     *\n     * @return uint64\n     */\n    function minimumGasLimit() public view returns (uint64) {\n        return uint64(_resourceConfig.maxResourceLimit) + uint64(_resourceConfig.systemTxMaxGas);\n    }\n\n    /**\n     * @notice High level getter for the unsafe block signer address. Unsafe blocks can be\n     *         propagated across the p2p network if they are signed by the key corresponding to\n     *         this address.\n     *\n     * @return Address of the unsafe block signer.\n     */\n    // solhint-disable-next-line ordering\n    function unsafeBlockSigner() external view returns (address) {\n        address addr;\n        bytes32 slot = UNSAFE_BLOCK_SIGNER_SLOT;\n        assembly {\n            addr := sload(slot)\n        }\n        return addr;\n    }\n\n    /**\n     * @notice Updates the unsafe block signer address.\n     *\n     * @param _unsafeBlockSigner New unsafe block signer address.\n     */\n    function setUnsafeBlockSigner(address _unsafeBlockSigner) external onlyOwner {\n        _setUnsafeBlockSigner(_unsafeBlockSigner);\n\n        bytes memory data = abi.encode(_unsafeBlockSigner);\n        emit ConfigUpdate(VERSION, UpdateType.UNSAFE_BLOCK_SIGNER, data);\n    }\n\n    /**\n     * @notice Updates the batcher hash.\n     *\n     * @param _batcherHash New batcher hash.\n     */\n    function setBatcherHash(bytes32 _batcherHash) external onlyOwner {\n        batcherHash = _batcherHash;\n\n        bytes memory data = abi.encode(_batcherHash);\n        emit ConfigUpdate(VERSION, UpdateType.BATCHER, data);\n    }\n\n    /**\n     * @notice Updates gas config.\n     *\n     * @param _overhead New overhead value.\n     * @param _scalar   New scalar value.\n     */\n    function setGasConfig(uint256 _overhead, uint256 _scalar) external onlyOwner {\n        overhead = _overhead;\n        scalar = _scalar;\n\n        bytes memory data = abi.encode(_overhead, _scalar);\n        emit ConfigUpdate(VERSION, UpdateType.GAS_CONFIG, data);\n    }\n\n    /**\n     * @notice Updates the L2 gas limit.\n     *\n     * @param _gasLimit New gas limit.\n     */\n    function setGasLimit(uint64 _gasLimit) external onlyOwner {\n        require(_gasLimit >= minimumGasLimit(), \"SystemConfig: gas limit too low\");\n        gasLimit = _gasLimit;\n\n        bytes memory data = abi.encode(_gasLimit);\n        emit ConfigUpdate(VERSION, UpdateType.GAS_LIMIT, data);\n    }\n\n    /**\n     * @notice Low level setter for the unsafe block signer address. This function exists to\n     *         deduplicate code around storing the unsafeBlockSigner address in storage.\n     *\n     * @param _unsafeBlockSigner New unsafeBlockSigner value.\n     */\n    function _setUnsafeBlockSigner(address _unsafeBlockSigner) internal {\n        bytes32 slot = UNSAFE_BLOCK_SIGNER_SLOT;\n        assembly {\n            sstore(slot, _unsafeBlockSigner)\n        }\n    }\n\n    /**\n     * @notice A getter for the resource config. Ensures that the struct is\n     *         returned instead of a tuple.\n     *\n     * @return ResourceConfig\n     */\n    function resourceConfig() external view returns (ResourceMetering.ResourceConfig memory) {\n        return _resourceConfig;\n    }\n\n    /**\n     * @notice An external setter for the resource config. In the future, this\n     *         method may emit an event that the `kroma-node` picks up for when the\n     *         resource config is changed.\n     *\n     * @param _config The new resource config values.\n     */\n    function setResourceConfig(ResourceMetering.ResourceConfig memory _config) external onlyOwner {\n        _setResourceConfig(_config);\n    }\n\n    /**\n     * @notice An internal setter for the resource config. Ensures that the\n     *         config is sane before storing it by checking for invariants.\n     *\n     * @param _config The new resource config.\n     */\n    function _setResourceConfig(ResourceMetering.ResourceConfig memory _config) internal {\n        // Min base fee must be less than or equal to max base fee.\n        require(\n            _config.minimumBaseFee <= _config.maximumBaseFee,\n            \"SystemConfig: min base fee must be less than max base\"\n        );\n        // Base fee change denominator must be greater than 1.\n        require(\n            _config.baseFeeMaxChangeDenominator > 1,\n            \"SystemConfig: denominator must be larger than 1\"\n        );\n        // Max resource limit plus system tx gas must be less than or equal to the L2 gas limit.\n        // The gas limit must be increased before these values can be increased.\n        require(\n            _config.maxResourceLimit + _config.systemTxMaxGas <= gasLimit,\n            \"SystemConfig: gas limit too low\"\n        );\n        // Elasticity multiplier must be greater than 0.\n        require(\n            _config.elasticityMultiplier > 0,\n            \"SystemConfig: elasticity multiplier cannot be 0\"\n        );\n        // No precision loss when computing target resource limit.\n        require(\n            ((_config.maxResourceLimit / _config.elasticityMultiplier) *\n                _config.elasticityMultiplier) == _config.maxResourceLimit,\n            \"SystemConfig: precision loss with target resource limit\"\n        );\n\n        _resourceConfig = _config;\n    }\n\n    /**\n     * @notice Updates the validator reward scalar.\n     *\n     * @param _validatorRewardScalar New validator reward scalar.\n     */\n    function setValidatorRewardScalar(uint256 _validatorRewardScalar) external onlyOwner {\n        require(\n            _validatorRewardScalar <= Constants.VALIDATOR_REWARD_DENOMINATOR,\n            \"SystemConfig: the max value of validator reward scalar has been exceeded\"\n        );\n\n        validatorRewardScalar = _validatorRewardScalar;\n\n        bytes memory data = abi.encode(_validatorRewardScalar);\n        emit ConfigUpdate(VERSION, UpdateType.VALIDATOR_REWARD_SCALAR, data);\n    }\n}\n"
    },
    "contracts/L1/ValidatorPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    ReentrancyGuardUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { ValidatorRewardVault } from \"../L2/ValidatorRewardVault.sol\";\nimport { KromaPortal } from \"./KromaPortal.sol\";\nimport { L2OutputOracle } from \"./L2OutputOracle.sol\";\n\n/**\n * @custom:proxied\n * @title ValidatorPool\n * @notice The ValidatorPool determines whether the validator is present and manages the validator's deposit.\n */\ncontract ValidatorPool is ReentrancyGuardUpgradeable, Semver {\n    /**\n     * @notice The gas limit to use when rewarding validator in the ValidatorRewardVault on L2.\n     *         This value is measured through simulation.\n     */\n    uint64 public constant VAULT_REWARD_GAS_LIMIT = 100000;\n\n    /**\n     * @notice The numerator of the tax.\n     */\n    uint128 public constant TAX_NUMERATOR = 20;\n\n    /**\n     * @notice The denominator of the tax.\n     */\n    uint128 public constant TAX_DENOMINATOR = 100;\n\n    /**\n     * @notice The address of the L2OutputOracle contract. Can be updated via upgrade.\n     */\n    L2OutputOracle public immutable L2_ORACLE;\n\n    /**\n     * @notice The address of the KromaPortal contract. Can be updated via upgrade.\n     */\n    KromaPortal public immutable PORTAL;\n\n    /**\n     * @notice The address of the SecurityCouncil contract. Can be updated via upgrade.\n     */\n    address public immutable SECURITY_COUNCIL;\n\n    /**\n     * @notice The address of the trusted validator. Can be updated via upgrade.\n     */\n    address public immutable TRUSTED_VALIDATOR;\n\n    /**\n     * @notice The required bond amount. Can be updated via upgrade.\n     */\n    uint128 public immutable REQUIRED_BOND_AMOUNT;\n\n    /**\n     * @notice The max number of unbonds when trying unbond.\n     */\n    uint256 public immutable MAX_UNBOND;\n\n    /**\n     * @notice The duration of a submission round for one output (in seconds).\n     *         Note that there are two submission rounds for an output: PRIORITY ROUND and PUBLIC ROUND.\n     */\n    uint256 public immutable ROUND_DURATION;\n\n    /**\n     * @notice A mapping of balances.\n     */\n    mapping(address => uint256) internal balances;\n\n    /**\n     * @notice The bond corresponding to a specific output index.\n     */\n    mapping(uint256 => Types.Bond) internal bonds;\n\n    /**\n     * @notice The output index to unbond next.\n     */\n    uint256 internal nextUnbondOutputIndex;\n\n    /**\n     * @notice An array of validator addresses.\n     */\n    address[] internal validators;\n\n    /**\n     * @notice The index of the specific address in the validator array.\n     */\n    mapping(address => uint256) internal validatorIndexes;\n\n    /**\n     * @notice Address of the next validator with priority for submitting output.\n     */\n    address internal nextPriorityValidator;\n\n    /**\n     * @notice A mapping of pending bonds that have not yet been included in a bond.\n     */\n    mapping(uint256 => mapping(address => uint128)) internal pendingBonds;\n\n    /**\n     * @notice Emitted when a validator bonds.\n     *\n     * @param submitter   Address of submitter.\n     * @param outputIndex Index of the L2 checkpoint output index.\n     * @param amount      Amount of bonded.\n     * @param expiresAt   The expiration timestamp of bond.\n     */\n    event Bonded(\n        address indexed submitter,\n        uint256 indexed outputIndex,\n        uint128 amount,\n        uint128 expiresAt\n    );\n\n    /**\n     * @notice Emitted when the pending bond is added.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param challenger  Address of the challenger.\n     * @param amount      Amount of bond added.\n     */\n    event PendingBondAdded(uint256 indexed outputIndex, address indexed challenger, uint128 amount);\n\n    /**\n     * @notice Emitted when the bond is increased.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param challenger  Address of the challenger.\n     * @param amount      Amount of bond increased.\n     */\n    event BondIncreased(uint256 indexed outputIndex, address indexed challenger, uint128 amount);\n\n    /**\n     * @notice Emitted when the pending bond is released(refunded).\n     *\n     * @param outputIndex  Index of the L2 checkpoint output.\n     * @param challenger   Address of the challenger.\n     * @param recipient    Address to receive amount from a pending bond.\n     * @param amount       Amount of bond released.\n     */\n    event PendingBondReleased(\n        uint256 indexed outputIndex,\n        address indexed challenger,\n        address indexed recipient,\n        uint128 amount\n    );\n\n    /**\n     * @notice Emitted when a validator unbonds.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param recipient   Address of the recipient.\n     * @param amount      Amount of unbonded.\n     */\n    event Unbonded(uint256 indexed outputIndex, address indexed recipient, uint128 amount);\n\n    /**\n     * @notice A modifier that only allows the Colosseum contract to call\n     */\n    modifier onlyColosseum() {\n        require(msg.sender == L2_ORACLE.COLOSSEUM(), \"ValidatorPool: sender is not Colosseum\");\n        _;\n    }\n\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _l2OutputOracle     Address of the L2OutputOracle.\n     * @param _portal             Address of the KromaPortal.\n     * @param _securityCouncil    Address of the security council.\n     * @param _trustedValidator   Address of the trusted validator.\n     * @param _requiredBondAmount The required bond amount.\n     * @param _maxUnbond          The max number of unbonds when trying unbond.\n     * @param _roundDuration      The duration of one submission round in seconds.\n     */\n    constructor(\n        L2OutputOracle _l2OutputOracle,\n        KromaPortal _portal,\n        address _securityCouncil,\n        address _trustedValidator,\n        uint256 _requiredBondAmount,\n        uint256 _maxUnbond,\n        uint256 _roundDuration\n    ) Semver(0, 1, 0) {\n        L2_ORACLE = _l2OutputOracle;\n        PORTAL = _portal;\n        SECURITY_COUNCIL = _securityCouncil;\n        TRUSTED_VALIDATOR = _trustedValidator;\n        REQUIRED_BOND_AMOUNT = uint128(_requiredBondAmount);\n        MAX_UNBOND = _maxUnbond;\n\n        // Note that this value MUST be (SUBMISSION_INTERVAL * L2_BLOCK_TIME) / 2.\n        ROUND_DURATION = _roundDuration;\n\n        initialize();\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize() public initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    /**\n     * @notice Deposit ETH to be used as bond.\n     */\n    function deposit() external payable {\n        _increaseBalance(msg.sender, msg.value);\n    }\n\n    /**\n     * @notice Withdraw a given amount.\n     *\n     * @param _amount Amount to withdraw.\n     */\n    function withdraw(uint256 _amount) external nonReentrant {\n        _decreaseBalance(msg.sender, _amount);\n\n        bool success = SafeCall.call(msg.sender, gasleft(), _amount, \"\");\n        require(success, \"ValidatorPool: ETH transfer failed\");\n    }\n\n    /**\n     * @notice Bond asset corresponding to the given output index.\n     *         This function is called when submitting output.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _expiresAt   The expiration timestamp of bond.\n     */\n    function createBond(uint256 _outputIndex, uint128 _expiresAt) external {\n        require(msg.sender == address(L2_ORACLE), \"ValidatorPool: sender is not L2OutputOracle\");\n\n        Types.Bond storage bond = bonds[_outputIndex];\n        require(\n            bond.expiresAt == 0,\n            \"ValidatorPool: bond of the given output index already exists\"\n        );\n\n        // Unbond the bond of nextUnbondOutputIndex if available.\n        _tryUnbond();\n\n        address submitter = L2_ORACLE.getSubmitter(_outputIndex);\n        _decreaseBalance(submitter, REQUIRED_BOND_AMOUNT);\n\n        bond.amount = REQUIRED_BOND_AMOUNT;\n        bond.expiresAt = _expiresAt;\n\n        emit Bonded(submitter, _outputIndex, REQUIRED_BOND_AMOUNT, _expiresAt);\n    }\n\n    /**\n     * @notice Adds a pending bond to the challenge corresponding to the given output index and challenger address.\n     *         The pending bond is added to the bond when the challenge is proven or challenger is timed out,\n     *         or refunded when the challenge is canceled.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _challenger  Address of the challenger.\n     */\n    function addPendingBond(uint256 _outputIndex, address _challenger) external onlyColosseum {\n        Types.Bond storage bond = bonds[_outputIndex];\n        require(\n            bond.expiresAt >= block.timestamp,\n            \"ValidatorPool: the output is already finalized\"\n        );\n\n        _decreaseBalance(_challenger, REQUIRED_BOND_AMOUNT);\n        pendingBonds[_outputIndex][_challenger] = REQUIRED_BOND_AMOUNT;\n\n        emit PendingBondAdded(_outputIndex, _challenger, REQUIRED_BOND_AMOUNT);\n    }\n\n    /**\n     * @notice Releases the corresponding pending bond to the given output index and challenger address\n     *         if a challenge is canceled.\n     *\n     * @param _outputIndex  Index of the L2 checkpoint output.\n     * @param _challenger   Address of the challenger.\n     * @param _recipient    Address to receive amount from a pending bond.\n     */\n    function releasePendingBond(\n        uint256 _outputIndex,\n        address _challenger,\n        address _recipient\n    ) external onlyColosseum {\n        uint128 bonded = pendingBonds[_outputIndex][_challenger];\n        require(bonded > 0, \"ValidatorPool: the pending bond does not exist\");\n        delete pendingBonds[_outputIndex][_challenger];\n\n        _increaseBalance(_recipient, bonded);\n        emit PendingBondReleased(_outputIndex, _challenger, _recipient, bonded);\n    }\n\n    /**\n     * @notice Increases the bond amount corresponding to the given output index by the pending bond amount.\n     *         This is when taxes are charged, and note that taxes are a means of preventing collusive attacks by\n     *         the asserter and challenger.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _challenger  Address of the challenger.\n     */\n    function increaseBond(uint256 _outputIndex, address _challenger) external onlyColosseum {\n        Types.Bond storage bond = bonds[_outputIndex];\n        require(\n            bond.expiresAt >= block.timestamp,\n            \"ValidatorPool: the output is already finalized\"\n        );\n\n        uint128 pendingBond = pendingBonds[_outputIndex][_challenger];\n        require(pendingBond > 0, \"ValidatorPool: the pending bond does not exist\");\n        uint128 tax = (pendingBond * TAX_NUMERATOR) / TAX_DENOMINATOR;\n        uint128 increased = pendingBond - tax;\n        delete pendingBonds[_outputIndex][_challenger];\n\n        unchecked {\n            bond.amount += increased;\n            balances[SECURITY_COUNCIL] += tax;\n        }\n\n        emit BondIncreased(_outputIndex, _challenger, increased);\n    }\n\n    /**\n     * @notice Attempt to unbond. Reverts if unbond is not possible.\n     */\n    function unbond() external {\n        bool released = _tryUnbond();\n        require(released, \"ValidatorPool: no bond that can be unbond\");\n    }\n\n    /**\n     * @notice Attempts to unbond starting from nextUnbondOutputIndex and returns whether at least\n     *         one unbond is executed. Tries unbond at most MAX_UNBOND number of bonds and sends\n     *         a reward message to L2 for each unbond.\n     *         Note that it updates the next priority validator using last unbond, and not updates\n     *         when no unbond.\n     *\n     * @return Whether at least one unbond is executed.\n     */\n    function _tryUnbond() private returns (bool) {\n        uint256 outputIndex = nextUnbondOutputIndex;\n        uint128 bondAmount;\n        Types.Bond storage bond;\n        Types.CheckpointOutput memory output;\n\n        uint256 unbondedNum = 0;\n        for (; unbondedNum < MAX_UNBOND; ) {\n            bond = bonds[outputIndex];\n            bondAmount = bond.amount;\n\n            if (block.timestamp >= bond.expiresAt && bondAmount > 0) {\n                delete bonds[outputIndex];\n                output = L2_ORACLE.getL2Output(outputIndex);\n                _increaseBalance(output.submitter, bondAmount);\n                emit Unbonded(outputIndex, output.submitter, bondAmount);\n\n                // Send reward message to L2 ValidatorRewardVault.\n                _sendRewardMessageToL2Vault(output);\n\n                unchecked {\n                    ++unbondedNum;\n                    ++outputIndex;\n                }\n            } else {\n                break;\n            }\n        }\n\n        if (unbondedNum > 0) {\n            // Select the next priority validator.\n            _updatePriorityValidator(output.outputRoot);\n\n            unchecked {\n                nextUnbondOutputIndex = outputIndex;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice Updates next priority validator address.\n     *\n     * @param _outputRoot The L2 output of the checkpoint block.\n     */\n    function _updatePriorityValidator(bytes32 _outputRoot) private {\n        uint256 len = validators.length;\n        if (len > 0) {\n            // TODO(pangssu): improve next validator selection\n            uint256 validatorIndex = uint256(\n                keccak256(\n                    abi.encodePacked(\n                        _outputRoot,\n                        block.number,\n                        block.coinbase,\n                        block.difficulty,\n                        blockhash(block.number - 1)\n                    )\n                )\n            ) % len;\n\n            nextPriorityValidator = validators[validatorIndex];\n        } else {\n            nextPriorityValidator = address(0);\n        }\n    }\n\n    /**\n     * @notice Sends reward message to ValidatorRewardVault contract on L2 using Portal.\n     *\n     * @param _output The finalized output.\n     */\n    function _sendRewardMessageToL2Vault(Types.CheckpointOutput memory _output) private {\n        // Pay out rewards via L2 Vault now that the output is finalized.\n        PORTAL.depositTransactionByValidatorPool(\n            Predeploys.VALIDATOR_REWARD_VAULT,\n            VAULT_REWARD_GAS_LIMIT,\n            abi.encodeWithSelector(\n                ValidatorRewardVault.reward.selector,\n                _output.submitter,\n                _output.l2BlockNumber\n            )\n        );\n    }\n\n    /**\n     * @notice Increases the balance of the given address. If the balance is greater than the required bond amount,\n     *         add the given address to the validator set.\n     *\n     * @param _validator Address to increase the balance.\n     * @param _amount    Amount of balance increased.\n     */\n    function _increaseBalance(address _validator, uint256 _amount) private {\n        uint256 balance = balances[_validator] + _amount;\n\n        if (balance >= REQUIRED_BOND_AMOUNT && !isValidator(_validator)) {\n            if (_validator != SECURITY_COUNCIL) {\n                validatorIndexes[_validator] = validators.length;\n                validators.push(_validator);\n            }\n        }\n\n        balances[_validator] = balance;\n    }\n\n    /**\n     * @notice Deceases the balance of the given address. If the balance is less than the required bond amount,\n     *         remove the given address from the validator set.\n     *\n     * @param _validator Address to decrease the balance.\n     * @param _amount    Amount of balance decreased.\n     */\n    function _decreaseBalance(address _validator, uint256 _amount) private {\n        uint256 balance = balances[_validator];\n        require(balance >= _amount, \"ValidatorPool: insufficient balances\");\n        balance = balance - _amount;\n\n        if (balance < REQUIRED_BOND_AMOUNT && isValidator(_validator)) {\n            uint256 lastValidatorIndex = validators.length - 1;\n            if (lastValidatorIndex > 0) {\n                uint256 validatorIndex = validatorIndexes[_validator];\n                address lastValidator = validators[lastValidatorIndex];\n\n                validators[validatorIndex] = lastValidator;\n                validatorIndexes[lastValidator] = validatorIndex;\n            }\n            delete validatorIndexes[_validator];\n            validators.pop();\n        }\n\n        balances[_validator] = balance;\n    }\n\n    /**\n     * @notice Returns the bond corresponding to the output index. Reverts if the bond does not exist.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     *\n     * @return The bond data.\n     */\n    function getBond(uint256 _outputIndex) external view returns (Types.Bond memory) {\n        Types.Bond storage bond = bonds[_outputIndex];\n        require(bond.amount > 0 && bond.expiresAt > 0, \"ValidatorPool: the bond does not exist\");\n        return bond;\n    }\n\n    /**\n     * @notice Returns the pending bond corresponding to the output index and challenger address.\n     *         Reverts if the pending bond does not exist.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _challenger  Address of the challenger.\n     *\n     * @return Amount of the pending bond.\n     */\n    function getPendingBond(uint256 _outputIndex, address _challenger)\n        external\n        view\n        returns (uint128)\n    {\n        uint128 pendingBond = pendingBonds[_outputIndex][_challenger];\n        require(pendingBond > 0, \"ValidatorPool: the pending bond does not exist\");\n        return pendingBond;\n    }\n\n    /**\n     * @notice Returns the balance of given address.\n     *\n     * @param _addr Address of validator.\n     *\n     * @return Balance of given address.\n     */\n    function balanceOf(address _addr) external view returns (uint256) {\n        return balances[_addr];\n    }\n\n    /**\n     * @notice Determines whether the given address is an active validator.\n     *\n     * @param _addr Address of validator.\n     *\n     * @return Whether the given address is an active validator.\n     */\n    function isValidator(address _addr) public view returns (bool) {\n        if (validators.length == 0) {\n            return false;\n        } else if (_addr == address(0)) {\n            return false;\n        }\n\n        uint256 index = validatorIndexes[_addr];\n        return validators[index] == _addr;\n    }\n\n    /**\n     * @notice Returns the number of validators.\n     *\n     * @return The number of validators.\n     */\n    function validatorCount() external view returns (uint256) {\n        return validators.length;\n    }\n\n    /**\n     * @notice Determines who can submit the L2 output next.\n     *\n     * @return The address of the validator.\n     */\n    function nextValidator() public view returns (address) {\n        if (nextPriorityValidator != address(0)) {\n            uint256 l2BlockNumber = L2_ORACLE.nextBlockNumber();\n            uint256 l2Timestamp = L2_ORACLE.computeL2Timestamp(l2BlockNumber + 1);\n            if (block.timestamp >= l2Timestamp) {\n                uint256 elapsed = block.timestamp - l2Timestamp;\n                // If the current time exceeds one round time, it is a public round.\n                if (elapsed > ROUND_DURATION) {\n                    return Constants.VALIDATOR_PUBLIC_ROUND_ADDRESS;\n                }\n            }\n\n            return nextPriorityValidator;\n        } else {\n            return TRUSTED_VALIDATOR;\n        }\n    }\n}\n"
    },
    "contracts/L1/ZKMerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bytes } from \"../libraries/Bytes.sol\";\nimport { NodeReader } from \"../libraries/NodeReader.sol\";\nimport { IZKMerkleTrie } from \"./IZKMerkleTrie.sol\";\nimport { ZKTrieHasher } from \"./ZKTrieHasher.sol\";\n\n/**\n * @custom:proxied\n * @title ZKMerkleTrie\n * @notice The ZKMerkleTrie is contract which can produce a hash according to ZKTrie.\n *         This owns an interface of Poseidon2 that is required to compute hash used by ZKTrie.\n */\ncontract ZKMerkleTrie is IZKMerkleTrie, ZKTrieHasher {\n    /**\n     * @notice Struct representing a node in the trie.\n     */\n    struct TrieNode {\n        bytes encoded;\n        NodeReader.Node decoded;\n    }\n\n    /**\n     * @notice Magic hash which indicates\n     *         See https://github.com/kroma-network/zktrie/blob/main/trie/zk_trie_proof.go.\n     */\n    bytes32 private constant MAGIC_SMT_BYTES_HASH =\n        keccak256(\n            hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\"\n        );\n\n    /**\n     * @param _poseidon2 The address of poseidon2 contract.\n     */\n    constructor(address _poseidon2) ZKTrieHasher(_poseidon2) {}\n\n    /**\n     * @notice Checks if a given bytes is MAGIC_SMT_BYTES_HASH.\n     *\n     * @param _value Bytes to be compared.\n     */\n    function isMagicSmtBytesHash(bytes memory _value) private pure returns (bool) {\n        return keccak256(_value) == MAGIC_SMT_BYTES_HASH;\n    }\n\n    /**\n     * @inheritdoc IZKMerkleTrie\n     */\n    function verifyInclusionProof(\n        bytes32 _key,\n        bytes memory _value,\n        bytes[] memory _proofs,\n        bytes32 _root\n    ) external view returns (bool) {\n        (bool exists, bytes memory value) = this.get(_key, _proofs, _root);\n        return (exists && Bytes.equal(_value, value));\n    }\n\n    /**\n     * @notice Retrieves the value associated with a given key.\n     *\n     * @param _key    Key to search for, as hex bytes.\n     * @param _proofs Merkle trie inclusion proof for the key.\n     * @param _root   Known root of the Merkle trie.\n     *\n     * @return Whether or not the key exists.\n     * @return Value of the key if it exists.\n     */\n    function get(\n        bytes32 _key,\n        bytes[] memory _proofs,\n        bytes32 _root\n    ) external view returns (bool, bytes memory) {\n        require(_proofs.length >= 2, \"ZKMerkleTrie: provided proof is too short\");\n        require(\n            isMagicSmtBytesHash(_proofs[_proofs.length - 1]),\n            \"ZKMerkleTrie: the last item is not magic hash\"\n        );\n        bytes32 key = _hashElem(_key);\n        TrieNode[] memory nodes = _parseProofs(_proofs);\n        NodeReader.Node memory currentNode;\n        bytes32 computedKey = bytes32(0);\n        bool exists = false;\n        bool empty = false;\n        bytes memory value = bytes(\"\");\n        for (uint256 i = nodes.length - 2; i >= 0; ) {\n            currentNode = nodes[i].decoded;\n            if (currentNode.nodeType == NodeReader.NodeType.MIDDLE) {\n                bool isLeft = _isLeft(key, i);\n                if (isLeft) {\n                    require(computedKey == currentNode.childL, \"ZKMerkleTrie: invalid key L\");\n                } else {\n                    require(computedKey == currentNode.childR, \"ZKMerkleTrie: invalid key R\");\n                }\n                computedKey = _hashFixed2Elems(\n                    currentNode.childL,\n                    currentNode.childR\n                );\n            } else if (currentNode.nodeType == NodeReader.NodeType.LEAF) {\n                require(!exists && !empty, \"ZKMerkleTrie: duplicated terminal node\");\n                exists = currentNode.nodeKey == key;\n                if (!exists) {\n                    break;\n                }\n                computedKey = _hashFixed3Elems(\n                    bytes32(uint256(1)),\n                    currentNode.nodeKey,\n                    _valueHash(currentNode.compressedFlags, currentNode.valuePreimage)\n                );\n                bytes32[] memory valuePreimage = currentNode.valuePreimage;\n                uint256 len = valuePreimage.length;\n                assembly {\n                    value := valuePreimage\n                    mstore(value, mul(len, 32))\n                }\n                if (currentNode.keyPreimage != bytes32(0)) {\n                    // NOTE(chokobole): The comparison order is important, because in this setting,\n                    // first condition is mostly evaluted to be true. When we're sure about\n                    // database preimage, then we need to enable just one of check below!\n                    require(\n                        currentNode.keyPreimage == _key || currentNode.keyPreimage == key,\n                        \"ZKMerkleTrie: invalid key preimage\"\n                    );\n                }\n            } else if (currentNode.nodeType == NodeReader.NodeType.EMPTY) {\n                require(!exists && !empty, \"ZKMerkleTrie: duplicated terminal node\");\n                empty = true;\n            }\n            if (i == 0) {\n                require(computedKey == _root, \"ZKMerkeTrie: invalid root\");\n                break;\n            }\n            unchecked {\n                --i;\n            }\n        }\n        return (exists, value);\n    }\n\n    /**\n     * @notice Parses an array of proof elements into a new array that contains both the original\n     *         encoded element and the decoded element.\n     *\n     * @param _proofs Array of proof elements to parse.\n     *\n     * @return TrieNode parsed into easily accessible structs.\n     */\n    function _parseProofs(bytes[] memory _proofs) private pure returns (TrieNode[] memory) {\n        uint256 length = _proofs.length;\n        TrieNode[] memory nodes = new TrieNode[](length);\n        // NOTE(chokobole): Last proof is MAGIC_SMT_BYTES_HASH!\n        for (uint256 i = 0; i < length - 1; ) {\n            NodeReader.Node memory node = NodeReader.readNode(_proofs[i]);\n            nodes[i] = TrieNode({ encoded: _proofs[i], decoded: node });\n            unchecked {\n                ++i;\n            }\n        }\n        return nodes;\n    }\n\n    /**\n     * @notice Computes merkle path at index n based on a given keyPreimage.\n     *\n     * @param _keyPreimage Keypreimage.\n     * @param _n           Bit to mask.\n     *\n     * @return Whether merkle path is left or not.\n     */\n    function _isLeft(bytes32 _keyPreimage, uint256 _n) private pure returns (bool) {\n        require(_n < 256, \"ZKMerkleTrie: too long depth\");\n        return _keyPreimage & bytes32(1 << _n) == 0;\n    }\n}\n"
    },
    "contracts/L1/ZKTrieHasher.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { Bytes32 } from \"../libraries/Bytes32.sol\";\n\n/**\n * @title IPoseidon2\n */\ninterface IPoseidon2 {\n    function poseidon(bytes32[2] memory inputs) external pure returns (bytes32);\n}\n\n/**\n * @custom:proxied\n * @title ZKTrieHasher\n * @notice The ZKTrieHasher is contract which can produce a hash according to ZKTrie.\n *         This owns an interface of Poseidon2 that is required to compute hash used by ZKTrie.\n */\ncontract ZKTrieHasher {\n    /**\n     * @notice Poseidon2 contract generated by circomlibjs.\n     */\n    IPoseidon2 public immutable POSEIDON2;\n\n    /**\n     * @param _poseidon2 The address of poseidon2 contract.\n     */\n    constructor(address _poseidon2) {\n        POSEIDON2 = IPoseidon2(_poseidon2);\n    }\n\n    /**\n     * @notice Computes a hash of values.\n     *\n     * @param _compressedFlags Compressed flags.\n     * @param _values          Values.\n     *\n     * @return A hash of values.\n     */\n    function _valueHash(uint32 _compressedFlags, bytes32[] memory _values)\n        internal\n        view\n        returns (bytes32)\n    {\n        require(_values.length >= 1, \"ZKTrieHasher: too few values for _valueHash\");\n        bytes32[] memory ret = new bytes32[](_values.length);\n        for (uint256 i = 0; i < _values.length; ) {\n            if ((_compressedFlags & (1 << i)) != 0) {\n                ret[i] = _hashElem(_values[i]);\n            } else {\n                ret[i] = _values[i];\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        if (_values.length < 2) {\n            return ret[0];\n        }\n        return _hashElems(ret);\n    }\n\n    /**\n     * @notice Computes a hash of an element.\n     *\n     * @param _elem Bytes32 to be hashed.\n     *\n     * @return A hash of an element.\n     */\n    function _hashElem(bytes32 _elem) internal view returns (bytes32) {\n        (bytes32 high, bytes32 low) = Bytes32.split(_elem);\n        return POSEIDON2.poseidon([high, low]);\n    }\n\n    /**\n     * @notice Computes a root hash of elements tree.\n     *\n     * @param _elems Bytes32 array to be hashed.\n     *\n     * @return A hash of elements tree.\n     */\n    function _hashElems(bytes32[] memory _elems) internal view returns (bytes32) {\n        require(_elems.length >= 4, \"ZKTrieHasher: too few values for _hashElems\");\n        IPoseidon2 iposeidon = POSEIDON2;\n\n        uint256 idx;\n        uint256 adjacent_idx;\n\n        uint256 adjacent_offset = 1;\n        uint256 jump = 2;\n        uint256 length = _elems.length;\n        for (; adjacent_offset < length;) {\n            for (idx = 0; idx < length;) {\n                unchecked {\n                    adjacent_idx = idx + adjacent_offset;\n                }\n                if (adjacent_idx < length) {\n                    _elems[idx] = iposeidon.poseidon( [_elems[idx], _elems[adjacent_idx]] );\n                }\n                unchecked {\n                    idx += jump;\n                }\n            }\n            adjacent_offset = jump;\n            jump <<= 1;\n        }\n\n        return _elems[0];\n    }\n\n    /**\n     * @notice Computes a root hash of 2 elements.\n     *\n     * @param left_leaf  Bytes32 left leaf to be hashed.\n     * @param right_leaf Bytes32 right leaf to be hashed.\n     *\n     * @return A hash of 2 elements.\n     */\n    function _hashFixed2Elems(bytes32 left_leaf, bytes32 right_leaf) internal view returns (bytes32) {\n        return POSEIDON2.poseidon([left_leaf, right_leaf]);\n    }\n\n   /**\n     * @notice Computes a root hash of 3 elements.\n     *\n     * @param left_leaf  Bytes32 left leaf to be hashed.\n     * @param right_leaf Bytes32 right leaf to be hashed.\n     * @param up_leaf    Bytes32 up leaf to be hashed with left||right hash.\n     *\n     * @return A hash of 3 elements.\n     */\n    function _hashFixed3Elems(bytes32 left_leaf, bytes32 right_leaf, bytes32 up_leaf) internal view returns (bytes32) {\n        IPoseidon2 iposeidon = POSEIDON2;\n        left_leaf = iposeidon.poseidon([left_leaf, right_leaf]);\n        return iposeidon.poseidon([left_leaf, up_leaf]);\n    }\n}\n"
    },
    "contracts/L1/ZKVerifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\ncontract ZKVerifier {\n    uint256 internal immutable HASH_SCALAR_VALUE;\n    uint256 internal immutable M_56_PX_VALUE;\n    uint256 internal immutable M_56_PY_VALUE;\n\n    constructor(uint256 _hashScalar, uint256 _m56Px, uint256 _m56Py) {\n        HASH_SCALAR_VALUE = _hashScalar;\n        M_56_PX_VALUE = _m56Px;\n        M_56_PY_VALUE = _m56Py;\n    }\n\n    function pairing(G1Point[] memory p1, G2Point[] memory p2) internal view returns (bool) {\n        uint256 length = p1.length * 6;\n        uint256[] memory input = new uint256[](length);\n        uint256[1] memory result;\n        bool ret;\n\n        require(p1.length == p2.length);\n\n        for (uint256 i = 0; i < p1.length; i++) {\n            input[0 + i * 6] = p1[i].x;\n            input[1 + i * 6] = p1[i].y;\n            input[2 + i * 6] = p2[i].x[0];\n            input[3 + i * 6] = p2[i].x[1];\n            input[4 + i * 6] = p2[i].y[0];\n            input[5 + i * 6] = p2[i].y[1];\n        }\n\n        assembly {\n            ret := staticcall(gas(), 8, add(input, 0x20), mul(length, 0x20), result, 0x20)\n        }\n        require(ret);\n        return result[0] != 0;\n    }\n\n    uint256 constant q_mod =\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    function fr_invert(uint256 a) internal view returns (uint256) {\n        return fr_pow(a, q_mod - 2);\n    }\n\n    function fr_pow(uint256 a, uint256 power) internal view returns (uint256) {\n        uint256[6] memory input;\n        uint256[1] memory result;\n        bool ret;\n\n        input[0] = 32;\n        input[1] = 32;\n        input[2] = 32;\n        input[3] = a;\n        input[4] = power;\n        input[5] = q_mod;\n\n        assembly {\n            ret := staticcall(gas(), 0x05, input, 0xc0, result, 0x20)\n        }\n        require(ret);\n\n        return result[0];\n    }\n\n    function fr_div(uint256 a, uint256 b) internal view returns (uint256) {\n        require(b != 0);\n        return mulmod(a, fr_invert(b), q_mod);\n    }\n\n    function fr_mul_add(\n        uint256 a,\n        uint256 b,\n        uint256 c\n    ) internal pure returns (uint256) {\n        return addmod(mulmod(a, b, q_mod), c, q_mod);\n    }\n\n    function fr_mul_add_pm(\n        uint256[84] memory m,\n        uint256[] calldata proof,\n        uint256 opcode,\n        uint256 t\n    ) internal pure returns (uint256) {\n        for (uint256 i = 0; i < 32; i += 2) {\n            uint256 a = opcode & 0xff;\n            if (a != 0xff) {\n                opcode >>= 8;\n                uint256 b = opcode & 0xff;\n                opcode >>= 8;\n                t = addmod(mulmod(proof[a], m[b], q_mod), t, q_mod);\n            } else {\n                break;\n            }\n        }\n\n        return t;\n    }\n\n    function fr_mul_add_mt(\n        uint256[84] memory m,\n        uint256 base,\n        uint256 opcode,\n        uint256 t\n    ) internal pure returns (uint256) {\n        for (uint256 i = 0; i < 32; i += 1) {\n            uint256 a = opcode & 0xff;\n            if (a != 0xff) {\n                opcode >>= 8;\n                t = addmod(mulmod(base, t, q_mod), m[a], q_mod);\n            } else {\n                break;\n            }\n        }\n\n        return t;\n    }\n\n    function fr_reverse(uint256 input) internal pure returns (uint256 v) {\n        v = input;\n\n        // swap bytes\n        v =\n            ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8) |\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n\n        // swap 2-byte long pairs\n        v =\n            ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16) |\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n\n        // swap 4-byte long pairs\n        v =\n            ((v & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32) |\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n\n        // swap 8-byte long pairs\n        v =\n            ((v & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64) |\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n\n        // swap 16-byte long pairs\n        v = (v >> 128) | (v << 128);\n    }\n\n    uint256 constant p_mod =\n        21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    struct G1Point {\n        uint256 x;\n        uint256 y;\n    }\n\n    struct G2Point {\n        uint256[2] x;\n        uint256[2] y;\n    }\n\n    function ecc_from(uint256 x, uint256 y) internal pure returns (G1Point memory r) {\n        r.x = x;\n        r.y = y;\n    }\n\n    function ecc_add(\n        uint256 ax,\n        uint256 ay,\n        uint256 bx,\n        uint256 by\n    ) internal view returns (uint256, uint256) {\n        bool ret = false;\n        G1Point memory r;\n        uint256[4] memory input_points;\n\n        input_points[0] = ax;\n        input_points[1] = ay;\n        input_points[2] = bx;\n        input_points[3] = by;\n\n        assembly {\n            ret := staticcall(gas(), 6, input_points, 0x80, r, 0x40)\n        }\n        require(ret);\n\n        return (r.x, r.y);\n    }\n\n    function ecc_sub(\n        uint256 ax,\n        uint256 ay,\n        uint256 bx,\n        uint256 by\n    ) internal view returns (uint256, uint256) {\n        return ecc_add(ax, ay, bx, p_mod - by);\n    }\n\n    function ecc_mul(\n        uint256 px,\n        uint256 py,\n        uint256 s\n    ) internal view returns (uint256, uint256) {\n        uint256[3] memory input;\n        bool ret = false;\n        G1Point memory r;\n\n        input[0] = px;\n        input[1] = py;\n        input[2] = s;\n\n        assembly {\n            ret := staticcall(gas(), 7, input, 0x60, r, 0x40)\n        }\n        require(ret);\n\n        return (r.x, r.y);\n    }\n\n    function _ecc_mul_add(uint256[5] memory input) internal view {\n        bool ret = false;\n\n        assembly {\n            ret := staticcall(gas(), 7, input, 0x60, add(input, 0x20), 0x40)\n        }\n        require(ret);\n\n        assembly {\n            ret := staticcall(gas(), 6, add(input, 0x20), 0x80, add(input, 0x60), 0x40)\n        }\n        require(ret);\n    }\n\n    function ecc_mul_add(\n        uint256 px,\n        uint256 py,\n        uint256 s,\n        uint256 qx,\n        uint256 qy\n    ) internal view returns (uint256, uint256) {\n        uint256[5] memory input;\n        input[0] = px;\n        input[1] = py;\n        input[2] = s;\n        input[3] = qx;\n        input[4] = qy;\n\n        _ecc_mul_add(input);\n\n        return (input[3], input[4]);\n    }\n\n    function ecc_mul_add_pm(\n        uint256[84] memory m,\n        uint256[] calldata proof,\n        uint256 opcode,\n        uint256 t0,\n        uint256 t1\n    ) internal view returns (uint256, uint256) {\n        uint256[5] memory input;\n        input[3] = t0;\n        input[4] = t1;\n        for (uint256 i = 0; i < 32; i += 2) {\n            uint256 a = opcode & 0xff;\n            if (a != 0xff) {\n                opcode >>= 8;\n                uint256 b = opcode & 0xff;\n                opcode >>= 8;\n                input[0] = proof[a];\n                input[1] = proof[a + 1];\n                input[2] = m[b];\n                _ecc_mul_add(input);\n            } else {\n                break;\n            }\n        }\n\n        return (input[3], input[4]);\n    }\n\n    function update_hash_scalar(\n        uint256 v,\n        uint256[144] memory absorbing,\n        uint256 pos\n    ) internal pure {\n        absorbing[pos++] = 0x02;\n        absorbing[pos++] = v;\n    }\n\n    function update_hash_point(\n        uint256 x,\n        uint256 y,\n        uint256[144] memory absorbing,\n        uint256 pos\n    ) internal pure {\n        absorbing[pos++] = 0x01;\n        absorbing[pos++] = x;\n        absorbing[pos++] = y;\n    }\n\n    function to_scalar(bytes32 r) private pure returns (uint256 v) {\n        uint256 tmp = uint256(r);\n        tmp = fr_reverse(tmp);\n        v = tmp % 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;\n    }\n\n    function hash(uint256[144] memory absorbing, uint256 length)\n        private\n        view\n        returns (bytes32[1] memory v)\n    {\n        bool success;\n        assembly {\n            success := staticcall(sub(gas(), 2000), 2, absorbing, length, v, 32)\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n        assert(success);\n    }\n\n    function squeeze_challenge(uint256[144] memory absorbing, uint32 length)\n        internal\n        view\n        returns (uint256 v)\n    {\n        absorbing[length] = 0;\n        bytes32 res = hash(absorbing, length * 32 + 1)[0];\n        v = to_scalar(res);\n        absorbing[0] = uint256(res);\n        length = 1;\n    }\n\n    function get_verify_circuit_g2_s() internal pure returns (G2Point memory s) {\n        s.x[0] = uint256(\n            19996377281670978687180986182441301914718493784645870391946826878753710639456\n        );\n        s.x[1] = uint256(\n            4287478848095488335912479212753150961411468232106701703291869721868407715111\n        );\n        s.y[0] = uint256(\n            6995741485533723263267942814565501722132921805029874890336635619836737653877\n        );\n        s.y[1] = uint256(\n            11126659726611658836425410744462014686753643655648740844565393330984713428953\n        );\n    }\n\n    function get_verify_circuit_g2_n() internal pure returns (G2Point memory n) {\n        n.x[0] = uint256(\n            11559732032986387107991004021392285783925812861821192530917403151452391805634\n        );\n        n.x[1] = uint256(\n            10857046999023057135944570762232829481370756359578518086990519993285655852781\n        );\n        n.y[0] = uint256(\n            17805874995975841540914202342111839520379459829704422454583296818431106115052\n        );\n        n.y[1] = uint256(\n            13392588948715843804641432497768002650278120570034223513918757245338268106653\n        );\n    }\n\n    function get_target_circuit_g2_s() internal pure returns (G2Point memory s) {\n        s.x[0] = uint256(\n            19996377281670978687180986182441301914718493784645870391946826878753710639456\n        );\n        s.x[1] = uint256(\n            4287478848095488335912479212753150961411468232106701703291869721868407715111\n        );\n        s.y[0] = uint256(\n            6995741485533723263267942814565501722132921805029874890336635619836737653877\n        );\n        s.y[1] = uint256(\n            11126659726611658836425410744462014686753643655648740844565393330984713428953\n        );\n    }\n\n    function get_target_circuit_g2_n() internal pure returns (G2Point memory n) {\n        n.x[0] = uint256(\n            11559732032986387107991004021392285783925812861821192530917403151452391805634\n        );\n        n.x[1] = uint256(\n            10857046999023057135944570762232829481370756359578518086990519993285655852781\n        );\n        n.y[0] = uint256(\n            17805874995975841540914202342111839520379459829704422454583296818431106115052\n        );\n        n.y[1] = uint256(\n            13392588948715843804641432497768002650278120570034223513918757245338268106653\n        );\n    }\n\n    function get_wx_wg(uint256[] calldata proof, uint256[6] memory instances)\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256[84] memory m;\n        uint256[144] memory absorbing;\n        uint256 t0 = 0;\n        uint256 t1 = 0;\n\n        (t0, t1) = (\n            ecc_mul(\n                16273630658577275004922498653030603356133576819117084202553121866583118864964,\n                6490159372778831696763963776713702553449715395136256408127406430701013586737,\n                instances[0]\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                21465583338900056601761668793508143213048509206826828900542864688378093593107,\n                18916078441896187703473496284050716429170517783995157941513585201547834049281,\n                instances[1],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                6343857336395576108841088300387244434710621968858839561085778033655098739860,\n                8647137667680968494319179221347060255241434220013711910139382436020093396308,\n                instances[2],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                17609998990685530094209191702545036897101285294398654477281719279316619940710,\n                7891327626892441842954365090016786852185025910332850053066512639794082797200,\n                instances[3],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                1271298011119556361067568041994358027954229594187408866479678256322993207430,\n                16519855264988006509000373008036578681979317060055767197977112967887569978562,\n                instances[4],\n                t0,\n                t1\n            )\n        );\n        (m[0], m[1]) = (\n            ecc_mul_add(\n                9106880861932848269529912338578777683259870408474914617967634470292361865683,\n                3191458938194545761508145121615374474619318896841102235687991186359560600763,\n                instances[5],\n                t0,\n                t1\n            )\n        );\n        update_hash_scalar(HASH_SCALAR_VALUE, absorbing, 0);\n        update_hash_point(m[0], m[1], absorbing, 2);\n        for (t0 = 0; t0 <= 4; t0++) {\n            update_hash_point(proof[0 + t0 * 2], proof[1 + t0 * 2], absorbing, 5 + t0 * 3);\n        }\n        m[2] = (squeeze_challenge(absorbing, 20));\n        for (t0 = 0; t0 <= 13; t0++) {\n            update_hash_point(proof[10 + t0 * 2], proof[11 + t0 * 2], absorbing, 1 + t0 * 3);\n        }\n        m[3] = (squeeze_challenge(absorbing, 43));\n        m[4] = (squeeze_challenge(absorbing, 1));\n        for (t0 = 0; t0 <= 9; t0++) {\n            update_hash_point(proof[38 + t0 * 2], proof[39 + t0 * 2], absorbing, 1 + t0 * 3);\n        }\n        m[5] = (squeeze_challenge(absorbing, 31));\n        for (t0 = 0; t0 <= 3; t0++) {\n            update_hash_point(proof[58 + t0 * 2], proof[59 + t0 * 2], absorbing, 1 + t0 * 3);\n        }\n        m[6] = (squeeze_challenge(absorbing, 13));\n        for (t0 = 0; t0 <= 70; t0++) {\n            update_hash_scalar(proof[66 + t0 * 1], absorbing, 1 + t0 * 2);\n        }\n        m[7] = (squeeze_challenge(absorbing, 143));\n        for (t0 = 0; t0 <= 3; t0++) {\n            update_hash_point(proof[137 + t0 * 2], proof[138 + t0 * 2], absorbing, 1 + t0 * 3);\n        }\n        m[8] = (squeeze_challenge(absorbing, 13));\n        m[9] = (\n            mulmod(\n                m[6],\n                13446667982376394161563610564587413125564757801019538732601045199901075958935,\n                q_mod\n            )\n        );\n        m[10] = (\n            mulmod(\n                m[6],\n                16569469942529664681363945218228869388192121720036659574609237682362097667612,\n                q_mod\n            )\n        );\n        m[11] = (\n            mulmod(\n                m[6],\n                14803907026430593724305438564799066516271154714737734572920456128449769927233,\n                q_mod\n            )\n        );\n        m[12] = (fr_pow(m[6], 67108864));\n        m[13] = (addmod(m[12], q_mod - 1, q_mod));\n        m[14] = (\n            mulmod(\n                21888242545679039938882419398440172875981108180010270949818755658014750055173,\n                m[13],\n                q_mod\n            )\n        );\n        t0 = (addmod(m[6], q_mod - 1, q_mod));\n        m[14] = (fr_div(m[14], t0));\n        m[15] = (\n            mulmod(\n                3495999257316610708652455694658595065970881061159015347599790211259094641512,\n                m[13],\n                q_mod\n            )\n        );\n        t0 = (\n            addmod(\n                m[6],\n                q_mod -\n                    14803907026430593724305438564799066516271154714737734572920456128449769927233,\n                q_mod\n            )\n        );\n        m[15] = (fr_div(m[15], t0));\n        m[16] = (\n            mulmod(\n                12851378806584061886934576302961450669946047974813165594039554733293326536714,\n                m[13],\n                q_mod\n            )\n        );\n        t0 = (\n            addmod(\n                m[6],\n                q_mod -\n                    11377606117859914088982205826922132024839443553408109299929510653283289974216,\n                q_mod\n            )\n        );\n        m[16] = (fr_div(m[16], t0));\n        m[17] = (\n            mulmod(\n                14638077285440018490948843142723135319134576188472316769433007423695824509066,\n                m[13],\n                q_mod\n            )\n        );\n        t0 = (\n            addmod(\n                m[6],\n                q_mod -\n                    3693565015985198455139889557180396682968596245011005461846595820698933079918,\n                q_mod\n            )\n        );\n        m[17] = (fr_div(m[17], t0));\n        m[18] = (\n            mulmod(\n                18027939092386982308810165776478549635922357517986691900813373197616541191289,\n                m[13],\n                q_mod\n            )\n        );\n        t0 = (\n            addmod(\n                m[6],\n                q_mod -\n                    17329448237240114492580865744088056414251735686965494637158808787419781175510,\n                q_mod\n            )\n        );\n        m[18] = (fr_div(m[18], t0));\n        m[19] = (\n            mulmod(\n                912591536032578604421866340844550116335029274442283291811906603256731601654,\n                m[13],\n                q_mod\n            )\n        );\n        t0 = (\n            addmod(\n                m[6],\n                q_mod -\n                    6047398202650739717314770882059679662647667807426525133977681644606291529311,\n                q_mod\n            )\n        );\n        m[19] = (fr_div(m[19], t0));\n        m[20] = (\n            mulmod(\n                17248638560015646562374089181598815896736916575459528793494921668169819478628,\n                m[13],\n                q_mod\n            )\n        );\n        t0 = (\n            addmod(\n                m[6],\n                q_mod -\n                    16569469942529664681363945218228869388192121720036659574609237682362097667612,\n                q_mod\n            )\n        );\n        m[20] = (fr_div(m[20], t0));\n        t0 = (addmod(m[15], m[16], q_mod));\n        t0 = (addmod(t0, m[17], q_mod));\n        t0 = (addmod(t0, m[18], q_mod));\n        m[15] = (addmod(t0, m[19], q_mod));\n        t0 = (fr_mul_add(proof[74], proof[72], proof[73]));\n        t0 = (fr_mul_add(proof[75], proof[67], t0));\n        t0 = (fr_mul_add(proof[76], proof[68], t0));\n        t0 = (fr_mul_add(proof[77], proof[69], t0));\n        t0 = (fr_mul_add(proof[78], proof[70], t0));\n        m[16] = (fr_mul_add(proof[79], proof[71], t0));\n        t0 = (mulmod(proof[67], proof[68], q_mod));\n        m[16] = (fr_mul_add(proof[80], t0, m[16]));\n        t0 = (mulmod(proof[69], proof[70], q_mod));\n        m[16] = (fr_mul_add(proof[81], t0, m[16]));\n        t0 = (addmod(1, q_mod - proof[97], q_mod));\n        m[17] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[100], proof[100], q_mod));\n        t0 = (addmod(t0, q_mod - proof[100], q_mod));\n        m[18] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(proof[100], q_mod - proof[99], q_mod));\n        m[19] = (mulmod(t0, m[14], q_mod));\n        m[21] = (mulmod(m[3], m[6], q_mod));\n        t0 = (addmod(m[20], m[15], q_mod));\n        m[15] = (addmod(1, q_mod - t0, q_mod));\n        m[22] = (addmod(proof[67], m[4], q_mod));\n        t0 = (fr_mul_add(proof[91], m[3], m[22]));\n        m[23] = (mulmod(t0, proof[98], q_mod));\n        t0 = (addmod(m[22], m[21], q_mod));\n        m[22] = (mulmod(t0, proof[97], q_mod));\n        m[24] = (\n            mulmod(\n                4131629893567559867359510883348571134090853742863529169391034518566172092834,\n                m[21],\n                q_mod\n            )\n        );\n        m[25] = (addmod(proof[68], m[4], q_mod));\n        t0 = (fr_mul_add(proof[92], m[3], m[25]));\n        m[23] = (mulmod(t0, m[23], q_mod));\n        t0 = (addmod(m[25], m[24], q_mod));\n        m[22] = (mulmod(t0, m[22], q_mod));\n        m[24] = (\n            mulmod(\n                4131629893567559867359510883348571134090853742863529169391034518566172092834,\n                m[24],\n                q_mod\n            )\n        );\n        m[25] = (addmod(proof[69], m[4], q_mod));\n        t0 = (fr_mul_add(proof[93], m[3], m[25]));\n        m[23] = (mulmod(t0, m[23], q_mod));\n        t0 = (addmod(m[25], m[24], q_mod));\n        m[22] = (mulmod(t0, m[22], q_mod));\n        m[24] = (\n            mulmod(\n                4131629893567559867359510883348571134090853742863529169391034518566172092834,\n                m[24],\n                q_mod\n            )\n        );\n        t0 = (addmod(m[23], q_mod - m[22], q_mod));\n        m[22] = (mulmod(t0, m[15], q_mod));\n        m[21] = (\n            mulmod(\n                m[21],\n                11166246659983828508719468090013646171463329086121580628794302409516816350802,\n                q_mod\n            )\n        );\n        m[23] = (addmod(proof[70], m[4], q_mod));\n        t0 = (fr_mul_add(proof[94], m[3], m[23]));\n        m[24] = (mulmod(t0, proof[101], q_mod));\n        t0 = (addmod(m[23], m[21], q_mod));\n        m[23] = (mulmod(t0, proof[100], q_mod));\n        m[21] = (\n            mulmod(\n                4131629893567559867359510883348571134090853742863529169391034518566172092834,\n                m[21],\n                q_mod\n            )\n        );\n        m[25] = (addmod(proof[71], m[4], q_mod));\n        t0 = (fr_mul_add(proof[95], m[3], m[25]));\n        m[24] = (mulmod(t0, m[24], q_mod));\n        t0 = (addmod(m[25], m[21], q_mod));\n        m[23] = (mulmod(t0, m[23], q_mod));\n        m[21] = (\n            mulmod(\n                4131629893567559867359510883348571134090853742863529169391034518566172092834,\n                m[21],\n                q_mod\n            )\n        );\n        m[25] = (addmod(proof[66], m[4], q_mod));\n        t0 = (fr_mul_add(proof[96], m[3], m[25]));\n        m[24] = (mulmod(t0, m[24], q_mod));\n        t0 = (addmod(m[25], m[21], q_mod));\n        m[23] = (mulmod(t0, m[23], q_mod));\n        m[21] = (\n            mulmod(\n                4131629893567559867359510883348571134090853742863529169391034518566172092834,\n                m[21],\n                q_mod\n            )\n        );\n        t0 = (addmod(m[24], q_mod - m[23], q_mod));\n        m[21] = (mulmod(t0, m[15], q_mod));\n        t0 = (addmod(proof[104], m[3], q_mod));\n        m[23] = (mulmod(proof[103], t0, q_mod));\n        t0 = (addmod(proof[106], m[4], q_mod));\n        m[23] = (mulmod(m[23], t0, q_mod));\n        m[24] = (mulmod(proof[67], proof[82], q_mod));\n        m[2] = (mulmod(0, m[2], q_mod));\n        m[24] = (addmod(m[2], m[24], q_mod));\n        m[25] = (addmod(m[2], proof[83], q_mod));\n        m[26] = (addmod(proof[104], q_mod - proof[106], q_mod));\n        t0 = (addmod(1, q_mod - proof[102], q_mod));\n        m[27] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[102], proof[102], q_mod));\n        t0 = (addmod(t0, q_mod - proof[102], q_mod));\n        m[28] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(m[24], m[3], q_mod));\n        m[24] = (mulmod(proof[102], t0, q_mod));\n        m[25] = (addmod(m[25], m[4], q_mod));\n        t0 = (mulmod(m[24], m[25], q_mod));\n        t0 = (addmod(m[23], q_mod - t0, q_mod));\n        m[23] = (mulmod(t0, m[15], q_mod));\n        m[24] = (mulmod(m[14], m[26], q_mod));\n        t0 = (addmod(proof[104], q_mod - proof[105], q_mod));\n        t0 = (mulmod(m[26], t0, q_mod));\n        m[26] = (mulmod(t0, m[15], q_mod));\n        t0 = (addmod(proof[109], m[3], q_mod));\n        m[29] = (mulmod(proof[108], t0, q_mod));\n        t0 = (addmod(proof[111], m[4], q_mod));\n        m[29] = (mulmod(m[29], t0, q_mod));\n        m[30] = (fr_mul_add(proof[82], proof[68], m[2]));\n        m[31] = (addmod(proof[109], q_mod - proof[111], q_mod));\n        t0 = (addmod(1, q_mod - proof[107], q_mod));\n        m[32] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[107], proof[107], q_mod));\n        t0 = (addmod(t0, q_mod - proof[107], q_mod));\n        m[33] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(m[30], m[3], q_mod));\n        t0 = (mulmod(proof[107], t0, q_mod));\n        t0 = (mulmod(t0, m[25], q_mod));\n        t0 = (addmod(m[29], q_mod - t0, q_mod));\n        m[29] = (mulmod(t0, m[15], q_mod));\n        m[30] = (mulmod(m[14], m[31], q_mod));\n        t0 = (addmod(proof[109], q_mod - proof[110], q_mod));\n        t0 = (mulmod(m[31], t0, q_mod));\n        m[31] = (mulmod(t0, m[15], q_mod));\n        t0 = (addmod(proof[114], m[3], q_mod));\n        m[34] = (mulmod(proof[113], t0, q_mod));\n        t0 = (addmod(proof[116], m[4], q_mod));\n        m[34] = (mulmod(m[34], t0, q_mod));\n        m[35] = (fr_mul_add(proof[82], proof[69], m[2]));\n        m[36] = (addmod(proof[114], q_mod - proof[116], q_mod));\n        t0 = (addmod(1, q_mod - proof[112], q_mod));\n        m[37] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[112], proof[112], q_mod));\n        t0 = (addmod(t0, q_mod - proof[112], q_mod));\n        m[38] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(m[35], m[3], q_mod));\n        t0 = (mulmod(proof[112], t0, q_mod));\n        t0 = (mulmod(t0, m[25], q_mod));\n        t0 = (addmod(m[34], q_mod - t0, q_mod));\n        m[34] = (mulmod(t0, m[15], q_mod));\n        m[35] = (mulmod(m[14], m[36], q_mod));\n        t0 = (addmod(proof[114], q_mod - proof[115], q_mod));\n        t0 = (mulmod(m[36], t0, q_mod));\n        m[36] = (mulmod(t0, m[15], q_mod));\n        t0 = (addmod(proof[119], m[3], q_mod));\n        m[39] = (mulmod(proof[118], t0, q_mod));\n        t0 = (addmod(proof[121], m[4], q_mod));\n        m[39] = (mulmod(m[39], t0, q_mod));\n        m[40] = (fr_mul_add(proof[82], proof[70], m[2]));\n        m[41] = (addmod(proof[119], q_mod - proof[121], q_mod));\n        t0 = (addmod(1, q_mod - proof[117], q_mod));\n        m[42] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[117], proof[117], q_mod));\n        t0 = (addmod(t0, q_mod - proof[117], q_mod));\n        m[43] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(m[40], m[3], q_mod));\n        t0 = (mulmod(proof[117], t0, q_mod));\n        t0 = (mulmod(t0, m[25], q_mod));\n        t0 = (addmod(m[39], q_mod - t0, q_mod));\n        m[25] = (mulmod(t0, m[15], q_mod));\n        m[39] = (mulmod(m[14], m[41], q_mod));\n        t0 = (addmod(proof[119], q_mod - proof[120], q_mod));\n        t0 = (mulmod(m[41], t0, q_mod));\n        m[40] = (mulmod(t0, m[15], q_mod));\n        t0 = (addmod(proof[124], m[3], q_mod));\n        m[41] = (mulmod(proof[123], t0, q_mod));\n        t0 = (addmod(proof[126], m[4], q_mod));\n        m[41] = (mulmod(m[41], t0, q_mod));\n        m[44] = (fr_mul_add(proof[84], proof[67], m[2]));\n        m[45] = (addmod(m[2], proof[85], q_mod));\n        m[46] = (addmod(proof[124], q_mod - proof[126], q_mod));\n        t0 = (addmod(1, q_mod - proof[122], q_mod));\n        m[47] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[122], proof[122], q_mod));\n        t0 = (addmod(t0, q_mod - proof[122], q_mod));\n        m[48] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(m[44], m[3], q_mod));\n        m[44] = (mulmod(proof[122], t0, q_mod));\n        t0 = (addmod(m[45], m[4], q_mod));\n        t0 = (mulmod(m[44], t0, q_mod));\n        t0 = (addmod(m[41], q_mod - t0, q_mod));\n        m[41] = (mulmod(t0, m[15], q_mod));\n        m[44] = (mulmod(m[14], m[46], q_mod));\n        t0 = (addmod(proof[124], q_mod - proof[125], q_mod));\n        t0 = (mulmod(m[46], t0, q_mod));\n        m[45] = (mulmod(t0, m[15], q_mod));\n        t0 = (addmod(proof[129], m[3], q_mod));\n        m[46] = (mulmod(proof[128], t0, q_mod));\n        t0 = (addmod(proof[131], m[4], q_mod));\n        m[46] = (mulmod(m[46], t0, q_mod));\n        m[49] = (fr_mul_add(proof[86], proof[67], m[2]));\n        m[50] = (addmod(m[2], proof[87], q_mod));\n        m[51] = (addmod(proof[129], q_mod - proof[131], q_mod));\n        t0 = (addmod(1, q_mod - proof[127], q_mod));\n        m[52] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[127], proof[127], q_mod));\n        t0 = (addmod(t0, q_mod - proof[127], q_mod));\n        m[53] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(m[49], m[3], q_mod));\n        m[49] = (mulmod(proof[127], t0, q_mod));\n        t0 = (addmod(m[50], m[4], q_mod));\n        t0 = (mulmod(m[49], t0, q_mod));\n        t0 = (addmod(m[46], q_mod - t0, q_mod));\n        m[46] = (mulmod(t0, m[15], q_mod));\n        m[49] = (mulmod(m[14], m[51], q_mod));\n        t0 = (addmod(proof[129], q_mod - proof[130], q_mod));\n        t0 = (mulmod(m[51], t0, q_mod));\n        m[50] = (mulmod(t0, m[15], q_mod));\n        t0 = (addmod(proof[134], m[3], q_mod));\n        m[51] = (mulmod(proof[133], t0, q_mod));\n        t0 = (addmod(proof[136], m[4], q_mod));\n        m[51] = (mulmod(m[51], t0, q_mod));\n        m[54] = (fr_mul_add(proof[88], proof[67], m[2]));\n        m[2] = (addmod(m[2], proof[89], q_mod));\n        m[55] = (addmod(proof[134], q_mod - proof[136], q_mod));\n        t0 = (addmod(1, q_mod - proof[132], q_mod));\n        m[56] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[132], proof[132], q_mod));\n        t0 = (addmod(t0, q_mod - proof[132], q_mod));\n        m[20] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(m[54], m[3], q_mod));\n        m[3] = (mulmod(proof[132], t0, q_mod));\n        t0 = (addmod(m[2], m[4], q_mod));\n        t0 = (mulmod(m[3], t0, q_mod));\n        t0 = (addmod(m[51], q_mod - t0, q_mod));\n        m[2] = (mulmod(t0, m[15], q_mod));\n        m[3] = (mulmod(m[14], m[55], q_mod));\n        t0 = (addmod(proof[134], q_mod - proof[135], q_mod));\n        t0 = (mulmod(m[55], t0, q_mod));\n        m[4] = (mulmod(t0, m[15], q_mod));\n        t0 = (fr_mul_add(m[5], 0, m[16]));\n        t0 = (\n            fr_mul_add_mt(\n                m,\n                m[5],\n                24064768791442479290152634096194013545513974547709823832001394403118888981009,\n                t0\n            )\n        );\n        t0 = (fr_mul_add_mt(m, m[5], 4704208815882882920750, t0));\n        m[2] = (fr_div(t0, m[13]));\n        m[3] = (mulmod(m[8], m[8], q_mod));\n        m[4] = (mulmod(m[3], m[8], q_mod));\n        (t0, t1) = (ecc_mul(proof[143], proof[144], m[4]));\n        (t0, t1) = (ecc_mul_add_pm(m, proof, 281470825071501, t0, t1));\n        (m[14], m[15]) = (ecc_add(t0, t1, proof[137], proof[138]));\n        m[5] = (mulmod(m[4], m[11], q_mod));\n        m[11] = (mulmod(m[4], m[7], q_mod));\n        m[13] = (mulmod(m[11], m[7], q_mod));\n        m[16] = (mulmod(m[13], m[7], q_mod));\n        m[17] = (mulmod(m[16], m[7], q_mod));\n        m[18] = (mulmod(m[17], m[7], q_mod));\n        m[19] = (mulmod(m[18], m[7], q_mod));\n        t0 = (mulmod(m[19], proof[135], q_mod));\n        t0 = (fr_mul_add_pm(m, proof, 79227007564587019091207590530, t0));\n        m[20] = (fr_mul_add(proof[105], m[4], t0));\n        m[10] = (mulmod(m[3], m[10], q_mod));\n        m[20] = (fr_mul_add(proof[99], m[3], m[20]));\n        m[9] = (mulmod(m[8], m[9], q_mod));\n        m[21] = (mulmod(m[8], m[7], q_mod));\n        for (t0 = 0; t0 < 8; t0++) {\n            m[22 + t0 * 1] = (mulmod(m[21 + t0 * 1], m[7 + t0 * 0], q_mod));\n        }\n        t0 = (mulmod(m[29], proof[133], q_mod));\n        t0 = (fr_mul_add_pm(m, proof, 1461480058012745347196003969984389955172320353408, t0));\n        m[20] = (addmod(m[20], t0, q_mod));\n        m[3] = (addmod(m[3], m[21], q_mod));\n        m[21] = (mulmod(m[7], m[7], q_mod));\n        m[30] = (mulmod(m[21], m[7], q_mod));\n        for (t0 = 0; t0 < 50; t0++) {\n            m[31 + t0 * 1] = (mulmod(m[30 + t0 * 1], m[7 + t0 * 0], q_mod));\n        }\n        m[81] = (mulmod(m[80], proof[90], q_mod));\n        m[82] = (mulmod(m[79], m[12], q_mod));\n        m[83] = (mulmod(m[82], m[12], q_mod));\n        m[12] = (mulmod(m[83], m[12], q_mod));\n        t0 = (fr_mul_add(m[79], m[2], m[81]));\n        t0 = (\n            fr_mul_add_pm(\n                m,\n                proof,\n                28637501128329066231612878461967933875285131620580756137874852300330784214624,\n                t0\n            )\n        );\n        t0 = (\n            fr_mul_add_pm(\n                m,\n                proof,\n                21474593857386732646168474467085622855647258609351047587832868301163767676495,\n                t0\n            )\n        );\n        t0 = (\n            fr_mul_add_pm(\n                m,\n                proof,\n                14145600374170319983429588659751245017860232382696106927048396310641433325177,\n                t0\n            )\n        );\n        t0 = (fr_mul_add_pm(m, proof, 18446470583433829957, t0));\n        t0 = (addmod(t0, proof[66], q_mod));\n        m[2] = (addmod(m[20], t0, q_mod));\n        m[19] = (addmod(m[19], m[54], q_mod));\n        m[20] = (addmod(m[29], m[53], q_mod));\n        m[18] = (addmod(m[18], m[51], q_mod));\n        m[28] = (addmod(m[28], m[50], q_mod));\n        m[17] = (addmod(m[17], m[48], q_mod));\n        m[27] = (addmod(m[27], m[47], q_mod));\n        m[16] = (addmod(m[16], m[45], q_mod));\n        m[26] = (addmod(m[26], m[44], q_mod));\n        m[13] = (addmod(m[13], m[42], q_mod));\n        m[25] = (addmod(m[25], m[41], q_mod));\n        m[11] = (addmod(m[11], m[39], q_mod));\n        m[24] = (addmod(m[24], m[38], q_mod));\n        m[4] = (addmod(m[4], m[36], q_mod));\n        m[23] = (addmod(m[23], m[35], q_mod));\n        m[22] = (addmod(m[22], m[34], q_mod));\n        m[3] = (addmod(m[3], m[33], q_mod));\n        m[8] = (addmod(m[8], m[32], q_mod));\n        (t0, t1) = (ecc_mul(proof[143], proof[144], m[5]));\n        (t0, t1) = (\n            ecc_mul_add_pm(\n                m,\n                proof,\n                10933423423422768024429730621579321771439401845242250760130969989159573132066,\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add_pm(m, proof, 1461486238301980199876269201563775120819706402602, t0, t1)\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                6142817583611318572656790694718211788114764931516417326618203124458942393512,\n                4646821324997622891656299786985648251755771687303265562041594443280268941435,\n                m[78],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                1394140441997098469277990129028168392464863717319893157779376066079215205995,\n                6479070357060105565230663751309877725893693760785866947291774767445218580725,\n                m[77],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                1505982605826495538337084731512603575610962644433829788142952088732637275900,\n                15638675134091979370843664702271623759528460495807814967966143101334975019218,\n                m[76],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                2920562342430032392513332641702835464035838604893227465222109896344556432781,\n                1233200019755399369644963656297879273471574905205481556774126313083620669188,\n                m[75],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                4793770747262543221162957134245718273660743968167442305148839925764721384385,\n                16491365131910875890473113316915135247069549590998256855917281930732102052146,\n                m[74],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                12073029823146420358357755459466510541167929997834912707160306328645716684634,\n                7002579881281064115771377119487732340828562242983846592023681036449210169941,\n                m[73],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                5422170891120229182360564594866246906567981360038071999127508208070564034524,\n                14722029885921976755274052080011416898514630484317773275415621146460924728182,\n                m[72],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                9768037088022160987792529895161170380140242871617764963181107834401821842732,\n                18832575845000440794371969135482601814248633755836923521592930147295616428911,\n                m[71],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                18451207565454686459225553564649439057698581050443267052774483067774590965003,\n                4419693978684087696088612463773850574955779922948673330581664932100506990694,\n                m[70],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                10955051564000848234174555727796659616779146634502155798906042850270306999028,\n                5044157639930088703193160205056600784986917761050014097511294717703335354756,\n                m[69],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                5422170891120229182360564594866246906567981360038071999127508208070564034524,\n                14722029885921976755274052080011416898514630484317773275415621146460924728182,\n                m[68],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                13105550014728729004155036996412783545950841894097753169739134984597847652697,\n                770569099300255260688332420518941166628824859946965110511956314794583528694,\n                m[67],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                21537162186981550637121053147454964150809482185492418377558290311964245821909,\n                2173324946696678910860567153502925685634606622474439126082176533839311460335,\n                m[66],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                19260083276107475178966891282754197624211455736673124446998411091227828289553,\n                2570537878389498753277218315004771614025811703544923427862807029802660958099,\n                m[65],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                8845661238106812206461459197564326952814344666903203623661463593134263896085,\n                9199661166487667889188104072051840793570190455147636185909257185981915686939,\n                m[64],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                1247301910598036969079443951451711450239021207173438336600746303301923637619,\n                12452008890862978663347524597422639287935789259006166244086331584833725627011,\n                m[63],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                5604610499897386861255889949519877143182190495525912738313285084277909443823,\n                10846093502024381162484878000759356250253658533536005705881187609138195832747,\n                m[62],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                21242518271599825569916643188427645420543445585556474469805024475250407545878,\n                17465592062378925051184078024251365114151104586351962146267321196670845041213,\n                m[61],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                4394779370836082712406958856077566946471251024945837930292850369228732540367,\n                14055556608051250377070851641965610024993199964737457704527984709839114705559,\n                m[60],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                10819795219762681902376301835590122215694186866378606265080686339562560138385,\n                19966781410778348947296831539481353126793783310593348439260795338950610476576,\n                m[59],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                21764175739688726125083670197919870409620040219415465823837999071958318298226,\n                10674380430548790992549153589666513639625528080118858035634397593415316259864,\n                m[58],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                14305536278729037949733395958634241814626316284509904005683590354628543981750,\n                4559470715733364509263937153338912572385508047696014198795854165844220686033,\n                m[57],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (ecc_mul_add(M_56_PX_VALUE, M_56_PY_VALUE, m[56], t0, t1));\n        (t0, t1) = (\n            ecc_mul_add_pm(\n                m,\n                proof,\n                6277008573546246765208814532330797927747086570010716419876,\n                t0,\n                t1\n            )\n        );\n        (m[0], m[1]) = (ecc_add(t0, t1, m[0], m[1]));\n        (t0, t1) = (ecc_mul(1, 2, m[2]));\n        (m[0], m[1]) = (ecc_sub(m[0], m[1], t0, t1));\n        return (m[14], m[15], m[0], m[1]);\n    }\n\n    function verify(\n        uint256[] calldata proof,\n        uint256[] calldata target_circuit_final_pair,\n        bytes32 publicInputHash\n    ) public view returns (bool) {\n        uint256[6] memory instances;\n        instances[0] = target_circuit_final_pair[0] & ((1 << 136) - 1);\n        instances[1] =\n            (target_circuit_final_pair[0] >> 136) +\n            ((target_circuit_final_pair[1] & 1) << 136);\n        instances[2] = target_circuit_final_pair[2] & ((1 << 136) - 1);\n        instances[3] =\n            (target_circuit_final_pair[2] >> 136) +\n            ((target_circuit_final_pair[3] & 1) << 136);\n\n        instances[4] = uint256(publicInputHash) >> (8 * 16);\n        instances[5] = uint256(publicInputHash) & uint256(2**128 - 1);\n\n        uint256 x0 = 0;\n        uint256 x1 = 0;\n        uint256 y0 = 0;\n        uint256 y1 = 0;\n\n        G1Point[] memory g1_points = new G1Point[](2);\n        G2Point[] memory g2_points = new G2Point[](2);\n\n        (x0, y0, x1, y1) = get_wx_wg(proof, instances);\n        g1_points[0].x = x0;\n        g1_points[0].y = y0;\n        g1_points[1].x = x1;\n        g1_points[1].y = y1;\n        g2_points[0] = get_verify_circuit_g2_s();\n        g2_points[1] = get_verify_circuit_g2_n();\n\n        if (!pairing(g1_points, g2_points)) {\n            return false;\n        }\n\n        g1_points[0].x = target_circuit_final_pair[0];\n        g1_points[0].y = target_circuit_final_pair[1];\n        g1_points[1].x = target_circuit_final_pair[2];\n        g1_points[1].y = target_circuit_final_pair[3];\n        g2_points[0] = get_target_circuit_g2_s();\n        g2_points[1] = get_target_circuit_g2_n();\n\n        if (!pairing(g1_points, g2_points)) {\n            return false;\n        }\n\n        return true;\n    }\n}\n"
    },
    "contracts/L2/CrossDomainOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\n\n/**\n * @title CrossDomainOwnable\n * @notice This contract extends the OpenZeppelin `Ownable` contract for L2 contracts to be owned\n *         by contracts on L1. Note that this contract is only safe to be used if the\n *         CrossDomainMessenger system is bypassed and the caller on L1 is calling the\n *         KromaPortal directly.\n */\nabstract contract CrossDomainOwnable is Ownable {\n    /**\n     * @notice Overrides the implementation of the `onlyOwner` modifier to check that the unaliased\n     *         `msg.sender` is the owner of the contract.\n     */\n    function _checkOwner() internal view override {\n        require(\n            owner() == AddressAliasHelper.undoL1ToL2Alias(msg.sender),\n            \"CrossDomainOwnable: caller is not the owner\"\n        );\n    }\n}\n"
    },
    "contracts/L2/CrossDomainOwnable2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { L2CrossDomainMessenger } from \"./L2CrossDomainMessenger.sol\";\n\n/**\n * @title CrossDomainOwnable2\n * @notice This contract extends the OpenZeppelin `Ownable` contract for L2 contracts to be owned\n *         by contracts on L1. Note that this contract is meant to be used with systems that use\n *         the CrossDomainMessenger system. It will not work if the KromaPortal is used\n *         directly.\n */\nabstract contract CrossDomainOwnable2 is Ownable {\n    /**\n     * @notice Overrides the implementation of the `onlyOwner` modifier to check that the unaliased\n     *         `xDomainMessageSender` is the owner of the contract. This value is set to the caller\n     *         of the L1CrossDomainMessenger.\n     */\n    function _checkOwner() internal view override {\n        L2CrossDomainMessenger messenger = L2CrossDomainMessenger(\n            Predeploys.L2_CROSS_DOMAIN_MESSENGER\n        );\n\n        require(\n            msg.sender == address(messenger),\n            \"CrossDomainOwnable2: caller is not the messenger\"\n        );\n\n        require(\n            owner() == messenger.xDomainMessageSender(),\n            \"CrossDomainOwnable2: caller is not the owner\"\n        );\n    }\n}\n"
    },
    "contracts/L2/CrossDomainOwnable3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { L2CrossDomainMessenger } from \"./L2CrossDomainMessenger.sol\";\n\n/**\n * @title CrossDomainOwnable3\n * @notice This contract extends the OpenZeppelin `Ownable` contract for L2 contracts to be owned\n *         by contracts on either L1 or L2. Note that this contract is meant to be used with systems\n *         that use the CrossDomainMessenger system. It will not work if the KromaPortal is\n *         used directly.\n */\nabstract contract CrossDomainOwnable3 is Ownable {\n    /**\n     * @notice If true, the contract uses the cross domain _checkOwner function override. If false\n     *         it uses the standard Ownable _checkOwner function.\n     */\n    bool public isLocal = true;\n\n    /**\n     * @notice Emits when ownership of the contract is transferred. Includes the\n     *         isLocal field in addition to the standard `Ownable` OwnershipTransferred event.\n     */\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner,\n        bool isLocal\n    );\n\n    /**\n     * @notice Allows for ownership to be transferred with specifying the locality.\n     * @param _owner   The new owner of the contract.\n     * @param _isLocal Configures the locality of the ownership.\n     */\n    function transferOwnership(address _owner, bool _isLocal) external onlyOwner {\n        require(_owner != address(0), \"CrossDomainOwnable3: new owner is the zero address\");\n\n        address oldOwner = owner();\n        _transferOwnership(_owner);\n        isLocal = _isLocal;\n\n        emit OwnershipTransferred(oldOwner, _owner, _isLocal);\n    }\n\n    /**\n     * @notice Overrides the implementation of the `onlyOwner` modifier to check that the unaliased\n     *         `xDomainMessageSender` is the owner of the contract. This value is set to the caller\n     *         of the L1CrossDomainMessenger.\n     */\n    function _checkOwner() internal view override {\n        if (isLocal) {\n            require(owner() == msg.sender, \"CrossDomainOwnable3: caller is not the owner\");\n        } else {\n            L2CrossDomainMessenger messenger = L2CrossDomainMessenger(\n                Predeploys.L2_CROSS_DOMAIN_MESSENGER\n            );\n\n            require(\n                msg.sender == address(messenger),\n                \"CrossDomainOwnable3: caller is not the messenger\"\n            );\n\n            require(\n                owner() == messenger.xDomainMessageSender(),\n                \"CrossDomainOwnable3: caller is not the owner\"\n            );\n        }\n    }\n}\n"
    },
    "contracts/L2/GasPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { L1Block } from \"../L2/L1Block.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000005\n * @title GasPriceOracle\n * @notice This contract maintains the variables responsible for computing the L1 portion of the\n *         total fee charged on L2. It also exposes an API that is useful for knowing how large\n *         the L1 portion of the transaction fee will be.\n */\ncontract GasPriceOracle is Semver {\n    /**\n     * @notice Number of decimals used in the scalar.\n     */\n    uint256 public constant DECIMALS = 6;\n\n    /**\n     * @custom:semver 0.1.0\n     */\n    constructor() Semver(0, 1, 0) {}\n\n    /**\n     * @notice Computes the L1 portion of the fee based on the size of the rlp encoded input\n     *         transaction, the current L1 base fee, and the various dynamic parameters.\n     *\n     * @param _data Unsigned fully RLP-encoded transaction to get the L1 fee for.\n     *\n     * @return L1 fee that should be paid for the tx\n     */\n    function getL1Fee(bytes memory _data) external view returns (uint256) {\n        uint256 l1GasUsed = getL1GasUsed(_data);\n        uint256 l1Fee = l1GasUsed * l1BaseFee();\n        uint256 divisor = 10**DECIMALS;\n        uint256 unscaled = l1Fee * scalar();\n        uint256 scaled = unscaled / divisor;\n        return scaled;\n    }\n\n    /**\n     * @notice Retrieves the current gas price (base fee).\n     *\n     * @return Current L2 gas price (base fee).\n     */\n    function gasPrice() public view returns (uint256) {\n        return block.basefee;\n    }\n\n    /**\n     * @notice Retrieves the current base fee.\n     *\n     * @return Current L2 base fee.\n     */\n    function baseFee() public view returns (uint256) {\n        return block.basefee;\n    }\n\n    /**\n     * @notice Retrieves the current fee overhead.\n     *\n     * @return Current fee overhead.\n     */\n    function overhead() public view returns (uint256) {\n        return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).l1FeeOverhead();\n    }\n\n    /**\n     * @notice Retrieves the current fee scalar.\n     *\n     * @return Current fee scalar.\n     */\n    function scalar() public view returns (uint256) {\n        return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).l1FeeScalar();\n    }\n\n    /**\n     * @notice Retrieves the latest known L1 base fee.\n     *\n     * @return Latest known L1 base fee.\n     */\n    function l1BaseFee() public view returns (uint256) {\n        return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).basefee();\n    }\n\n    /**\n     * @notice Computes the amount of L1 gas used for a transaction. Adds the overhead which\n     *         represents the per-transaction gas overhead of posting the transaction and state\n     *         roots to L1. Adds 68 bytes of padding to account for the fact that the input does\n     *         not have a signature.\n     *\n     * @param _data Unsigned fully RLP-encoded transaction to get the L1 gas for.\n     *\n     * @return Amount of L1 gas used to publish the transaction.\n     */\n    function getL1GasUsed(bytes memory _data) public view returns (uint256) {\n        uint256 total = 0;\n        uint256 length = _data.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (_data[i] == 0) {\n                total += 4;\n            } else {\n                total += 16;\n            }\n        }\n        return total + overhead();\n    }\n}\n"
    },
    "contracts/L2/L1Block.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000002\n * @title L1Block\n * @notice The L1Block predeploy gives users access to information about the last known L1 block.\n *         Values within this contract are updated once per epoch (every L1 block) and can only be\n *         set by the \"depositor\" account, a special system address. Depositor account transactions\n *         are created by the protocol whenever we move to a new epoch.\n */\ncontract L1Block is Semver {\n    /**\n     * @notice Address of the special depositor account.\n     */\n    address public constant DEPOSITOR_ACCOUNT = 0xDeaDDEaDDeAdDeAdDEAdDEaddeAddEAdDEAd0001;\n\n    /**\n     * @notice The latest L1 block number known by the L2 system.\n     */\n    uint64 public number;\n\n    /**\n     * @notice The latest L1 timestamp known by the L2 system.\n     */\n    uint64 public timestamp;\n\n    /**\n     * @notice The latest L1 basefee.\n     */\n    uint256 public basefee;\n\n    /**\n     * @notice The latest L1 blockhash.\n     */\n    bytes32 public hash;\n\n    /**\n     * @notice The number of L2 blocks in the same epoch.\n     */\n    uint64 public sequenceNumber;\n\n    /**\n     * @notice The versioned hash to authenticate the batcher by.\n     */\n    bytes32 public batcherHash;\n\n    /**\n     * @notice The overhead value applied to the L1 portion of the transaction\n     *         fee.\n     */\n    uint256 public l1FeeOverhead;\n\n    /**\n     * @notice The scalar value applied to the L1 portion of the transaction fee.\n     *         The denominator is 1,000,000, so the ratio is expressed in 6 decimal places.\n     */\n    uint256 public l1FeeScalar;\n\n    /**\n     * @notice The scalar value to distribute transaction fees as validator reward.\n     *         The denominator is 10000, so the ratio is expressed in 4 decimal places.\n     */\n    uint256 public validatorRewardScalar;\n\n    /**\n     * @custom:semver 0.1.0\n     */\n    constructor() Semver(0, 1, 0) {}\n\n    /**\n     * @notice Updates the L1 block values.\n     *\n     * @param _number                  L1 blocknumber.\n     * @param _timestamp               L1 timestamp.\n     * @param _basefee                 L1 basefee.\n     * @param _hash                    L1 blockhash.\n     * @param _sequenceNumber          Number of L2 blocks since epoch start.\n     * @param _batcherHash             Versioned hash to authenticate batcher by.\n     * @param _l1FeeOverhead           L1 fee overhead.\n     * @param _l1FeeScalar             L1 fee scalar.\n     * @param _validatorRewardScalar   Validator reward scalar.\n     */\n    function setL1BlockValues(\n        uint64 _number,\n        uint64 _timestamp,\n        uint256 _basefee,\n        bytes32 _hash,\n        uint64 _sequenceNumber,\n        bytes32 _batcherHash,\n        uint256 _l1FeeOverhead,\n        uint256 _l1FeeScalar,\n        uint256 _validatorRewardScalar\n    ) external {\n        require(\n            msg.sender == DEPOSITOR_ACCOUNT,\n            \"L1Block: only the depositor account can set L1 block values\"\n        );\n        require(\n            _validatorRewardScalar <= Constants.VALIDATOR_REWARD_DENOMINATOR,\n            \"L1Block: the max value of validator reward scalar has been exceeded\"\n        );\n\n        number = _number;\n        timestamp = _timestamp;\n        basefee = _basefee;\n        hash = _hash;\n        sequenceNumber = _sequenceNumber;\n        batcherHash = _batcherHash;\n        l1FeeOverhead = _l1FeeOverhead;\n        l1FeeScalar = _l1FeeScalar;\n        validatorRewardScalar = _validatorRewardScalar;\n    }\n}\n"
    },
    "contracts/L2/L2CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { L2ToL1MessagePasser } from \"./L2ToL1MessagePasser.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000004\n * @title L2CrossDomainMessenger\n * @notice The L2CrossDomainMessenger is a high-level interface for message passing between L1 and\n *         L2 on the L2 side. Users are generally encouraged to use this contract instead of lower\n *         level message passing contracts.\n */\ncontract L2CrossDomainMessenger is CrossDomainMessenger, Semver {\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _l1CrossDomainMessenger Address of the L1CrossDomainMessenger contract.\n     */\n    constructor(address _l1CrossDomainMessenger)\n        Semver(0, 1, 0)\n        CrossDomainMessenger(_l1CrossDomainMessenger)\n    {\n        initialize();\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize() public initializer {\n        __CrossDomainMessenger_init();\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal override {\n        L2ToL1MessagePasser(payable(Predeploys.L2_TO_L1_MESSAGE_PASSER)).initiateWithdrawal{\n            value: _value\n        }(_to, _gasLimit, _data);\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _isOtherMessenger() internal view override returns (bool) {\n        return AddressAliasHelper.undoL1ToL2Alias(msg.sender) == OTHER_MESSENGER;\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _isUnsafeTarget(address _target) internal view override returns (bool) {\n        return _target == address(this) || _target == address(Predeploys.L2_TO_L1_MESSAGE_PASSER);\n    }\n}\n"
    },
    "contracts/L2/L2ERC721Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport { L1ERC721Bridge } from \"../L1/L1ERC721Bridge.sol\";\nimport { ERC721Bridge } from \"../universal/ERC721Bridge.sol\";\nimport { IKromaMintableERC721 } from \"../universal/IKromaMintableERC721.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @title L2ERC721Bridge\n * @notice The L2 ERC721 bridge is a contract which works together with the L1 ERC721 bridge to\n *         make it possible to transfer ERC721 tokens from Ethereum to Kroma. This contract\n *         acts as a minter for new tokens when it hears about deposits into the L1 ERC721 bridge.\n *         This contract also acts as a burner for tokens being withdrawn.\n *         **WARNING**: Do not bridge an ERC721 that was originally deployed on Kroma. This\n *         bridge ONLY supports ERC721s originally deployed on Ethereum. Users will need to\n *         wait for the one-week challenge period to elapse before their Kroma-native NFT\n *         can be refunded on L2.\n */\ncontract L2ERC721Bridge is ERC721Bridge, Semver {\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _messenger   Address of the CrossDomainMessenger on this network.\n     * @param _otherBridge Address of the ERC721 bridge on the other network.\n     */\n    constructor(address _messenger, address _otherBridge)\n        Semver(0, 1, 0)\n        ERC721Bridge(_messenger, _otherBridge)\n    {}\n\n    /**\n     * @notice Completes an ERC721 bridge from the other domain and sends the ERC721 token to the\n     *         recipient on this domain.\n     *\n     * @param _localToken  Address of the ERC721 token on this domain.\n     * @param _remoteToken Address of the ERC721 token on the other domain.\n     * @param _from        Address that triggered the bridge on the other domain.\n     * @param _to          Address to receive the token on this domain.\n     * @param _tokenId     ID of the token being deposited.\n     * @param _extraData   Optional data to forward to L1. Data supplied here will not be used to\n     *                     execute any code on L1 and is only emitted as extra data for the\n     *                     convenience of off-chain tooling.\n     */\n    function finalizeBridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes calldata _extraData\n    ) external onlyOtherBridge {\n        require(_localToken != address(this), \"L2ERC721Bridge: local token cannot be self\");\n\n        // Note that supportsInterface makes a callback to the _localToken address which is user\n        // provided.\n        require(\n            ERC165Checker.supportsInterface(_localToken, type(IKromaMintableERC721).interfaceId),\n            \"L2ERC721Bridge: local token interface is not compliant\"\n        );\n\n        require(\n            _remoteToken == IKromaMintableERC721(_localToken).REMOTE_TOKEN(),\n            \"L2ERC721Bridge: wrong remote token for Kroma Mintable ERC721 local token\"\n        );\n\n        // When a deposit is finalized, we give the NFT with the same tokenId to the account\n        // on L2. Note that safeMint makes a callback to the _to address which is user provided.\n        IKromaMintableERC721(_localToken).safeMint(_to, _tokenId);\n\n        // slither-disable-next-line reentrancy-events\n        emit ERC721BridgeFinalized(_localToken, _remoteToken, _from, _to, _tokenId, _extraData);\n    }\n\n    /**\n     * @inheritdoc ERC721Bridge\n     */\n    function _initiateBridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) internal override {\n        require(_remoteToken != address(0), \"L2ERC721Bridge: remote token cannot be address(0)\");\n\n        // Check that the withdrawal is being initiated by the NFT owner\n        require(\n            _from == IKromaMintableERC721(_localToken).ownerOf(_tokenId),\n            \"L2ERC721Bridge: Withdrawal is not being initiated by NFT owner\"\n        );\n\n        // Construct calldata for l1ERC721Bridge.finalizeBridgeERC721(_to, _tokenId)\n        // slither-disable-next-line reentrancy-events\n        address remoteToken = IKromaMintableERC721(_localToken).REMOTE_TOKEN();\n        require(\n            remoteToken == _remoteToken,\n            \"L2ERC721Bridge: remote token does not match given value\"\n        );\n\n        // When a withdrawal is initiated, we burn the withdrawer's NFT to prevent subsequent L2\n        // usage\n        // slither-disable-next-line reentrancy-events\n        IKromaMintableERC721(_localToken).burn(_from, _tokenId);\n\n        bytes memory message = abi.encodeWithSelector(\n            L1ERC721Bridge.finalizeBridgeERC721.selector,\n            remoteToken,\n            _localToken,\n            _from,\n            _to,\n            _tokenId,\n            _extraData\n        );\n\n        // Send message to L1 bridge\n        // slither-disable-next-line reentrancy-events\n        MESSENGER.sendMessage(OTHER_BRIDGE, message, _minGasLimit);\n\n        // slither-disable-next-line reentrancy-events\n        emit ERC721BridgeInitiated(_localToken, remoteToken, _from, _to, _tokenId, _extraData);\n    }\n}\n"
    },
    "contracts/L2/L2StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000009\n * @title L2StandardBridge\n * @notice The L2StandardBridge is responsible for transfering ETH and ERC20 tokens between L1 and\n *         L2. In the case that an ERC20 token is native to L2, it will be escrowed within this\n *         contract. If the ERC20 token is native to L1, it will be burnt.\n *         NOTE: this contract is not intended to support all variations of ERC20 tokens. Examples\n *         of some token types that may not be properly supported by this contract include, but are\n *         not limited to: tokens with transfer fees, rebasing tokens, and tokens with blocklists.\n */\ncontract L2StandardBridge is StandardBridge, Semver {\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _otherBridge Address of the L1StandardBridge.\n     */\n    constructor(address payable _otherBridge)\n        Semver(0, 1, 0)\n        StandardBridge(payable(Predeploys.L2_CROSS_DOMAIN_MESSENGER), _otherBridge)\n    {}\n\n    /**\n     * @notice Allows EOAs to bridge ETH by sending directly to the bridge.\n     */\n    receive() external payable override onlyEOA {\n        _initiateBridgeETH(\n            msg.sender,\n            msg.sender,\n            msg.value,\n            RECEIVE_DEFAULT_GAS_LIMIT,\n            bytes(\"\")\n        );\n    }\n}\n"
    },
    "contracts/L2/L2ToL1MessagePasser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Burn } from \"../libraries/Burn.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000003\n * @title L2ToL1MessagePasser\n * @notice The L2ToL1MessagePasser is a dedicated contract where messages that are being sent from\n *         L2 to L1 can be stored. The storage root of this contract is pulled up to the top level\n *         of the L2 output to reduce the cost of proving the existence of sent messages.\n */\ncontract L2ToL1MessagePasser is Semver {\n    /**\n     * @notice The L1 gas limit set when eth is withdrawn using the receive() function.\n     */\n    uint256 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;\n\n    /**\n     * @notice Current message version identifier.\n     */\n    uint16 public constant MESSAGE_VERSION = 0;\n\n    /**\n     * @notice Includes the message hashes for all withdrawals\n     */\n    mapping(bytes32 => bool) public sentMessages;\n\n    /**\n     * @notice A unique value hashed with each withdrawal.\n     */\n    uint240 internal msgNonce;\n\n    /**\n     * @notice Emitted any time a withdrawal is initiated.\n     *\n     * @param nonce          Unique value corresponding to each withdrawal.\n     * @param sender         The L2 account address which initiated the withdrawal.\n     * @param target         The L1 account address the call will be send to.\n     * @param value          The ETH value submitted for withdrawal, to be forwarded to the target.\n     * @param gasLimit       The minimum amount of gas that must be provided when withdrawing.\n     * @param data           The data to be forwarded to the target on L1.\n     * @param withdrawalHash The hash of the withdrawal.\n     */\n    event MessagePassed(\n        uint256 indexed nonce,\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes data,\n        bytes32 withdrawalHash\n    );\n\n    /**\n     * @notice Emitted when the balance of this contract is burned.\n     *\n     * @param amount Amount of ETh that was burned.\n     */\n    event WithdrawerBalanceBurnt(uint256 indexed amount);\n\n    /**\n     * @custom:semver 0.1.0\n     */\n    constructor() Semver(0, 1, 0) {}\n\n    /**\n     * @notice Allows users to withdraw ETH by sending directly to this contract.\n     */\n    receive() external payable {\n        initiateWithdrawal(msg.sender, RECEIVE_DEFAULT_GAS_LIMIT, bytes(\"\"));\n    }\n\n    /**\n     * @notice Removes all ETH held by this contract from the state. Used to prevent the amount of\n     *         ETH on L2 inflating when ETH is withdrawn. Anyone can call this function. Not\n     *         incentivized since this function is very cheap.\n     */\n    function burn() external {\n        uint256 balance = address(this).balance;\n        Burn.eth(balance);\n        emit WithdrawerBalanceBurnt(balance);\n    }\n\n    /**\n     * @notice Sends a message from L2 to L1.\n     *\n     * @param _target   Address to call on L1 execution.\n     * @param _gasLimit Minimum gas limit for executing the message on L1.\n     * @param _data     Data to forward to L1 target.\n     */\n    function initiateWithdrawal(\n        address _target,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) public payable {\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction({\n                nonce: messageNonce(),\n                sender: msg.sender,\n                target: _target,\n                value: msg.value,\n                gasLimit: _gasLimit,\n                data: _data\n            })\n        );\n\n        sentMessages[withdrawalHash] = true;\n\n        emit MessagePassed(\n            messageNonce(),\n            msg.sender,\n            _target,\n            msg.value,\n            _gasLimit,\n            _data,\n            withdrawalHash\n        );\n\n        unchecked {\n            ++msgNonce;\n        }\n    }\n\n    /**\n     * @notice Retrieves the next message nonce. Message version will be added to the upper two\n     *         bytes of the message nonce. Message version allows us to treat messages as having\n     *         different structures.\n     *\n     * @return Nonce of the next message to be sent, with added message version.\n     */\n    function messageNonce() public view returns (uint256) {\n        return Encoding.encodeVersionedNonce(msgNonce, MESSAGE_VERSION);\n    }\n}\n"
    },
    "contracts/L2/ProposerRewardVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { FeeVault } from \"../universal/FeeVault.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000007\n * @title ProposerRewardVault\n * @notice The ProposerRewardVault accumulates the L1 portion of the transaction fees.\n */\ncontract ProposerRewardVault is FeeVault, Semver {\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _recipient Address that will receive the accumulated fees.\n     */\n    constructor(address _recipient) FeeVault(_recipient, 10 ether) Semver(0, 1, 0) {}\n}\n"
    },
    "contracts/L2/ProtocolVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { FeeVault } from \"../universal/FeeVault.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000006\n * @title ProtocolVault\n * @notice The ProtocolVault accumulates transaction fees to fund network operation.\n */\ncontract ProtocolVault is FeeVault, Semver {\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _recipient Address that will receive the accumulated fees.\n     */\n    constructor(address _recipient) FeeVault(_recipient, 10 ether) Semver(0, 1, 0) {}\n}\n"
    },
    "contracts/L2/ValidatorRewardVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { L2StandardBridge } from \"../L2/L2StandardBridge.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { FeeVault } from \"../universal/FeeVault.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000008\n * @title ValidatorRewardVault\n * @notice The ValidatorRewardVault accumulates transaction fees and pays rewards to validators.\n */\ncontract ValidatorRewardVault is FeeVault, Semver {\n    /**\n     * @notice Address of the ValidatorPool contract on L1.\n     */\n    address public immutable VALIDATOR_POOL;\n\n    /**\n     * @notice A value to divide the vault balance by when determining the reward amount.\n     */\n    uint256 public immutable REWARD_DIVIDER;\n\n    /**\n     * @notice The reward balance that the validator is eligible to receive.\n     */\n    mapping(address => uint256) internal rewards;\n\n    /**\n     * @notice A mapping of whether the reward corresponding to the L2 block number has been paid.\n     */\n    mapping(uint256 => bool) internal isPaid;\n\n    /**\n     * @notice The amount of determined as rewards.\n     */\n    uint256 public totalReserved;\n\n    /**\n     * @notice Emitted when the balance of a validator has increased.\n     *\n     * @param validator     Address of the validator.\n     * @param l2BlockNumber The L2 block number of the output root.\n     * @param amount        Amount of the reward.\n     */\n    event Rewarded(address indexed validator, uint256 indexed l2BlockNumber, uint256 amount);\n\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _validatorPool Address of the ValidatorPool contract on L1.\n     * @param _rewardDivider A value to divide the vault balance by when determining the reward amount.\n     */\n    constructor(address _validatorPool, uint256 _rewardDivider)\n        FeeVault(address(0), 10 ether)\n        Semver(0, 1, 0)\n    {\n        VALIDATOR_POOL = _validatorPool;\n        REWARD_DIVIDER = _rewardDivider;\n    }\n\n    /**\n     * @notice Rewards the validator for submitting the output.\n     *         ValidatorPool contract on L1 calls this function over the portal when output is finalized.\n     *\n     * @param _validator     Address of the validator.\n     * @param _l2BlockNumber The L2 block number of the output root.\n     */\n    function reward(address _validator, uint256 _l2BlockNumber) external {\n        require(\n            AddressAliasHelper.undoL1ToL2Alias(msg.sender) == VALIDATOR_POOL,\n            \"ValidatorRewardVault: function can only be called from the ValidatorPool\"\n        );\n\n        require(_validator != address(0), \"ValidatorRewardVault: validator address cannot be 0\");\n\n        require(\n            !isPaid[_l2BlockNumber],\n            \"ValidatorRewardVault: the reward has already been paid for the L2 block number\"\n        );\n\n        uint256 amount = _determineRewardAmount();\n\n        unchecked {\n            totalReserved += amount;\n            rewards[_validator] += amount;\n        }\n\n        isPaid[_l2BlockNumber] = true;\n\n        emit Rewarded(_validator, _l2BlockNumber, amount);\n    }\n\n    /**\n     * @notice Withdraws all of the sender's balance.\n     *         Reverts if the balance is less than the minimum withdrawal amount.\n     */\n    function withdraw() external override {\n        uint256 balance = rewards[msg.sender];\n\n        require(\n            balance >= MIN_WITHDRAWAL_AMOUNT,\n            \"ValidatorRewardVault: withdrawal amount must be greater than minimum withdrawal amount\"\n        );\n\n        rewards[msg.sender] = 0;\n\n        unchecked {\n            totalReserved -= balance;\n            totalProcessed += balance;\n        }\n\n        emit Withdrawal(balance, msg.sender, msg.sender);\n\n        L2StandardBridge(payable(Predeploys.L2_STANDARD_BRIDGE)).bridgeETHTo{ value: balance }(\n            msg.sender,\n            WITHDRAWAL_MIN_GAS,\n            bytes(\"\")\n        );\n    }\n\n    /**\n     * @notice Determines the reward amount.\n     *\n     * @return Amount of the reward.\n     */\n    function _determineRewardAmount() internal view returns (uint256) {\n        return (address(this).balance - totalReserved) / REWARD_DIVIDER;\n    }\n\n    /**\n     * @notice Returns the reward balance of the given address.\n     *\n     * @param _addr Address to lookup.\n     *\n     * @return The reward balance of the given address.\n     */\n    function balanceOf(address _addr) external view returns (uint256) {\n        return rewards[_addr];\n    }\n}\n"
    },
    "contracts/echidna/FuzzAddressAliasing.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\n\ncontract EchidnaFuzzAddressAliasing {\n    bool internal failedRoundtrip;\n\n    /**\n     * @notice Takes an address to be aliased with AddressAliasHelper and then unaliased\n     *         and updates the test contract's state indicating if the round trip encoding\n     *         failed.\n     */\n    function testRoundTrip(address addr) public {\n        // Alias our address\n        address aliasedAddr = AddressAliasHelper.applyL1ToL2Alias(addr);\n\n        // Unalias our address\n        address undoneAliasAddr = AddressAliasHelper.undoL1ToL2Alias(aliasedAddr);\n\n        // If our round trip aliasing did not return the original result, set our state.\n        if (addr != undoneAliasAddr) {\n            failedRoundtrip = true;\n        }\n    }\n\n    /**\n     * @custom:invariant Address aliases are always able to be undone.\n     *\n     * Asserts that an address that has been aliased with `applyL1ToL2Alias` can always\n     * be unaliased with `undoL1ToL2Alias`.\n     */\n    function echidna_round_trip_aliasing() public view returns (bool) {\n        // ASSERTION: The round trip aliasing done in testRoundTrip(...) should never fail.\n        return !failedRoundtrip;\n    }\n}\n"
    },
    "contracts/echidna/FuzzBurn.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { StdUtils } from \"forge-std/Test.sol\";\n\nimport { Burn } from \"../libraries/Burn.sol\";\n\ncontract EchidnaFuzzBurnEth is StdUtils {\n    bool internal failedEthBurn;\n\n    /**\n     * @notice Takes an integer amount of eth to burn through the Burn library and\n     * updates the contract state if an incorrect amount of eth moved from the contract\n     */\n    function testBurn(uint256 _value) public {\n        // cache the contract's eth balance\n        uint256 preBurnBalance = address(this).balance;\n        uint256 value = bound(_value, 0, preBurnBalance);\n\n        // execute a burn of _value eth\n        Burn.eth(value);\n\n        // check that exactly value eth was transfered from the contract\n        unchecked {\n            if (address(this).balance != preBurnBalance - value) {\n                failedEthBurn = true;\n            }\n        }\n    }\n\n    /**\n     * @custom:invariant `eth(uint256)` always burns the exact amount of eth passed.\n     *\n     * Asserts that when `Burn.eth(uint256)` is called, it always burns the exact amount\n     * of ETH passed to the function.\n     */\n    function echidna_burn_eth() public view returns (bool) {\n        // ASSERTION: The amount burned should always match the amount passed exactly\n        return !failedEthBurn;\n    }\n}\n\ncontract EchidnaFuzzBurnGas is StdUtils {\n    bool internal failedGasBurn;\n\n    /**\n     * @notice Takes an integer amount of gas to burn through the Burn library and\n     * updates the contract state if at least that amount of gas was not burned\n     * by the library\n     */\n    function testGas(uint256 _value) public {\n        // cap the value to the max resource limit\n        uint256 MAX_RESOURCE_LIMIT = 8_000_000;\n        uint256 value = bound(_value, 0, MAX_RESOURCE_LIMIT);\n\n        // cache the contract's current remaining gas\n        uint256 preBurnGas = gasleft();\n\n        // execute the gas burn\n        Burn.gas(value);\n\n        // cache the remaining gas post burn\n        uint256 postBurnGas = gasleft();\n\n        // check that at least value gas was burnt (and that there was no underflow)\n        unchecked {\n            if (postBurnGas - preBurnGas > value || preBurnGas - value > preBurnGas) {\n                failedGasBurn = true;\n            }\n        }\n    }\n\n    /**\n     * @custom:invariant `gas(uint256)` always burns at least the amount of gas passed.\n     *\n     * Asserts that when `Burn.gas(uint256)` is called, it always burns at least the amount\n     * of gas passed to the function.\n     */\n    function echidna_burn_gas() public view returns (bool) {\n        // ASSERTION: The amount of gas burned should be strictly greater than the\n        // the amount passed as _value (minimum _value + whatever minor overhead to\n        // the value after the call)\n        return !failedGasBurn;\n    }\n}\n"
    },
    "contracts/echidna/FuzzEncoding.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Encoding } from \"../libraries/Encoding.sol\";\n\ncontract EchidnaFuzzEncoding {\n    bool internal failedRoundtripAToB;\n    bool internal failedRoundtripBToA;\n\n    /**\n     * @notice Takes a pair of integers to be encoded into a versioned nonce with the\n     *         Encoding library and then decoded and updates the test contract's state\n     *         indicating if the round trip encoding failed.\n     */\n    function testRoundTripAToB(uint240 _nonce, uint16 _version) public {\n        // Encode the nonce and version\n        uint256 encodedVersionedNonce = Encoding.encodeVersionedNonce(_nonce, _version);\n\n        // Decode the nonce and version\n        uint240 decodedNonce;\n        uint16 decodedVersion;\n\n        (decodedNonce, decodedVersion) = Encoding.decodeVersionedNonce(encodedVersionedNonce);\n\n        // If our round trip encoding did not return the original result, set our state.\n        if ((decodedNonce != _nonce) || (decodedVersion != _version)) {\n            failedRoundtripAToB = true;\n        }\n    }\n\n    /**\n     * @notice Takes an integer representing a packed version and nonce and attempts\n     *         to decode them using the Encoding library before re-encoding and updates\n     *         the test contract's state indicating if the round trip encoding failed.\n     */\n    function testRoundTripBToA(uint256 _versionedNonce) public {\n        // Decode the nonce and version\n        uint240 decodedNonce;\n        uint16 decodedVersion;\n\n        (decodedNonce, decodedVersion) = Encoding.decodeVersionedNonce(_versionedNonce);\n\n        // Encode the nonce and version\n        uint256 encodedVersionedNonce = Encoding.encodeVersionedNonce(decodedNonce, decodedVersion);\n\n        // If our round trip encoding did not return the original result, set our state.\n        if (encodedVersionedNonce != _versionedNonce) {\n            failedRoundtripBToA = true;\n        }\n    }\n\n    /**\n     * @custom:invariant `testRoundTripAToB` never fails.\n     *\n     * Asserts that a raw versioned nonce can be encoded / decoded to reach the same raw value.\n     */\n    function echidna_round_trip_encoding_AToB() public view returns (bool) {\n        // ASSERTION: The round trip encoding done in testRoundTripAToB(...)\n        return !failedRoundtripAToB;\n    }\n\n    /**\n     * @custom:invariant `testRoundTripBToA` never fails.\n     *\n     * Asserts that an encoded versioned nonce can always be decoded / re-encoded to reach\n     * the same encoded value.\n     */\n    function echidna_round_trip_encoding_BToA() public view returns (bool) {\n        // ASSERTION: The round trip encoding done in testRoundTripBToA should never\n        // fail.\n        return !failedRoundtripBToA;\n    }\n}\n"
    },
    "contracts/echidna/FuzzHashing.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\n\ncontract EchidnaFuzzHashing {\n    bool internal failedCrossDomainHashHighVersion;\n    bool internal failedCrossDomainHashV0;\n\n    /**\n     * @notice Takes the necessary parameters to perform a cross domain hash with a randomly\n     * generated version. Only schema version 0 is supported and all others should revert.\n     */\n    function testHashCrossDomainMessageHighVersion(\n        uint16 _version,\n        uint240 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) public {\n        // generate the versioned nonce\n        uint256 encodedNonce = Encoding.encodeVersionedNonce(_nonce, _version);\n\n        // hash the cross domain message. we don't need to store the result since the function\n        // validates and should revert if an invalid version (>0) is encoded\n        Hashing.hashCrossDomainMessage(encodedNonce, _sender, _target, _value, _gasLimit, _data);\n\n        // check that execution never makes it this far for an invalid version\n        if (_version > 0) {\n            failedCrossDomainHashHighVersion = true;\n        }\n    }\n\n    /**\n     * @notice Takes the necessary parameters to perform a cross domain hash using the v0 schema\n     * and compares the output of a call to the unversioned function to the v0 function directly\n     */\n    function testHashCrossDomainMessageV0(\n        uint240 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) public {\n        // generate the versioned nonce with the version set to 0\n        uint256 encodedNonce = Encoding.encodeVersionedNonce(_nonce, 0);\n\n        // hash the cross domain message using the unversioned and versioned functions for\n        // comparison\n        bytes32 sampleHash1 = Hashing.hashCrossDomainMessage(\n            encodedNonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n        bytes32 sampleHash2 = Hashing.hashCrossDomainMessageV0(\n            encodedNonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n\n        // check that the output of both functions matches\n        if (sampleHash1 != sampleHash2) {\n            failedCrossDomainHashV0 = true;\n        }\n    }\n\n    /**\n     * @custom:invariant `hashCrossDomainMessage` reverts if `version` is > `0`.\n     *\n     * The `hashCrossDomainMessage` function should always revert if the `version` passed is > `0`.\n     */\n    function echidna_hash_xdomain_msg_high_version() public view returns (bool) {\n        // ASSERTION: A call to hashCrossDomainMessage will never succeed for a version > 1\n        return !failedCrossDomainHashHighVersion;\n    }\n\n    /**\n     * @custom:invariant `version` = `0`: `hashCrossDomainMessage` and `hashCrossDomainMessageV0`\n     * are equivalent.\n     *\n     * If the version passed is 0, `hashCrossDomainMessage` and `hashCrossDomainMessageV0` should be\n     * equivalent.\n     */\n    function echidna_hash_xdomain_msg_0() public view returns (bool) {\n        // ASSERTION: A call to hashCrossDomainMessage and hashCrossDomainMessageV0\n        // should always match when the version passed is 0\n        return !failedCrossDomainHashV0;\n    }\n}\n"
    },
    "contracts/echidna/FuzzKromaPortal.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { KromaPortal } from \"../L1/KromaPortal.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { SystemConfig } from \"../L1/SystemConfig.sol\";\nimport { ZKMerkleTrie } from \"../L1/ZKMerkleTrie.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\n\ncontract EchidnaFuzzKromaPortal {\n    KromaPortal internal portal;\n    bool internal failedToComplete;\n\n    constructor() {\n        ResourceMetering.ResourceConfig memory rcfg = Constants.DEFAULT_RESOURCE_CONFIG();\n\n        SystemConfig systemConfig = new SystemConfig({\n            _owner: address(1),\n            _overhead: 0,\n            _scalar: 10000,\n            _batcherHash: bytes32(0),\n            _gasLimit: 30_000_000,\n            _unsafeBlockSigner: address(0),\n            _config: rcfg,\n            _validatorRewardScalar: 5000\n        });\n        portal = new KromaPortal({\n            _l2Oracle: L2OutputOracle(address(0)),\n            _validatorPool: address(0),\n            _guardian: address(0),\n            _paused: false,\n            _config: systemConfig,\n            _zkMerkleTrie: ZKMerkleTrie(address(0))\n        });\n    }\n\n    // A test intended to identify any unexpected halting conditions\n    function testDepositTransactionCompletes(\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    ) public payable {\n        failedToComplete = true;\n        require(!_isCreation || _to == address(0), \"EchidnaFuzzKromaPortal: invalid test case.\");\n        portal.depositTransaction{ value: _mint }(_to, _value, _gasLimit, _isCreation, _data);\n        failedToComplete = false;\n    }\n\n    /**\n     * @custom:invariant Deposits of any value should always succeed unless\n     * `_to` = `address(0)` or `_isCreation` = `true`.\n     *\n     * All deposits, barring creation transactions and transactions sent to `address(0)`,\n     * should always succeed.\n     */\n    function echidna_deposit_completes() public view returns (bool) {\n        return !failedToComplete;\n    }\n}\n"
    },
    "contracts/echidna/FuzzResourceMetering.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { StdUtils } from \"forge-std/Test.sol\";\n\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { Arithmetic } from \"../libraries/Arithmetic.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\n\ncontract EchidnaFuzzResourceMetering is ResourceMetering, StdUtils {\n    bool internal failedMaxGasPerBlock;\n    bool internal failedRaiseBaseFee;\n    bool internal failedLowerBaseFee;\n    bool internal failedNeverBelowMinBaseFee;\n    bool internal failedMaxRaiseBaseFeePerBlock;\n    bool internal failedMaxLowerBaseFeePerBlock;\n\n    // Used as a special flag for the purpose of identifying unchecked math errors specifically\n    // in the test contracts, not the target contracts themselves.\n    bool internal underflow;\n\n    constructor() {\n        initialize();\n    }\n\n    function initialize() internal initializer {\n        __ResourceMetering_init();\n    }\n\n    function resourceConfig() public pure returns (ResourceMetering.ResourceConfig memory) {\n        return _resourceConfig();\n    }\n\n    function _resourceConfig()\n        internal\n        pure\n        override\n        returns (ResourceMetering.ResourceConfig memory)\n    {\n        ResourceMetering.ResourceConfig memory rcfg = Constants.DEFAULT_RESOURCE_CONFIG();\n        return rcfg;\n    }\n\n    /**\n     * @notice Takes the necessary parameters to allow us to burn arbitrary amounts of gas to test\n     *         the underlying resource metering/gas market logic\n     */\n    function testBurn(uint256 _gasToBurn, bool _raiseBaseFee) public {\n        // Part 1: we cache the current param values and do some basic checks on them.\n        uint256 cachedPrevBaseFee = uint256(params.prevBaseFee);\n        uint256 cachedPrevBoughtGas = uint256(params.prevBoughtGas);\n        uint256 cachedPrevBlockNum = uint256(params.prevBlockNum);\n\n        ResourceMetering.ResourceConfig memory rcfg = resourceConfig();\n        uint256 targetResourceLimit = uint256(rcfg.maxResourceLimit) /\n            uint256(rcfg.elasticityMultiplier);\n\n        // check that the last block's base fee hasn't dropped below the minimum\n        if (cachedPrevBaseFee < uint256(rcfg.minimumBaseFee)) {\n            failedNeverBelowMinBaseFee = true;\n        }\n        // check that the last block didn't consume more than the max amount of gas\n        if (cachedPrevBoughtGas > uint256(rcfg.maxResourceLimit)) {\n            failedMaxGasPerBlock = true;\n        }\n\n        // Part2: we perform the gas burn\n\n        // force the gasToBurn into the correct range based on whether we intend to\n        // raise or lower the baseFee after this block, respectively\n        uint256 gasToBurn;\n        if (_raiseBaseFee) {\n            gasToBurn = bound(\n                _gasToBurn,\n                uint256(targetResourceLimit),\n                uint256(rcfg.maxResourceLimit)\n            );\n        } else {\n            gasToBurn = bound(_gasToBurn, 0, targetResourceLimit);\n        }\n\n        _burnInternal(uint64(gasToBurn));\n\n        // Part 3: we run checks and modify our invariant flags based on the updated params values\n\n        // Calculate the maximum allowed baseFee change (per block)\n        uint256 maxBaseFeeChange = cachedPrevBaseFee / uint256(rcfg.baseFeeMaxChangeDenominator);\n\n        // If the last block used more than the target amount of gas (and there were no\n        // empty blocks in between), ensure this block's baseFee increased, but not by\n        // more than the max amount per block\n        if (\n            (cachedPrevBoughtGas > uint256(targetResourceLimit)) &&\n            (uint256(params.prevBlockNum) - cachedPrevBlockNum == 1)\n        ) {\n            failedRaiseBaseFee = failedRaiseBaseFee || (params.prevBaseFee <= cachedPrevBaseFee);\n            failedMaxRaiseBaseFeePerBlock =\n                failedMaxRaiseBaseFeePerBlock ||\n                ((uint256(params.prevBaseFee) - cachedPrevBaseFee) < maxBaseFeeChange);\n        }\n\n        // If the last block used less than the target amount of gas, (or was empty),\n        // ensure that: this block's baseFee was decreased, but not by more than the max amount\n        if (\n            (cachedPrevBoughtGas < uint256(targetResourceLimit)) ||\n            (uint256(params.prevBlockNum) - cachedPrevBlockNum > 1)\n        ) {\n            // Invariant: baseFee should decrease\n            failedLowerBaseFee =\n                failedLowerBaseFee ||\n                (uint256(params.prevBaseFee) > cachedPrevBaseFee);\n\n            if (params.prevBlockNum - cachedPrevBlockNum == 1) {\n                // No empty blocks\n                // Invariant: baseFee should not have decreased by more than the maximum amount\n                failedMaxLowerBaseFeePerBlock =\n                    failedMaxLowerBaseFeePerBlock ||\n                    ((cachedPrevBaseFee - uint256(params.prevBaseFee)) <= maxBaseFeeChange);\n            } else if (params.prevBlockNum - cachedPrevBlockNum > 1) {\n                // We have at least one empty block\n                // Update the maxBaseFeeChange to account for multiple blocks having passed\n                unchecked {\n                    maxBaseFeeChange = uint256(\n                        int256(cachedPrevBaseFee) -\n                            Arithmetic.clamp(\n                                Arithmetic.cdexp(\n                                    int256(cachedPrevBaseFee),\n                                    int256(uint256(rcfg.baseFeeMaxChangeDenominator)),\n                                    int256(uint256(params.prevBlockNum) - cachedPrevBlockNum)\n                                ),\n                                int256(uint256(rcfg.minimumBaseFee)),\n                                int256(uint256(rcfg.maximumBaseFee))\n                            )\n                    );\n                }\n\n                // Detect an underflow in the previous calculation.\n                // Without using unchecked above, and detecting the underflow here, echidna would\n                // otherwise ignore the revert.\n                underflow = underflow || maxBaseFeeChange > cachedPrevBaseFee;\n\n                // Invariant: baseFee should not have decreased by more than the maximum amount\n                failedMaxLowerBaseFeePerBlock =\n                    failedMaxLowerBaseFeePerBlock ||\n                    ((cachedPrevBaseFee - uint256(params.prevBaseFee)) <= maxBaseFeeChange);\n            }\n        }\n    }\n\n    function _burnInternal(uint64 _gasToBurn) private metered(_gasToBurn) {}\n\n    /**\n     * @custom:invariant The base fee should increase if the last block used more\n     * than the target amount of gas\n     *\n     * If the last block used more than the target amount of gas (and there were no\n     * empty blocks in between), ensure this block's baseFee increased, but not by\n     * more than the max amount per block.\n     */\n    function echidna_high_usage_raise_baseFee() public view returns (bool) {\n        return !failedRaiseBaseFee;\n    }\n\n    /**\n     * @custom:invariant The base fee should decrease if the last block used less\n     * than the target amount of gas\n     *\n     * If the previous block used less than the target amount of gas, the base fee should decrease,\n     * but not more than the max amount.\n     */\n    function echidna_low_usage_lower_baseFee() public view returns (bool) {\n        return !failedLowerBaseFee;\n    }\n\n    /**\n     * @custom:invariant A block's base fee should never be below `MINIMUM_BASE_FEE`\n     *\n     * This test asserts that a block's base fee can never drop below the\n     * `MINIMUM_BASE_FEE` threshold.\n     */\n    function echidna_never_below_min_baseFee() public view returns (bool) {\n        return !failedNeverBelowMinBaseFee;\n    }\n\n    /**\n     * @custom:invariant A block can never consume more than `MAX_RESOURCE_LIMIT` gas.\n     *\n     * This test asserts that a block can never consume more than the `MAX_RESOURCE_LIMIT`\n     * gas threshold.\n     */\n    function echidna_never_above_max_gas_limit() public view returns (bool) {\n        return !failedMaxGasPerBlock;\n    }\n\n    /**\n     * @custom:invariant The base fee can never be raised more than the max base fee change.\n     *\n     * After a block consumes more gas than the target gas, the base fee cannot be raised\n     * more than the maximum amount allowed. The max base fee change (per-block) is derived\n     * as follows: `prevBaseFee / BASE_FEE_MAX_CHANGE_DENOMINATOR`\n     */\n    function echidna_never_exceed_max_increase() public view returns (bool) {\n        return !failedMaxRaiseBaseFeePerBlock;\n    }\n\n    /**\n     * @custom:invariant The base fee can never be lowered more than the max base fee change.\n     *\n     * After a block consumes less than the target gas, the base fee cannot be lowered more\n     * than the maximum amount allowed. The max base fee change (per-block) is derived as\n     *follows: `prevBaseFee / BASE_FEE_MAX_CHANGE_DENOMINATOR`\n     */\n    function echidna_never_exceed_max_decrease() public view returns (bool) {\n        return !failedMaxLowerBaseFeePerBlock;\n    }\n\n    /**\n     * @custom:invariant The `maxBaseFeeChange` calculation over multiple blocks can never\n     * underflow.\n     *\n     * When calculating the `maxBaseFeeChange` after multiple empty blocks, the calculation\n     * should never be allowed to underflow.\n     */\n    function echidna_underflow() public view returns (bool) {\n        return !underflow;\n    }\n}\n"
    },
    "contracts/governance/SecurityCouncilToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport { Semver } from \"../universal/Semver.sol\";\nimport \"../universal/KromaSoulBoundERC721.sol\";\n\n/**\n * @custom:proxied\n * @title SecurityCouncilToken\n * @notice The SecurityCouncilToken is a basic token based on KromaSoulBoundERC721.\n */\ncontract SecurityCouncilToken is KromaSoulBoundERC721, Semver {\n    /**\n     * @custom:semver 0.1.0\n     */\n    constructor() Semver(0, 1, 0) {}\n\n    /**\n     * @notice Initializer.\n     *\n     * @param _owner Owner of this token contract.\n     */\n    function initialize(address _owner) public initializer {\n        __KromaSoulBoundERC721_init(\"KromaSecurityCouncil\", \"KSC\", _owner);\n    }\n\n    // TODO(ayaan): set base URI for security council SBT\n    function _baseURI() internal pure override returns (string memory) {\n        return \"\";\n    }\n}\n"
    },
    "contracts/governance/TimeLock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @title TimeLock\n * @notice The TimeLock is a timelock controller based on OpenZeppelin TimelockController.\n */\ncontract TimeLock is Initializable, TimelockControllerUpgradeable, Semver {\n    /**\n     * @custom:semver 0.1.0\n     */\n    constructor() Semver(0, 1, 0) {}\n\n    /**\n     * @notice Initializer.\n     *\n     * @param _minDelay  Initial minimum delay for operations.\n     * @param _proposers Accounts to be granted proposer and canceller roles.\n     * @param _executors Accounts to be granted executor role.\n     * @param _admin     Optional account to be granted admin role; disable with zero address.\n     */\n    function initialize(\n        uint256 _minDelay,\n        address[] memory _proposers,\n        address[] memory _executors,\n        address _admin\n    ) public initializer {\n        __TimelockController_init(_minDelay, _proposers, _executors, _admin);\n    }\n}\n"
    },
    "contracts/governance/UpgradeGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorCountingSimpleUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @title UpgradeGovernor\n * @notice The UpgradeGovernor is a basic ERC20, ERC721 based DAO using OpenZeppelin Governor.\n */\ncontract UpgradeGovernor is\n    Initializable,\n    GovernorUpgradeable,\n    GovernorSettingsUpgradeable,\n    GovernorCountingSimpleUpgradeable,\n    GovernorVotesUpgradeable,\n    GovernorVotesQuorumFractionUpgradeable,\n    GovernorTimelockControlUpgradeable,\n    Semver\n{\n    /**\n     * @custom:semver 0.1.0\n     */\n    constructor() Semver(0, 1, 0) {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializer.\n     *\n     * @param _token                    Address of the token(ERC20 or ERC721).\n     * @param _timelock                 Address of the timelock controller.\n     * @param _initialVotingDelay       Voting delay.(unit: 1 block = 12 seconds on L1)\n     * @param _initialVotingPeriod      Voting period.(unit: 1 block = 12 seconds on L1)\n     * @param _initialProposalThreshold Proposal threshold.\n     * @param _votesQuorumFraction      Quorum as a fraction of the token's total supply.\n     */\n    function initialize(\n        address _token,\n        address payable _timelock,\n        uint256 _initialVotingDelay,\n        uint256 _initialVotingPeriod,\n        uint256 _initialProposalThreshold,\n        uint256 _votesQuorumFraction\n    ) public initializer {\n        __Governor_init(\"UpgradeGovernor\");\n        __GovernorSettings_init(\n            _initialVotingDelay,\n            _initialVotingPeriod,\n            _initialProposalThreshold\n        );\n        __GovernorCountingSimple_init();\n        __GovernorVotes_init(IVotesUpgradeable(_token));\n        __GovernorVotesQuorumFraction_init(_votesQuorumFraction);\n        __GovernorTimelockControl_init(TimelockControllerUpgradeable(_timelock));\n    }\n\n    // The following functions are overridden cause required by Solidity.\n\n    function votingDelay()\n        public\n        view\n        override(IGovernorUpgradeable, GovernorSettingsUpgradeable)\n        returns (uint256)\n    {\n        return super.votingDelay();\n    }\n\n    function votingPeriod()\n        public\n        view\n        override(IGovernorUpgradeable, GovernorSettingsUpgradeable)\n        returns (uint256)\n    {\n        return super.votingPeriod();\n    }\n\n    function quorum(uint256 blockNumber)\n        public\n        view\n        override(IGovernorUpgradeable, GovernorVotesQuorumFractionUpgradeable)\n        returns (uint256)\n    {\n        return super.quorum(blockNumber);\n    }\n\n    function state(uint256 proposalId)\n        public\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (ProposalState)\n    {\n        return super.state(proposalId);\n    }\n\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public override(GovernorUpgradeable, IGovernorUpgradeable) returns (uint256) {\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    function proposalThreshold()\n        public\n        view\n        override(GovernorUpgradeable, GovernorSettingsUpgradeable)\n        returns (uint256)\n    {\n        return super.proposalThreshold();\n    }\n\n    /**\n     * @notice Returns the full contract version.\n     *\n     * @return contract version as a string.\n     */\n    function version()\n        public\n        view\n        override(IGovernorUpgradeable, GovernorUpgradeable, Semver)\n        returns (string memory)\n    {\n        return Semver.version();\n    }\n\n    function _execute(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) {\n        super._execute(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (uint256) {\n        return super._cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    function _executor()\n        internal\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (address)\n    {\n        return super._executor();\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/libraries/Arithmetic.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SignedMath } from \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport { FixedPointMathLib } from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\n\n/**\n * @title Arithmetic\n * @notice Even more math than before.\n */\nlibrary Arithmetic {\n    /**\n     * @notice Clamps a value between a minimum and maximum.\n     *\n     * @param _value The value to clamp.\n     * @param _min   The minimum value.\n     * @param _max   The maximum value.\n     *\n     * @return The clamped value.\n     */\n    function clamp(\n        int256 _value,\n        int256 _min,\n        int256 _max\n    ) internal pure returns (int256) {\n        return SignedMath.min(SignedMath.max(_value, _min), _max);\n    }\n\n    /**\n     * @notice Clamps a value between a minimum and maximum.\n     *\n     * @param _value The value to clamp.\n     * @param _min   The minimum value.\n     * @param _max   The maximum value.\n     *\n     * @return The clamped value.\n     */\n    function clamp(\n        uint256 _value,\n        uint256 _min,\n        uint256 _max\n    ) internal pure returns (uint256) {\n        return Math.min(Math.max(_value, _min), _max);\n    }\n\n    /**\n     * @notice (c)oefficient (d)enominator (exp)onentiation function.\n     *         Returns the result of: c * (1 - 1/d)^exp.\n     *\n     * @param _coefficient Coefficient of the function.\n     * @param _denominator Fractional denominator.\n     * @param _exponent    Power function exponent.\n     *\n     * @return Result of c * (1 - 1/d)^exp.\n     */\n    function cdexp(\n        int256 _coefficient,\n        int256 _denominator,\n        int256 _exponent\n    ) internal pure returns (int256) {\n        return\n            (_coefficient *\n                (FixedPointMathLib.powWad(1e18 - (1e18 / _denominator), _exponent * 1e18))) / 1e18;\n    }\n}\n"
    },
    "contracts/libraries/Burn.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { SafeCall } from \"./SafeCall.sol\";\n\n/**\n * @title Burn\n * @notice Utilities for burning stuff.\n */\nlibrary Burn {\n    /**\n     * Burns a given amount of ETH.\n     * Note that execution engine of Kroma does not support SELFDESTRUCT opcode, so it sends ETH to zero address.\n     *\n     * @param _amount Amount of ETH to burn.\n     */\n    function eth(uint256 _amount) internal {\n        SafeCall.call(address(0), gasleft(), _amount, \"\");\n    }\n\n    /**\n     * Burns a given amount of gas.\n     *\n     * @param _amount Amount of gas to burn.\n     */\n    function gas(uint256 _amount) internal view {\n        uint256 i = 0;\n        uint256 initialGas = gasleft();\n        while (initialGas - gasleft() < _amount) {\n            ++i;\n        }\n    }\n}\n"
    },
    "contracts/libraries/Bytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Bytes\n * @notice Bytes is a library for manipulating byte arrays.\n */\nlibrary Bytes {\n    /**\n     * @notice Compares two byte arrays by comparing their keccak256 hashes.\n     *\n     * @param _bytes First byte array to compare.\n     * @param _other Second byte array to compare.\n     *\n     * @return True if the two byte arrays are equal, false otherwise.\n     */\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\n        return keccak256(_bytes) == keccak256(_other);\n    }\n}\n"
    },
    "contracts/libraries/Bytes32.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Bytes32\n * @notice Bytes32 is a library for manipulating byte32.\n */\nlibrary Bytes32 {\n    /**\n     * @notice Splits bytes32 to high and low parts.\n     *\n     * @param _bytes Bytes32 to split.\n     *\n     * @return High part of bytes32.\n     * @return Low part of bytes32.\n     */\n    function split(bytes32 _bytes) internal pure returns (bytes32, bytes32) {\n        bytes16 high = bytes16(_bytes);\n        bytes16 low = bytes16(uint128(uint256(_bytes)));\n        return (fromBytes16(high), fromBytes16(low));\n    }\n\n    /**\n     * @notice Converts bytes16 to bytes32.\n     *\n     * @param _bytes Bytes to constrcut to bytes32.\n     *\n     * @return Bytes32 constructed from bytes16.\n     */\n    function fromBytes16(bytes16 _bytes) internal pure returns (bytes32) {\n        return bytes32(uint256(uint128(_bytes)));\n    }\n}\n"
    },
    "contracts/libraries/CodeDeployer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title CodeDeployer\n * @notice CodeDeployer is a library to deploy bytecode.\n */\nlibrary CodeDeployer {\n    function deployCode(bytes memory _code) internal returns (address deployedAddress) {\n        assembly {\n            deployedAddress := create(0, add(_code, 0x20), mload(_code))\n        }\n    }\n}\n"
    },
    "contracts/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\n\n/**\n * @title Constants\n * @notice Constants is a library for storing constants. Simple! Don't put everything in here, just\n *         the stuff used in multiple contracts. Constants that only apply to a single contract\n *         should be defined in that contract instead.\n */\nlibrary Constants {\n    /**\n     * @notice Special address to be used as the tx origin for gas estimation calls in the\n     *         KromaPortal and CrossDomainMessenger calls. You only need to use this address if\n     *         the minimum gas limit specified by the user is not actually enough to execute the\n     *         given message and you're attempting to estimate the actual necessary gas limit. We\n     *         use address(1) because it's the ecrecover precompile and therefore guaranteed to\n     *         never have any code on any EVM chain.\n     */\n    address internal constant ESTIMATION_ADDRESS = address(1);\n\n    /**\n     * @notice Value used for the L2 sender storage slot in both the KromaPortal and the\n     *         CrossDomainMessenger contracts before an actual sender is set. This value is\n     *         non-zero to reduce the gas cost of message passing transactions.\n     */\n    address internal constant DEFAULT_L2_SENDER = 0x000000000000000000000000000000000000dEaD;\n\n    /**\n     * @notice Returns the default values for the ResourceConfig. These are the recommended values\n     *         for a production network.\n     */\n    function DEFAULT_RESOURCE_CONFIG()\n        internal\n        pure\n        returns (ResourceMetering.ResourceConfig memory)\n    {\n        ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({\n            maxResourceLimit: 20_000_000,\n            elasticityMultiplier: 10,\n            baseFeeMaxChangeDenominator: 8,\n            minimumBaseFee: 1 gwei,\n            systemTxMaxGas: 1_000_000,\n            maximumBaseFee: type(uint128).max\n        });\n        return config;\n    }\n\n    /**\n     * @notice The denominator of the validator reward.\n     *         DO NOT change this value if the L2 chain is already operational.\n     */\n    uint256 internal constant VALIDATOR_REWARD_DENOMINATOR = 10000;\n\n    /**\n     * @notice An address that identifies that current submission round is a public round.\n     */\n    address internal constant VALIDATOR_PUBLIC_ROUND_ADDRESS = address(type(uint160).max);\n}\n"
    },
    "contracts/libraries/Encoding.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Hashing } from \"./Hashing.sol\";\nimport { Types } from \"./Types.sol\";\nimport { RLPWriter } from \"./rlp/RLPWriter.sol\";\n\n/**\n * @title Encoding\n * @notice Encoding handles Kroma's various different encoding schemes.\n */\nlibrary Encoding {\n    /**\n     * @notice RLP encodes the L2 transaction that would be generated when a given deposit is sent\n     *         to the L2 system. Useful for searching for a deposit in the L2 system. The\n     *         transaction is prefixed with 0x7e to identify its EIP-2718 type.\n     *\n     * @param _tx User deposit transaction to encode.\n     *\n     * @return RLP encoded L2 deposit transaction.\n     */\n    function encodeDepositTransaction(Types.UserDepositTransaction memory _tx)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes32 source = Hashing.hashDepositSource(_tx.l1BlockHash, _tx.logIndex);\n        bytes[] memory raw = new bytes[](7);\n        raw[0] = RLPWriter.writeBytes(abi.encodePacked(source));\n        raw[1] = RLPWriter.writeAddress(_tx.from);\n        raw[2] = _tx.isCreation ? RLPWriter.writeBytes(\"\") : RLPWriter.writeAddress(_tx.to);\n        raw[3] = RLPWriter.writeUint(_tx.mint);\n        raw[4] = RLPWriter.writeUint(_tx.value);\n        raw[5] = RLPWriter.writeUint(uint256(_tx.gasLimit));\n        raw[6] = RLPWriter.writeBytes(_tx.data);\n        return abi.encodePacked(uint8(0x7e), RLPWriter.writeList(raw));\n    }\n\n    /**\n     * @notice Encodes the cross domain message based on the version that is encoded into the\n     *         message nonce.\n     *\n     * @param _nonce    Message nonce with version encoded into the first two bytes.\n     * @param _sender   Address of the sender of the message.\n     * @param _target   Address of the target of the message.\n     * @param _value    ETH value to send to the target.\n     * @param _gasLimit Gas limit to use for the message.\n     * @param _data     Data to send with the message.\n     *\n     * @return Encoded cross domain message.\n     */\n    function encodeCrossDomainMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes memory) {\n        (, uint16 version) = decodeVersionedNonce(_nonce);\n        if (version == 0) {\n            return encodeCrossDomainMessageV0(_nonce, _sender, _target, _value, _gasLimit, _data);\n        } else {\n            revert(\"Encoding: unknown cross domain message version\");\n        }\n    }\n\n    /**\n     * @notice Encodes a cross domain message based on the V0 (current) encoding.\n     *\n     * @param _nonce    Message nonce.\n     * @param _sender   Address of the sender of the message.\n     * @param _target   Address of the target of the message.\n     * @param _value    ETH value to send to the target.\n     * @param _gasLimit Gas limit to use for the message.\n     * @param _data     Data to send with the message.\n     *\n     * @return Encoded cross domain message.\n     */\n    function encodeCrossDomainMessageV0(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                \"relayMessage(uint256,address,address,uint256,uint256,bytes)\",\n                _nonce,\n                _sender,\n                _target,\n                _value,\n                _gasLimit,\n                _data\n            );\n    }\n\n    /**\n     * @notice Adds a version number into the first two bytes of a message nonce.\n     *\n     * @param _nonce   Message nonce to encode into.\n     * @param _version Version number to encode into the message nonce.\n     *\n     * @return Message nonce with version encoded into the first two bytes.\n     */\n    function encodeVersionedNonce(uint240 _nonce, uint16 _version) internal pure returns (uint256) {\n        uint256 nonce;\n        assembly {\n            nonce := or(shl(240, _version), _nonce)\n        }\n        return nonce;\n    }\n\n    /**\n     * @notice Pulls the version out of a version-encoded nonce.\n     *\n     * @param _nonce Message nonce with version encoded into the first two bytes.\n     *\n     * @return Nonce without encoded version.\n     * @return Version of the message.\n     */\n    function decodeVersionedNonce(uint256 _nonce) internal pure returns (uint240, uint16) {\n        uint240 nonce;\n        uint16 version;\n        assembly {\n            nonce := and(_nonce, 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            version := shr(240, _nonce)\n        }\n        return (nonce, version);\n    }\n}\n"
    },
    "contracts/libraries/Hashing.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Encoding } from \"./Encoding.sol\";\nimport { RLPWriter } from \"./rlp/RLPWriter.sol\";\nimport { Types } from \"./Types.sol\";\n\n/**\n * @title Hashing\n * @notice Hashing handles Kroma's various different hashing schemes.\n */\nlibrary Hashing {\n    /**\n     * @notice Computes the hash of the RLP encoded L2 transaction that would be generated when a\n     *         given deposit is sent to the L2 system. Useful for searching for a deposit in the L2\n     *         system.\n     *\n     * @param _tx User deposit transaction to hash.\n     *\n     * @return Hash of the RLP encoded L2 deposit transaction.\n     */\n    function hashDepositTransaction(Types.UserDepositTransaction memory _tx)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(Encoding.encodeDepositTransaction(_tx));\n    }\n\n    /**\n     * @notice Computes the deposit transaction's \"source hash\", a value that guarantees the hash\n     *         of the L2 transaction that corresponds to a deposit is unique and is\n     *         deterministically generated from L1 transaction data.\n     *\n     * @param _l1BlockHash Hash of the L1 block where the deposit was included.\n     * @param _logIndex    The index of the log that created the deposit transaction.\n     *\n     * @return Hash of the deposit transaction's \"source hash\".\n     */\n    function hashDepositSource(bytes32 _l1BlockHash, uint64 _logIndex)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 depositId = keccak256(abi.encode(_l1BlockHash, _logIndex));\n        return keccak256(abi.encode(bytes32(0), depositId));\n    }\n\n    /**\n     * @notice Hashes the cross domain message based on the version that is encoded into the\n     *         message nonce.\n     *\n     * @param _nonce    Message nonce with version encoded into the first two bytes.\n     * @param _sender   Address of the sender of the message.\n     * @param _target   Address of the target of the message.\n     * @param _value    ETH value to send to the target.\n     * @param _gasLimit Gas limit to use for the message.\n     * @param _data     Data to send with the message.\n     *\n     * @return Hashed cross domain message.\n     */\n    function hashCrossDomainMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes32) {\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\n        if (version == 0) {\n            return hashCrossDomainMessageV0(_nonce, _sender, _target, _value, _gasLimit, _data);\n        } else {\n            revert(\"Hashing: unknown cross domain message version\");\n        }\n    }\n\n    /**\n     * @notice Hashes a cross domain message based on the V0 (current) encoding.\n     *\n     * @param _nonce    Message nonce.\n     * @param _sender   Address of the sender of the message.\n     * @param _target   Address of the target of the message.\n     * @param _value    ETH value to send to the target.\n     * @param _gasLimit Gas limit to use for the message.\n     * @param _data     Data to send with the message.\n     *\n     * @return Hashed cross domain message.\n     */\n    function hashCrossDomainMessageV0(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                Encoding.encodeCrossDomainMessageV0(\n                    _nonce,\n                    _sender,\n                    _target,\n                    _value,\n                    _gasLimit,\n                    _data\n                )\n            );\n    }\n\n    /**\n     * @notice Derives the withdrawal hash according to the encoding in the L2 Withdrawer contract\n     *\n     * @param _tx Withdrawal transaction to hash.\n     *\n     * @return Hashed withdrawal transaction.\n     */\n    function hashWithdrawal(Types.WithdrawalTransaction memory _tx)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(_tx.nonce, _tx.sender, _tx.target, _tx.value, _tx.gasLimit, _tx.data)\n            );\n    }\n\n    /**\n     * @notice Hashes the various elements of an output root proof into an output root hash which\n     *         can be used to check if the proof is valid.\n     *\n     * @param _outputRootProof Output root proof which should be hashed to an output root.\n     *\n     * @return Hashed output root proof.\n     */\n    function hashOutputRootProof(Types.OutputRootProof memory _outputRootProof)\n        internal\n        pure\n        returns (bytes32)\n    {\n        if (_outputRootProof.version == bytes32(uint256(0))) {\n            return hashOutputRootProofV0(_outputRootProof);\n        } else {\n            revert(\"Hashing: unknown output root proof version\");\n        }\n    }\n\n    /**\n     * @notice Hashes the various elements of an output root proof into an output root hash which\n     *         can be used to check if the proof is valid. (version 0)\n     *\n     * @param _outputRootProof Output root proof which should be hashed to an output root.\n     *\n     * @return Hashed output root proof.\n     */\n    function hashOutputRootProofV0(Types.OutputRootProof memory _outputRootProof)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    _outputRootProof.version,\n                    _outputRootProof.stateRoot,\n                    _outputRootProof.messagePasserStorageRoot,\n                    _outputRootProof.blockHash,\n                    _outputRootProof.nextBlockHash\n                )\n            );\n    }\n\n    /**\n     * @notice Fills the values of the block hash fields to a given bytes.\n     *\n     * @param _publicInput Public input which should be hashed to a block hash.\n     * @param _rlps        Pre-RLP encoded data which should be hashed to a block hash.\n     * @param _raw         An array of bytes to be populated.\n     */\n    function _fillBlockHashFieldsToBytes(\n        Types.PublicInput memory _publicInput,\n        Types.BlockHeaderRLP memory _rlps,\n        bytes[] memory _raw\n    ) private pure {\n        _raw[0] = RLPWriter.writeBytes(abi.encodePacked(_publicInput.parentHash));\n        _raw[1] = _rlps.uncleHash;\n        _raw[2] = _rlps.coinbase;\n        _raw[3] = RLPWriter.writeBytes(abi.encodePacked(_publicInput.stateRoot));\n        _raw[4] = RLPWriter.writeBytes(abi.encodePacked(_publicInput.transactionsRoot));\n        _raw[5] = _rlps.receiptsRoot;\n        _raw[6] = _rlps.logsBloom;\n        _raw[7] = _rlps.difficulty;\n        _raw[8] = RLPWriter.writeUint(_publicInput.number);\n        _raw[9] = RLPWriter.writeUint(_publicInput.gasLimit);\n        _raw[10] = _rlps.gasUsed;\n        _raw[11] = RLPWriter.writeUint(_publicInput.timestamp);\n        _raw[12] = _rlps.extraData;\n        _raw[13] = _rlps.mixHash;\n        _raw[14] = _rlps.nonce;\n        _raw[15] = RLPWriter.writeUint(_publicInput.baseFee);\n    }\n\n    /**\n     * @notice Hashes the various elements of a block header into a block hash(before shanghai).\n     *\n     * @param _publicInput Public input which should be hashed to a block hash.\n     * @param _rlps        Pre-RLP encoded data which should be hashed to a block hash.\n     *\n     * @return Hashed block header.\n     */\n    function hashBlockHeader(\n        Types.PublicInput memory _publicInput,\n        Types.BlockHeaderRLP memory _rlps\n    ) internal pure returns (bytes32) {\n        bytes[] memory raw = new bytes[](16);\n        _fillBlockHashFieldsToBytes(_publicInput, _rlps, raw);\n        return keccak256(RLPWriter.writeList(raw));\n    }\n\n    /**\n     * @notice Hashes the various elements of a block header into a block hash(after shanghai).\n     *\n     * @param _publicInput Public input which should be hashed to a block hash.\n     * @param _rlps        Pre-RLP encoded data which should be hashed to a block hash.\n     *\n     * @return Hashed block header.\n     */\n    function hashBlockHeaderShanghai(\n        Types.PublicInput memory _publicInput,\n        Types.BlockHeaderRLP memory _rlps\n    ) internal pure returns (bytes32) {\n        bytes[] memory raw = new bytes[](17);\n        _fillBlockHashFieldsToBytes(_publicInput, _rlps, raw);\n        raw[16] = RLPWriter.writeBytes(abi.encodePacked(_publicInput.withdrawalsRoot));\n        return keccak256(RLPWriter.writeList(raw));\n    }\n\n    /**\n     * @notice Hashes the various elements of a public input into a public input hash.\n     *\n     * @param _prevStateRoot Previous state root.\n     * @param _publicInput   Public input which should be hashed to a public input hash.\n     * @param _dummyHashes   Dummy hashes returned from generateDummyHashes().\n     *\n     * @return Hashed block header.\n     */\n    function hashPublicInput(\n        bytes32 _prevStateRoot,\n        Types.PublicInput memory _publicInput,\n        bytes32[] memory _dummyHashes\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    _prevStateRoot,\n                    _publicInput.stateRoot,\n                    _publicInput.withdrawalsRoot,\n                    _publicInput.blockHash,\n                    _publicInput.parentHash,\n                    _publicInput.number,\n                    _publicInput.timestamp,\n                    _publicInput.baseFee,\n                    _publicInput.gasLimit,\n                    uint16(_publicInput.txHashes.length),\n                    _publicInput.txHashes,\n                    _dummyHashes\n                )\n            );\n    }\n\n    /**\n     * @notice Generates a bytes32 array filled with a dummy hash for the given length.\n     *\n     * @param _dummyHashes Dummy hash.\n     * @param _length      A length of the array.\n     *\n     * @return Bytes32 array filled with dummy hash.\n     */\n    function generateDummyHashes(bytes32 _dummyHashes, uint256 _length)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        bytes32[] memory hashes = new bytes32[](_length);\n        for (uint256 i = 0; i < _length; i++) {\n            hashes[i] = _dummyHashes;\n        }\n        return hashes;\n    }\n}\n"
    },
    "contracts/libraries/NodeReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title NodeReader\n * @notice NodeReader is a library for reading ZKTrie Node.\n */\nlibrary NodeReader {\n    /**\n     * @notice Node types.\n     *         See https://github.com/kroma-network/zktrie/blob/main/types/README.md.\n     *\n     * @custom:value MIDDLE Represents a middle node.\n     * @custom:value LEAF   Represents a leaf node.\n     * @custom:value EMPTY  Represents a empty node.\n     * @custom:value ROOT   Represents a root node.\n     */\n    enum NodeType {\n        MIDDLE,\n        LEAF,\n        EMPTY,\n        ROOT\n    }\n\n    /**\n     * @notice Struct representing a Node.\n     *         See https://github.com/kroma-network/zktrie/blob/main/types/README.md.\n     */\n    struct Node {\n        NodeType nodeType;\n        bytes32 childL;\n        bytes32 childR;\n        bytes32 nodeKey;\n        bytes32[] valuePreimage;\n        uint32 compressedFlags;\n        bytes32 valueHash;\n        bytes32 keyPreimage;\n    }\n\n    /**\n     * @notice Struct representing an Item.\n     */\n    struct Item {\n        bytes ptr;\n        uint256 len;\n    }\n\n    /**\n     * @notice Converts bytes to Item.\n     *\n     * @param _bytes bytes to convert.\n     *\n     * @return Item referencing _bytes.\n     */\n    function toItem(bytes memory _bytes) internal pure returns (Item memory) {\n        bytes memory ptr;\n        assembly {\n            ptr := add(_bytes, 32)\n        }\n        return Item({ ptr: ptr, len: _bytes.length });\n    }\n\n    /**\n     * @notice Reads an Item into an uint8.\n     *         Internal ptr and length is updated automatically.\n     *\n     * @param _item Item to read.\n     *\n     * @return An uint8 value.\n     */\n    function readUint8(Item memory _item) internal pure returns (uint8) {\n        require(_item.len >= 1, \"NodeReader: too short for uint8\");\n        bytes memory newPtr;\n        bytes memory ptr = _item.ptr;\n        uint8 ret;\n        assembly {\n            ret := shr(248, mload(ptr))\n            newPtr := add(ptr, 1)\n        }\n        _item.ptr = newPtr;\n        _item.len -= 1;\n        return ret;\n    }\n\n    /**\n     * @notice Reads an Item into compressed flags and length of values.\n     *         Internal ptr and length is updated automatically.\n     *\n     * @param _item Item to read.\n     *\n     * @return Compressed flags.\n     * @return Length of values.\n     */\n    function readCompressedFlags(Item memory _item) internal pure returns (uint32, uint8) {\n        require(_item.len >= 4, \"NodeReader: too short for uint32\");\n        bytes memory newPtr;\n        bytes memory ptr = _item.ptr;\n        uint32 temp;\n        uint8 flag;\n        uint8 len;\n        assembly {\n            temp := mload(ptr)\n            len := shr(248, temp)\n            flag := shr(240, temp)\n            newPtr := add(ptr, 4)\n        }\n        _item.ptr = newPtr;\n        _item.len -= 4;\n        return (flag, len);\n    }\n\n    /**\n     * @notice Reads an Item into a bytes32.\n     *         Internal ptr and length is updated automatically.\n     *\n     * @param _item Item to read.\n     *\n     * @return A bytes32 value.\n     */\n    function readBytes32(Item memory _item) internal pure returns (bytes32) {\n        require(_item.len >= 32, \"NodeReader: too short for bytes32\");\n        bytes memory newPtr;\n        bytes memory ptr = _item.ptr;\n        bytes32 ret;\n        assembly {\n            ret := mload(ptr)\n            newPtr := add(ptr, 32)\n        }\n        _item.ptr = newPtr;\n        _item.len -= 32;\n        return ret;\n    }\n\n    /**\n     * @notice Reads an Item by n bytes into a bytes32.\n     *         Internal ptr and length is updated automatically.\n     *\n     * @param _item Item to read.\n     *\n     * @return A bytes32 value.\n     */\n    function readBytesN(Item memory _item, uint256 _length) internal pure returns (bytes32) {\n        require(_item.len >= _length, \"NodeReader: too short for n bytes\");\n        bytes memory newPtr;\n        bytes memory ptr = _item.ptr;\n        bytes32 ret;\n        uint256 to = 256 - _length * 8;\n        assembly {\n            newPtr := add(ptr, _length)\n            ret := shr(to, mload(ptr))\n        }\n        _item.ptr = newPtr;\n        _item.len -= _length;\n        return ret;\n    }\n\n    /**\n     * @notice Reads bytes into a Node.\n     *\n     * @param _proof Bytes to read.\n     *\n     * @return A decoded Node.\n     */\n    function readNode(bytes memory _proof) internal pure returns (Node memory) {\n        Node memory node;\n        Item memory item = toItem(_proof);\n        uint256 nodeType = readUint8(item);\n        if (nodeType == uint256(NodeType.MIDDLE)) {\n            // TODO(chokobole): Do the length check as much as possible at once and read the bytes.\n            node.childL = readBytes32(item);\n            node.childR = readBytes32(item);\n        } else if (nodeType == uint256(NodeType.LEAF)) {\n            // TODO(chokobole): Do the length check as much as possible at once and read the bytes.\n            node.nodeKey = readBytes32(item);\n            (uint32 compressedFlags, uint256 valuePreimageLen) = readCompressedFlags(item);\n            require((compressedFlags == 1 && valuePreimageLen == 1) || (compressedFlags == 4 && valuePreimageLen == 4), \"NodeReader: invalid compressedFlags\");\n            node.compressedFlags = compressedFlags;\n            node.valuePreimage = new bytes32[](valuePreimageLen);\n            for (uint256 i = 0; i < valuePreimageLen; ) {\n                node.valuePreimage[i] = readBytes32(item);\n                unchecked {\n                    ++i;\n                }\n            }\n            uint256 keyPreimageLen = readUint8(item);\n            if (keyPreimageLen > 0) {\n                node.keyPreimage = readBytesN(item, keyPreimageLen);\n            }\n        } else if (nodeType == uint256(NodeType.EMPTY)) {\n            // Do nothing.\n        } else if (nodeType == uint256(NodeType.ROOT)) {\n            revert(\"NodeReader: unexpected root node type\");\n        } else {\n            revert(\"NodeReader: invalid node type\");\n        }\n        node.nodeType = NodeType(nodeType);\n        return node;\n    }\n}\n"
    },
    "contracts/libraries/Predeploys.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Predeploys\n * @notice Contains constant addresses for contracts that are pre-deployed to the L2 system.\n */\nlibrary Predeploys {\n    /**\n     * @notice Address of the ProxyAdmin predeploy.\n     */\n    address internal constant PROXY_ADMIN = 0x4200000000000000000000000000000000000000;\n\n    /**\n     * @notice Address of the L1Block predeploy.\n     */\n    address internal constant L1_BLOCK_ATTRIBUTES = 0x4200000000000000000000000000000000000002;\n\n    /**\n     * @notice Address of the L2ToL1MessagePasser predeploy.\n     */\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000003;\n\n    /**\n     * @notice Address of the L2CrossDomainMessenger predeploy.\n     */\n    address internal constant L2_CROSS_DOMAIN_MESSENGER =\n        0x4200000000000000000000000000000000000004;\n\n    /**\n     * @notice Address of the GasPriceOracle predeploy. Includes fee information\n     *         and helpers for computing the L1 portion of the transaction fee.\n     */\n    address internal constant GAS_PRICE_ORACLE = 0x4200000000000000000000000000000000000005;\n\n    /**\n     * @notice Address of the ProtocolVault predeploy.\n     */\n    address internal constant PROTOCOL_VAULT = 0x4200000000000000000000000000000000000006;\n\n    /**\n     * @notice Address of the ProposerRewardVault predeploy.\n     */\n    address internal constant PROPOSER_REWARD_VAULT = 0x4200000000000000000000000000000000000007;\n\n    /**\n     * @notice Address of the ValidatorRewardVault predeploy.\n     */\n    address internal constant VALIDATOR_REWARD_VAULT = 0x4200000000000000000000000000000000000008;\n\n    /**\n     * @notice Address of the L2StandardBridge predeploy.\n     */\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000009;\n\n    /**\n     * @notice Address of the L2ERC721Bridge predeploy.\n     */\n    address internal constant L2_ERC721_BRIDGE = 0x420000000000000000000000000000000000000A;\n\n    /**\n     * @notice Address of the KromaMintableERC20Factory predeploy.\n     */\n    address internal constant KROMA_MINTABLE_ERC20_FACTORY =\n        0x420000000000000000000000000000000000000B;\n\n    /**\n     * @notice Address of the KromaMintableERC721Factory predeploy.\n     */\n    address internal constant KROMA_MINTABLE_ERC721_FACTORY =\n        0x420000000000000000000000000000000000000c;\n}\n"
    },
    "contracts/libraries/SafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title SafeCall\n * @notice Perform low level safe calls\n */\nlibrary SafeCall {\n    /**\n     * @notice Perform a low level call without copying any returndata\n     *\n     * @param _target   Address to call\n     * @param _gas      Amount of gas to pass to the call\n     * @param _value    Amount of value to pass to the call\n     * @param _calldata Calldata to pass to the call\n     */\n    function call(\n        address _target,\n        uint256 _gas,\n        uint256 _value,\n        bytes memory _calldata\n    ) internal returns (bool) {\n        bool _success;\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 32), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n        }\n        return _success;\n    }\n\n    /**\n     * @notice Helper function to determine if there is sufficient gas remaining within the context\n     *         to guarantee that the minimum gas requirement for a call will be met as well as\n     *         optionally reserving a specified amount of gas for after the call has concluded.\n     *\n     * @param _minGas      The minimum amount of gas that may be passed to the target context.\n     * @param _reservedGas Optional amount of gas to reserve for the caller after the execution\n     *                     of the target context.\n     *\n     * @return `true` if there is enough gas remaining to safely supply `_minGas` to the target\n     *         context as well as reserve `_reservedGas` for the caller after the execution of\n     *         the target context.\n     *\n     * @dev !!!!! FOOTGUN ALERT !!!!!\n     *      1.) The 40_000 base buffer is to account for the worst case of the dynamic cost of the\n     *          `CALL` opcode's `address_access_cost`, `positive_value_cost`, and\n     *          `value_to_empty_account_cost` factors with an added buffer of 5,700 gas. It is\n     *          still possible to self-rekt by initiating a withdrawal with a minimum gas limit\n     *          that does not account for the `memory_expansion_cost` & `code_execution_cost`\n     *          factors of the dynamic cost of the `CALL` opcode.\n     *      2.) This function should *directly* precede the external call if possible. There is an\n     *          added buffer to account for gas consumed between this check and the call, but it\n     *          is only 5,700 gas.\n     *      3.) Because EIP-150 ensures that a maximum of 63/64ths of the remaining gas in the call\n     *          frame may be passed to a subcontext, we need to ensure that the gas will not be\n     *          truncated.\n     *      4.) Use wisely. This function is not a silver bullet.\n     */\n    function hasMinGas(uint256 _minGas, uint256 _reservedGas) internal view returns (bool) {\n        bool _hasMinGas;\n        assembly {\n            // Equation: gas × 63 ≥ minGas × 64 + 63(40_000 + reservedGas)\n            _hasMinGas := iszero(\n                lt(mul(gas(), 63), add(mul(_minGas, 64), mul(add(40000, _reservedGas), 63)))\n            )\n        }\n        return _hasMinGas;\n    }\n\n    /**\n     * @notice Perform a low level call without copying any returndata. This function\n     *         will revert if the call cannot be performed with the specified minimum\n     *         gas.\n     *\n     * @param _target   Address to call\n     * @param _minGas   The minimum amount of gas that may be passed to the call\n     * @param _value    Amount of value to pass to the call\n     * @param _calldata Calldata to pass to the call\n     */\n    function callWithMinGas(\n        address _target,\n        uint256 _minGas,\n        uint256 _value,\n        bytes memory _calldata\n    ) internal returns (bool) {\n        bool _success;\n        bool _hasMinGas = hasMinGas(_minGas, 0);\n        assembly {\n            // Assertion: gasleft() >= (_minGas * 64) / 63 + 40_000\n            if iszero(_hasMinGas) {\n                // Store the \"Error(string)\" selector in scratch space.\n                mstore(0, 0x08c379a0)\n                // Store the pointer to the string length in scratch space.\n                mstore(32, 32)\n                // Store the string.\n                //\n                // SAFETY:\n                // - We pad the beginning of the string with two zero bytes as well as the\n                // length (24) to ensure that we override the free memory pointer at offset\n                // 0x40. This is necessary because the free memory pointer is likely to\n                // be greater than 1 byte when this function is called, but it is incredibly\n                // unlikely that it will be greater than 3 bytes. As for the data within\n                // 0x60, it is ensured that it is 0 due to 0x60 being the zero offset.\n                // - It's fine to clobber the free memory pointer, we're reverting.\n                mstore(88, 0x0000185361666543616c6c3a204e6f7420656e6f75676820676173)\n\n                // Revert with 'Error(\"SafeCall: Not enough gas\")'\n                revert(28, 100)\n            }\n\n            // The call will be supplied at least ((_minGas * 64) / 63 + 40_000 - 49) gas due to the\n            // above assertion. This ensures that, in all circumstances (except for when the\n            // `_minGas` does not account for the `memory_expansion_cost` and `code_execution_cost`\n            // factors of the dynamic cost of the `CALL` opcode), the call will receive at least\n            // the minimum amount of gas specified.\n            _success := call(\n                gas(), // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 32), // inloc\n                mload(_calldata), // inlen\n                0x00, // outloc\n                0x00 // outlen\n            )\n        }\n        return _success;\n    }\n}\n"
    },
    "contracts/libraries/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Types\n * @notice Contains various types used throughout the Kroma contract system.\n */\nlibrary Types {\n    /**\n     * @notice CheckpointOutput represents a commitment to the state of L2 checkpoint. The timestamp\n     *         is the L1 timestamp that the output root is posted. This timestamp is used to verify\n     *         that the finalization period has passed since the output root was submitted.\n     *\n     * @custom:field submitter     Address of the output submitter.\n     * @custom:field outputRoot    Hash of the L2 output.\n     * @custom:field timestamp     Timestamp of the L1 block that the output root was submitted in.\n     * @custom:field l2BlockNumber L2 block number that the output corresponds to.\n     */\n    struct CheckpointOutput {\n        address submitter;\n        bytes32 outputRoot;\n        uint128 timestamp;\n        uint128 l2BlockNumber;\n    }\n\n    /**\n     * @notice Struct representing the elements that are hashed together to generate an output root\n     *         which itself represents a snapshot of the L2 state.\n     *\n     * @custom:field version                  Version of the output root.\n     * @custom:field stateRoot                Root of the state trie at the block of this output.\n     * @custom:field messagePasserStorageRoot Root of the message passer storage trie.\n     * @custom:field blockHash                Hash of the block this output was generated from.\n     * @custom:field nextBlockHash            Hash of the next block.\n     */\n    struct OutputRootProof {\n        bytes32 version;\n        bytes32 stateRoot;\n        bytes32 messagePasserStorageRoot;\n        bytes32 blockHash;\n        bytes32 nextBlockHash;\n    }\n\n    /**\n     * @notice Struct representing the elements that are hashed together to generate a public input.\n     *\n     * @custom:field blockHash        The hash of the block.\n     * @custom:field parentHash       The hash of the previous block.\n     * @custom:field timestamp        The block time.\n     * @custom:field number           The block number.\n     * @custom:field gasLimit         Maximum gas allowed.\n     * @custom:field baseFee          The base fee per gas.\n     * @custom:field transactionsRoot Root hash of the transactions.\n     * @custom:field stateRoot        Root hash of the state trie.\n     * @custom:field withdrawalsRoot  Root hash of the withdrawals.\n     * @custom:field txHashes         Array of hash of the transaction.\n     */\n    struct PublicInput {\n        bytes32 blockHash;\n        bytes32 parentHash;\n        uint64 timestamp;\n        uint64 number;\n        uint64 gasLimit;\n        uint256 baseFee;\n        bytes32 transactionsRoot;\n        bytes32 stateRoot;\n        bytes32 withdrawalsRoot;\n        bytes32[] txHashes;\n    }\n\n    /**\n     * @notice Struct representing the elements that are hashed together to generate a block hash.\n     *         Some of fields that are contained in PublicInput are omitted.\n     *\n     * @custom:field uncleHash    RLP encoded uncle hash.\n     * @custom:field coinbase     RLP encoded coinbase.\n     * @custom:field receiptsRoot RLP encoded receipts root.\n     * @custom:field logsBloom    RLP encoded logs bloom.\n     * @custom:field difficulty   RLP encoded difficulty.\n     * @custom:field gasUsed      RLP encoded gas used.\n     * @custom:field extraData    RLP encoded extra data.\n     * @custom:field mixHash      RLP encoded mix hash.\n     * @custom:field nonce        RLP encoded nonce.\n     */\n    struct BlockHeaderRLP {\n        bytes uncleHash;\n        bytes coinbase;\n        bytes receiptsRoot;\n        bytes logsBloom;\n        bytes difficulty;\n        bytes gasUsed;\n        bytes extraData;\n        bytes mixHash;\n        bytes nonce;\n    }\n\n    /**\n     * @notice Struct representing a deposit transaction (L1 => L2 transaction) created by an end\n     *         user (as opposed to a system deposit transaction generated by the system).\n     *\n     * @custom:field from        Address of the sender of the transaction.\n     * @custom:field to          Address of the recipient of the transaction.\n     * @custom:field isCreation  True if the transaction is a contract creation.\n     * @custom:field value       Value to send to the recipient.\n     * @custom:field mint        Amount of ETH to mint.\n     * @custom:field gasLimit    Gas limit of the transaction.\n     * @custom:field data        Data of the transaction.\n     * @custom:field l1BlockHash Hash of the block the transaction was submitted in.\n     * @custom:field logIndex    Index of the log in the block the transaction was submitted in.\n     */\n    struct UserDepositTransaction {\n        address from;\n        address to;\n        bool isCreation;\n        uint256 value;\n        uint256 mint;\n        uint64 gasLimit;\n        bytes data;\n        bytes32 l1BlockHash;\n        uint64 logIndex;\n    }\n\n    /**\n     * @notice Struct representing a withdrawal transaction.\n     *\n     * @custom:field nonce    Nonce of the withdrawal transaction\n     * @custom:field sender   Address of the sender of the transaction.\n     * @custom:field target   Address of the recipient of the transaction.\n     * @custom:field value    Value to send to the recipient.\n     * @custom:field gasLimit Gas limit of the transaction.\n     * @custom:field data     Data of the transaction.\n     */\n    struct WithdrawalTransaction {\n        uint256 nonce;\n        address sender;\n        address target;\n        uint256 value;\n        uint256 gasLimit;\n        bytes data;\n    }\n\n    /**\n     * @notice Struct representing a challenge.\n     *\n     * @custom:field turn       The current turn.\n     * @custom:field timeoutAt  Timeout timestamp of the next turn.\n     * @custom:field asserter   Address of the asserter.\n     * @custom:field challenger Address of the challenger.\n     * @custom:field segments   Array of the segment.\n     * @custom:field segStart   The L2 block number of the first segment.\n     * @custom:field segSize    The number of L2 blocks.\n     */\n    struct Challenge {\n        uint8 turn;\n        uint64 timeoutAt;\n        address asserter;\n        address challenger;\n        bytes32[] segments;\n        uint256 segSize;\n        uint256 segStart;\n    }\n\n    /**\n     * @notice Struct representing a validator's bond.\n     *\n     * @custom:field amount    Amount of the lock.\n     * @custom:field expiresAt The expiration timestamp of bond.\n     */\n    struct Bond {\n        uint128 amount;\n        uint128 expiresAt;\n    }\n\n    /**\n     * @notice Struct representing multisig transaction data.\n     *\n     * @custom:field destination The destination address to run the transaction.\n     * @custom:field executed    Record whether a transaction was executed or not.\n     * @custom:field value       The value passed in while executing the transaction.\n     * @custom:field data        Calldata for transaction.\n     */\n    struct MultiSigTransaction {\n        address destination;\n        bool executed;\n        uint256 value;\n        bytes data;\n    }\n\n    /**\n     * @notice Struct representing the data for verifying the public input.\n     *\n     * @custom:field srcOutputRootProof          Proof of the source output root.\n     * @custom:field dstOutputRootProof          Proof of the destination output root.\n     * @custom:field publicInput                 Ingredients to compute the public input used by ZK proof verification.\n     * @custom:field rlps                        Pre-encoded RLPs to compute the next block hash\n     *                                           of the source output root proof.\n     * @custom:field l2ToL1MessagePasserBalance  Balance of the L2ToL1MessagePasser account.\n     * @custom:field l2ToL1MessagePasserCodeHash Codehash of the L2ToL1MessagePasser account.\n     * @custom:field merkleProof                 Merkle proof of L2ToL1MessagePasser account against the state root.\n     */\n    struct PublicInputProof {\n        OutputRootProof srcOutputRootProof;\n        OutputRootProof dstOutputRootProof;\n        PublicInput publicInput;\n        BlockHeaderRLP rlps;\n        bytes32 l2ToL1MessagePasserBalance;\n        bytes32 l2ToL1MessagePasserCodeHash;\n        bytes[] merkleProof;\n    }\n}\n"
    },
    "contracts/libraries/rlp/RLPWriter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @custom:attribution https://github.com/bakaoh/solidity-rlp-encode\n * @title RLPWriter\n * @author RLPWriter is a library for encoding Solidity types to RLP bytes. Adapted from Bakaoh's\n *         RLPEncode library (https://github.com/bakaoh/solidity-rlp-encode) with minor\n *         modifications to improve legibility.\n */\nlibrary RLPWriter {\n    /**\n     * @notice RLP encodes a byte string.\n     *\n     * @param _in The byte string to encode.\n     *\n     * @return The RLP encoded string in bytes.\n     */\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\n            encoded = _in;\n        } else {\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\n        }\n\n        return encoded;\n    }\n\n    /**\n     * @notice RLP encodes a list of RLP encoded byte byte strings.\n     *\n     * @param _in The list of RLP encoded byte strings.\n     *\n     * @return The RLP encoded list of items in bytes.\n     */\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\n        bytes memory list = _flatten(_in);\n        return abi.encodePacked(_writeLength(list.length, 192), list);\n    }\n\n    /**\n     * @notice RLP encodes a string.\n     *\n     * @param _in The string to encode.\n     *\n     * @return The RLP encoded string in bytes.\n     */\n    function writeString(string memory _in) internal pure returns (bytes memory) {\n        return writeBytes(bytes(_in));\n    }\n\n    /**\n     * @notice RLP encodes an address.\n     *\n     * @param _in The address to encode.\n     *\n     * @return The RLP encoded address in bytes.\n     */\n    function writeAddress(address _in) internal pure returns (bytes memory) {\n        return writeBytes(abi.encodePacked(_in));\n    }\n\n    /**\n     * @notice RLP encodes a uint.\n     *\n     * @param _in The uint256 to encode.\n     *\n     * @return The RLP encoded uint256 in bytes.\n     */\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\n        return writeBytes(_toBinary(_in));\n    }\n\n    /**\n     * @notice RLP encodes a bool.\n     *\n     * @param _in The bool to encode.\n     *\n     * @return The RLP encoded bool in bytes.\n     */\n    function writeBool(bool _in) internal pure returns (bytes memory) {\n        bytes memory encoded = new bytes(1);\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\n        return encoded;\n    }\n\n    /**\n     * @notice Encode the first byte and then the `len` in binary form if `length` is more than 55.\n     *\n     * @param _len    The length of the string or the payload.\n     * @param _offset 128 if item is string, 192 if item is list.\n     *\n     * @return RLP encoded bytes.\n     */\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\n        } else {\n            uint256 lenLen;\n            uint256 i = 1;\n            while (_len / i != 0) {\n                lenLen++;\n                i *= 256;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\n            for (i = 1; i <= lenLen; i++) {\n                encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));\n            }\n        }\n\n        return encoded;\n    }\n\n    /**\n     * @notice Encode integer in big endian binary form with no leading zeroes.\n     *\n     * @param _x The integer to encode.\n     *\n     * @return RLP encoded bytes.\n     */\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\n        bytes memory b = abi.encodePacked(_x);\n\n        uint256 i = 0;\n        for (; i < 32; i++) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n\n        bytes memory res = new bytes(32 - i);\n        for (uint256 j = 0; j < res.length; j++) {\n            res[j] = b[i++];\n        }\n\n        return res;\n    }\n\n    /**\n     * @custom:attribution https://github.com/Arachnid/solidity-stringutils\n     * @notice Copies a piece of memory to another location.\n     *\n     * @param _dest Destination location.\n     * @param _src  Source location.\n     * @param _len  Length of memory to copy.\n     */\n    function _memcpy(\n        uint256 _dest,\n        uint256 _src,\n        uint256 _len\n    ) private pure {\n        uint256 dest = _dest;\n        uint256 src = _src;\n        uint256 len = _len;\n\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        uint256 mask;\n        unchecked {\n            mask = 256**(32 - len) - 1;\n        }\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * @custom:attribution https://github.com/sammayo/solidity-rlp-encoder\n     * @notice Flattens a list of byte strings into one byte string.\n     *\n     * @param _list List of byte strings to flatten.\n     *\n     * @return The flattened byte string.\n     */\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint256 len;\n        uint256 i = 0;\n        for (; i < _list.length; i++) {\n            len += _list[i].length;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint256 flattenedPtr;\n        assembly {\n            flattenedPtr := add(flattened, 0x20)\n        }\n\n        for (i = 0; i < _list.length; i++) {\n            bytes memory item = _list[i];\n\n            uint256 listPtr;\n            assembly {\n                listPtr := add(item, 0x20)\n            }\n\n            _memcpy(flattenedPtr, listPtr, item.length);\n            flattenedPtr += _list[i].length;\n        }\n\n        return flattened;\n    }\n}\n"
    },
    "contracts/test/AddressAliasHelper.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\n\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\n\ncontract AddressAliasHelper_applyAndUndo_Test is Test {\n    /**\n     * @notice Tests that applying and then undoing an alias results in the original address.\n     */\n    function testFuzz_applyAndUndo_succeeds(address _address) external {\n        address aliased = AddressAliasHelper.applyL1ToL2Alias(_address);\n        address unaliased = AddressAliasHelper.undoL1ToL2Alias(aliased);\n        assertEq(_address, unaliased);\n    }\n}\n"
    },
    "contracts/test/BenchmarkTest.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/* Testing utilities */\nimport { Test } from \"forge-std/Test.sol\";\nimport { Vm } from \"forge-std/Vm.sol\";\n\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport \"./CommonTest.t.sol\";\n\n// Free function for setting the prevBaseFee param in the KromaPortal.\nfunction setPrevBaseFee(\n    Vm _vm,\n    address _portal,\n    uint128 _prevBaseFee\n) {\n    _vm.store(address(_portal), bytes32(uint256(1)), bytes32((block.number << 192) | _prevBaseFee));\n}\n\ncontract SetPrevBaseFee_Test is Portal_Initializer {\n    function test_setPrevBaseFee_succeeds() external {\n        setPrevBaseFee(vm, address(portal), 100 gwei);\n        (uint128 prevBaseFee, , uint64 prevBlockNum) = portal.params();\n        assertEq(uint256(prevBaseFee), 100 gwei);\n        assertEq(uint256(prevBlockNum), block.number);\n    }\n}\n\n// Tests for obtaining pure gas cost estimates for commonly used functions.\n// The objective with these benchmarks is to strip down the actual test functions\n// so that they are nothing more than the call we want measure the gas cost of.\n// In order to achieve this we make no assertions, and handle everything else in the setUp()\n// function.\ncontract GasBenchMark_KromaPortal is Portal_Initializer {\n    // Reusable default values for a test withdrawal\n    Types.WithdrawalTransaction _defaultTx;\n\n    uint256 _submittedOutputIndex;\n    uint256 _submittedBlockNumber;\n    bytes[] _withdrawalProof;\n    Types.OutputRootProof internal _outputRootProof;\n    bytes32 _outputRoot;\n\n    // Use a constructor to set the storage vars above, so as to minimize the number of ffi calls.\n    constructor() {\n        super.setUp();\n        _defaultTx = Types.WithdrawalTransaction({\n            nonce: 0,\n            sender: alice,\n            target: bob,\n            value: 100,\n            gasLimit: 100_000,\n            data: hex\"\"\n        });\n\n        // Get withdrawal proof data we can use for testing.\n        bytes32 _storageRoot;\n        bytes32 _stateRoot;\n        (_stateRoot, _storageRoot, _outputRoot, , _withdrawalProof) = ffi\n            .getProveWithdrawalTransactionInputs(_defaultTx);\n\n        // Setup a dummy output root proof for reuse.\n        _outputRootProof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: _stateRoot,\n            messagePasserStorageRoot: _storageRoot,\n            blockHash: bytes32(uint256(0)),\n            nextBlockHash: bytes32(uint256(0))\n        });\n        _submittedBlockNumber = oracle.nextBlockNumber();\n        _submittedOutputIndex = oracle.nextOutputIndex();\n    }\n\n    // Get the system into a nice ready-to-use state.\n    function setUp() public override {\n        // Configure the oracle to return the output root we've prepared.\n        vm.warp(oracle.computeL2Timestamp(_submittedBlockNumber) + 1);\n        vm.prank(trusted);\n        oracle.submitL2Output(_outputRoot, _submittedBlockNumber, 0, 0);\n\n        // Warp beyond the finalization period for the block we've submitted.\n        vm.warp(\n            oracle.getL2Output(_submittedOutputIndex).timestamp +\n                oracle.FINALIZATION_PERIOD_SECONDS() +\n                1\n        );\n\n        // Fund the portal so that we can withdraw ETH.\n        vm.deal(address(portal), 0xFFFFFFFF);\n    }\n\n    function test_depositTransaction_benchmark() external {\n        portal.depositTransaction{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    function test_depositTransaction_benchmark_1() external {\n        setPrevBaseFee(vm, address(portal), 1 gwei);\n        portal.depositTransaction{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    function test_proveWithdrawalTransaction_benchmark() external {\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n}\n\ncontract GasBenchMark_L1CrossDomainMessenger is Messenger_Initializer {\n    function test_sendMessage_benchmark_0() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(portal), 1 gwei);\n        // The amount of data typically sent during a bridge deposit.\n        bytes\n            memory data = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n        vm.resumeGasMetering();\n        L1Messenger.sendMessage(bob, data, uint32(100));\n    }\n\n    function test_sendMessage_benchmark_1() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(portal), 10 gwei);\n        // The amount of data typically sent during a bridge deposit.\n        bytes\n            memory data = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n        vm.resumeGasMetering();\n        L1Messenger.sendMessage(bob, data, uint32(100));\n    }\n}\n\ncontract GasBenchMark_L1StandardBridge_Deposit is Bridge_Initializer {\n    function setUp() public virtual override {\n        super.setUp();\n        deal(address(L1Token), alice, 100000, true);\n        vm.startPrank(alice, alice);\n        L1Token.approve(address(L1Bridge), type(uint256).max);\n    }\n\n    function test_depositETH_benchmark_0() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(portal), 1 gwei);\n        vm.resumeGasMetering();\n        L1Bridge.bridgeETH{ value: 500 }(50000, hex\"\");\n    }\n\n    function test_depositETH_benchmark_1() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(portal), 10 gwei);\n        vm.resumeGasMetering();\n        L1Bridge.bridgeETH{ value: 500 }(50000, hex\"\");\n    }\n\n    function test_depositERC20_benchmark_0() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(portal), 1 gwei);\n        vm.resumeGasMetering();\n        L1Bridge.bridgeERC20({\n            _localToken: address(L1Token),\n            _remoteToken: address(L2Token),\n            _amount: 100,\n            _minGasLimit: 100_000,\n            _extraData: hex\"\"\n        });\n    }\n\n    function test_depositERC20_benchmark_1() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(portal), 10 gwei);\n        vm.resumeGasMetering();\n        L1Bridge.bridgeERC20({\n            _localToken: address(L1Token),\n            _remoteToken: address(L2Token),\n            _amount: 100,\n            _minGasLimit: 100_000,\n            _extraData: hex\"\"\n        });\n    }\n}\n\ncontract GasBenchMark_L1StandardBridge_Finalize is Bridge_Initializer {\n    function setUp() public virtual override {\n        super.setUp();\n        deal(address(L1Token), address(L1Bridge), 100, true);\n        vm.mockCall(\n            address(L1Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.startPrank(address(L1Bridge.MESSENGER()));\n        vm.deal(address(L1Bridge.MESSENGER()), 100);\n    }\n\n    function test_finalizeBridgeETH_benchmark() external {\n        // TODO: Make this more accurate. It is underestimating the cost because it pranks\n        // the call coming from the messenger, which bypasses the portal\n        // and oracle.\n        L1Bridge.finalizeBridgeETH{ value: 100 }(alice, alice, 100, hex\"\");\n    }\n}\n\ncontract GasBenchMark_L2OutputOracle is L2OutputOracle_Initializer {\n    uint256 nextBlockNumber;\n\n    function setUp() public override {\n        super.setUp();\n\n        vm.deal(trusted, requiredBondAmount);\n        vm.prank(trusted);\n        pool.deposit{ value: requiredBondAmount }();\n\n        nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber);\n        vm.startPrank(trusted);\n    }\n\n    function test_submitL2Output_benchmark() external {\n        oracle.submitL2Output(nonZeroHash, nextBlockNumber, 0, 0);\n    }\n}\n"
    },
    "contracts/test/Bytes.t.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\n\nimport { Bytes } from \"../libraries/Bytes.sol\";\n\ncontract Bytes_equal_Test is Test {\n    /**\n     * @notice Manually checks equality of two dynamic `bytes` arrays in memory.\n     *\n     * @param _a The first `bytes` array to compare.\n     * @param _b The second `bytes` array to compare.\n     *\n     * @return True if the two `bytes` arrays are equal in memory.\n     */\n    function manualEq(bytes memory _a, bytes memory _b) internal pure returns (bool) {\n        bool _eq;\n        assembly {\n            _eq := and(\n                // Check if the contents of the two bytes arrays are equal in memory.\n                eq(keccak256(add(0x20, _a), mload(_a)), keccak256(add(0x20, _b), mload(_b))),\n                // Check if the length of the two bytes arrays are equal in memory.\n                // This is redundant given the above check, but included for completeness.\n                eq(mload(_a), mload(_b))\n            )\n        }\n        return _eq;\n    }\n\n    /**\n     * @notice Tests that the `equal` function in the `Bytes` library returns `false` if given two\n     *         non-equal byte arrays.\n     */\n    function testFuzz_equal_notEqual_works(bytes memory _a, bytes memory _b) public {\n        vm.assume(!manualEq(_a, _b));\n        assertFalse(Bytes.equal(_a, _b));\n    }\n\n    /**\n     * @notice Test whether or not the `equal` function in the `Bytes` library is equivalent to\n     *         manually checking equality of the two dynamic `bytes` arrays in memory.\n     */\n    function testDiff_equal_works(bytes memory _a, bytes memory _b) public {\n        assertEq(Bytes.equal(_a, _b), manualEq(_a, _b));\n    }\n}\n"
    },
    "contracts/test/Colosseum.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { Types } from \"../libraries/Types.sol\";\nimport { Colosseum } from \"../L1/Colosseum.sol\";\nimport { Colosseum_Initializer } from \"./CommonTest.t.sol\";\nimport { ColosseumTestData } from \"./testdata/ColosseumTestData.sol\";\nimport { SecurityCouncil } from \"../L1/SecurityCouncil.sol\";\n\n// Test the implementations of the Colosseum\ncontract ColosseumTest is Colosseum_Initializer {\n    uint256 internal targetOutputIndex;\n    mapping(address => bool) internal isChallenger;\n\n    event ReadyToProve(uint256 indexed outputIndex, address indexed challenger);\n\n    function nextSender(Types.Challenge memory _challenge) internal pure returns (address) {\n        return _challenge.turn % 2 == 0 ? _challenge.challenger : _challenge.asserter;\n    }\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        vm.prank(trusted);\n        pool.deposit{ value: trusted.balance }();\n        vm.prank(asserter);\n        pool.deposit{ value: asserter.balance }();\n\n        // Submit genesis output\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        // Roll to after the block number we'll submit\n        warpToSubmitTime(nextBlockNumber);\n        vm.prank(pool.nextValidator());\n        oracle.submitL2Output(bytes32(nextBlockNumber), nextBlockNumber, 0, 0);\n\n        // Submit invalid output\n        nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber);\n        vm.prank(pool.nextValidator());\n        oracle.submitL2Output(keccak256(abi.encode()), nextBlockNumber, 0, 0);\n\n        vm.prank(challenger);\n        pool.deposit{ value: challenger.balance }();\n        isChallenger[challenger] = true;\n\n        targetOutputIndex = oracle.latestOutputIndex();\n    }\n\n    function _getOutputRoot(address _sender, uint256 _blockNumber) private view returns (bytes32) {\n        uint256 targetBlockNumber = ColosseumTestData.INVALID_BLOCK_NUMBER;\n        if (_blockNumber == targetBlockNumber - 1) {\n            return ColosseumTestData.PREV_OUTPUT_ROOT;\n        }\n\n        if (isChallenger[_sender]) {\n            if (_blockNumber == targetBlockNumber) {\n                return ColosseumTestData.TARGET_OUTPUT_ROOT;\n            }\n        } else if (_blockNumber >= targetBlockNumber) {\n            return keccak256(abi.encode(_blockNumber));\n        }\n\n        return bytes32(_blockNumber);\n    }\n\n    function _newSegments(\n        address _sender,\n        uint8 _turn,\n        uint256 _segStart,\n        uint256 _segSize\n    ) private view returns (bytes32[] memory) {\n        uint256 segLen = colosseum.getSegmentsLength(_turn);\n\n        bytes32[] memory arr = new bytes32[](segLen);\n\n        for (uint256 i = 0; i < segLen; i++) {\n            uint256 n = _segStart + i * (_segSize / (segLen - 1));\n            arr[i] = _getOutputRoot(_sender, n);\n        }\n\n        return arr;\n    }\n\n    function _detectFault(Types.Challenge memory _challenge, address _sender)\n        private\n        view\n        returns (uint256)\n    {\n        if (_sender == _challenge.challenger && _sender != nextSender(_challenge)) {\n            return 0;\n        }\n\n        uint256 segLen = colosseum.getSegmentsLength(_challenge.turn);\n        uint256 start = _challenge.segStart;\n        uint256 degree = _challenge.segSize / (segLen - 1);\n        uint256 current = start + degree;\n\n        for (uint256 i = 1; i < segLen; i++) {\n            bytes32 output = _getOutputRoot(_sender, current);\n\n            if (_challenge.segments[i] != output) {\n                return i - 1;\n            }\n\n            current += degree;\n        }\n\n        revert(\"failed to select\");\n    }\n\n    function _newChallenger(string memory name) private returns (address) {\n        address newAddr = makeAddr(name);\n\n        vm.deal(newAddr, 10 ether);\n        vm.prank(newAddr);\n        pool.deposit{ value: newAddr.balance }();\n        isChallenger[newAddr] = true;\n\n        return newAddr;\n    }\n\n    function _createChallenge(uint256 _outputIndex, address _challenger) private {\n        Types.CheckpointOutput memory targetOutput = oracle.getL2Output(_outputIndex);\n        uint256 end = targetOutput.l2BlockNumber;\n        uint256 start = end - oracle.SUBMISSION_INTERVAL();\n\n        assertTrue(\n            _getOutputRoot(targetOutput.submitter, end) != targetOutput.outputRoot,\n            \"not an invalid output\"\n        );\n\n        bytes32[] memory segments = _newSegments(_challenger, 1, start, end - start);\n\n        vm.prank(_challenger);\n        colosseum.createChallenge(_outputIndex, bytes32(0), 0, segments);\n\n        Types.Challenge memory challenge = colosseum.getChallenge(_outputIndex, _challenger);\n\n        assertEq(challenge.asserter, targetOutput.submitter);\n        assertEq(challenge.challenger, _challenger);\n        assertEq(challenge.timeoutAt, block.timestamp + colosseum.BISECTION_TIMEOUT());\n        assertEq(challenge.segments.length, colosseum.getSegmentsLength(1));\n        assertEq(challenge.segStart, start);\n        assertEq(challenge.segSize, end - start);\n        assertEq(challenge.turn, 1);\n    }\n\n    function _bisect(\n        uint256 _outputIndex,\n        address _challenger,\n        address _sender\n    ) private {\n        Types.Challenge memory challenge = colosseum.getChallenge(_outputIndex, _challenger);\n\n        uint256 position = _detectFault(challenge, _sender);\n        uint256 segSize = challenge.segSize / (colosseum.getSegmentsLength(challenge.turn) - 1);\n        uint256 segStart = challenge.segStart + position * segSize;\n\n        bytes32[] memory segments = _newSegments(_sender, challenge.turn + 1, segStart, segSize);\n\n        vm.prank(_sender);\n        // check that ReadyToProve event was emitted on the last bisection.\n        if (challenge.turn + 1 == segmentsLengths.length) {\n            vm.expectEmit(true, true, false, false);\n            emit ReadyToProve(_outputIndex, _challenger);\n        }\n        colosseum.bisect(_outputIndex, challenge.challenger, position, segments);\n\n        Types.Challenge memory newChallenge = colosseum.getChallenge(_outputIndex, _challenger);\n        assertEq(newChallenge.turn, challenge.turn + 1);\n        assertEq(newChallenge.segments.length, segments.length);\n        assertEq(newChallenge.segStart, segStart);\n        assertEq(newChallenge.segSize, segSize);\n    }\n\n    function _proveFault(uint256 _outputIndex, address _challenger) private {\n        // get previous snapshot\n        Types.CheckpointOutput memory prevOutput = oracle.getL2Output(_outputIndex);\n\n        Types.Challenge memory challenge = colosseum.getChallenge(_outputIndex, _challenger);\n\n        uint256 position = _detectFault(challenge, challenge.challenger);\n        _doProveFault(challenge.challenger, _outputIndex, position);\n\n        assertEq(\n            uint256(colosseum.getStatus(_outputIndex, challenge.challenger)),\n            uint256(Colosseum.ChallengeStatus.NONE)\n        );\n\n        Types.CheckpointOutput memory newOutput = oracle.getL2Output(_outputIndex);\n\n        assertEq(newOutput.submitter, _challenger);\n        assertEq(newOutput.outputRoot, bytes32(0));\n        assertEq(prevOutput.timestamp, newOutput.timestamp);\n        assertEq(prevOutput.l2BlockNumber, newOutput.l2BlockNumber);\n    }\n\n    function _doProveFault(\n        address _challenger,\n        uint256 _outputIndex,\n        uint256 _position\n    ) private {\n        (\n            Types.OutputRootProof memory srcOutputRootProof,\n            Types.OutputRootProof memory dstOutputRootProof\n        ) = ColosseumTestData.outputRootProof();\n        Types.PublicInput memory publicInput = ColosseumTestData.publicInput();\n        Types.BlockHeaderRLP memory rlps = ColosseumTestData.blockHeaderRLP();\n\n        ColosseumTestData.ProofPair memory pp = ColosseumTestData.proofAndPair();\n\n        (ColosseumTestData.Account memory account, bytes[] memory merkleProof) = ColosseumTestData\n            .merkleProof();\n\n        Types.PublicInputProof memory proof = Types.PublicInputProof({\n            srcOutputRootProof: srcOutputRootProof,\n            dstOutputRootProof: dstOutputRootProof,\n            publicInput: publicInput,\n            rlps: rlps,\n            l2ToL1MessagePasserBalance: bytes32(account.balance),\n            l2ToL1MessagePasserCodeHash: account.codeHash,\n            merkleProof: merkleProof\n        });\n\n        vm.prank(_challenger);\n        colosseum.proveFault(_outputIndex, _position, proof, pp.proof, pp.pair);\n    }\n\n    function _dismissChallenge(uint256 txId) private {\n        // confirm transaction without check condition\n        vm.prank(securityCouncilOwners[0]);\n        securityCouncil.confirmTransaction(txId);\n\n        vm.prank(securityCouncilOwners[1]);\n        securityCouncil.confirmTransaction(txId);\n    }\n\n    function test_constructor() external {\n        assertEq(address(colosseum.L2_ORACLE()), address(oracle), \"oracle address not matched\");\n        assertEq(\n            address(colosseum.ZK_VERIFIER()),\n            address(zkVerifier),\n            \"zk verifier address not matched\"\n        );\n        assertEq(colosseum.DUMMY_HASH(), DUMMY_HASH);\n        assertEq(colosseum.MAX_TXS(), MAX_TXS);\n        assertEq(colosseum.SECURITY_COUNCIL(), address(securityCouncil));\n    }\n\n    function test_createChallenge_succeeds() external {\n        _createChallenge(targetOutputIndex, challenger);\n    }\n\n    function test_createChallenge_otherChallenger_succeeds() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n\n        address otherChallenger = makeAddr(\"other challenger\");\n\n        vm.deal(otherChallenger, 1 ether);\n        vm.prank(otherChallenger);\n        pool.deposit{ value: requiredBondAmount }();\n\n        _createChallenge(outputIndex, otherChallenger);\n\n        // ensure that both challenges are enabled.\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenger)),\n            uint256(Colosseum.ChallengeStatus.ASSERTER_TURN)\n        );\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, otherChallenger)),\n            uint256(Colosseum.ChallengeStatus.ASSERTER_TURN)\n        );\n    }\n\n    function test_createChallenge_genesisOutput_reverts() external {\n        uint256 segLen = colosseum.getSegmentsLength(1);\n\n        vm.prank(challenger);\n        vm.expectRevert(\"Colosseum: challenge for genesis output is not allowed\");\n        colosseum.createChallenge(0, bytes32(0), 0, new bytes32[](segLen));\n    }\n\n    function test_createChallenge_finalizedOutput_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        Types.CheckpointOutput memory targetOutput = oracle.getL2Output(outputIndex);\n        uint256 segLen = colosseum.getSegmentsLength(1);\n\n        vm.warp(targetOutput.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        vm.prank(challenger);\n        vm.expectRevert(\n            \"Colosseum: cannot progress challenge process about already finalized output\"\n        );\n        colosseum.createChallenge(outputIndex, bytes32(0), 0, new bytes32[](segLen));\n    }\n\n    function test_createChallenge_asAsserter_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        Types.CheckpointOutput memory targetOutput = oracle.getL2Output(outputIndex);\n        uint256 segLen = colosseum.getSegmentsLength(1);\n\n        vm.prank(targetOutput.submitter);\n        vm.expectRevert(\"Colosseum: the asserter and challenger must be different\");\n        colosseum.createChallenge(outputIndex, bytes32(0), 0, new bytes32[](segLen));\n    }\n\n    function test_createChallenge_existedChallenge_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenger)),\n            uint256(Colosseum.ChallengeStatus.ASSERTER_TURN)\n        );\n\n        uint256 segLen = colosseum.getSegmentsLength(1);\n        vm.prank(challenger);\n        vm.expectRevert(\"Colosseum: the challenge for given output index is already in progress\");\n        colosseum.createChallenge(outputIndex, bytes32(0), 0, new bytes32[](segLen));\n    }\n\n    function test_createChallenge_withBadSegments_reverts() external {\n        uint256 latestBlockNumber = oracle.latestBlockNumber();\n        uint256 outputIndex = oracle.getL2OutputIndexAfter(latestBlockNumber);\n        uint256 segLen = colosseum.getSegmentsLength(1);\n\n        vm.startPrank(challenger);\n\n        // invalid segments length\n        vm.expectRevert(\"Colosseum: invalid segments length\");\n        colosseum.createChallenge(outputIndex, bytes32(0), 0, new bytes32[](segLen + 1));\n\n        bytes32[] memory segments = new bytes32[](segLen);\n\n        // invalid output root of the first segment\n        for (uint256 i = 0; i < segments.length; i++) {\n            segments[i] = keccak256(abi.encodePacked(\"wrong hash\", i));\n        }\n        segments[segLen - 1] = oracle.getL2Output(outputIndex).outputRoot;\n        vm.expectRevert(\"Colosseum: the first segment must be matched\");\n        colosseum.createChallenge(outputIndex, bytes32(0), 0, segments);\n\n        // invalid output root of the last segment\n        for (uint256 i = 0; i < segments.length; i++) {\n            segments[i] = keccak256(abi.encodePacked(\"wrong hash\", i));\n        }\n        segments[0] = oracle.getL2Output(outputIndex - 1).outputRoot;\n        segments[segLen - 1] = oracle.getL2Output(outputIndex).outputRoot;\n        vm.expectRevert(\"Colosseum: the last segment must not be matched\");\n        colosseum.createChallenge(outputIndex, bytes32(0), 0, segments);\n\n        vm.stopPrank();\n    }\n\n    function test_createChallenge_notSubmittedOutput_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        uint256 segLen = colosseum.getSegmentsLength(1);\n\n        vm.prank(challenger);\n        vm.expectRevert();\n        colosseum.createChallenge(outputIndex + 1, bytes32(0), 0, new bytes32[](segLen));\n    }\n\n    function test_createChallenge_afterChallengeProven_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        test_proveFault_succeeds();\n\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenger)),\n            uint256(Colosseum.ChallengeStatus.NONE)\n        );\n\n        uint256 segLen = colosseum.getSegmentsLength(1);\n\n        vm.prank(challenger);\n        vm.expectRevert(\"Colosseum: challenge for deleted output is not allowed\");\n        colosseum.createChallenge(outputIndex, bytes32(0), 0, new bytes32[](segLen));\n    }\n\n    function test_createChallenge_afterChallengerTimedOut_succeeds() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n\n        Types.Challenge memory challenge = colosseum.getChallenge(outputIndex, challenger);\n\n        _bisect(outputIndex, challenge.challenger, challenge.asserter);\n        challenge = colosseum.getChallenge(outputIndex, challenge.challenger);\n        vm.warp(challenge.timeoutAt + 1);\n\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenge.challenger)),\n            uint256(Colosseum.ChallengeStatus.CHALLENGER_TIMEOUT)\n        );\n\n        // the asserter calls the challengerTimeout() to close the timed out challenge.\n        vm.prank(challenge.asserter);\n        colosseum.challengerTimeout(outputIndex, challenge.challenger);\n\n        _createChallenge(outputIndex, challenge.challenger);\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenge.challenger)),\n            uint256(Colosseum.ChallengeStatus.ASSERTER_TURN)\n        );\n    }\n\n    function test_createChallenge_afterDismissed_succeeds() external {\n        uint256 outputIndex = targetOutputIndex;\n\n        test_dismissChallenge_succeeds();\n\n        _createChallenge(outputIndex, challenger);\n    }\n\n    function test_createChallenge_afterCreationPeriod_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n\n        Types.CheckpointOutput memory output = oracle.getL2Output(outputIndex);\n        // warp to creation deadline\n        vm.warp(output.timestamp + colosseum.CREATION_PERIOD_SECONDS() + 1);\n\n        bytes32[] memory segments = new bytes32[](0);\n        vm.prank(challenger);\n        vm.expectRevert(\"Colosseum: cannot create a challenge after the creation period\");\n        colosseum.createChallenge(outputIndex, bytes32(0), 0, segments);\n    }\n\n    function test_createChallenge_wrongFork_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        uint256 segLen = colosseum.getSegmentsLength(1);\n\n        vm.prank(challenger);\n        vm.expectRevert(\"Colosseum: block hash does not match the hash at the expected height\");\n        colosseum.createChallenge(\n            outputIndex,\n            bytes32(uint256(0x01)),\n            block.number - 1,\n            new bytes32[](segLen)\n        );\n    }\n\n    function test_bisect_succeeds() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n        Types.Challenge memory challenge = colosseum.getChallenge(outputIndex, challenger);\n\n        assertEq(nextSender(challenge), challenge.asserter);\n\n        _bisect(outputIndex, challenge.challenger, challenge.asserter);\n    }\n\n    function test_bisect_finalizedOutput_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n        Types.Challenge memory challenge = colosseum.getChallenge(outputIndex, challenger);\n\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenger)),\n            uint256(Colosseum.ChallengeStatus.ASSERTER_TURN)\n        );\n\n        Types.CheckpointOutput memory targetOutput = oracle.getL2Output(outputIndex);\n        vm.warp(targetOutput.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        uint256 segLen = colosseum.getSegmentsLength(challenge.turn + 1);\n\n        vm.prank(challenge.asserter);\n        vm.expectRevert(\n            \"Colosseum: cannot progress challenge process about already finalized output\"\n        );\n        colosseum.bisect(outputIndex, challenge.challenger, 0, new bytes32[](segLen));\n    }\n\n    function test_bisect_withBadSegments_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n        Types.Challenge memory challenge = colosseum.getChallenge(outputIndex, challenger);\n\n        assertEq(nextSender(challenge), challenge.asserter);\n\n        uint256 position = _detectFault(challenge, challenge.asserter);\n        uint256 segSize = challenge.segSize / (colosseum.getSegmentsLength(challenge.turn) - 1);\n        uint256 segStart = challenge.segStart + position * segSize;\n\n        bytes32[] memory segments = _newSegments(\n            challenge.asserter,\n            challenge.turn + 1,\n            segStart,\n            segSize\n        );\n\n        vm.startPrank(challenge.asserter);\n\n        // invalid output of the first segment\n        bytes32 firstSegment = segments[0];\n        segments[0] = keccak256(abi.encodePacked(\"wrong hash\", uint256(0)));\n        vm.expectRevert(\"Colosseum: the first segment must be matched\");\n        colosseum.bisect(outputIndex, challenge.challenger, position, segments);\n\n        // invalid output of the last segment\n        segments[0] = firstSegment;\n        segments[segments.length - 1] = challenge.segments[position + 1];\n        vm.expectRevert(\"Colosseum: the last segment must not be matched\");\n        colosseum.bisect(outputIndex, challenge.challenger, position, segments);\n\n        vm.stopPrank();\n    }\n\n    function test_bisect_ifNotYourTurn_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n        Types.Challenge memory challenge = colosseum.getChallenge(outputIndex, challenger);\n\n        assertEq(nextSender(challenge), challenge.asserter);\n\n        uint256 segLen = colosseum.getSegmentsLength(challenge.turn + 1);\n\n        vm.prank(challenge.challenger);\n        vm.expectRevert(\"Colosseum: not your turn\");\n        colosseum.bisect(outputIndex, challenge.challenger, 0, new bytes32[](segLen));\n    }\n\n    function test_bisect_whenAsserterTimedOut_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n        Types.Challenge memory challenge = colosseum.getChallenge(outputIndex, challenger);\n\n        assertEq(nextSender(challenge), challenge.asserter);\n\n        uint256 segLen = colosseum.getSegmentsLength(challenge.turn + 1);\n\n        vm.warp(challenge.timeoutAt + 1);\n        vm.prank(challenge.asserter);\n        vm.expectRevert(\"Colosseum: not your turn\");\n        colosseum.bisect(outputIndex, challenge.challenger, 0, new bytes32[](segLen));\n\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenge.challenger)),\n            uint256(Colosseum.ChallengeStatus.ASSERTER_TIMEOUT)\n        );\n    }\n\n    function test_bisect_whenChallengerTimedOut_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n        Types.Challenge memory challenge = colosseum.getChallenge(outputIndex, challenger);\n\n        assertEq(nextSender(challenge), challenge.asserter);\n\n        _bisect(outputIndex, challenge.challenger, challenge.asserter);\n\n        // update challenge\n        challenge = colosseum.getChallenge(outputIndex, challenge.challenger);\n\n        uint256 segLen = colosseum.getSegmentsLength(challenge.turn + 1);\n\n        vm.warp(challenge.timeoutAt + 1);\n        vm.prank(challenge.challenger);\n        vm.expectRevert(\"Colosseum: not your turn\");\n        colosseum.bisect(outputIndex, challenge.challenger, 0, new bytes32[](segLen));\n\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenger)),\n            uint256(Colosseum.ChallengeStatus.CHALLENGER_TIMEOUT)\n        );\n    }\n\n    function test_bisect_cancelChallenge_succeeds() external {\n        uint256 outputIndex = targetOutputIndex;\n        address otherChallenger = _newChallenger(\"other challenger\");\n\n        _createChallenge(outputIndex, otherChallenger);\n        Types.Challenge memory challenge = colosseum.getChallenge(outputIndex, otherChallenger);\n        // Make it the challenger turn\n        _bisect(outputIndex, otherChallenger, challenge.asserter);\n\n        // The output root of the target output index was replaced by another challenge.\n        test_proveFault_succeeds();\n\n        uint256 prevDeposit = pool.balanceOf(otherChallenger);\n        uint256 pendingBond = pool.getPendingBond(outputIndex, otherChallenger);\n\n        vm.prank(otherChallenger);\n        colosseum.bisect(outputIndex, otherChallenger, 0, new bytes32[](0));\n\n        // Ensure that the challenge has been deleted.\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, otherChallenger)),\n            uint256(Colosseum.ChallengeStatus.NONE)\n        );\n        // Ensure that the pending bond has been refunded.\n        vm.expectRevert(\"ValidatorPool: the pending bond does not exist\");\n        pool.getPendingBond(outputIndex, otherChallenger);\n        assertEq(pool.balanceOf(otherChallenger), prevDeposit + pendingBond);\n    }\n\n    function test_proveFault_succeeds() public {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n        Types.Challenge memory challenge = colosseum.getChallenge(outputIndex, challenger);\n\n        while (colosseum.isAbleToBisect(outputIndex, challenge.challenger)) {\n            challenge = colosseum.getChallenge(outputIndex, challenge.challenger);\n            _bisect(outputIndex, challenge.challenger, nextSender(challenge));\n        }\n\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenger)),\n            uint256(Colosseum.ChallengeStatus.READY_TO_PROVE)\n        );\n\n        _proveFault(outputIndex, challenge.challenger);\n    }\n\n    function test_proveFault_finalizedOutput_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n        Types.Challenge memory challenge = colosseum.getChallenge(outputIndex, challenger);\n\n        while (colosseum.isAbleToBisect(outputIndex, challenge.challenger)) {\n            challenge = colosseum.getChallenge(outputIndex, challenge.challenger);\n            _bisect(outputIndex, challenge.challenger, nextSender(challenge));\n        }\n\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenger)),\n            uint256(Colosseum.ChallengeStatus.READY_TO_PROVE)\n        );\n\n        Types.CheckpointOutput memory targetOutput = oracle.getL2Output(outputIndex);\n        vm.warp(targetOutput.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        vm.expectRevert(\n            \"Colosseum: cannot progress challenge process about already finalized output\"\n        );\n        _doProveFault(challenger, outputIndex, 0);\n    }\n\n    // TODO(pangssu): Testing is impossible in the current state. It must be fixed without fail.\n    // function test_proveFault_whenAsserterTimedOut_succeeds() external {\n    //     uint256 outputIndex = targetOutputIndex;\n    //\n    //     _createChallenge(outputIndex, challenger);\n    //\n    //     Types.Challenge memory challenge = colosseum.getChallenge(outputIndex, challenger);\n    //\n    //     assertEq(nextSender(challenge), challenge.asserter);\n    //\n    //     vm.warp(challenge.timeoutAt + 1);\n    //     // check the asserter timeout\n    //     assertEq(\n    //         uint256(colosseum.getStatus(outputIndex, challenge.challenger)),\n    //         uint256(Colosseum.ChallengeStatus.ASSERTER_TIMEOUT)\n    //     );\n    //\n    //     _proveFault(outputIndex, challenge.challenger);\n    // }\n\n    function test_proveFault_cancelChallenge_succeeds() external {\n        uint256 outputIndex = targetOutputIndex;\n        address otherChallenger = _newChallenger(\"other challenger\");\n\n        _createChallenge(outputIndex, otherChallenger);\n        Types.Challenge memory challenge = colosseum.getChallenge(outputIndex, otherChallenger);\n        while (colosseum.isAbleToBisect(outputIndex, otherChallenger)) {\n            challenge = colosseum.getChallenge(outputIndex, otherChallenger);\n            _bisect(outputIndex, otherChallenger, nextSender(challenge));\n        }\n\n        // The output root of the target output index was replaced by another challenge.\n        test_proveFault_succeeds();\n\n        uint256 prevDeposit = pool.balanceOf(otherChallenger);\n        uint256 pendingBond = pool.getPendingBond(outputIndex, otherChallenger);\n        Types.PublicInputProof memory _emptyProof;\n\n        vm.prank(otherChallenger);\n        colosseum.proveFault(outputIndex, 0, _emptyProof, new uint256[](0), new uint256[](0));\n\n        // Ensure that the challenge has been deleted.\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, otherChallenger)),\n            uint256(Colosseum.ChallengeStatus.NONE)\n        );\n        // Ensure that the pending bond has been refunded.\n        vm.expectRevert(\"ValidatorPool: the pending bond does not exist\");\n        pool.getPendingBond(outputIndex, otherChallenger);\n        assertEq(pool.balanceOf(otherChallenger), prevDeposit + pendingBond);\n    }\n\n    function test_dismissChallenge_succeeds() public {\n        uint256 outputIndex = targetOutputIndex;\n        Types.CheckpointOutput memory output = oracle.getL2Output(outputIndex);\n\n        test_proveFault_succeeds();\n        Types.CheckpointOutput memory newOutput = oracle.getL2Output(outputIndex);\n\n        vm.prank(address(securityCouncil));\n        colosseum.dismissChallenge(\n            outputIndex,\n            newOutput.submitter,\n            output.submitter,\n            output.outputRoot,\n            bytes32(0)\n        );\n    }\n\n    function test_dismissChallenge_notSecurityCouncil_reverts() external {\n        test_proveFault_succeeds();\n\n        vm.prank(makeAddr(\"not_security_council\"));\n        vm.expectRevert(\"Colosseum: sender is not the security council\");\n        colosseum.dismissChallenge(0, address(0), address(0), bytes32(0), bytes32(0));\n    }\n\n    function test_dismissChallenge_outputNotDeleted_reverts() external {\n        vm.prank(address(securityCouncil));\n        vm.expectRevert(\"Colosseum: cannot rollback output to zero hash\");\n        colosseum.dismissChallenge(0, address(0), address(0), bytes32(0), bytes32(0));\n    }\n\n    function test_challengerTimeout_succeeds() public {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n        Types.Challenge memory challenge = colosseum.getChallenge(outputIndex, challenger);\n\n        assertEq(nextSender(challenge), challenge.asserter);\n\n        _bisect(outputIndex, challenge.challenger, challenge.asserter);\n\n        challenge = colosseum.getChallenge(outputIndex, challenge.challenger);\n        vm.warp(challenge.timeoutAt + 1);\n        // check the challenger timeout\n        assertEq(nextSender(challenge), challenge.challenger);\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenge.challenger)),\n            uint256(Colosseum.ChallengeStatus.CHALLENGER_TIMEOUT)\n        );\n\n        vm.prank(challenge.asserter);\n        colosseum.challengerTimeout(outputIndex, challenge.challenger);\n    }\n\n    function test_challengerNotCloseWhenAsserterTimeout_succeeds() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n        Types.Challenge memory challenge = colosseum.getChallenge(outputIndex, challenger);\n\n        assertEq(nextSender(challenge), challenge.asserter);\n\n        vm.warp(challenge.timeoutAt + 1);\n        // check the asserter timeout\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenge.challenger)),\n            uint256(Colosseum.ChallengeStatus.ASSERTER_TIMEOUT)\n        );\n        // then challenger do not anything\n\n        vm.warp(challenge.timeoutAt + colosseum.PROVING_TIMEOUT() + 1);\n        // check the challenger timeout\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenge.challenger)),\n            uint256(Colosseum.ChallengeStatus.CHALLENGER_TIMEOUT)\n        );\n    }\n\n    function test_cancelChallenge_succeeds() external {\n        uint256 outputIndex = targetOutputIndex;\n        address otherChallenger = _newChallenger(\"other challenger\");\n\n        _createChallenge(outputIndex, otherChallenger);\n\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, otherChallenger)),\n            uint256(Colosseum.ChallengeStatus.ASSERTER_TURN)\n        );\n\n        // The output root of the target output index was replaced by another challenge.\n        test_proveFault_succeeds();\n\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, otherChallenger)),\n            uint256(Colosseum.ChallengeStatus.ASSERTER_TURN)\n        );\n\n        uint256 prevDeposit = pool.balanceOf(otherChallenger);\n        uint256 pendingBond = pool.getPendingBond(outputIndex, otherChallenger);\n\n        vm.prank(otherChallenger);\n        colosseum.cancelChallenge(outputIndex);\n\n        // Ensure that the pending bond has been refunded.\n        vm.expectRevert(\"ValidatorPool: the pending bond does not exist\");\n        pool.getPendingBond(outputIndex, otherChallenger);\n        assertEq(pool.balanceOf(otherChallenger), prevDeposit + pendingBond);\n    }\n\n    function test_cancelChallenge_noChallenge_reverts() external {\n        vm.expectRevert(\"Colosseum: the challenge does not exist\");\n        colosseum.cancelChallenge(0);\n    }\n\n    function test_cancelChallenge_outputNotDeleted_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n\n        _createChallenge(outputIndex, challenger);\n\n        vm.prank(challenger);\n        vm.expectRevert(\"Colosseum: challenge cannot be cancelled\");\n        colosseum.cancelChallenge(outputIndex);\n    }\n\n    function test_cancelChallenge_senderNotChallenger_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        address otherChallenger = _newChallenger(\"other challenger\");\n\n        _createChallenge(outputIndex, otherChallenger);\n\n        // The output root of the target output index was replaced by another challenge.\n        test_proveFault_succeeds();\n\n        vm.prank(challenger);\n        vm.expectRevert(\"Colosseum: the challenge does not exist\");\n        colosseum.cancelChallenge(outputIndex);\n    }\n\n    function test_cancelChallenge_whenChallengerTimedOut_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        address otherChallenger = _newChallenger(\"other challenger\");\n\n        _createChallenge(outputIndex, otherChallenger);\n        Types.Challenge memory challenge = colosseum.getChallenge(outputIndex, otherChallenger);\n        _bisect(outputIndex, otherChallenger, challenge.asserter);\n\n        vm.warp(challenge.timeoutAt + 1);\n        // The output root of the target output index was replaced by another challenge.\n        test_proveFault_succeeds();\n\n        vm.prank(otherChallenger);\n        vm.expectRevert(\"Colosseum: challenge cannot be cancelled if challenger timed out\");\n        colosseum.cancelChallenge(outputIndex);\n    }\n\n    function test_forceDeleteOutput_succeeds() external {\n        uint256 outputIndex = targetOutputIndex;\n\n        _createChallenge(outputIndex, challenger);\n\n        Types.Challenge memory challenge = colosseum.getChallenge(outputIndex, challenger);\n\n        while (colosseum.isAbleToBisect(outputIndex, challenge.challenger)) {\n            challenge = colosseum.getChallenge(outputIndex, challenge.challenger);\n            _bisect(outputIndex, challenge.challenger, nextSender(challenge));\n        }\n\n        vm.prank(address(securityCouncil));\n        colosseum.forceDeleteOutput(outputIndex);\n    }\n\n    function test_forceDeleteOutput_notSecurityCouncil_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n\n        vm.prank(address(1));\n        vm.expectRevert(\"Colosseum: sender is not the security council\");\n        colosseum.forceDeleteOutput(outputIndex);\n    }\n\n    function test_forceDeleteOutput_finalizedOutput_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n\n        _createChallenge(outputIndex, challenger);\n\n        Types.Challenge memory challenge = colosseum.getChallenge(outputIndex, challenger);\n\n        while (colosseum.isAbleToBisect(outputIndex, challenge.challenger)) {\n            challenge = colosseum.getChallenge(outputIndex, challenge.challenger);\n            _bisect(outputIndex, challenge.challenger, nextSender(challenge));\n        }\n\n        vm.warp(oracle.finalizedAt(outputIndex) + 1);\n\n        vm.prank(address(securityCouncil));\n        vm.expectRevert(\n            \"Colosseum: cannot progress challenge process about already finalized output\"\n        );\n        colosseum.forceDeleteOutput(outputIndex);\n    }\n\n    function test_forceDeleteOutput_alreadyDeletedOutput_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n\n        _createChallenge(outputIndex, challenger);\n\n        Types.Challenge memory challenge = colosseum.getChallenge(outputIndex, challenger);\n\n        while (colosseum.isAbleToBisect(outputIndex, challenge.challenger)) {\n            challenge = colosseum.getChallenge(outputIndex, challenge.challenger);\n            _bisect(outputIndex, challenge.challenger, nextSender(challenge));\n        }\n\n        vm.prank(address(securityCouncil));\n        colosseum.forceDeleteOutput(outputIndex);\n\n        vm.prank(address(securityCouncil));\n        vm.expectRevert(\"Colosseum: the output has already been deleted\");\n        colosseum.forceDeleteOutput(outputIndex);\n    }\n\n    function test_isInCreationPeriod_succeeds() external {\n        uint256 outputIndex = targetOutputIndex;\n\n        assertEq(colosseum.isInCreationPeriod(outputIndex), true);\n\n        Types.CheckpointOutput memory output = oracle.getL2Output(outputIndex);\n        vm.warp(output.timestamp + colosseum.CREATION_PERIOD_SECONDS() + 1);\n\n        assertEq(colosseum.isInCreationPeriod(outputIndex), false);\n    }\n}\n"
    },
    "contracts/test/CommonTest.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/* Testing utilities */\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { Test, StdUtils } from \"forge-std/Test.sol\";\n\nimport { SecurityCouncilToken } from \"../governance/SecurityCouncilToken.sol\";\nimport { TimeLock } from \"../governance/TimeLock.sol\";\nimport { UpgradeGovernor } from \"../governance/UpgradeGovernor.sol\";\nimport { Colosseum } from \"../L1/Colosseum.sol\";\nimport { KromaPortal } from \"../L1/KromaPortal.sol\";\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\nimport { L1ERC721Bridge } from \"../L1/L1ERC721Bridge.sol\";\nimport { L1StandardBridge } from \"../L1/L1StandardBridge.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { SecurityCouncil } from \"../L1/SecurityCouncil.sol\";\nimport { ValidatorPool } from \"../L1/ValidatorPool.sol\";\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { SystemConfig } from \"../L1/SystemConfig.sol\";\nimport { ZKMerkleTrie } from \"../L1/ZKMerkleTrie.sol\";\nimport { ZKVerifier } from \"../L1/ZKVerifier.sol\";\nimport { L2CrossDomainMessenger } from \"../L2/L2CrossDomainMessenger.sol\";\nimport { L2ERC721Bridge } from \"../L2/L2ERC721Bridge.sol\";\nimport { L2StandardBridge } from \"../L2/L2StandardBridge.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { CodeDeployer } from \"../libraries/CodeDeployer.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { KromaMintableERC20 } from \"../universal/KromaMintableERC20.sol\";\nimport { KromaMintableERC20Factory } from \"../universal/KromaMintableERC20Factory.sol\";\nimport { KromaMintableERC721Factory } from \"../universal/KromaMintableERC721Factory.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { ProxyAdmin } from \"../universal/ProxyAdmin.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\n\ncontract CommonTest is Test {\n    address alice = address(128);\n    address bob = address(256);\n    address multisig = address(512);\n\n    address immutable ZERO_ADDRESS = address(0);\n    address immutable NON_ZERO_ADDRESS = address(1);\n    uint256 immutable NON_ZERO_VALUE = 100;\n    uint256 immutable ZERO_VALUE = 0;\n    uint64 immutable NON_ZERO_GASLIMIT = 50000;\n    bytes32 nonZeroHash = keccak256(abi.encode(\"NON_ZERO\"));\n    bytes NON_ZERO_DATA = hex\"0000111122223333444455556666777788889999aaaabbbbccccddddeeeeffff0000\";\n\n    uint256 constant MAX_OUTPUT_ROOT_PROOF_VERSION = 0;\n\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 indexed version,\n        bytes opaqueData\n    );\n\n    FFIInterface ffi;\n\n    function setUp() public virtual {\n        // Give alice and bob some ETH\n        vm.deal(alice, 1 << 16);\n        vm.deal(bob, 1 << 16);\n        vm.deal(multisig, 1 << 16);\n\n        vm.label(alice, \"alice\");\n        vm.label(bob, \"bob\");\n        vm.label(multisig, \"multisig\");\n\n        // Make sure we have a non-zero base fee\n        vm.fee(1000000000);\n\n        ffi = new FFIInterface();\n    }\n\n    function emitTransactionDeposited(\n        address _from,\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    ) internal {\n        emit TransactionDeposited(\n            _from,\n            _to,\n            0,\n            abi.encodePacked(_mint, _value, _gasLimit, _isCreation, _data)\n        );\n    }\n}\n\ncontract L2OutputOracle_Initializer is CommonTest {\n    // Test target\n    ValidatorPool pool;\n    ValidatorPool poolImpl;\n    L2OutputOracle oracle;\n    L2OutputOracle oracleImpl;\n    Colosseum colosseum;\n    SystemConfig systemConfig;\n\n    L2ToL1MessagePasser messagePasser =\n        L2ToL1MessagePasser(payable(Predeploys.L2_TO_L1_MESSAGE_PASSER));\n\n    // Constructor arguments\n    uint256 internal submissionInterval = 1800;\n    uint256 internal l2BlockTime = 2;\n    uint256 internal startingBlockNumber = 10;\n    uint256 internal startingTimestamp = 1000;\n    address internal guardian = 0x000000000000000000000000000000000000AaaD;\n\n    // ValidatorPool constructor arguments\n    address internal trusted = 0x000000000000000000000000000000000000aaaa;\n    uint256 internal requiredBondAmount = 0.1 ether;\n    uint256 internal maxUnbond = 2;\n    uint256 internal roundDuration = (submissionInterval * l2BlockTime) / 2;\n\n    // Test data\n    address internal asserter = 0x000000000000000000000000000000000000aAaB;\n    address internal challenger = 0x000000000000000000000000000000000000AAaC;\n    uint256 initL1Time;\n\n    event OutputSubmitted(\n        bytes32 indexed outputRoot,\n        uint256 indexed l2OutputIndex,\n        uint256 indexed l2BlockNumber,\n        uint256 l1Timestamp\n    );\n\n    event OutputReplaced(uint256 indexed outputIndex, bytes32 newOutputRoot);\n\n    // Advance the evm's time to meet the L2OutputOracle's requirements for submitL2Output\n    function warpToSubmitTime(uint256 _nextBlockNumber) public {\n        vm.warp(oracle.computeL2Timestamp(_nextBlockNumber + 1));\n    }\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        vm.deal(trusted, requiredBondAmount * 10);\n        vm.deal(asserter, requiredBondAmount * 10);\n        vm.deal(challenger, requiredBondAmount * 10);\n\n        // Deploy proxies\n        pool = ValidatorPool(address(new Proxy(multisig)));\n        vm.label(address(pool), \"ValidatorPool\");\n        oracle = L2OutputOracle(address(new Proxy(multisig)));\n        vm.label(address(oracle), \"L2OutputOracle\");\n\n        ResourceMetering.ResourceConfig memory config = Constants.DEFAULT_RESOURCE_CONFIG();\n        systemConfig = new SystemConfig({\n            _owner: address(1),\n            _overhead: 0,\n            _scalar: 10000,\n            _batcherHash: bytes32(0),\n            _gasLimit: 30_000_000,\n            _unsafeBlockSigner: address(0),\n            _config: config,\n            _validatorRewardScalar: 5000\n        });\n\n        // Mock KromaPortal\n        KromaPortal mockPortal = new KromaPortal({\n            _l2Oracle: oracle,\n            _validatorPool: address(pool),\n            _guardian: guardian,\n            _paused: false,\n            _config: systemConfig,\n            _zkMerkleTrie: ZKMerkleTrie(address(0))\n        });\n\n        // Deploy the ValidatorPool\n        poolImpl = new ValidatorPool({\n            _l2OutputOracle: oracle,\n            _portal: mockPortal,\n            _securityCouncil: guardian,\n            _trustedValidator: trusted,\n            _requiredBondAmount: requiredBondAmount,\n            _maxUnbond: maxUnbond,\n            _roundDuration: roundDuration\n        });\n\n        // By default the first block has timestamp and number zero, which will cause underflows in\n        // the tests, so we'll move forward to these block values.\n        initL1Time = startingTimestamp + 1;\n        vm.warp(initL1Time);\n        vm.roll(startingBlockNumber);\n        // Deploy the L2OutputOracle\n        oracleImpl = new L2OutputOracle({\n            _validatorPool: pool,\n            _colosseum: address(colosseum),\n            _submissionInterval: submissionInterval,\n            _l2BlockTime: l2BlockTime,\n            _startingBlockNumber: startingBlockNumber,\n            _startingTimestamp: startingTimestamp,\n            _finalizationPeriodSeconds: 7 days\n        });\n\n        vm.prank(multisig);\n        Proxy(payable(address(pool))).upgradeToAndCall(\n            address(poolImpl),\n            abi.encodeWithSelector(ValidatorPool.initialize.selector, false)\n        );\n\n        vm.prank(multisig);\n        Proxy(payable(address(oracle))).upgradeToAndCall(\n            address(oracleImpl),\n            abi.encodeCall(L2OutputOracle.initialize, (startingBlockNumber, startingTimestamp))\n        );\n\n        // Set the L2ToL1MessagePasser at the correct address\n        vm.etch(Predeploys.L2_TO_L1_MESSAGE_PASSER, address(new L2ToL1MessagePasser()).code);\n\n        vm.label(Predeploys.L2_TO_L1_MESSAGE_PASSER, \"L2ToL1MessagePasser\");\n    }\n}\n\ncontract Poseidon2Deployer {\n    bytes constant poseidon2Code =\n        //solhint-disable-next-line max-line-length\n        hex\"38600c60003961260f6000f37c010000000000000000000000000000000000000000000000000000000060003504806329a5f2f6149063299e566014176200003757fe5b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b6020527f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e06040527f2b90bba00fca0589f617e7dcbfe82e0df706ab640ceb247b791a93b74e36736d6060527f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd7716080527f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2360a0527f101071f0032379b697315876690f053d148d4e109f5fb065c8aacc55a0f89bfa60c0527f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a760e0527f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee2911610100527f19a3fc0a56702bf417ba7fee3802593fa644470307043f7773279cd71d25d5e0610120527f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000016024356004356000837f0ee9a592ba9a9518d05986d656f40c2114c4993c11bb29938d21d47304cd8e6e82089050837f00f1445235f2148c5986587169fc1bcd887b08d4d00868df5696fff40956e86483089150837f08dff3487e8ac99e1f29a058d0fa80b930c728730b7ab36ce879f3890ecf73f58408925083818180828009800909905083828180828009800909915083838180828009800909925062000249600052620025ba565b837f2f27be690fdaee46c3ce28f7532b13c856c35342c84bda6e20966310fadc01d082089050837f2b2ae1acf68b7b8d2416bebf3d4f6234b763fe04b8043ee48b8327bebca16cf283089150837f0319d062072bef7ecca5eac06f97d4d55952c175ab6b03eae64b44c7dbf11cfa84089250838181808280098009099050838281808280098009099150838381808280098009099250620002ec600052620025ba565b837f28813dcaebaeaa828a376df87af4a63bc8b7bf27ad49c6298ef7b387bf28526d82089050837f2727673b2ccbc903f181bf38e1c1d40d2033865200c352bc150928adddf9cb7883089150837f234ec45ca27727c2e74abd2b2a1494cd6efbd43e340587d6b8fb9e31e65cc632840892508381818082800980090990508382818082800980090991508383818082800980090992506200038f600052620025ba565b837f15b52534031ae18f7f862cb2cf7cf760ab10a8150a337b1ccd99ff6e8797d42882089050837f0dc8fad6d9e4b35f5ed9a3d186b79ce38e0e8a8d1b58b132d701d4eecf68d1f683089150837f1bcd95ffc211fbca600f705fad3fb567ea4eb378f62e1fec97805518a47e4d9c8408925083818180828009800909905083828180828009800909915083838180828009800909925062000432600052620025ba565b837f10520b0ab721cadfe9eff81b016fc34dc76da36c2578937817cb978d069de55982089050837f1f6d48149b8e7f7d9b257d8ed5fbbaf42932498075fed0ace88a9eb81f5627f683089150837f1d9655f652309014d29e00ef35a2089bfff8dc1c816f0dc9ca34bdb5460c870584089250838181808280098009099050620004bd600052620025ba565b837f04df5a56ff95bcafb051f7b1cd43a99ba731ff67e47032058fe3d4185697cc7d82089050837f0672d995f8fff640151b3d290cedaf148690a10a8c8424a7f6ec282b6e4be82883089150837f099952b414884454b21200d7ffafdd5f0c9a9dcc06f2708e9fc1d8209b5c75b98408925083818180828009800909905062000548600052620025ba565b837f052cba2255dfd00c7c483143ba8d469448e43586a9b4cd9183fd0e843a6b9fa682089050837f0b8badee690adb8eb0bd74712b7999af82de55707251ad7716077cb93c464ddc83089150837f119b1590f13307af5a1ee651020c07c749c15d60683a8050b963d0a8e4b2bdd184089250838181808280098009099050620005d3600052620025ba565b837f03150b7cd6d5d17b2529d36be0f67b832c4acfc884ef4ee5ce15be0bfb4a8d0982089050837f2cc6182c5e14546e3cf1951f173912355374efb83d80898abe69cb317c9ea56583089150837f005032551e6378c450cfe129a404b3764218cadedac14e2b92d2cd73111bf0f9840892508381818082800980090990506200065e600052620025ba565b837f233237e3289baa34bb147e972ebcb9516469c399fcc069fb88f9da2cc28276b582089050837f05c8f4f4ebd4a6e3c980d31674bfbe6323037f21b34ae5a4e80c2d4c24d6028083089150837f0a7b1db13042d396ba05d818a319f25252bcf35ef3aeed91ee1f09b2590fc65b84089250838181808280098009099050620006e9600052620025ba565b837f2a73b71f9b210cf5b14296572c9d32dbf156e2b086ff47dc5df542365a404ec082089050837f1ac9b0417abcc9a1935107e9ffc91dc3ec18f2c4dbe7f22976a760bb5c50c46083089150837f12c0339ae08374823fabb076707ef479269f3e4d6cb104349015ee046dc93fc08408925083818180828009800909905062000774600052620025ba565b837f0b7475b102a165ad7f5b18db4e1e704f52900aa3253baac68246682e56e9a28e82089050837f037c2849e191ca3edb1c5e49f6e8b8917c843e379366f2ea32ab3aa88d7f844883089150837f05a6811f8556f014e92674661e217e9bd5206c5c93a07dc145fdb176a716346f84089250838181808280098009099050620007ff600052620025ba565b837f29a795e7d98028946e947b75d54e9f044076e87a7b2883b47b675ef5f38bd66e82089050837f20439a0c84b322eb45a3857afc18f5826e8c7382c8a1585c507be199981fd22f83089150837f2e0ba8d94d9ecf4a94ec2050c7371ff1bb50f27799a84b6d4a2a6f2a0982c887840892508381818082800980090990506200088a600052620025ba565b837f143fd115ce08fb27ca38eb7cce822b4517822cd2109048d2e6d0ddcca17d71c882089050837f0c64cbecb1c734b857968dbbdcf813cdf8611659323dbcbfc84323623be9caf183089150837f028a305847c683f646fca925c163ff5ae74f348d62c2b670f1426cef9403da538408925083818180828009800909905062000915600052620025ba565b837f2e4ef510ff0b6fda5fa940ab4c4380f26a6bcb64d89427b824d6755b5db9e30c82089050837f0081c95bc43384e663d79270c956ce3b8925b4f6d033b078b96384f50579400e83089150837f2ed5f0c91cbd9749187e2fade687e05ee2491b349c039a0bba8a9f4023a0bb3884089250838181808280098009099050620009a0600052620025ba565b837f30509991f88da3504bbf374ed5aae2f03448a22c76234c8c990f01f33a73520682089050837f1c3f20fd55409a53221b7c4d49a356b9f0a1119fb2067b41a7529094424ec6ad83089150837f10b4e7f3ab5df003049514459b6e18eec46bb2213e8e131e170887b47ddcb96c8408925083818180828009800909905062000a2b600052620025ba565b837f2a1982979c3ff7f43ddd543d891c2abddd80f804c077d775039aa3502e43adef82089050837f1c74ee64f15e1db6feddbead56d6d55dba431ebc396c9af95cad0f1315bd5c9183089150837f07533ec850ba7f98eab9303cace01b4b9e4f2e8b82708cfa9c2fe45a0ae146a08408925083818180828009800909905062000ab6600052620025ba565b837f21576b438e500449a151e4eeaf17b154285c68f42d42c1808a11abf3764c075082089050837f2f17c0559b8fe79608ad5ca193d62f10bce8384c815f0906743d6930836d4a9e83089150837f2d477e3862d07708a79e8aae946170bc9775a4201318474ae665b0b1b7e2730e8408925083818180828009800909905062000b41600052620025ba565b837f162f5243967064c390e095577984f291afba2266c38f5abcd89be0f5b2747eab82089050837f2b4cb233ede9ba48264ecd2c8ae50d1ad7a8596a87f29f8a7777a7009239331183089150837f2c8fbcb2dd8573dc1dbaf8f4622854776db2eece6d85c4cf4254e7c35e03b07a8408925083818180828009800909905062000bcc600052620025ba565b837f1d6f347725e4816af2ff453f0cd56b199e1b61e9f601e9ade5e88db870949da982089050837f204b0c397f4ebe71ebc2d8b3df5b913df9e6ac02b68d31324cd49af5c456552983089150837f0c4cb9dc3c4fd8174f1149b3c63c3c2f9ecb827cd7dc25534ff8fb75bc79c5028408925083818180828009800909905062000c57600052620025ba565b837f174ad61a1448c899a25416474f4930301e5c49475279e0639a616ddc45bc7b5482089050837f1a96177bcf4d8d89f759df4ec2f3cde2eaaa28c177cc0fa13a9816d49a38d2ef83089150837f066d04b24331d71cd0ef8054bc60c4ff05202c126a233c1a8242ace360b8a30a8408925083818180828009800909905062000ce2600052620025ba565b837f2a4c4fc6ec0b0cf52195782871c6dd3b381cc65f72e02ad527037a62aa1bd80482089050837f13ab2d136ccf37d447e9f2e14a7cedc95e727f8446f6d9d7e55afc01219fd64983089150837f1121552fca26061619d24d843dc82769c1b04fcec26f55194c2e3e869acc6a9a8408925083818180828009800909905062000d6d600052620025ba565b837f00ef653322b13d6c889bc81715c37d77a6cd267d595c4a8909a5546c7c97cff182089050837f0e25483e45a665208b261d8ba74051e6400c776d652595d9845aca35d8a397d383089150837f29f536dcb9dd7682245264659e15d88e395ac3d4dde92d8c46448db979eeba898408925083818180828009800909905062000df8600052620025ba565b837f2a56ef9f2c53febadfda33575dbdbd885a124e2780bbea170e456baace0fa5be82089050837f1c8361c78eb5cf5decfb7a2d17b5c409f2ae2999a46762e8ee416240a8cb9af183089150837f151aff5f38b20a0fc0473089aaf0206b83e8e68a764507bfd3d0ab4be74319c58408925083818180828009800909905062000e83600052620025ba565b837f04c6187e41ed881dc1b239c88f7f9d43a9f52fc8c8b6cdd1e76e47615b51f10082089050837f13b37bd80f4d27fb10d84331f6fb6d534b81c61ed15776449e801b7ddc9c296783089150837f01a5c536273c2d9df578bfbd32c17b7a2ce3664c2a52032c9321ceb1c4e8a8e48408925083818180828009800909905062000f0e600052620025ba565b837f2ab3561834ca73835ad05f5d7acb950b4a9a2c666b9726da832239065b7c3b0282089050837f1d4d8ec291e720db200fe6d686c0d613acaf6af4e95d3bf69f7ed516a597b64683089150837f041294d2cc484d228f5784fe7919fd2bb925351240a04b711514c9c80b65af1d8408925083818180828009800909905062000f99600052620025ba565b837f154ac98e01708c611c4fa715991f004898f57939d126e392042971dd90e81fc682089050837f0b339d8acca7d4f83eedd84093aef51050b3684c88f8b0b04524563bc6ea4da483089150837f0955e49e6610c94254a4f84cfbab344598f0e71eaff4a7dd81ed95b50839c82e8408925083818180828009800909905062001024600052620025ba565b837f06746a6156eba54426b9e22206f15abca9a6f41e6f535c6f3525401ea065462682089050837f0f18f5a0ecd1423c496f3820c549c27838e5790e2bd0a196ac917c7ff32077fb83089150837f04f6eeca1751f7308ac59eff5beb261e4bb563583ede7bc92a738223d6f76e1384089250838181808280098009099050620010af600052620025ba565b837f2b56973364c4c4f5c1a3ec4da3cdce038811eb116fb3e45bc1768d26fc0b375882089050837f123769dd49d5b054dcd76b89804b1bcb8e1392b385716a5d83feb65d437f29ef83089150837f2147b424fc48c80a88ee52b91169aacea989f6446471150994257b2fb01c63e9840892508381818082800980090990506200113a600052620025ba565b837f0fdc1f58548b85701a6c5505ea332a29647e6f34ad4243c2ea54ad897cebe54d82089050837f12373a8251fea004df68abcf0f7786d4bceff28c5dbbe0c3944f685cc0a0b1f283089150837f21e4f4ea5f35f85bad7ea52ff742c9e8a642756b6af44203dd8a1f35c1a9003584089250838181808280098009099050620011c5600052620025ba565b837f16243916d69d2ca3dfb4722224d4c462b57366492f45e90d8a81934f1bc3b14782089050837f1efbe46dd7a578b4f66f9adbc88b4378abc21566e1a0453ca13a4159cac04ac283089150837f07ea5e8537cf5dd08886020e23a7f387d468d5525be66f853b672cc96a88969a8408925083818180828009800909905062001250600052620025ba565b837f05a8c4f9968b8aa3b7b478a30f9a5b63650f19a75e7ce11ca9fe16c0b76c00bc82089050837f20f057712cc21654fbfe59bd345e8dac3f7818c701b9c7882d9d57b72a32e83f83089150837f04a12ededa9dfd689672f8c67fee31636dcd8e88d01d49019bd90b33eb33db6984089250838181808280098009099050620012db600052620025ba565b837f27e88d8c15f37dcee44f1e5425a51decbd136ce5091a6767e49ec9544ccd101a82089050837f2feed17b84285ed9b8a5c8c5e95a41f66e096619a7703223176c41ee433de4d183089150837f1ed7cc76edf45c7c404241420f729cf394e5942911312a0d6972b8bd53aff2b88408925083818180828009800909905062001366600052620025ba565b837f15742e99b9bfa323157ff8c586f5660eac6783476144cdcadf2874be45466b1a82089050837f1aac285387f65e82c895fc6887ddf40577107454c6ec0317284f033f27d0c78583089150837f25851c3c845d4790f9ddadbdb6057357832e2e7a49775f71ec75a96554d67c7784089250838181808280098009099050620013f1600052620025ba565b837f15a5821565cc2ec2ce78457db197edf353b7ebba2c5523370ddccc3d9f146a6782089050837f2411d57a4813b9980efa7e31a1db5966dcf64f36044277502f15485f28c7172783089150837f002e6f8d6520cd4713e335b8c0b6d2e647e9a98e12f4cd2558828b5ef6cb4c9b840892508381818082800980090990506200147c600052620025ba565b837f2ff7bc8f4380cde997da00b616b0fcd1af8f0e91e2fe1ed7398834609e0315d282089050837f00b9831b948525595ee02724471bcd182e9521f6b7bb68f1e93be4febb0d3cbe83089150837f0a2f53768b8ebf6a86913b0e57c04e011ca408648a4743a87d77adbf0c9c35128408925083818180828009800909905062001507600052620025ba565b837f00248156142fd0373a479f91ff239e960f599ff7e94be69b7f2a290305e1198d82089050837f171d5620b87bfb1328cf8c02ab3f0c9a397196aa6a542c2350eb512a2b2bcda983089150837f170a4f55536f7dc970087c7c10d6fad760c952172dd54dd99d1045e4ec34a8088408925083818180828009800909905062001592600052620025ba565b837f29aba33f799fe66c2ef3134aea04336ecc37e38c1cd211ba482eca17e2dbfae182089050837f1e9bc179a4fdd758fdd1bb1945088d47e70d114a03f6a0e8b5ba650369e6497383089150837f1dd269799b660fad58f7f4892dfb0b5afeaad869a9c4b44f9c9e1c43bdaf8f09840892508381818082800980090990506200161d600052620025ba565b837f22cdbc8b70117ad1401181d02e15459e7ccd426fe869c7c95d1dd2cb0f24af3882089050837f0ef042e454771c533a9f57a55c503fcefd3150f52ed94a7cd5ba93b9c7dacefd83089150837f11609e06ad6c8fe2f287f3036037e8851318e8b08a0359a03b304ffca62e828484089250838181808280098009099050620016a8600052620025ba565b837f1166d9e554616dba9e753eea427c17b7fecd58c076dfe42708b08f5b783aa9af82089050837f2de52989431a859593413026354413db177fbf4cd2ac0b56f855a888357ee46683089150837f3006eb4ffc7a85819a6da492f3a8ac1df51aee5b17b8e89d74bf01cf5f71e9ad8408925083818180828009800909905062001733600052620025ba565b837f2af41fbb61ba8a80fdcf6fff9e3f6f422993fe8f0a4639f962344c822514508682089050837f119e684de476155fe5a6b41a8ebc85db8718ab27889e85e781b214bace4827c383089150837f1835b786e2e8925e188bea59ae363537b51248c23828f047cff784b97b3fd80084089250838181808280098009099050620017be600052620025ba565b837f28201a34c594dfa34d794996c6433a20d152bac2a7905c926c40e285ab32eeb682089050837f083efd7a27d1751094e80fefaf78b000864c82eb571187724a761f88c22cc4e783089150837f0b6f88a3577199526158e61ceea27be811c16df7774dd8519e079564f61fd13b8408925083818180828009800909905062001849600052620025ba565b837f0ec868e6d15e51d9644f66e1d6471a94589511ca00d29e1014390e6ee4254f5b82089050837f2af33e3f866771271ac0c9b3ed2e1142ecd3e74b939cd40d00d937ab84c9859183089150837f0b520211f904b5e7d09b5d961c6ace7734568c547dd6858b364ce5e47951f17884089250838181808280098009099050620018d4600052620025ba565b837f0b2d722d0919a1aad8db58f10062a92ea0c56ac4270e822cca228620188a1d4082089050837f1f790d4d7f8cf094d980ceb37c2453e957b54a9991ca38bbe0061d1ed6e562d483089150837f0171eb95dfbf7d1eaea97cd385f780150885c16235a2a6a8da92ceb01e504233840892508381818082800980090990506200195f600052620025ba565b837f0c2d0e3b5fd57549329bf6885da66b9b790b40defd2c8650762305381b16887382089050837f1162fb28689c27154e5a8228b4e72b377cbcafa589e283c35d3803054407a18d83089150837f2f1459b65dee441b64ad386a91e8310f282c5a92a89e19921623ef8249711bc084089250838181808280098009099050620019ea600052620025ba565b837f1e6ff3216b688c3d996d74367d5cd4c1bc489d46754eb712c243f70d1b53cfbb82089050837f01ca8be73832b8d0681487d27d157802d741a6f36cdc2a0576881f932647887583089150837f1f7735706ffe9fc586f976d5bdf223dc680286080b10cea00b9b5de315f9650e8408925083818180828009800909905062001a75600052620025ba565b837f2522b60f4ea3307640a0c2dce041fba921ac10a3d5f096ef4745ca838285f01982089050837f23f0bee001b1029d5255075ddc957f833418cad4f52b6c3f8ce16c235572575b83089150837f2bc1ae8b8ddbb81fcaac2d44555ed5685d142633e9df905f66d9401093082d598408925083818180828009800909905062001b00600052620025ba565b837f0f9406b8296564a37304507b8dba3ed162371273a07b1fc98011fcd6ad72205f82089050837f2360a8eb0cc7defa67b72998de90714e17e75b174a52ee4acb126c8cd995f0a883089150837f15871a5cddead976804c803cbaef255eb4815a5e96df8b006dcbbc2767f889488408925083818180828009800909905062001b8b600052620025ba565b837f193a56766998ee9e0a8652dd2f3b1da0362f4f54f72379544f957ccdeefb420f82089050837f2a394a43934f86982f9be56ff4fab1703b2e63c8ad334834e4309805e777ae0f83089150837f1859954cfeb8695f3e8b635dcb345192892cd11223443ba7b4166e8876c0d1428408925083818180828009800909905062001c16600052620025ba565b837f04e1181763050e58013444dbcb99f1902b11bc25d90bbdca408d3819f4fed32b82089050837f0fdb253dee83869d40c335ea64de8c5bb10eb82db08b5e8b1f5e5552bfd05f2383089150837f058cbe8a9a5027bdaa4efb623adead6275f08686f1c08984a9d7c5bae9b4f1c08408925083818180828009800909905062001ca1600052620025ba565b837f1382edce9971e186497eadb1aeb1f52b23b4b83bef023ab0d15228b4cceca59a82089050837f03464990f045c6ee0819ca51fd11b0be7f61b8eb99f14b77e1e6634601d9e8b583089150837f23f7bfc8720dc296fff33b41f98ff83c6fcab4605db2eb5aaa5bc137aeb70a588408925083818180828009800909905062001d2c600052620025ba565b837f0a59a158e3eec2117e6e94e7f0e9decf18c3ffd5e1531a9219636158bbaf62f282089050837f06ec54c80381c052b58bf23b312ffd3ce2c4eba065420af8f4c23ed0075fd07b83089150837f118872dc832e0eb5476b56648e867ec8b09340f7a7bcb1b4962f0ff9ed1f9d018408925083818180828009800909905062001db7600052620025ba565b837f13d69fa127d834165ad5c7cba7ad59ed52e0b0f0e42d7fea95e1906b520921b182089050837f169a177f63ea681270b1c6877a73d21bde143942fb71dc55fd8a49f19f10c77b83089150837f04ef51591c6ead97ef42f287adce40d93abeb032b922f66ffb7e9a5a7450544d8408925083818180828009800909905062001e42600052620025ba565b837f256e175a1dc079390ecd7ca703fb2e3b19ec61805d4f03ced5f45ee6dd0f69ec82089050837f30102d28636abd5fe5f2af412ff6004f75cc360d3205dd2da002813d3e2ceeb283089150837f10998e42dfcd3bbf1c0714bc73eb1bf40443a3fa99bef4a31fd31be182fcc7928408925083818180828009800909905062001ecd600052620025ba565b837f193edd8e9fcf3d7625fa7d24b598a1d89f3362eaf4d582efecad76f879e3686082089050837f18168afd34f2d915d0368ce80b7b3347d1c7a561ce611425f2664d7aa51f0b5d83089150837f29383c01ebd3b6ab0c017656ebe658b6a328ec77bc33626e29e2e95b33ea61118408925083818180828009800909905062001f58600052620025ba565b837f10646d2f2603de39a1f4ae5e7771a64a702db6e86fb76ab600bf573f9010c71182089050837f0beb5e07d1b27145f575f1395a55bf132f90c25b40da7b3864d0242dcb1117fb83089150837f16d685252078c133dc0d3ecad62b5c8830f95bb2e54b59abdffbf018d96fa3368408925083818180828009800909905062001fe3600052620025ba565b837f0a6abd1d833938f33c74154e0404b4b40a555bbbec21ddfafd672dd62047f01a82089050837f1a679f5d36eb7b5c8ea12a4c2dedc8feb12dffeec450317270a6f19b34cf186083089150837f0980fb233bd456c23974d50e0ebfde4726a423eada4e8f6ffbc7592e3f1b93d6840892508381818082800980090990506200206e600052620025ba565b837f161b42232e61b84cbf1810af93a38fc0cece3d5628c9282003ebacb5c312c72b82089050837f0ada10a90c7f0520950f7d47a60d5e6a493f09787f1564e5d09203db47de1a0b83089150837f1a730d372310ba82320345a29ac4238ed3f07a8a2b4e121bb50ddb9af407f45184089250838181808280098009099050620020f9600052620025ba565b837f2c8120f268ef054f817064c369dda7ea908377feaba5c4dffbda10ef58e8c55682089050837f1c7c8824f758753fa57c00789c684217b930e95313bcb73e6e7b8649a4968f7083089150837f2cd9ed31f5f8691c8e39e4077a74faa0f400ad8b491eb3f7b47b27fa3fd1cf778408925083818180828009800909905062002184600052620025ba565b837f23ff4f9d46813457cf60d92f57618399a5e022ac321ca550854ae23918a22eea82089050837f09945a5d147a4f66ceece6405dddd9d0af5a2c5103529407dff1ea58f180426d83089150837f188d9c528025d4c2b67660c6b771b90f7c7da6eaa29d3f268a6dd223ec6fc630840892508381818082800980090990506200220f600052620025ba565b837f3050e37996596b7f81f68311431d8734dba7d926d3633595e0c0d8ddf4f0f47f82089050837f15af1169396830a91600ca8102c35c426ceae5461e3f95d89d829518d30afd7883089150837f1da6d09885432ea9a06d9f37f873d985dae933e351466b2904284da3320d8acc840892508381818082800980090990506200229a600052620025ba565b837f2796ea90d269af29f5f8acf33921124e4e4fad3dbe658945e546ee411ddaa9cb82089050837f202d7dd1da0f6b4b0325c8b3307742f01e15612ec8e9304a7cb0319e01d32d6083089150837f096d6790d05bb759156a952ba263d672a2d7f9c788f4c831a29dace4c0f8be5f8408925083818180828009800909905062002325600052620025ba565b837f054efa1f65b0fce283808965275d877b438da23ce5b13e1963798cb1447d25a482089050837f1b162f83d917e93edb3308c29802deb9d8aa690113b2e14864ccf6e18e4165f183089150837f21e5241e12564dd6fd9f1cdd2a0de39eedfefc1466cc568ec5ceb745a0506edc84089250838181808280098009099050838281808280098009099150838381808280098009099250620023c8600052620025ba565b837f1cfb5662e8cf5ac9226a80ee17b36abecb73ab5f87e161927b4349e10e4bdf0882089050837f0f21177e302a771bbae6d8d1ecb373b62c99af346220ac0129c53f666eb2410083089150837f1671522374606992affb0dd7f71b12bec4236aede6290546bcef7e1f515c2320840892508381818082800980090990508382818082800980090991508383818082800980090992506200246b600052620025ba565b837f0fa3ec5b9488259c2eb4cf24501bfad9be2ec9e42c5cc8ccd419d2a692cad87082089050837f193c0e04e0bd298357cb266c1506080ed36edce85c648cc085e8c57b1ab54bba83089150837f102adf8ef74735a27e9128306dcbc3c99f6f7291cd406578ce14ea2adaba68f8840892508381818082800980090990508382818082800980090991508383818082800980090992506200250e600052620025ba565b837f0fe0af7858e49859e2a54d6f1ad945b1316aa24bfbdd23ae40a6d0cb70c3eab182089050837f216f6717bbc7dedb08536a2220843f4e2da5f1daa9ebdefde8a5ea7344798d2283089150837f1da55cc900f0d21f4a3e694391918a1b3c23b2ac773c6b3ef88e2e422832516184089250838181808280098009099050838281808280098009099150838381808280098009099250620025b1600052620025ba565b60005260206000f35b8360205182098460405184098591088460605185098591088460805183098560a05185098691088560c05186098691088560e0518409866101005186098791088661012051870987910894509250905060005156\";\n\n    function deployPoseidon2() public returns (address) {\n        return CodeDeployer.deployCode(poseidon2Code);\n    }\n}\n\ncontract Portal_Initializer is L2OutputOracle_Initializer, Poseidon2Deployer {\n    ZKMerkleTrie zkMerkleTrie;\n\n    // Test target\n    KromaPortal portalImpl;\n    KromaPortal portal;\n\n    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);\n    event WithdrawalProven(\n        bytes32 indexed withdrawalHash,\n        address indexed from,\n        address indexed to\n    );\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        vm.deal(trusted, requiredBondAmount * 100);\n        vm.prank(trusted);\n        pool.deposit{ value: trusted.balance }();\n\n        zkMerkleTrie = new ZKMerkleTrie(deployPoseidon2());\n\n        portalImpl = new KromaPortal({\n            _l2Oracle: oracle,\n            _validatorPool: address(pool),\n            _guardian: guardian,\n            _paused: true,\n            _config: systemConfig,\n            _zkMerkleTrie: zkMerkleTrie\n        });\n        Proxy proxy = new Proxy(multisig);\n        vm.prank(multisig);\n        proxy.upgradeToAndCall(\n            address(portalImpl),\n            abi.encodeWithSelector(KromaPortal.initialize.selector, false)\n        );\n        portal = KromaPortal(payable(address(proxy)));\n        vm.label(address(portal), \"KromaPortal\");\n    }\n}\n\ncontract Messenger_Initializer is Portal_Initializer {\n    L1CrossDomainMessenger L1Messenger;\n    L2CrossDomainMessenger L2Messenger =\n        L2CrossDomainMessenger(Predeploys.L2_CROSS_DOMAIN_MESSENGER);\n\n    event SentMessage(\n        address indexed target,\n        address indexed sender,\n        uint256 value,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n\n    event MessagePassed(\n        uint256 indexed nonce,\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes data,\n        bytes32 withdrawalHash\n    );\n\n    event RelayedMessage(bytes32 indexed msgHash);\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 mint,\n        uint256 value,\n        uint64 gasLimit,\n        bool isCreation,\n        bytes data\n    );\n\n    event WhatHappened(bool success, bytes returndata);\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        // Setup implementation\n        L1CrossDomainMessenger L1MessengerImpl = new L1CrossDomainMessenger(portal);\n\n        // Setup proxy\n        Proxy proxy = new Proxy(multisig);\n        vm.prank(multisig);\n        proxy.upgradeToAndCall(\n            address(L1MessengerImpl),\n            abi.encodeCall(L1Messenger.initialize, ())\n        );\n        L1Messenger = L1CrossDomainMessenger(address(proxy));\n\n        vm.etch(\n            Predeploys.L2_CROSS_DOMAIN_MESSENGER,\n            address(new L2CrossDomainMessenger(address(L1Messenger))).code\n        );\n\n        L2Messenger.initialize();\n\n        // Label addresses\n        vm.label(address(L1MessengerImpl), \"L1CrossDomainMessenger_Impl\");\n        vm.label(Predeploys.L2_CROSS_DOMAIN_MESSENGER, \"L2CrossDomainMessenger\");\n\n        vm.label(\n            AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)),\n            \"L1CrossDomainMessenger_aliased\"\n        );\n    }\n}\n\ncontract Bridge_Initializer is Messenger_Initializer {\n    L1StandardBridge L1Bridge;\n    L2StandardBridge L2Bridge;\n    KromaMintableERC20Factory L2TokenFactory;\n    KromaMintableERC20Factory L1TokenFactory;\n    ERC20 L1Token;\n    ERC20 BadL1Token;\n    KromaMintableERC20 L2Token;\n    ERC20 NativeL2Token;\n    ERC20 BadL2Token;\n    KromaMintableERC20 RemoteL1Token;\n\n    event DepositFailed(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    event ETHBridgeInitiated(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    event ETHBridgeFinalized(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    event ERC20BridgeInitiated(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    event ERC20BridgeFinalized(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        vm.label(Predeploys.L2_STANDARD_BRIDGE, \"L2StandardBridge\");\n        vm.label(Predeploys.KROMA_MINTABLE_ERC20_FACTORY, \"KromaMintableERC20Factory\");\n\n        // Deploy the L1 bridge and initialize it with the address of the\n        // L1CrossDomainMessenger\n        L1StandardBridge L1Bridge_Impl = new L1StandardBridge(payable(address(L1Messenger)));\n        Proxy proxy = new Proxy(multisig);\n        vm.prank(multisig);\n        proxy.upgradeTo(address(L1Bridge_Impl));\n\n        L1Bridge = L1StandardBridge(payable(address(proxy)));\n\n        vm.label(address(proxy), \"L1StandardBridge_Proxy\");\n        vm.label(address(L1Bridge_Impl), \"L1StandardBridge_Impl\");\n\n        // Deploy the L2StandardBridge, move it to the correct predeploy\n        // address and then initialize it\n        L2StandardBridge l2B = new L2StandardBridge(payable(proxy));\n        vm.etch(Predeploys.L2_STANDARD_BRIDGE, address(l2B).code);\n        L2Bridge = L2StandardBridge(payable(Predeploys.L2_STANDARD_BRIDGE));\n\n        // Set up the L2 mintable token factory\n        KromaMintableERC20Factory factory = new KromaMintableERC20Factory(\n            Predeploys.L2_STANDARD_BRIDGE\n        );\n        vm.etch(Predeploys.KROMA_MINTABLE_ERC20_FACTORY, address(factory).code);\n        L2TokenFactory = KromaMintableERC20Factory(Predeploys.KROMA_MINTABLE_ERC20_FACTORY);\n\n        L1Token = new ERC20(\"Native L1 Token\", \"L1T\");\n\n        // Deploy the L2 ERC20 now\n        L2Token = KromaMintableERC20(\n            L2TokenFactory.createKromaMintableERC20(\n                address(L1Token),\n                string(abi.encodePacked(\"L2-\", L1Token.name())),\n                string(abi.encodePacked(\"L2-\", L1Token.symbol()))\n            )\n        );\n\n        BadL2Token = KromaMintableERC20(\n            L2TokenFactory.createKromaMintableERC20(\n                address(1),\n                string(abi.encodePacked(\"L2-\", L1Token.name())),\n                string(abi.encodePacked(\"L2-\", L1Token.symbol()))\n            )\n        );\n\n        NativeL2Token = new ERC20(\"Native L2 Token\", \"L2T\");\n        L1TokenFactory = new KromaMintableERC20Factory(address(L1Bridge));\n\n        RemoteL1Token = KromaMintableERC20(\n            L1TokenFactory.createKromaMintableERC20(\n                address(NativeL2Token),\n                string(abi.encodePacked(\"L1-\", NativeL2Token.name())),\n                string(abi.encodePacked(\"L1-\", NativeL2Token.symbol()))\n            )\n        );\n\n        BadL1Token = KromaMintableERC20(\n            L1TokenFactory.createKromaMintableERC20(\n                address(1),\n                string(abi.encodePacked(\"L1-\", NativeL2Token.name())),\n                string(abi.encodePacked(\"L1-\", NativeL2Token.symbol()))\n            )\n        );\n    }\n}\n\ncontract ERC721Bridge_Initializer is Messenger_Initializer {\n    L1ERC721Bridge L1Bridge;\n    L2ERC721Bridge L2Bridge;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        // Deploy the L1ERC721Bridge.\n        L1Bridge = new L1ERC721Bridge(address(L1Messenger), Predeploys.L2_ERC721_BRIDGE);\n\n        // Deploy the implementation for the L2ERC721Bridge and etch it into the predeploy address.\n        vm.etch(\n            Predeploys.L2_ERC721_BRIDGE,\n            address(new L2ERC721Bridge(Predeploys.L2_CROSS_DOMAIN_MESSENGER, address(L1Bridge)))\n                .code\n        );\n\n        // Set up a reference to the L2ERC721Bridge.\n        L2Bridge = L2ERC721Bridge(Predeploys.L2_ERC721_BRIDGE);\n\n        // Label the L1 and L2 bridges.\n        vm.label(address(L1Bridge), \"L1ERC721Bridge\");\n        vm.label(address(L2Bridge), \"L2ERC721Bridge\");\n    }\n}\n\ncontract Colosseum_Initializer is Portal_Initializer {\n    uint256 immutable CHAIN_ID = 901;\n    bytes32 immutable DUMMY_HASH =\n        hex\"a1235b834d6f1f78f78bc4db856fbc49302cce2c519921347600693021e087f7\";\n    uint256 immutable MAX_TXS = 100;\n\n    // Test target\n    Colosseum colosseumImpl;\n\n    ZKVerifier zkVerifier;\n    ZKVerifier zkVerifierImpl;\n\n    SecurityCouncil securityCouncilImpl;\n    SecurityCouncil securityCouncil;\n    uint256 NUM_CONFIRMATIONS_REQUIRED = 2;\n    address[] securityCouncilOwners = new address[](3);\n\n    uint256[] segmentsLengths;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        // Deploy the ZKVerifier\n        // Chain ID 901\n        Proxy verifierProxy = new Proxy(multisig);\n        zkVerifier = ZKVerifier(payable(address(verifierProxy)));\n        zkVerifierImpl = new ZKVerifier({\n            _hashScalar: 14523433211431174524389868863993690365141010513245706409377065114304218460986,\n            _m56Px: 4616778122792150218780382812396143832905328947307040502364327766326173155703,\n            _m56Py: 1715078755142899395367703690683049275256965470385291428932481791418357695593\n        });\n        vm.prank(multisig);\n        verifierProxy.upgradeTo(address(zkVerifierImpl));\n\n        // case - L2OutputOracle submissionInterval == 1800\n        segmentsLengths.push(9);\n        segmentsLengths.push(6);\n        segmentsLengths.push(10);\n        segmentsLengths.push(6);\n\n        Proxy proxy = new Proxy(multisig);\n        colosseum = Colosseum(payable(address(proxy)));\n\n        // Deploy the SecurityCouncil (after Colosseum contract deployment)\n        Proxy securityCouncilProxy = new Proxy(multisig);\n        securityCouncil = SecurityCouncil(address(securityCouncilProxy));\n        securityCouncilImpl = new SecurityCouncil(address(colosseum));\n        vm.prank(multisig);\n\n        securityCouncilOwners[0] = makeAddr(\"alice\");\n        securityCouncilOwners[1] = makeAddr(\"bob\");\n        securityCouncilOwners[2] = makeAddr(\"carol\");\n        securityCouncilProxy.upgradeToAndCall(\n            address(securityCouncilImpl),\n            abi.encodeCall(\n                SecurityCouncil.initialize,\n                (true, securityCouncilOwners, NUM_CONFIRMATIONS_REQUIRED)\n            )\n        );\n\n        colosseumImpl = new Colosseum({\n            _l2Oracle: oracle,\n            _zkVerifier: zkVerifier,\n            _submissionInterval: submissionInterval,\n            _creationPeriodSeconds: 6 days,\n            _bisectionTimeout: 30 minutes,\n            _provingTimeout: 1 hours,\n            _dummyHash: DUMMY_HASH,\n            _maxTxs: MAX_TXS,\n            _segmentsLengths: segmentsLengths,\n            _securityCouncil: address(securityCouncilProxy),\n            _zkMerkleTrie: address(zkMerkleTrie)\n        });\n        vm.prank(multisig);\n        proxy.upgradeToAndCall(\n            address(colosseumImpl),\n            abi.encodeCall(Colosseum.initialize, (segmentsLengths))\n        );\n    }\n}\n\ncontract SecurityCouncil_Initializer is CommonTest {\n    uint256 immutable NUM_CONFIRMATIONS_REQUIRED = 2;\n    address[] owners = new address[](3);\n    SecurityCouncil securityCouncilImpl;\n    SecurityCouncil securityCouncil;\n    address colosseumAddr;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        Proxy proxy = new Proxy(multisig);\n        securityCouncil = SecurityCouncil(address(proxy));\n        colosseumAddr = makeAddr(\"colosseum\");\n        securityCouncilImpl = new SecurityCouncil(colosseumAddr);\n        vm.prank(multisig);\n\n        owners[0] = makeAddr(\"alice\");\n        owners[1] = makeAddr(\"bob\");\n        owners[2] = makeAddr(\"carol\");\n        proxy.upgradeToAndCall(\n            address(securityCouncilImpl),\n            abi.encodeCall(SecurityCouncil.initialize, (true, owners, NUM_CONFIRMATIONS_REQUIRED))\n        );\n    }\n}\n\ncontract UpgradeGovernor_Initializer is CommonTest {\n    address superAdmin = makeAddr(\"superAdmin\");\n    address owner = makeAddr(\"owner\");\n\n    // Constructor arguments\n    uint256 internal initialVotingDelay = 0;\n    uint256 internal initialVotingPeriod = 30;\n    uint256 internal initialProposalThreshold = 1;\n    uint256 internal votesQuorumFraction = 51;\n    uint256 internal minDelaySeconds = 3;\n    string internal baseUri = \"\";\n\n    // Test data\n    address internal guardian1 = 0x0000000000000000000000000000000000001004;\n    address internal guardian2 = 0x0000000000000000000000000000000000001005;\n    address internal notGuardian = 0x0000000000000000000000000000000000001006;\n\n    address[] timeLockProposers = new address[](1);\n    address[] timeLockExecutors = new address[](1);\n\n    SecurityCouncilToken securityCouncilToken;\n    TimeLock timeLock;\n    UpgradeGovernor upgradeGovernor;\n\n    function setUp() public virtual override {\n        super.setUp();\n        vm.startPrank(multisig);\n\n        // setup SecurityCouncilToken\n        Proxy securityCouncilTokenProxy = new Proxy(multisig);\n        SecurityCouncilToken securityCouncilTokenImpl = new SecurityCouncilToken();\n        securityCouncilToken = SecurityCouncilToken(payable(address(securityCouncilTokenProxy)));\n        securityCouncilTokenProxy.upgradeToAndCall(\n            address(securityCouncilTokenImpl),\n            abi.encodeCall(SecurityCouncilToken.initialize, owner)\n        );\n\n        // setup TimeLock & UpgradeGovernor\n        Proxy timeLockProxy = new Proxy(multisig);\n        Proxy upgradeGovernorProxy = new Proxy(multisig);\n        TimeLock timeLockImpl = new TimeLock();\n        UpgradeGovernor upgradeGovernorImpl = new UpgradeGovernor();\n        timeLock = TimeLock(payable(address(timeLockProxy)));\n        upgradeGovernor = UpgradeGovernor(payable(address(upgradeGovernorProxy)));\n\n        timeLockProposers[0] = address(upgradeGovernor);\n        timeLockExecutors[0] = address(upgradeGovernor);\n\n        timeLockProxy.upgradeToAndCall(\n            address(timeLockImpl),\n            abi.encodeCall(\n                TimeLock.initialize,\n                (minDelaySeconds, timeLockProposers, timeLockExecutors, address(upgradeGovernor))\n            )\n        );\n\n        upgradeGovernorProxy.upgradeToAndCall(\n            address(upgradeGovernorImpl),\n            abi.encodeCall(\n                UpgradeGovernor.initialize,\n                (\n                    address(securityCouncilToken),\n                    payable(address(timeLock)),\n                    initialVotingDelay,\n                    initialVotingPeriod,\n                    initialProposalThreshold,\n                    votesQuorumFraction\n                )\n            )\n        );\n\n        //change proxy admin to upgradeGovernor\n        securityCouncilTokenProxy.changeAdmin(address(upgradeGovernor));\n        timeLockProxy.changeAdmin(address(upgradeGovernor));\n        upgradeGovernorProxy.changeAdmin(address(upgradeGovernor));\n        vm.stopPrank();\n    }\n}\n\ncontract FFIInterface is Test {\n    function getProveWithdrawalTransactionInputs(Types.WithdrawalTransaction memory _tx)\n        external\n        returns (\n            bytes32,\n            bytes32,\n            bytes32,\n            bytes32,\n            bytes[] memory\n        )\n    {\n        string[] memory cmds = new string[](8);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"getProveWithdrawalTransactionInputs\";\n        cmds[2] = vm.toString(_tx.nonce);\n        cmds[3] = vm.toString(_tx.sender);\n        cmds[4] = vm.toString(_tx.target);\n        cmds[5] = vm.toString(_tx.value);\n        cmds[6] = vm.toString(_tx.gasLimit);\n        cmds[7] = vm.toString(_tx.data);\n\n        bytes memory result = vm.ffi(cmds);\n        (\n            bytes32 stateRoot,\n            bytes32 storageRoot,\n            bytes32 outputRoot,\n            bytes32 withdrawalHash,\n            bytes[] memory withdrawalProof\n        ) = abi.decode(result, (bytes32, bytes32, bytes32, bytes32, bytes[]));\n\n        return (stateRoot, storageRoot, outputRoot, withdrawalHash, withdrawalProof);\n    }\n\n    function hashCrossDomainMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external returns (bytes32) {\n        string[] memory cmds = new string[](8);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"hashCrossDomainMessage\";\n        cmds[2] = vm.toString(_nonce);\n        cmds[3] = vm.toString(_sender);\n        cmds[4] = vm.toString(_target);\n        cmds[5] = vm.toString(_value);\n        cmds[6] = vm.toString(_gasLimit);\n        cmds[7] = vm.toString(_data);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes32));\n    }\n\n    function hashWithdrawal(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external returns (bytes32) {\n        string[] memory cmds = new string[](8);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"hashWithdrawal\";\n        cmds[2] = vm.toString(_nonce);\n        cmds[3] = vm.toString(_sender);\n        cmds[4] = vm.toString(_target);\n        cmds[5] = vm.toString(_value);\n        cmds[6] = vm.toString(_gasLimit);\n        cmds[7] = vm.toString(_data);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes32));\n    }\n\n    function hashOutputRootProof(\n        bytes32 _version,\n        bytes32 _stateRoot,\n        bytes32 _messagePasserStorageRoot,\n        bytes32 _blockhash,\n        bytes32 _nextBlockhash\n    ) external returns (bytes32) {\n        string[] memory cmds = new string[](7);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"hashOutputRootProof\";\n        cmds[2] = Strings.toHexString(uint256(_version));\n        cmds[3] = Strings.toHexString(uint256(_stateRoot));\n        cmds[4] = Strings.toHexString(uint256(_messagePasserStorageRoot));\n        cmds[5] = Strings.toHexString(uint256(_blockhash));\n        cmds[6] = Strings.toHexString(uint256(_nextBlockhash));\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes32));\n    }\n\n    function hashDepositTransaction(\n        address _from,\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gas,\n        bytes memory _data,\n        uint64 _logIndex\n    ) external returns (bytes32) {\n        string[] memory cmds = new string[](10);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"hashDepositTransaction\";\n        cmds[2] = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n        cmds[3] = vm.toString(_logIndex);\n        cmds[4] = vm.toString(_from);\n        cmds[5] = vm.toString(_to);\n        cmds[6] = vm.toString(_mint);\n        cmds[7] = vm.toString(_value);\n        cmds[8] = vm.toString(_gas);\n        cmds[9] = vm.toString(_data);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes32));\n    }\n\n    function encodeDepositTransaction(Types.UserDepositTransaction calldata txn)\n        external\n        returns (bytes memory)\n    {\n        string[] memory cmds = new string[](11);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"encodeDepositTransaction\";\n        cmds[2] = vm.toString(txn.from);\n        cmds[3] = vm.toString(txn.to);\n        cmds[4] = vm.toString(txn.value);\n        cmds[5] = vm.toString(txn.mint);\n        cmds[6] = vm.toString(txn.gasLimit);\n        cmds[7] = vm.toString(txn.isCreation);\n        cmds[8] = vm.toString(txn.data);\n        cmds[9] = vm.toString(txn.l1BlockHash);\n        cmds[10] = vm.toString(txn.logIndex);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes));\n    }\n\n    function encodeCrossDomainMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external returns (bytes memory) {\n        string[] memory cmds = new string[](8);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"encodeCrossDomainMessage\";\n        cmds[2] = vm.toString(_nonce);\n        cmds[3] = vm.toString(_sender);\n        cmds[4] = vm.toString(_target);\n        cmds[5] = vm.toString(_value);\n        cmds[6] = vm.toString(_gasLimit);\n        cmds[7] = vm.toString(_data);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes));\n    }\n\n    function decodeVersionedNonce(uint256 nonce) external returns (uint256, uint256) {\n        string[] memory cmds = new string[](3);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"decodeVersionedNonce\";\n        cmds[2] = vm.toString(nonce);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (uint256, uint256));\n    }\n\n    function getMerkleTrieFuzzCase(string memory variant)\n        external\n        returns (\n            bytes32,\n            bytes memory,\n            bytes memory,\n            bytes[] memory\n        )\n    {\n        string[] memory cmds = new string[](5);\n        cmds[0] = \"./test-case-generator/fuzz\";\n        cmds[1] = \"-m\";\n        cmds[2] = \"trie\";\n        cmds[3] = \"-v\";\n        cmds[4] = variant;\n\n        return abi.decode(vm.ffi(cmds), (bytes32, bytes, bytes, bytes[]));\n    }\n}\n\n// Used for testing a future upgrade beyond the current implementations.\n// We include some variables so that we can sanity check accessing storage values after an upgrade.\ncontract NextImpl is Initializable {\n    // Initializable occupies the zero-th slot.\n    bytes32 slot1;\n    bytes32[19] __gap;\n    bytes32 slot21;\n    bytes32 public constant slot21Init = bytes32(hex\"1337\");\n\n    function initialize() public reinitializer(2) {\n        // Slot21 is unused by an of our upgradeable contracts.\n        // This is used to verify that we can access this value after an upgrade.\n        slot21 = slot21Init;\n    }\n}\n\ncontract Reverter {\n    fallback() external {\n        revert();\n    }\n}\n\n// Useful for testing reentrancy guards\ncontract CallerCaller {\n    event WhatHappened(bool success, bytes returndata);\n\n    fallback() external {\n        (bool success, bytes memory returndata) = msg.sender.call(msg.data);\n        emit WhatHappened(success, returndata);\n        assembly {\n            switch success\n            case 0 {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n            default {\n                return(add(returndata, 0x20), mload(returndata))\n            }\n        }\n    }\n}\n\n// Used for testing the `CrossDomainMessenger`'s per-message reentrancy guard.\ncontract ConfigurableCaller {\n    bool doRevert = true;\n    address target;\n    bytes payload;\n\n    event WhatHappened(bool success, bytes returndata);\n\n    /**\n     * @notice Call the configured target with the configured payload OR revert.\n     */\n    function call() external {\n        if (doRevert) {\n            revert(\"ConfigurableCaller: revert\");\n        } else {\n            (bool success, bytes memory returndata) = address(target).call(payload);\n            emit WhatHappened(success, returndata);\n            assembly {\n                switch success\n                case 0 {\n                    revert(add(returndata, 0x20), mload(returndata))\n                }\n                default {\n                    return(add(returndata, 0x20), mload(returndata))\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Set whether or not to have `call` revert.\n     */\n    function setDoRevert(bool _doRevert) external {\n        doRevert = _doRevert;\n    }\n\n    /**\n     * @notice Set the target for the call made in `call`.\n     */\n    function setTarget(address _target) external {\n        target = _target;\n    }\n\n    /**\n     * @notice Set the payload for the call made in `call`.\n     */\n    function setPayload(bytes calldata _payload) external {\n        payload = _payload;\n    }\n\n    /**\n     * @notice Fallback function that reverts if `doRevert` is true.\n     *         Otherwise, it does nothing.\n     */\n    fallback() external {\n        if (doRevert) {\n            revert(\"ConfigurableCaller: revert\");\n        }\n    }\n}\n"
    },
    "contracts/test/CrossDomainMessenger.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n// Libraries\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\nimport { Messenger_Initializer, Reverter, CallerCaller, CommonTest } from \"./CommonTest.t.sol\";\n\n// CrossDomainMessenger_Test is for testing functionality which is common to both the L1 and L2\n// CrossDomainMessenger contracts. For simplicity, we use the L1 Messenger as the test contract.\ncontract CrossDomainMessenger_BaseGas_Test is Messenger_Initializer {\n    // Ensure that baseGas passes for the max value of _minGasLimit,\n    // this is about 4 Billion.\n    function test_baseGas_succeeds() external view {\n        L1Messenger.baseGas(hex\"ff\", type(uint32).max);\n    }\n\n    // Fuzz for other values which might cause a revert in baseGas.\n    function testFuzz_baseGas_succeeds(uint32 _minGasLimit) external view {\n        L1Messenger.baseGas(hex\"ff\", _minGasLimit);\n    }\n}\n\n/**\n * @title ExternalRelay\n * @notice A mock external contract called via the SafeCall inside\n *         the CrossDomainMessenger's `relayMessage` function.\n */\ncontract ExternalRelay is CommonTest {\n    address internal portal;\n    address internal fuzzedSender;\n    L1CrossDomainMessenger internal L1Messenger;\n\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    constructor(L1CrossDomainMessenger _l1Messenger, address _portal) {\n        L1Messenger = _l1Messenger;\n        portal = _portal;\n    }\n\n    /**\n     * @notice Internal helper function to relay a message and perform assertions.\n     */\n    function _internalRelay(address _innerSender) internal {\n        address initialSender = L1Messenger.xDomainMessageSender();\n\n        bytes memory callMessage = getCallData();\n\n        bytes32 hash = Hashing.hashCrossDomainMessage({\n            _nonce: Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            _sender: _innerSender,\n            _target: address(this),\n            _value: 0,\n            _gasLimit: 0,\n            _data: callMessage\n        });\n\n        vm.expectEmit(true, true, true, true);\n        emit FailedRelayedMessage(hash);\n\n        vm.prank(address(portal));\n        L1Messenger.relayMessage({\n            _nonce: Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            _sender: _innerSender,\n            _target: address(this),\n            _value: 0,\n            _minGasLimit: 0,\n            _message: callMessage\n        });\n\n        assertTrue(L1Messenger.failedMessages(hash));\n        assertFalse(L1Messenger.successfulMessages(hash));\n        assertEq(initialSender, L1Messenger.xDomainMessageSender());\n    }\n\n    /**\n     * @notice externalCallWithMinGas is called by the CrossDomainMessenger.\n     */\n    function externalCallWithMinGas() external payable {\n        for (uint256 i = 0; i < 10; i++) {\n            address _innerSender;\n            unchecked {\n                _innerSender = address(uint160(uint256(uint160(fuzzedSender)) + i));\n            }\n            _internalRelay(_innerSender);\n        }\n    }\n\n    /**\n     * @notice Helper function to get the callData for an `externalCallWithMinGas`.\n     */\n    function getCallData() public pure returns (bytes memory) {\n        return abi.encodeWithSelector(ExternalRelay.externalCallWithMinGas.selector);\n    }\n\n    /**\n     * @notice Helper function to set the fuzzed sender.\n     */\n    function setFuzzedSender(address _fuzzedSender) public {\n        fuzzedSender = _fuzzedSender;\n    }\n}\n\n/**\n * @title CrossDomainMessenger_RelayMessage_Test\n * @notice Fuzz tests re-entrancy into the CrossDomainMessenger relayMessage function.\n */\ncontract CrossDomainMessenger_RelayMessage_Test is Messenger_Initializer {\n    // Storage slot of the l2Sender\n    uint256 constant senderSlotIndex = 50;\n\n    ExternalRelay public er;\n\n    function setUp() public override {\n        super.setUp();\n        er = new ExternalRelay(L1Messenger, address(portal));\n    }\n\n    /**\n     * @dev This test mocks an KromaPortal call to the L1CrossDomainMessenger via\n     *      the relayMessage function. The relayMessage function will then use SafeCall's\n     *      callWithMinGas to call the target with call data packed in the callMessage.\n     *      For this test, the callWithMinGas will call the mock ExternalRelay test contract\n     *      defined above, executing the externalCallWithMinGas function which will try to\n     *      re-enter the CrossDomainMessenger's relayMessage function, resulting in that message\n     *      being recorded as failed.\n     */\n    function testFuzz_relayMessageReenter_succeeds(address _sender, uint256 _gasLimit) external {\n        vm.assume(_sender != Predeploys.L2_CROSS_DOMAIN_MESSENGER);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        er.setFuzzedSender(_sender);\n        address target = address(er);\n        bytes memory callMessage = er.getCallData();\n\n        vm.expectCall(target, callMessage);\n\n        uint64 gasLimit = uint64(bound(_gasLimit, 0, 30_000_000));\n\n        bytes32 hash = Hashing.hashCrossDomainMessage({\n            _nonce: Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            _sender: sender,\n            _target: target,\n            _value: 0,\n            _gasLimit: gasLimit,\n            _data: callMessage\n        });\n\n        // Set the value of portal.l2Sender() to be the L2 Cross Domain Messenger\n        vm.store(address(portal), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n        vm.prank(address(portal));\n        L1Messenger.relayMessage({\n            _nonce: Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            _sender: sender,\n            _target: target,\n            _value: 0,\n            _minGasLimit: gasLimit,\n            _message: callMessage\n        });\n\n        assertTrue(L1Messenger.successfulMessages(hash));\n        assertEq(L1Messenger.failedMessages(hash), false);\n\n        // Ensures that the `xDomainMsgSender` is set back to `Predeploys.L2_CROSS_DOMAIN_MESSENGER`\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L1Messenger.xDomainMessageSender();\n    }\n}\n"
    },
    "contracts/test/CrossDomainOwnable.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\nimport { Vm, VmSafe } from \"forge-std/Vm.sol\";\n\nimport { CrossDomainOwnable } from \"../L2/CrossDomainOwnable.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { CommonTest, Portal_Initializer } from \"./CommonTest.t.sol\";\n\ncontract XDomainSetter is CrossDomainOwnable {\n    uint256 public value;\n\n    function set(uint256 _value) external onlyOwner {\n        value = _value;\n    }\n}\n\ncontract CrossDomainOwnable_Test is CommonTest {\n    XDomainSetter setter;\n\n    function setUp() public override {\n        super.setUp();\n        setter = new XDomainSetter();\n    }\n\n    // Check that the revert message is correct\n    function test_onlyOwner_notOwner_reverts() external {\n        vm.expectRevert(\"CrossDomainOwnable: caller is not the owner\");\n        setter.set(1);\n    }\n\n    // Check that making a call can set the value properly\n    function test_onlyOwner_succeeds() external {\n        assertEq(setter.value(), 0);\n\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(setter.owner()));\n        setter.set(1);\n        assertEq(setter.value(), 1);\n    }\n}\n\ncontract CrossDomainOwnableThroughPortal_Test is Portal_Initializer {\n    XDomainSetter setter;\n\n    function setUp() public override {\n        super.setUp();\n\n        vm.prank(alice);\n        setter = new XDomainSetter();\n    }\n\n    function test_depositTransaction_crossDomainOwner_succeeds() external {\n        vm.recordLogs();\n\n        vm.prank(alice);\n        portal.depositTransaction({\n            _to: address(setter),\n            _value: 0,\n            _gasLimit: 21_000,\n            _isCreation: false,\n            _data: abi.encodeWithSelector(XDomainSetter.set.selector, 1)\n        });\n\n        // Simulate the operation of the `kroma-node` by parsing data\n        // from logs\n        VmSafe.Log[] memory logs = vm.getRecordedLogs();\n        // Only 1 log emitted\n        assertEq(logs.length, 1);\n\n        VmSafe.Log memory log = logs[0];\n\n        // It is the expected topic\n        bytes32 topic = log.topics[0];\n        assertEq(topic, keccak256(\"TransactionDeposited(address,address,uint256,bytes)\"));\n\n        // from is indexed and the first argument to the event.\n        bytes32 _from = log.topics[1];\n        address from = Bytes32AddressLib.fromLast20Bytes(_from);\n\n        assertEq(AddressAliasHelper.undoL1ToL2Alias(from), alice);\n\n        // Make a call from the \"from\" value received from the log.\n        // In theory the opaque data could be parsed from the log\n        // and passed to a low level call to \"to\", but calling set\n        // directly on the setter is good enough.\n        vm.prank(from);\n        setter.set(1);\n        assertEq(setter.value(), 1);\n    }\n}\n"
    },
    "contracts/test/CrossDomainOwnable2.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\n\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { CrossDomainOwnable2 } from \"../L2/CrossDomainOwnable2.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { CommonTest, Messenger_Initializer } from \"./CommonTest.t.sol\";\n\ncontract XDomainSetter2 is CrossDomainOwnable2 {\n    uint256 public value;\n\n    function set(uint256 _value) external onlyOwner {\n        value = _value;\n    }\n}\n\ncontract CrossDomainOwnable2_Test is Messenger_Initializer {\n    XDomainSetter2 setter;\n\n    function setUp() public override {\n        super.setUp();\n        vm.prank(alice);\n        setter = new XDomainSetter2();\n    }\n\n    function test_onlyOwner_notMessenger_reverts() external {\n        vm.expectRevert(\"CrossDomainOwnable2: caller is not the messenger\");\n        setter.set(1);\n    }\n\n    function test_onlyOwner_notOwner_reverts() external {\n        // set the xDomainMsgSender storage slot\n        bytes32 key = bytes32(uint256(102));\n        bytes32 value = Bytes32AddressLib.fillLast12Bytes(address(alice));\n        vm.store(address(L2Messenger), key, value);\n\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"CrossDomainOwnable2: caller is not the owner\");\n        setter.set(1);\n    }\n\n    function test_onlyOwner_notOwner2_reverts() external {\n        uint240 nonce = 0;\n        address sender = bob;\n        address target = address(setter);\n        uint256 value = 0;\n        uint256 minGasLimit = 0;\n        bytes memory message = abi.encodeWithSelector(XDomainSetter2.set.selector, 1);\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: nonce, _version: 0 }),\n            sender,\n            target,\n            value,\n            minGasLimit,\n            message\n        );\n\n        // It should be a failed message. The revert is caught,\n        // so we cannot expectRevert here.\n        vm.expectEmit(true, true, true, true);\n        emit FailedRelayedMessage(hash);\n\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: nonce, _version: 0 }),\n            sender,\n            target,\n            value,\n            minGasLimit,\n            message\n        );\n\n        assertEq(setter.value(), 0);\n    }\n\n    function test_onlyOwner_succeeds() external {\n        address owner = setter.owner();\n\n        // Simulate the L2 execution where the call is coming from\n        // the L1CrossDomainMessenger\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 1, _version: 0 }),\n            owner,\n            address(setter),\n            0,\n            0,\n            abi.encodeWithSelector(XDomainSetter2.set.selector, 2)\n        );\n\n        assertEq(setter.value(), 2);\n    }\n}\n"
    },
    "contracts/test/CrossDomainOwnable3.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\n\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { CrossDomainOwnable3 } from \"../L2/CrossDomainOwnable3.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { CommonTest, Messenger_Initializer } from \"./CommonTest.t.sol\";\n\ncontract XDomainSetter3 is CrossDomainOwnable3 {\n    uint256 public value;\n\n    function set(uint256 _value) external onlyOwner {\n        value = _value;\n    }\n}\n\ncontract CrossDomainOwnable3_Test is Messenger_Initializer {\n    XDomainSetter3 setter;\n\n    /**\n     * @notice OpenZeppelin Ownable.sol transferOwnership event\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @notice CrossDomainOwnable3.sol transferOwnership event\n     */\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner,\n        bool isLocal\n    );\n\n    function setUp() public override {\n        super.setUp();\n        vm.prank(alice);\n        setter = new XDomainSetter3();\n    }\n\n    function test_constructor_succeeds() public {\n        assertEq(setter.owner(), alice);\n        assertEq(setter.isLocal(), true);\n    }\n\n    function test_localOnlyOwner_notOwner_reverts() public {\n        vm.prank(bob);\n        vm.expectRevert(\"CrossDomainOwnable3: caller is not the owner\");\n        setter.set(1);\n    }\n\n    function test_transferOwnership_notOwner_reverts() public {\n        vm.prank(bob);\n        vm.expectRevert(\"CrossDomainOwnable3: caller is not the owner\");\n        setter.transferOwnership({ _owner: bob, _isLocal: true });\n    }\n\n    function test_crossDomainOnlyOwner_notOwner_reverts() public {\n        vm.expectEmit(true, true, true, true);\n\n        // OpenZeppelin Ownable.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice);\n\n        // CrossDomainOwnable3.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice, false);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership({ _owner: alice, _isLocal: false });\n\n        // set the xDomainMsgSender storage slot\n        bytes32 key = bytes32(uint256(102));\n        bytes32 value = Bytes32AddressLib.fillLast12Bytes(bob);\n        vm.store(address(L2Messenger), key, value);\n\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"CrossDomainOwnable3: caller is not the owner\");\n        setter.set(1);\n    }\n\n    function test_crossDomainOnlyOwner_notOwner2_reverts() public {\n        vm.expectEmit(true, true, true, true);\n\n        // OpenZeppelin Ownable.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice);\n\n        // CrossDomainOwnable3.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice, false);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership({ _owner: alice, _isLocal: false });\n\n        assertEq(setter.isLocal(), false);\n\n        uint240 nonce = 0;\n        address sender = bob;\n        address target = address(setter);\n        uint256 value = 0;\n        uint256 minGasLimit = 0;\n        bytes memory message = abi.encodeWithSelector(XDomainSetter3.set.selector, 1);\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: nonce, _version: 0 }),\n            sender,\n            target,\n            value,\n            minGasLimit,\n            message\n        );\n\n        // It should be a failed message. The revert is caught,\n        // so we cannot expectRevert here.\n        vm.expectEmit(true, true, true, true, address(L2Messenger));\n        emit FailedRelayedMessage(hash);\n\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: nonce, _version: 0 }),\n            sender,\n            target,\n            value,\n            minGasLimit,\n            message\n        );\n\n        assertEq(setter.value(), 0);\n    }\n\n    function test_crossDomainOnlyOwner_notMessenger_reverts() public {\n        vm.expectEmit(true, true, true, true);\n\n        // OpenZeppelin Ownable.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice);\n\n        // CrossDomainOwnable3.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice, false);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership({ _owner: alice, _isLocal: false });\n\n        vm.prank(bob);\n        vm.expectRevert(\"CrossDomainOwnable3: caller is not the messenger\");\n        setter.set(1);\n    }\n\n    function test_transferOwnership_zeroAddress_reverts() public {\n        vm.prank(setter.owner());\n        vm.expectRevert(\"CrossDomainOwnable3: new owner is the zero address\");\n        setter.transferOwnership({ _owner: address(0), _isLocal: true });\n    }\n\n    function test_transferOwnership_noLocalZeroAddress_reverts() public {\n        vm.prank(setter.owner());\n        vm.expectRevert(\"Ownable: new owner is the zero address\");\n        setter.transferOwnership(address(0));\n    }\n\n    function test_localOnlyOwner_succeeds() public {\n        assertEq(setter.isLocal(), true);\n        vm.prank(setter.owner());\n        setter.set(1);\n        assertEq(setter.value(), 1);\n    }\n\n    function test_localTransferOwnership_succeeds() public {\n        vm.expectEmit(true, true, true, true, address(setter));\n        emit OwnershipTransferred(alice, bob);\n        emit OwnershipTransferred(alice, bob, true);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership({ _owner: bob, _isLocal: true });\n\n        assertEq(setter.isLocal(), true);\n\n        vm.prank(bob);\n        setter.set(2);\n        assertEq(setter.value(), 2);\n    }\n\n    /**\n     * @notice The existing transferOwnership(address) method\n     *         still exists on the contract\n     */\n    function test_transferOwnershipNoLocal_succeeds() public {\n        bool isLocal = setter.isLocal();\n\n        vm.expectEmit(true, true, true, true, address(setter));\n        emit OwnershipTransferred(alice, bob);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership(bob);\n\n        // isLocal has not changed\n        assertEq(setter.isLocal(), isLocal);\n\n        vm.prank(bob);\n        setter.set(2);\n        assertEq(setter.value(), 2);\n    }\n\n    function test_crossDomainTransferOwnership_succeeds() public {\n        vm.expectEmit(true, true, true, true, address(setter));\n        emit OwnershipTransferred(alice, bob);\n        emit OwnershipTransferred(alice, bob, false);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership({ _owner: bob, _isLocal: false });\n\n        assertEq(setter.isLocal(), false);\n\n        // Simulate the L2 execution where the call is coming from\n        // the L1CrossDomainMessenger\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 1, _version: 0 }),\n            bob,\n            address(setter),\n            0,\n            0,\n            abi.encodeWithSelector(XDomainSetter3.set.selector, 2)\n        );\n\n        assertEq(setter.value(), 2);\n    }\n}\n"
    },
    "contracts/test/Encoding.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract Encoding_Test is CommonTest {\n    function testFuzz_nonceVersioning_succeeds(uint240 _nonce, uint16 _version) external {\n        (uint240 nonce, uint16 version) = Encoding.decodeVersionedNonce(\n            Encoding.encodeVersionedNonce(_nonce, _version)\n        );\n        assertEq(version, _version);\n        assertEq(nonce, _nonce);\n    }\n\n    function testDiff_decodeVersionedNonce_succeeds(uint240 _nonce, uint16 _version) external {\n        uint256 nonce = uint256(Encoding.encodeVersionedNonce(_nonce, _version));\n        (uint256 decodedNonce, uint256 decodedVersion) = ffi.decodeVersionedNonce(nonce);\n\n        assertEq(_version, uint16(decodedVersion));\n\n        assertEq(_nonce, uint240(decodedNonce));\n    }\n\n    function testDiff_encodeCrossDomainMessage_succeeds(\n        uint240 _nonce,\n        uint8 _version,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        uint8 version = uint8(bound(uint256(_version), 0, 0));\n        uint256 nonce = Encoding.encodeVersionedNonce(_nonce, version);\n\n        bytes memory encoding = Encoding.encodeCrossDomainMessage(\n            nonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n\n        bytes memory _encoding = ffi.encodeCrossDomainMessage(\n            nonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n\n        assertEq(encoding, _encoding);\n    }\n\n    function testDiff_encodeDepositTransaction_succeeds(\n        address _from,\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gas,\n        bool isCreate,\n        bytes memory _data,\n        uint64 _logIndex\n    ) external {\n        Types.UserDepositTransaction memory t = Types.UserDepositTransaction(\n            _from,\n            _to,\n            isCreate,\n            _value,\n            _mint,\n            _gas,\n            _data,\n            bytes32(uint256(0)),\n            _logIndex\n        );\n\n        bytes memory txn = Encoding.encodeDepositTransaction(t);\n        bytes memory _txn = ffi.encodeDepositTransaction(t);\n\n        assertEq(txn, _txn);\n    }\n}\n"
    },
    "contracts/test/FeeVault.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { ProtocolVault } from \"../L2/ProtocolVault.sol\";\nimport { ProposerRewardVault } from \"../L2/ProposerRewardVault.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\n\n// Test the implementations of the FeeVault\ncontract FeeVault_Test is Bridge_Initializer {\n    ProtocolVault protocolVault = ProtocolVault(payable(Predeploys.PROTOCOL_VAULT));\n    ProposerRewardVault proposerRewardVault = ProposerRewardVault(payable(Predeploys.PROPOSER_REWARD_VAULT));\n\n    address constant recipient = address(0x10000);\n\n    function setUp() public override {\n        super.setUp();\n        vm.etch(Predeploys.PROTOCOL_VAULT, address(new ProtocolVault(recipient)).code);\n        vm.etch(Predeploys.PROPOSER_REWARD_VAULT, address(new ProposerRewardVault(recipient)).code);\n\n        vm.label(Predeploys.PROTOCOL_VAULT, \"ProtocolVault\");\n        vm.label(Predeploys.PROPOSER_REWARD_VAULT, \"ProposerRewardVault\");\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(protocolVault.RECIPIENT(), recipient);\n        assertEq(proposerRewardVault.RECIPIENT(), recipient);\n    }\n\n    function test_minWithdrawalAmount_succeeds() external {\n        assertEq(protocolVault.MIN_WITHDRAWAL_AMOUNT(), 10 ether);\n        assertEq(proposerRewardVault.MIN_WITHDRAWAL_AMOUNT(), 10 ether);\n    }\n}\n"
    },
    "contracts/test/GasPriceOracle.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { GasPriceOracle } from \"../L2/GasPriceOracle.sol\";\nimport { L1Block } from \"../L2/L1Block.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract GasPriceOracle_Test is CommonTest {\n    event OverheadUpdated(uint256);\n    event ScalarUpdated(uint256);\n    event DecimalsUpdated(uint256);\n\n    GasPriceOracle gasOracle;\n    L1Block l1Block;\n    address depositor;\n\n    // set the initial L1 context values\n    uint64 constant number = 10;\n    uint64 constant timestamp = 11;\n    uint256 constant basefee = 100;\n    bytes32 constant hash = bytes32(uint256(64));\n    uint64 constant sequenceNumber = 0;\n    bytes32 constant batcherHash = bytes32(uint256(777));\n    uint256 constant l1FeeOverhead = 310;\n    uint256 constant l1FeeScalar = 10;\n    uint256 constant validatorRewardScalar = 5000;\n\n    function setUp() public virtual override {\n        super.setUp();\n        // place the L1Block contract at the predeploy address\n        vm.etch(Predeploys.L1_BLOCK_ATTRIBUTES, address(new L1Block()).code);\n\n        l1Block = L1Block(Predeploys.L1_BLOCK_ATTRIBUTES);\n        depositor = l1Block.DEPOSITOR_ACCOUNT();\n\n        // We are not setting the gas oracle at its predeploy\n        // address for simplicity purposes. Nothing in this test\n        // requires it to be at a particular address\n        gasOracle = new GasPriceOracle();\n\n        vm.prank(depositor);\n        l1Block.setL1BlockValues({\n            _number: number,\n            _timestamp: timestamp,\n            _basefee: basefee,\n            _hash: hash,\n            _sequenceNumber: sequenceNumber,\n            _batcherHash: batcherHash,\n            _l1FeeOverhead: l1FeeOverhead,\n            _l1FeeScalar: l1FeeScalar,\n            _validatorRewardScalar: validatorRewardScalar\n        });\n    }\n\n    function test_l1BaseFee_succeeds() external {\n        assertEq(gasOracle.l1BaseFee(), basefee);\n    }\n\n    function test_gasPrice_succeeds() external {\n        vm.fee(100);\n        uint256 gasPrice = gasOracle.gasPrice();\n        assertEq(gasPrice, 100);\n    }\n\n    function test_baseFee_succeeds() external {\n        vm.fee(64);\n        uint256 gasPrice = gasOracle.baseFee();\n        assertEq(gasPrice, 64);\n    }\n\n    function test_scalar_succeeds() external {\n        assertEq(gasOracle.scalar(), l1FeeScalar);\n    }\n\n    function test_overhead_succeeds() external {\n        assertEq(gasOracle.overhead(), l1FeeOverhead);\n    }\n\n    function test_decimals_succeeds() external {\n        assertEq(gasOracle.DECIMALS(), 6);\n    }\n}\n"
    },
    "contracts/test/Hashing.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Arithmetic } from \"../libraries/Arithmetic.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract Hashing_hashDepositSource_Test is CommonTest {\n    /**\n     * @notice Tests that hashDepositSource returns the correct hash in a simple case.\n     */\n    function test_hashDepositSource_succeeds() external {\n        assertEq(\n            Hashing.hashDepositSource(\n                0xd25df7858efc1778118fb133ac561b138845361626dfb976699c5287ed0f4959,\n                0x1\n            ),\n            0xf923fb07134d7d287cb52c770cc619e17e82606c21a875c92f4c63b65280a5cc\n        );\n    }\n}\n\ncontract Hashing_hashCrossDomainMessage_Test is CommonTest {\n    /**\n     * @notice Tests that hashCrossDomainMessage returns the correct hash in a simple case.\n     */\n    function testDiff_hashCrossDomainMessage_succeeds(\n        uint240 _nonce,\n        uint16 _version,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        // Ensure the version is valid.\n        uint16 version = uint16(bound(uint256(_version), 0, 0));\n        uint256 nonce = Encoding.encodeVersionedNonce(_nonce, version);\n\n        assertEq(\n            Hashing.hashCrossDomainMessage(nonce, _sender, _target, _value, _gasLimit, _data),\n            ffi.hashCrossDomainMessage(nonce, _sender, _target, _value, _gasLimit, _data)\n        );\n    }\n}\n\ncontract Hashing_hashWithdrawal_Test is CommonTest {\n    /**\n     * @notice Tests that hashWithdrawal returns the correct hash in a simple case.\n     */\n    function testDiff_hashWithdrawal_succeeds(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        assertEq(\n            Hashing.hashWithdrawal(\n                Types.WithdrawalTransaction(_nonce, _sender, _target, _value, _gasLimit, _data)\n            ),\n            ffi.hashWithdrawal(_nonce, _sender, _target, _value, _gasLimit, _data)\n        );\n    }\n}\n\ncontract Hashing_hashOutputRootProof_Test is CommonTest {\n    /**\n     * @notice Tests that hashOutputRootProof returns the correct hash in a simple case.\n     */\n    function testDiff_hashOutputRootProof_succeeds(\n        bytes32 _version,\n        bytes32 _stateRoot,\n        bytes32 _messagePasserStorageRoot,\n        bytes32 _blockHash,\n        bytes32 _nextBlockHash\n    ) external {\n        _version = bytes32(Arithmetic.clamp(uint256(_version), 0, MAX_OUTPUT_ROOT_PROOF_VERSION));\n        assertEq(\n            Hashing.hashOutputRootProof(\n                Types.OutputRootProof({\n                    version: _version,\n                    stateRoot: _stateRoot,\n                    messagePasserStorageRoot: _messagePasserStorageRoot,\n                    blockHash: _blockHash,\n                    nextBlockHash: _nextBlockHash\n                })\n            ),\n            ffi.hashOutputRootProof(\n                _version,\n                _stateRoot,\n                _messagePasserStorageRoot,\n                _blockHash,\n                _nextBlockHash\n            )\n        );\n    }\n}\n\ncontract Hashing_hashDepositTransaction_Test is CommonTest {\n    /**\n     * @notice Tests that hashDepositTransaction returns the correct hash in a simple case.\n     */\n    function testDiff_hashDepositTransaction_succeeds(\n        address _from,\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gas,\n        bytes memory _data,\n        uint64 _logIndex\n    ) external {\n        assertEq(\n            Hashing.hashDepositTransaction(\n                Types.UserDepositTransaction(\n                    _from,\n                    _to,\n                    false, // isCreate\n                    _value,\n                    _mint,\n                    _gas,\n                    _data,\n                    bytes32(uint256(0)),\n                    _logIndex\n                )\n            ),\n            ffi.hashDepositTransaction(_from, _to, _mint, _value, _gas, _data, _logIndex)\n        );\n    }\n}\n"
    },
    "contracts/test/KromaMintableERC20.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {\n    IKromaMintableERC20\n} from \"../universal/IKromaMintableERC20.sol\";\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\n\ncontract KromaMintableERC20_Test is Bridge_Initializer {\n    event Mint(address indexed account, uint256 amount);\n    event Burn(address indexed account, uint256 amount);\n\n    function test_semver_succeeds() external {\n        assertEq(L2Token.version(), \"0.1.0\");\n    }\n\n    function test_remoteToken_succeeds() external {\n        assertEq(L2Token.REMOTE_TOKEN(), address(L1Token));\n    }\n\n    function test_bridge_succeeds() external {\n        assertEq(L2Token.BRIDGE(), address(L2Bridge));\n    }\n\n    function test_mint_succeeds() external {\n        vm.expectEmit(true, true, true, true);\n        emit Mint(alice, 100);\n\n        vm.prank(address(L2Bridge));\n        L2Token.mint(alice, 100);\n\n        assertEq(L2Token.balanceOf(alice), 100);\n    }\n\n    function test_mint_notBridge_reverts() external {\n        // NOT the bridge\n        vm.expectRevert(\"KromaMintableERC20: only bridge can mint and burn\");\n        vm.prank(address(alice));\n        L2Token.mint(alice, 100);\n    }\n\n    function test_burn_succeeds() external {\n        vm.prank(address(L2Bridge));\n        L2Token.mint(alice, 100);\n\n        vm.expectEmit(true, true, true, true);\n        emit Burn(alice, 100);\n\n        vm.prank(address(L2Bridge));\n        L2Token.burn(alice, 100);\n\n        assertEq(L2Token.balanceOf(alice), 0);\n    }\n\n    function test_burn_notBridge_reverts() external {\n        // NOT the bridge\n        vm.expectRevert(\"KromaMintableERC20: only bridge can mint and burn\");\n        vm.prank(address(alice));\n        L2Token.burn(alice, 100);\n    }\n\n    function test_erc165_supportsInterface_succeeds() external {\n        // The assertEq calls in this test are comparing the manual calculation of the iface,\n        // with what is returned by the solidity's type().interfaceId, just to be safe.\n        bytes4 iface1 = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n        assertEq(iface1, type(IERC165).interfaceId);\n        assert(L2Token.supportsInterface(iface1));\n\n        bytes4 iface2 = L2Token.REMOTE_TOKEN.selector ^\n            L2Token.BRIDGE.selector ^\n            L2Token.mint.selector ^\n            L2Token.burn.selector;\n        assertEq(iface2, type(IKromaMintableERC20).interfaceId);\n        assert(L2Token.supportsInterface(iface2));\n    }\n}\n"
    },
    "contracts/test/KromaMintableERC20Factory.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\nimport { LibRLP } from \"./RLP.t.sol\";\n\ncontract KromaMintableTokenFactory_Test is Bridge_Initializer {\n    event KromaMintableERC20Created(\n        address indexed localToken,\n        address indexed remoteToken,\n        address deployer\n    );\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_bridge_succeeds() external {\n        assertEq(address(L2TokenFactory.BRIDGE()), address(L2Bridge));\n    }\n\n    function test_createKromaMintableERC20_succeeds() external {\n        address remote = address(4);\n        address local = LibRLP.computeAddress(address(L2TokenFactory), 2);\n\n        vm.expectEmit(true, true, true, true);\n        emit KromaMintableERC20Created(local, remote, alice);\n\n        vm.prank(alice);\n        L2TokenFactory.createKromaMintableERC20(remote, \"Beep\", \"BOOP\");\n    }\n\n    function test_createKromaMintableERC20_sameTwice_succeeds() external {\n        address remote = address(4);\n\n        vm.prank(alice);\n        L2TokenFactory.createKromaMintableERC20(remote, \"Beep\", \"BOOP\");\n\n        address local = LibRLP.computeAddress(address(L2TokenFactory), 3);\n\n        vm.expectEmit(true, true, true, true);\n        emit KromaMintableERC20Created(local, remote, alice);\n\n        vm.prank(alice);\n        L2TokenFactory.createKromaMintableERC20(remote, \"Beep\", \"BOOP\");\n    }\n\n    function test_createKromaMintableERC20_remoteIsZero_succeeds() external {\n        address remote = address(0);\n        vm.expectRevert(\"KromaMintableERC20Factory: must provide remote token address\");\n        L2TokenFactory.createKromaMintableERC20(remote, \"Beep\", \"BOOP\");\n    }\n}\n"
    },
    "contracts/test/KromaMintableERC721.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport { KromaMintableERC721 } from \"../universal/KromaMintableERC721.sol\";\nimport { ERC721Bridge_Initializer } from \"./CommonTest.t.sol\";\n\ncontract KromaMintableERC721_Test is ERC721Bridge_Initializer {\n    ERC721 internal L1Token;\n    KromaMintableERC721 internal L2Token;\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    event Mint(address indexed account, uint256 tokenId);\n\n    event Burn(address indexed account, uint256 tokenId);\n\n    function setUp() public override {\n        super.setUp();\n\n        // Set up the token pair.\n        L1Token = new ERC721(\"L1Token\", \"L1T\");\n        L2Token = new KromaMintableERC721(\n            address(L2Bridge),\n            1,\n            address(L1Token),\n            \"L2Token\",\n            \"L2T\"\n        );\n\n        // Label the addresses for nice traces.\n        vm.label(address(L1Token), \"L1ERC721Token\");\n        vm.label(address(L2Token), \"L2ERC721Token\");\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(L2Token.name(), \"L2Token\");\n        assertEq(L2Token.symbol(), \"L2T\");\n        assertEq(L2Token.remoteChainId(), 1);\n        assertEq(L2Token.REMOTE_TOKEN(), address(L1Token));\n        assertEq(L2Token.BRIDGE(), address(L2Bridge));\n        assertEq(L2Token.REMOTE_CHAIN_ID(), 1);\n    }\n\n    function test_safeMint_succeeds() external {\n        // Expect a transfer event.\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(0), alice, 1);\n\n        // Expect a mint event.\n        vm.expectEmit(true, true, true, true);\n        emit Mint(alice, 1);\n\n        // Mint the token.\n        vm.prank(address(L2Bridge));\n        L2Token.safeMint(alice, 1);\n\n        // Token should be owned by alice.\n        assertEq(L2Token.ownerOf(1), alice);\n    }\n\n    function test_safeMint_notBridge_reverts() external {\n        // Try to mint the token.\n        vm.expectRevert(\"KromaMintableERC721: only bridge can call this function\");\n        vm.prank(address(alice));\n        L2Token.safeMint(alice, 1);\n    }\n\n    function test_burn_succeeds() external {\n        // Mint the token first.\n        vm.prank(address(L2Bridge));\n        L2Token.safeMint(alice, 1);\n\n        // Expect a transfer event.\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(alice, address(0), 1);\n\n        // Expect a burn event.\n        vm.expectEmit(true, true, true, true);\n        emit Burn(alice, 1);\n\n        // Burn the token.\n        vm.prank(address(L2Bridge));\n        L2Token.burn(alice, 1);\n\n        // Token should be owned by address(0).\n        vm.expectRevert(\"ERC721: invalid token ID\");\n        L2Token.ownerOf(1);\n    }\n\n    function test_burn_notBridge_reverts() external {\n        // Mint the token first.\n        vm.prank(address(L2Bridge));\n        L2Token.safeMint(alice, 1);\n\n        // Try to burn the token.\n        vm.expectRevert(\"KromaMintableERC721: only bridge can call this function\");\n        vm.prank(address(alice));\n        L2Token.burn(alice, 1);\n    }\n\n    function test_tokenURI_succeeds() external {\n        // Mint the token first.\n        vm.prank(address(L2Bridge));\n        L2Token.safeMint(alice, 1);\n\n        // Token URI should be correct.\n        assertEq(\n            L2Token.tokenURI(1),\n            string(\n                abi.encodePacked(\n                    \"ethereum:\",\n                    Strings.toHexString(uint160(address(L1Token)), 20),\n                    \"@\",\n                    Strings.toString(uint256(1)),\n                    \"/tokenURI?uint256=\",\n                    Strings.toString(uint256(1))\n                )\n            )\n        );\n    }\n}\n"
    },
    "contracts/test/KromaMintableERC721Factory.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport { KromaMintableERC721 } from \"../universal/KromaMintableERC721.sol\";\nimport { KromaMintableERC721Factory } from \"../universal/KromaMintableERC721Factory.sol\";\nimport { ERC721Bridge_Initializer } from \"./CommonTest.t.sol\";\nimport { LibRLP } from \"./RLP.t.sol\";\n\ncontract KromaMintableERC721Factory_Test is ERC721Bridge_Initializer {\n    KromaMintableERC721Factory internal factory;\n\n    event KromaMintableERC721Created(\n        address indexed localToken,\n        address indexed remoteToken,\n        address deployer\n    );\n\n    function setUp() public override {\n        super.setUp();\n\n        // Set up the token pair.\n        factory = new KromaMintableERC721Factory(address(L2Bridge), 1);\n\n        // Label the addresses for nice traces.\n        vm.label(address(factory), \"KromaMintableERC721Factory\");\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(factory.BRIDGE(), address(L2Bridge));\n        assertEq(factory.REMOTE_CHAIN_ID(), 1);\n    }\n\n    function test_createKromaMintableERC721_succeeds() external {\n        // Predict the address based on the factory address and nonce.\n        address predicted = LibRLP.computeAddress(address(factory), 1);\n\n        // Expect a token creation event.\n        vm.expectEmit(true, true, true, true);\n        emit KromaMintableERC721Created(predicted, address(1234), alice);\n\n        // Create the token.\n        vm.prank(alice);\n        KromaMintableERC721 created = KromaMintableERC721(\n            factory.createKromaMintableERC721(address(1234), \"L2Token\", \"L2T\")\n        );\n\n        // Token address should be correct.\n        assertEq(address(created), predicted);\n\n        // Should be marked as created by the factory.\n        assertEq(factory.isKromaMintableERC721(address(created)), true);\n\n        // Token should've been constructed correctly.\n        assertEq(created.name(), \"L2Token\");\n        assertEq(created.symbol(), \"L2T\");\n        assertEq(created.REMOTE_TOKEN(), address(1234));\n        assertEq(created.BRIDGE(), address(L2Bridge));\n        assertEq(created.REMOTE_CHAIN_ID(), 1);\n    }\n\n    function test_createKromaMintableERC721_zeroRemoteToken_reverts() external {\n        // Try to create a token with a zero remote token address.\n        vm.expectRevert(\"KromaMintableERC721Factory: L1 token address cannot be address(0)\");\n        factory.createKromaMintableERC721(address(0), \"L2Token\", \"L2T\");\n    }\n}\n"
    },
    "contracts/test/KromaPortal.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { stdError } from \"forge-std/Test.sol\";\n\nimport { KromaPortal } from \"../L1/KromaPortal.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Portal_Initializer, CommonTest, NextImpl } from \"./CommonTest.t.sol\";\n\ncontract KromaPortal_Test is Portal_Initializer {\n    event Paused(address);\n    event Unpaused(address);\n\n    function test_constructor_succeeds() external {\n        assertEq(address(portal.L2_ORACLE()), address(oracle));\n        assertEq(portal.l2Sender(), 0x000000000000000000000000000000000000dEaD);\n        assertEq(portal.paused(), false);\n    }\n\n    /**\n     * @notice The KromaPortal can be paused by the GUARDIAN\n     */\n    function test_pause_succeeds() external {\n        address guardian = portal.GUARDIAN();\n\n        assertEq(portal.paused(), false);\n\n        vm.expectEmit(true, true, true, true, address(portal));\n        emit Paused(guardian);\n\n        vm.prank(guardian);\n        portal.pause();\n\n        assertEq(portal.paused(), true);\n    }\n\n    /**\n     * @notice The KromaPortal reverts when an account that is not the\n     *         GUARDIAN calls `pause()`\n     */\n    function test_pause_onlyGuardian_reverts() external {\n        assertEq(portal.paused(), false);\n\n        assertTrue(portal.GUARDIAN() != alice);\n        vm.expectRevert(\"KromaPortal: only guardian can pause\");\n        vm.prank(alice);\n        portal.pause();\n\n        assertEq(portal.paused(), false);\n    }\n\n    /**\n     * @notice The KromaPortal can be unpaused by the GUARDIAN\n     */\n    function test_unpause_succeeds() external {\n        address guardian = portal.GUARDIAN();\n\n        vm.prank(guardian);\n        portal.pause();\n        assertEq(portal.paused(), true);\n\n        vm.expectEmit(true, true, true, true, address(portal));\n        emit Unpaused(guardian);\n        vm.prank(guardian);\n        portal.unpause();\n\n        assertEq(portal.paused(), false);\n    }\n\n    /**\n     * @notice The KromaPortal reverts when an account that is not\n     *         the GUARDIAN calls `unpause()`\n     */\n    function test_unpause_onlyGuardian_reverts() external {\n        address guardian = portal.GUARDIAN();\n\n        vm.prank(guardian);\n        portal.pause();\n        assertEq(portal.paused(), true);\n\n        assertTrue(portal.GUARDIAN() != alice);\n        vm.expectRevert(\"KromaPortal: only guardian can unpause\");\n        vm.prank(alice);\n        portal.unpause();\n\n        assertEq(portal.paused(), true);\n    }\n\n    function test_receive_succeeds() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(alice, alice, 100, 100, 100_000, false, hex\"\");\n\n        // give alice money and send as an eoa\n        vm.deal(alice, 2**64);\n        vm.prank(alice, alice);\n        (bool s, ) = address(portal).call{ value: 100 }(hex\"\");\n\n        assert(s);\n        assertEq(address(portal).balance, 100);\n    }\n\n    // Test: depositTransaction fails when contract creation has a non-zero destination address\n    function test_depositTransaction_contractCreation_reverts() external {\n        // contract creation must have a target of address(0)\n        vm.expectRevert(\"KromaPortal: must send to address(0) when creating a contract\");\n        portal.depositTransaction(address(1), 1, 0, true, hex\"\");\n    }\n\n    /**\n     * @notice Prevent gasless deposits from being force processed in L2 by\n     *         ensuring that they have a large enough gas limit set.\n     */\n    function test_depositTransaction_smallGasLimit_reverts() external {\n        vm.expectRevert(\"KromaPortal: gas limit must cover instrinsic gas cost\");\n        portal.depositTransaction({\n            _to: address(1),\n            _value: 0,\n            _gasLimit: 0,\n            _isCreation: false,\n            _data: hex\"\"\n        });\n    }\n\n    // Test: depositTransaction should emit the correct log when an EOA deposits a tx with 0 value\n    function test_depositTransaction_noValueEOA_succeeds() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            address(this),\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        portal.depositTransaction(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    // Test: depositTransaction should emit the correct log when a contract deposits a tx with 0 value\n    function test_depositTransaction_noValueContract_succeeds() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        portal.depositTransaction(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    // Test: depositTransaction should emit the correct log when an EOA deposits a contract creation with 0 value\n    function test_depositTransaction_createWithZeroValueForEOA_succeeds() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            address(this),\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n\n        portal.depositTransaction(ZERO_ADDRESS, ZERO_VALUE, NON_ZERO_GASLIMIT, true, NON_ZERO_DATA);\n    }\n\n    // Test: depositTransaction should emit the correct log when a contract deposits a contract creation with 0 value\n    function test_depositTransaction_createWithZeroValueForContract_succeeds() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n\n        portal.depositTransaction(ZERO_ADDRESS, ZERO_VALUE, NON_ZERO_GASLIMIT, true, NON_ZERO_DATA);\n    }\n\n    // Test: depositTransaction should increase its eth balance when an EOA deposits a transaction with ETH\n    function test_depositTransaction_withEthValueFromEOA_succeeds() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            address(this),\n            NON_ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        portal.depositTransaction{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n        assertEq(address(portal).balance, NON_ZERO_VALUE);\n    }\n\n    // Test: depositTransaction should increase its eth balance when a contract deposits a transaction with ETH\n    function test_depositTransaction_withEthValueFromContract_succeeds() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            NON_ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        portal.depositTransaction{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    // Test: depositTransaction should increase its eth balance when an EOA deposits a contract creation with ETH\n    function test_depositTransaction_withEthValueAndEOAContractCreation_succeeds() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            address(this),\n            ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            hex\"\"\n        );\n\n        portal.depositTransaction{ value: NON_ZERO_VALUE }(\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            hex\"\"\n        );\n        assertEq(address(portal).balance, NON_ZERO_VALUE);\n    }\n\n    // Test: depositTransaction should increase its eth balance when a contract deposits a contract creation with ETH\n    function test_depositTransaction_withEthValueAndContractContractCreation_succeeds() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n\n        portal.depositTransaction{ value: NON_ZERO_VALUE }(\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n        assertEq(address(portal).balance, NON_ZERO_VALUE);\n    }\n\n    function test_simple_isOutputFinalized_succeeds() external {\n        uint256 ts = block.timestamp;\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.CheckpointOutput(\n                    trusted,\n                    bytes32(uint256(1)),\n                    uint128(ts),\n                    uint128(startingBlockNumber)\n                )\n            )\n        );\n\n        // warp to the finalization period\n        vm.warp(ts + oracle.FINALIZATION_PERIOD_SECONDS());\n        assertEq(portal.isOutputFinalized(0), false);\n\n        // warp past the finalization period\n        vm.warp(ts + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        assertEq(portal.isOutputFinalized(0), true);\n    }\n\n    function test_isOutputFinalized_succeeds() external {\n        uint256 checkpoint = oracle.nextBlockNumber();\n        uint256 nextOutputIndex = oracle.nextOutputIndex();\n        vm.roll(checkpoint);\n        vm.warp(oracle.computeL2Timestamp(checkpoint) + 1);\n        vm.prank(trusted);\n        oracle.submitL2Output(keccak256(abi.encode(2)), checkpoint, 0, 0);\n\n        // warp to the final second of the finalization period\n        uint256 finalizationHorizon = block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS();\n        vm.warp(finalizationHorizon);\n        // The checkpointed block should not be finalized until 1 second from now.\n        assertEq(portal.isOutputFinalized(nextOutputIndex), false);\n        // Nor should a block after it\n        vm.expectRevert(stdError.indexOOBError);\n        assertEq(portal.isOutputFinalized(nextOutputIndex + 1), false);\n\n        // warp past the finalization period\n        vm.warp(finalizationHorizon + 1);\n        // It should now be finalized.\n        assertEq(portal.isOutputFinalized(nextOutputIndex), true);\n        // But not the block after it.\n        vm.expectRevert(stdError.indexOOBError);\n        assertEq(portal.isOutputFinalized(nextOutputIndex + 1), false);\n    }\n}\n\ncontract KromaPortal_FinalizeWithdrawal_Test is Portal_Initializer {\n    // Reusable default values for a test withdrawal\n    Types.WithdrawalTransaction _defaultTx;\n\n    uint256 _submittedOutputIndex;\n    uint256 _submittedBlockNumber;\n    bytes32 _stateRoot;\n    bytes32 _storageRoot;\n    bytes32 _outputRoot;\n    bytes32 _withdrawalHash;\n    bytes[] _withdrawalProof;\n    Types.OutputRootProof internal _outputRootProof;\n\n    // Use a constructor to set the storage vars above, so as to minimize the number of ffi calls.\n    constructor() {\n        super.setUp();\n        _defaultTx = Types.WithdrawalTransaction({\n            nonce: 0,\n            sender: alice,\n            target: bob,\n            value: 100,\n            gasLimit: 100_000,\n            data: hex\"\"\n        });\n        // Get withdrawal proof data we can use for testing.\n        (_stateRoot, _storageRoot, _outputRoot, _withdrawalHash, _withdrawalProof) = ffi\n            .getProveWithdrawalTransactionInputs(_defaultTx);\n\n        // Setup a dummy output root proof for reuse.\n        _outputRootProof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: _stateRoot,\n            messagePasserStorageRoot: _storageRoot,\n            blockHash: bytes32(uint256(0)),\n            nextBlockHash: bytes32(uint256(0))\n        });\n        _submittedBlockNumber = oracle.nextBlockNumber();\n        _submittedOutputIndex = oracle.nextOutputIndex();\n    }\n\n    // Get the system into a nice ready-to-use state.\n    function setUp() public override {\n        // Configure the oracle to return the output root we've prepared.\n        vm.warp(oracle.computeL2Timestamp(_submittedBlockNumber + 1));\n        vm.prank(trusted);\n        oracle.submitL2Output(_outputRoot, _submittedBlockNumber, 0, 0);\n\n        // Warp beyond the finalization period for the block we've submitted.\n        vm.warp(\n            oracle.getL2Output(_submittedOutputIndex).timestamp +\n                oracle.FINALIZATION_PERIOD_SECONDS() +\n                1\n        );\n        // Fund the portal so that we can withdraw ETH.\n        vm.deal(address(portal), 0xFFFFFFFF);\n    }\n\n    // Utility function used in the subsequent test. This is necessary to assert that the\n    // reentrant call will revert.\n    function callPortalAndExpectRevert() external payable {\n        vm.expectRevert(\"KromaPortal: can only trigger one withdrawal per transaction\");\n        // Arguments here don't matter, as the require check is the first thing that happens.\n        // We assume that this has already been proven.\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n        // Assert that the withdrawal was not finalized.\n        assertFalse(portal.finalizedWithdrawals(Hashing.hashWithdrawal(_defaultTx)));\n    }\n\n    /**\n     * @notice Proving withdrawal transactions should revert when paused\n     */\n    function test_proveWithdrawalTransaction_paused_reverts() external {\n        vm.prank(portal.GUARDIAN());\n        portal.pause();\n\n        vm.expectRevert(\"KromaPortal: paused\");\n        portal.proveWithdrawalTransaction({\n            _tx: _defaultTx,\n            _l2OutputIndex: _submittedOutputIndex,\n            _outputRootProof: _outputRootProof,\n            _withdrawalProof: _withdrawalProof\n        });\n    }\n\n    // Test: proveWithdrawalTransaction cannot prove a withdrawal with itself (the KromaPortal) as the target.\n    function test_proveWithdrawalTransaction_onSelfCall_reverts() external {\n        _defaultTx.target = address(portal);\n        vm.expectRevert(\"KromaPortal: you cannot send messages to the portal contract\");\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n\n    // Test: proveWithdrawalTransaction reverts if the outputRootProof does not match the output root\n    function test_proveWithdrawalTransaction_onInvalidOutputRootProof_reverts() external {\n        // Modify the version to invalidate the withdrawal proof.\n        _outputRootProof.version = bytes32(uint256(MAX_OUTPUT_ROOT_PROOF_VERSION + 1));\n        vm.expectRevert(\"Hashing: unknown output root proof version\");\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n\n    // Test: proveWithdrawalTransaction reverts if the passed transaction's withdrawalHash has\n    // already been proven.\n    function test_proveWithdrawalTransaction_replayProve_reverts() external {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        vm.expectRevert(\"KromaPortal: withdrawal hash has already been proven\");\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n\n    // Test: proveWithdrawalTransaction succeeds if the passed transaction's withdrawalHash has\n    // already been proven AND the output root has changed AND the l2BlockNumber stays the same.\n    function test_proveWithdrawalTransaction_replayProveChangedOutputRoot_succeeds() external {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Compute the storage slot of the outputRoot corresponding to the `withdrawalHash`\n        // inside of the `provenWithdrawal`s mapping.\n        bytes32 slot;\n        assembly {\n            mstore(0x00, sload(_withdrawalHash.slot))\n            mstore(0x20, 52) // 52 is the slot of the `provenWithdrawals` mapping in KromaPortal\n            slot := keccak256(0x00, 0x40)\n        }\n\n        // Store a different output root within the `provenWithdrawals` mapping without\n        // touching the l2BlockNumber or timestamp.\n        vm.store(address(portal), slot, bytes32(0));\n\n        // Warp ahead 1 second\n        vm.warp(block.timestamp + 1);\n\n        // Even though we have already proven this withdrawalHash, we should be allowed to re-submit\n        // our proof with a changed outputRoot\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Ensure that the withdrawal was updated within the mapping\n        (, uint128 timestamp, ) = portal.provenWithdrawals(_withdrawalHash);\n        assertEq(timestamp, block.timestamp);\n    }\n\n    // Test: proveWithdrawalTransaction succeeds if the passed transaction's withdrawalHash has\n    // already been proven AND the output root + output index + l2BlockNumber changes.\n    function test_proveWithdrawalTransaction_replayProveChangedOutputRootAndOutputIndex_succeeds()\n        external\n    {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Compute the storage slot of the outputRoot corresponding to the `withdrawalHash`\n        // inside of the `provenWithdrawal`s mapping.\n        bytes32 slot;\n        assembly {\n            mstore(0x00, sload(_withdrawalHash.slot))\n            mstore(0x20, 52) // 52 is the slot of the `provenWithdrawals` mapping in KromaPortal\n            slot := keccak256(0x00, 0x40)\n        }\n\n        // Store a dummy output root within the `provenWithdrawals` mapping without touching the\n        // l2BlockNumber or timestamp.\n        vm.store(address(portal), slot, bytes32(0));\n\n        // Fetch the checkpoint output at `_submittedOutputIndex` from the L2OutputOracle\n        Types.CheckpointOutput memory output = portal.L2_ORACLE().getL2Output(\n            _submittedOutputIndex\n        );\n\n        // Propose the same output root again, creating the same output at a different index + l2BlockNumber.\n        vm.startPrank(trusted);\n        portal.L2_ORACLE().submitL2Output(\n            output.outputRoot,\n            portal.L2_ORACLE().nextBlockNumber(),\n            blockhash(block.number),\n            block.number\n        );\n        vm.stopPrank();\n\n        // Warp ahead 1 second\n        vm.warp(block.timestamp + 1);\n\n        // Even though we have already proven this withdrawalHash, we should be allowed to re-submit\n        // our proof with a changed outputRoot + a different output index\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex + 1,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Ensure that the withdrawal was updated within the mapping\n        (, uint128 timestamp, ) = portal.provenWithdrawals(_withdrawalHash);\n        assertEq(timestamp, block.timestamp);\n    }\n\n    // Test: proveWithdrawalTransaction succeeds and emits the WithdrawalProven event.\n    function test_proveWithdrawalTransaction_validWithdrawalProof_succeeds() external {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n\n    // Test: finalizeWithdrawalTransaction succeeds and emits the WithdrawalFinalized event.\n    function test_finalizeWithdrawalTransaction_provenWithdrawalHash_succeeds() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        vm.expectEmit(true, true, false, true);\n        emit WithdrawalFinalized(_withdrawalHash, true);\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        assert(address(bob).balance == bobBalanceBefore + 100);\n    }\n\n    /**\n     * @notice Finalizing withdrawal transactions should revert when paused\n     */\n    function test_finalizeWithdrawalTransaction_paused_reverts() external {\n        vm.prank(portal.GUARDIAN());\n        portal.pause();\n\n        vm.expectRevert(\"KromaPortal: paused\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the withdrawal has not been proven.\n    function test_finalizeWithdrawalTransaction_ifWithdrawalNotProven_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        vm.expectRevert(\"KromaPortal: withdrawal has not been proven yet\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        assert(address(bob).balance == bobBalanceBefore);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if withdrawal not proven long enough ago.\n    function test_finalizeWithdrawalTransaction_ifWithdrawalProofNotOldEnough_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Mock a call where the resulting output root is anything but the original output root. In\n        // this case we just use bytes32(uint256(1)).\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(bytes32(uint256(1)), _submittedBlockNumber)\n        );\n\n        vm.expectRevert(\"KromaPortal: proven withdrawal finalization period has not elapsed\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        assert(address(bob).balance == bobBalanceBefore);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the provenWithdrawal's timestamp is less\n    // than the L2 output oracle's starting timestamp\n    function test_finalizeWithdrawalTransaction_timestampLessThanL2OracleStart_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        // Prove our withdrawal\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Warp to after the finalization period\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Mock a startingTimestamp change on the L2 Oracle\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSignature(\"startingTimestamp()\"),\n            abi.encode(block.timestamp + 1)\n        );\n\n        // Attempt to finalize the withdrawal\n        vm.expectRevert(\"KromaPortal: withdrawal timestamp less than L2 Oracle starting timestamp\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        // Ensure that bob's balance has remained the same\n        assertEq(bobBalanceBefore, address(bob).balance);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the output root proven is not the same as the\n    // output root at the time of finalization.\n    function test_finalizeWithdrawalTransaction_ifOutputRootChanges_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        // Prove our withdrawal\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Warp to after the finalization period\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Mock an outputRoot change on the checkpoint output before attempting\n        // to finalize the withdrawal.\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.CheckpointOutput(\n                    trusted,\n                    bytes32(uint256(0)),\n                    uint128(block.timestamp),\n                    uint128(_submittedBlockNumber)\n                )\n            )\n        );\n\n        // Attempt to finalize the withdrawal\n        vm.expectRevert(\"KromaPortal: output root proven is not the same as current output root\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        // Ensure that bob's balance has remained the same\n        assertEq(bobBalanceBefore, address(bob).balance);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the checkpoint output's timestamp has\n    // not passed the finalization period.\n    function test_finalizeWithdrawalTransaction_ifOutputTimestampIsNotFinalized_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        // Prove our withdrawal\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Warp to after the finalization period\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Mock a timestamp change on the checkpoint output that has not passed the\n        // finalization period.\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.CheckpointOutput(\n                    trusted,\n                    _outputRoot,\n                    uint128(block.timestamp + 1),\n                    uint128(_submittedBlockNumber)\n                )\n            )\n        );\n\n        // Attempt to finalize the withdrawal\n        vm.expectRevert(\"KromaPortal: checkpoint output finalization period has not elapsed\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        // Ensure that bob's balance has remained the same\n        assertEq(bobBalanceBefore, address(bob).balance);\n    }\n\n    // Test: finalizeWithdrawalTransaction fails because the target reverts,\n    // and emits the WithdrawalFinalized event with success=false.\n    function test_finalizeWithdrawalTransaction_targetFails_fails() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n        vm.etch(bob, hex\"fe\"); // Contract with just the invalid opcode.\n\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalFinalized(_withdrawalHash, false);\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        assert(address(bob).balance == bobBalanceBefore);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the finalization period has not yet passed.\n    function test_finalizeWithdrawalTransaction_onRecentWithdrawal_reverts() external {\n        // Setup the Oracle to return an output with a recent timestamp\n        uint256 recentTimestamp = block.timestamp - 1000;\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.CheckpointOutput(\n                    trusted,\n                    _outputRoot,\n                    uint128(recentTimestamp),\n                    uint128(_submittedBlockNumber)\n                )\n            )\n        );\n\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        vm.expectRevert(\"KromaPortal: proven withdrawal finalization period has not elapsed\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the withdrawal has already been finalized.\n    function test_finalizeWithdrawalTransaction_onReplay_reverts() external {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalFinalized(_withdrawalHash, true);\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        vm.expectRevert(\"KromaPortal: withdrawal has already been finalized\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if insufficient gas is supplied.\n    function test_finalizeWithdrawalTransaction_onInsufficientGas_reverts() external {\n        // This number was identified through trial and error.\n        uint256 gasLimit = 150_000;\n        Types.WithdrawalTransaction memory insufficientGasTx = Types.WithdrawalTransaction({\n            nonce: 0,\n            sender: alice,\n            target: bob,\n            value: 100,\n            gasLimit: gasLimit,\n            data: hex\"\"\n        });\n\n        // Get updated proof inputs.\n        (bytes32 stateRoot, bytes32 storageRoot, , , bytes[] memory withdrawalProof) = ffi\n            .getProveWithdrawalTransactionInputs(insufficientGasTx);\n        Types.OutputRootProof memory outputRootProof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: stateRoot,\n            messagePasserStorageRoot: storageRoot,\n            blockHash: bytes32(uint256(0)),\n            nextBlockHash: bytes32(uint256(0))\n        });\n\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.CheckpointOutput(\n                    trusted,\n                    Hashing.hashOutputRootProof(outputRootProof),\n                    uint128(block.timestamp),\n                    uint128(_submittedBlockNumber)\n                )\n            )\n        );\n\n        portal.proveWithdrawalTransaction(\n            insufficientGasTx,\n            _submittedOutputIndex,\n            outputRootProof,\n            withdrawalProof\n        );\n\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        vm.expectRevert(\"SafeCall: Not enough gas\");\n        portal.finalizeWithdrawalTransaction{ gas: gasLimit }(insufficientGasTx);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if a sub-call attempts to finalize another\n    // withdrawal.\n    function test_finalizeWithdrawalTransaction_onReentrancy_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        // Copy and modify the default test values to attempt a reentrant call by first calling to\n        // this contract's callPortalAndExpectRevert() function above.\n        Types.WithdrawalTransaction memory _testTx = _defaultTx;\n        _testTx.target = address(this);\n        _testTx.data = abi.encodeWithSelector(this.callPortalAndExpectRevert.selector);\n\n        // Get modified proof inputs.\n        (\n            bytes32 stateRoot,\n            bytes32 storageRoot,\n            bytes32 outputRoot,\n            bytes32 withdrawalHash,\n            bytes[] memory withdrawalProof\n        ) = ffi.getProveWithdrawalTransactionInputs(_testTx);\n        Types.OutputRootProof memory outputRootProof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: stateRoot,\n            messagePasserStorageRoot: storageRoot,\n            blockHash: bytes32(uint256(0)),\n            nextBlockHash: bytes32(uint256(0))\n        });\n\n        // Setup the Oracle to return the outputRoot we want as well as a finalized timestamp.\n        uint256 finalizedTimestamp = block.timestamp - oracle.FINALIZATION_PERIOD_SECONDS() - 1;\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.CheckpointOutput(\n                    trusted,\n                    outputRoot,\n                    uint128(finalizedTimestamp),\n                    uint128(_submittedBlockNumber)\n                )\n            )\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(withdrawalHash, alice, address(this));\n        portal.proveWithdrawalTransaction(\n            _testTx,\n            _submittedBlockNumber,\n            outputRootProof,\n            withdrawalProof\n        );\n\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        vm.expectCall(address(this), _testTx.data);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalFinalized(withdrawalHash, true);\n        portal.finalizeWithdrawalTransaction(_testTx);\n\n        // Ensure that bob's balance was not changed by the reentrant call.\n        assert(address(bob).balance == bobBalanceBefore);\n    }\n\n    function testDiff_finalizeWithdrawalTransaction_succeeds(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        vm.assume(\n            _target != address(portal) && // Cannot call the kroma portal or a contract\n                _target.code.length == 0 && // No accounts with code\n                _target != CONSOLE && // The console has no code but behaves like a contract\n                uint160(_target) > 9 // No precompiles (or zero address)\n        );\n\n        // Total ETH supply is currently about 120M ETH.\n        uint256 value = bound(_value, 0, 200_000_000 ether);\n        vm.deal(address(portal), value);\n\n        uint256 gasLimit = bound(_gasLimit, 0, 50_000_000);\n        uint256 nonce = messagePasser.messageNonce();\n\n        // Get a withdrawal transaction and mock proof from the differential testing script.\n        Types.WithdrawalTransaction memory _tx = Types.WithdrawalTransaction({\n            nonce: nonce,\n            sender: _sender,\n            target: _target,\n            value: value,\n            gasLimit: gasLimit,\n            data: _data\n        });\n        (\n            bytes32 stateRoot,\n            bytes32 storageRoot,\n            bytes32 outputRoot,\n            bytes32 withdrawalHash,\n            bytes[] memory withdrawalProof\n        ) = ffi.getProveWithdrawalTransactionInputs(_tx);\n\n        // Create the output root proof\n        Types.OutputRootProof memory proof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: stateRoot,\n            messagePasserStorageRoot: storageRoot,\n            blockHash: bytes32(uint256(0)),\n            nextBlockHash: bytes32(uint256(0))\n        });\n\n        // Ensure the values returned from ffi are correct\n        assertEq(outputRoot, Hashing.hashOutputRootProof(proof));\n        assertEq(withdrawalHash, Hashing.hashWithdrawal(_tx));\n\n        // Setup the Oracle to return the outputRoot\n        vm.mockCall(\n            address(oracle),\n            abi.encodeWithSelector(oracle.getL2Output.selector),\n            abi.encode(address(0), outputRoot, block.timestamp, 100)\n        );\n\n        // Prove the withdrawal transaction\n        portal.proveWithdrawalTransaction(\n            _tx,\n            1, // l2OutputIndex\n            proof,\n            withdrawalProof\n        );\n        (bytes32 _root, , ) = portal.provenWithdrawals(withdrawalHash);\n        assertTrue(_root != bytes32(0));\n\n        // Warp past the finalization period\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Finalize the withdrawal transaction\n        vm.expectCallMinGas(_tx.target, _tx.value, uint64(_tx.gasLimit), _tx.data);\n        portal.finalizeWithdrawalTransaction(_tx);\n        assertTrue(portal.finalizedWithdrawals(withdrawalHash));\n    }\n}\n\ncontract KromaPortalUpgradeable_Test is Portal_Initializer {\n    Proxy internal proxy;\n    uint64 initialBlockNum;\n\n    function setUp() public override {\n        super.setUp();\n        initialBlockNum = uint64(block.number);\n        proxy = Proxy(payable(address(portal)));\n    }\n\n    function test_params_initValuesOnProxy_succeeds() external {\n        KromaPortal p = KromaPortal(payable(address(proxy)));\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = p.params();\n        ResourceMetering.ResourceConfig memory rcfg = systemConfig.resourceConfig();\n\n        assertEq(prevBaseFee, rcfg.minimumBaseFee);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum);\n    }\n\n    function test_initialize_cannotInitProxy_reverts() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        KromaPortal(payable(proxy)).initialize(false);\n    }\n\n    function test_initialize_cannotInitImpl_reverts() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        KromaPortal(portalImpl).initialize(false);\n    }\n\n    function test_upgradeToAndCall_upgrading_succeeds() external {\n        // Check an unused slot before upgrading.\n        bytes32 slot21Before = vm.load(address(portal), bytes32(uint256(21)));\n        assertEq(bytes32(0), slot21Before);\n\n        NextImpl nextImpl = new NextImpl();\n        vm.startPrank(multisig);\n        proxy.upgradeToAndCall(\n            address(nextImpl),\n            abi.encodeWithSelector(NextImpl.initialize.selector)\n        );\n        assertEq(proxy.implementation(), address(nextImpl));\n\n        // Verify that the NextImpl contract initialized its values according as expected\n        bytes32 slot21After = vm.load(address(portal), bytes32(uint256(21)));\n        bytes32 slot21Expected = NextImpl(address(portal)).slot21Init();\n        assertEq(slot21Expected, slot21After);\n    }\n}\n\n/**\n * @title KromaPortalResourceFuzz_Test\n * @dev Test various values of the resource metering config to ensure that deposits cannot be\n *         broken by changing the config.\n */\ncontract KromaPortalResourceFuzz_Test is Portal_Initializer {\n    /**\n     * @dev The max gas limit observed throughout this test. Setting this too high can cause\n     *      the test to take too long to run.\n     */\n    uint256 constant MAX_GAS_LIMIT = 30_000_000;\n\n    /**\n     * @dev Test that various values of the resource metering config will not break deposits.\n     */\n    function testFuzz_systemConfigDeposit_succeeds(\n        uint32 _maxResourceLimit,\n        uint8 _elasticityMultiplier,\n        uint8 _baseFeeMaxChangeDenominator,\n        uint32 _minimumBaseFee,\n        uint32 _systemTxMaxGas,\n        uint128 _maximumBaseFee,\n        uint64 _gasLimit,\n        uint64 _prevBoughtGas,\n        uint128 _prevBaseFee,\n        uint8 _blockDiff\n    ) external {\n        // Get the set system gas limit\n        uint64 gasLimit = systemConfig.gasLimit();\n        // Bound resource config\n        _maxResourceLimit = uint32(bound(_maxResourceLimit, 21000, MAX_GAS_LIMIT / 8));\n        _gasLimit = uint64(bound(_gasLimit, 21000, _maxResourceLimit));\n        _prevBaseFee = uint128(bound(_prevBaseFee, 0, 5 gwei));\n        // Prevent values that would cause reverts\n        vm.assume(gasLimit >= _gasLimit);\n        vm.assume(_minimumBaseFee < _maximumBaseFee);\n        vm.assume(_baseFeeMaxChangeDenominator > 1);\n        vm.assume(uint256(_maxResourceLimit) + uint256(_systemTxMaxGas) <= gasLimit);\n        vm.assume(_elasticityMultiplier > 0);\n        vm.assume(\n            ((_maxResourceLimit / _elasticityMultiplier) * _elasticityMultiplier) ==\n                _maxResourceLimit\n        );\n        _prevBoughtGas = uint64(bound(_prevBoughtGas, 0, _maxResourceLimit - _gasLimit));\n        _blockDiff = uint8(bound(_blockDiff, 0, 3));\n\n        // Create a resource config to mock the call to the system config with\n        ResourceMetering.ResourceConfig memory rcfg = ResourceMetering.ResourceConfig({\n            maxResourceLimit: _maxResourceLimit,\n            elasticityMultiplier: _elasticityMultiplier,\n            baseFeeMaxChangeDenominator: _baseFeeMaxChangeDenominator,\n            minimumBaseFee: _minimumBaseFee,\n            systemTxMaxGas: _systemTxMaxGas,\n            maximumBaseFee: _maximumBaseFee\n        });\n        vm.mockCall(\n            address(systemConfig),\n            abi.encodeWithSelector(systemConfig.resourceConfig.selector),\n            abi.encode(rcfg)\n        );\n\n        // Set the resource params\n        uint256 _prevBlockNum = block.number - _blockDiff;\n        vm.store(\n            address(portal),\n            bytes32(uint256(1)),\n            bytes32((_prevBlockNum << 192) | (uint256(_prevBoughtGas) << 128) | _prevBaseFee)\n        );\n        // Ensure that the storage setting is correct\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = portal.params();\n        assertEq(prevBaseFee, _prevBaseFee);\n        assertEq(prevBoughtGas, _prevBoughtGas);\n        assertEq(prevBlockNum, _prevBlockNum);\n\n        // Do a deposit, should not revert\n        portal.depositTransaction{ gas: MAX_GAS_LIMIT }({\n            _to: address(0x20),\n            _value: 0x40,\n            _gasLimit: _gasLimit,\n            _isCreation: false,\n            _data: hex\"\"\n        });\n    }\n}\n"
    },
    "contracts/test/L1Block.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { L1Block } from \"../L2/L1Block.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract L1BlockTest is CommonTest {\n    L1Block lb;\n    address depositor;\n    bytes32 immutable NON_ZERO_HASH = keccak256(abi.encode(1));\n\n    function setUp() public override {\n        super.setUp();\n        lb = new L1Block();\n        depositor = lb.DEPOSITOR_ACCOUNT();\n        vm.prank(depositor);\n        lb.setL1BlockValues({\n            _number: uint64(1),\n            _timestamp: uint64(2),\n            _basefee: 3,\n            _hash: NON_ZERO_HASH,\n            _sequenceNumber: uint64(4),\n            _batcherHash: bytes32(0),\n            _l1FeeOverhead: 2,\n            _l1FeeScalar: 3,\n            _validatorRewardScalar: 1\n        });\n    }\n\n    function testFuzz_updatesValues_succeeds(\n        uint64 n,\n        uint64 t,\n        uint256 b,\n        bytes32 h,\n        uint64 s,\n        bytes32 bt,\n        uint256 fo,\n        uint256 fs,\n        uint256 vrr\n    ) external {\n        vrr = bound(vrr, 0, 10000);\n        vm.prank(depositor);\n        lb.setL1BlockValues(n, t, b, h, s, bt, fo, fs, vrr);\n        assertEq(lb.number(), n);\n        assertEq(lb.timestamp(), t);\n        assertEq(lb.basefee(), b);\n        assertEq(lb.hash(), h);\n        assertEq(lb.sequenceNumber(), s);\n        assertEq(lb.batcherHash(), bt);\n        assertEq(lb.l1FeeOverhead(), fo);\n        assertEq(lb.l1FeeScalar(), fs);\n        assertEq(lb.validatorRewardScalar(), vrr);\n    }\n\n    function test_number_succeeds() external {\n        assertEq(lb.number(), uint64(1));\n    }\n\n    function test_timestamp_succeeds() external {\n        assertEq(lb.timestamp(), uint64(2));\n    }\n\n    function test_basefee_succeeds() external {\n        assertEq(lb.basefee(), 3);\n    }\n\n    function test_hash_succeeds() external {\n        assertEq(lb.hash(), NON_ZERO_HASH);\n    }\n\n    function test_sequenceNumber_succeeds() external {\n        assertEq(lb.sequenceNumber(), uint64(4));\n    }\n\n    function test_updateValues_succeeds() external {\n        vm.prank(depositor);\n        lb.setL1BlockValues({\n            _number: type(uint64).max,\n            _timestamp: type(uint64).max,\n            _basefee: type(uint256).max,\n            _hash: keccak256(abi.encode(1)),\n            _sequenceNumber: type(uint64).max,\n            _batcherHash: bytes32(type(uint256).max),\n            _l1FeeOverhead: type(uint256).max,\n            _l1FeeScalar: type(uint256).max,\n            _validatorRewardScalar: 10000\n        });\n    }\n}\n"
    },
    "contracts/test/L1CrossDomainMessenger.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { KromaPortal } from \"../L1/KromaPortal.sol\";\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Messenger_Initializer, Reverter, ConfigurableCaller } from \"./CommonTest.t.sol\";\nimport { L2OutputOracle_Initializer } from \"./L2OutputOracle.t.sol\";\n\ncontract L1CrossDomainMessenger_Test is Messenger_Initializer {\n    // Receiver address for testing\n    address recipient = address(0xabbaacdc);\n\n    // Storage slot of the l2Sender\n    uint256 constant senderSlotIndex = 50;\n\n    // the version is encoded in the nonce\n    function test_messageVersion_succeeds() external {\n        (, uint16 version) = Encoding.decodeVersionedNonce(L1Messenger.messageNonce());\n        assertEq(version, L1Messenger.MESSAGE_VERSION());\n    }\n\n    // sendMessage: should be able to send a single message\n    function test_sendMessage_succeeds() external {\n        // deposit transaction on the kroma portal should be called\n        vm.expectCall(\n            address(portal),\n            abi.encodeWithSelector(\n                KromaPortal.depositTransaction.selector,\n                Predeploys.L2_CROSS_DOMAIN_MESSENGER,\n                0,\n                L1Messenger.baseGas(hex\"ff\", 100),\n                false,\n                Encoding.encodeCrossDomainMessage(\n                    L1Messenger.messageNonce(),\n                    alice,\n                    recipient,\n                    0,\n                    100,\n                    hex\"ff\"\n                )\n            )\n        );\n\n        // TransactionDeposited event\n        vm.expectEmit(true, true, true, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)),\n            Predeploys.L2_CROSS_DOMAIN_MESSENGER,\n            0,\n            0,\n            L1Messenger.baseGas(hex\"ff\", 100),\n            false,\n            Encoding.encodeCrossDomainMessage(\n                L1Messenger.messageNonce(),\n                alice,\n                recipient,\n                0,\n                100,\n                hex\"ff\"\n            )\n        );\n\n        // SentMessage event\n        vm.expectEmit(true, true, true, true);\n        emit SentMessage(recipient, alice, 0, hex\"ff\", L1Messenger.messageNonce(), 100);\n\n        vm.prank(alice);\n        L1Messenger.sendMessage(recipient, hex\"ff\", uint32(100));\n    }\n\n    // sendMessage: should be able to send the same message twice\n    function test_sendMessage_twice_succeeds() external {\n        uint256 nonce = L1Messenger.messageNonce();\n        L1Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        L1Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        // the nonce increments for each message sent\n        assertEq(nonce + 2, L1Messenger.messageNonce());\n    }\n\n    function test_xDomainSender_notSet_reverts() external {\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L1Messenger.xDomainMessageSender();\n    }\n\n    function test_relayMessage_v2_reverts() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        // Set the value of portal.l2Sender() to be the L2 Cross Domain Messenger.\n        vm.store(address(portal), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n\n        // Expect a revert.\n        vm.expectRevert(\"CrossDomainMessenger: only version 0 messages is supported at this time\");\n\n        // Try to relay a v2 message.\n        vm.prank(address(portal));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 2 }), // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            hex\"1111\"\n        );\n    }\n\n    // relayMessage: should send a successful call to the target contract\n    function test_relayMessage_succeeds() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        vm.expectCall(target, hex\"1111\");\n\n        // set the value of portal.l2Sender() to be the L2 Cross Domain Messenger.\n        vm.store(address(portal), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n        vm.prank(address(portal));\n\n        vm.expectEmit(true, true, true, true);\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            hex\"1111\"\n        );\n\n        emit RelayedMessage(hash);\n\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            hex\"1111\"\n        );\n\n        // the message hash is in the successfulMessages mapping\n        assert(L1Messenger.successfulMessages(hash));\n        // it is not in the received messages mapping\n        assertEq(L1Messenger.failedMessages(hash), false);\n    }\n\n    // relayMessage: should revert if attempting to relay a message sent to an L1 system contract\n    function test_relayMessage_toSystemContract_reverts() external {\n        // set the target to be the KromaPortal\n        address target = address(portal);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n        bytes memory message = hex\"1111\";\n\n        vm.prank(address(portal));\n        vm.expectRevert(\"CrossDomainMessenger: message cannot be replayed\");\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            message\n        );\n\n        vm.store(address(portal), 0, bytes32(abi.encode(sender)));\n        vm.expectRevert(\"CrossDomainMessenger: message cannot be replayed\");\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            message\n        );\n    }\n\n    // relayMessage: should revert if eth is sent from a contract other than the standard bridge\n    function test_replayMessage_withValue_reverts() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n        bytes memory message = hex\"1111\";\n\n        vm.expectRevert(\n            \"CrossDomainMessenger: value must be zero unless message is from a system address\"\n        );\n        L1Messenger.relayMessage{ value: 100 }(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            message\n        );\n    }\n\n    // relayMessage: the xDomainMessageSender is reset to the original value\n    function test_xDomainMessageSender_reset_succeeds() external {\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L1Messenger.xDomainMessageSender();\n\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        vm.store(address(portal), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n        vm.prank(address(portal));\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            address(0),\n            address(0),\n            0,\n            0,\n            hex\"\"\n        );\n\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L1Messenger.xDomainMessageSender();\n    }\n\n    // relayMessage: should send a successful call to the target contract after the first message\n    // fails and ETH gets stuck, but the second message succeeds\n    function test_relayMessage_retryAfterFailure_succeeds() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n        uint256 value = 100;\n\n        vm.expectCall(target, hex\"1111\");\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        vm.store(address(portal), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n        vm.etch(target, address(new Reverter()).code);\n        vm.deal(address(portal), value);\n        vm.prank(address(portal));\n        L1Messenger.relayMessage{ value: value }(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        assertEq(address(L1Messenger).balance, value);\n        assertEq(address(target).balance, 0);\n        assertEq(L1Messenger.successfulMessages(hash), false);\n        assertEq(L1Messenger.failedMessages(hash), true);\n\n        vm.expectEmit(true, true, true, true);\n\n        emit RelayedMessage(hash);\n\n        vm.etch(target, address(0).code);\n        vm.prank(address(sender));\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        assertEq(address(L1Messenger).balance, 0);\n        assertEq(address(target).balance, value);\n        assertEq(L1Messenger.successfulMessages(hash), true);\n        assertEq(L1Messenger.failedMessages(hash), true);\n    }\n}\n"
    },
    "contracts/test/L1ERC721Bridge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport { L1ERC721Bridge } from \"../L1/L1ERC721Bridge.sol\";\nimport { L2ERC721Bridge } from \"../L2/L2ERC721Bridge.sol\";\nimport { Messenger_Initializer } from \"./CommonTest.t.sol\";\n\ncontract TestERC721 is ERC721 {\n    constructor() ERC721(\"Test\", \"TST\") {}\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n}\n\ncontract L1ERC721Bridge_Test is Messenger_Initializer {\n    TestERC721 internal localToken;\n    TestERC721 internal remoteToken;\n    L1ERC721Bridge internal bridge;\n    address internal constant otherBridge = address(0x3456);\n    uint256 internal constant tokenId = 1;\n\n    event ERC721BridgeInitiated(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    event ERC721BridgeFinalized(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    function setUp() public override {\n        super.setUp();\n\n        // Create necessary contracts.\n        bridge = new L1ERC721Bridge(address(L1Messenger), otherBridge);\n        localToken = new TestERC721();\n        remoteToken = new TestERC721();\n\n        // Label the bridge so we get nice traces.\n        vm.label(address(bridge), \"L1ERC721Bridge\");\n\n        // Mint alice a token.\n        localToken.mint(alice, tokenId);\n\n        // Approve the bridge to transfer the token.\n        vm.prank(alice);\n        localToken.approve(address(bridge), tokenId);\n    }\n\n    function test_constructor_succeeds() public {\n        assertEq(address(bridge.MESSENGER()), address(L1Messenger));\n        assertEq(address(bridge.OTHER_BRIDGE()), otherBridge);\n    }\n\n    function test_bridgeERC721_succeeds() public {\n        // Expect a call to the messenger.\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeCall(\n                L1Messenger.sendMessage,\n                (\n                    address(otherBridge),\n                    abi.encodeCall(\n                        L2ERC721Bridge.finalizeBridgeERC721,\n                        (\n                            address(remoteToken),\n                            address(localToken),\n                            alice,\n                            alice,\n                            tokenId,\n                            hex\"5678\"\n                        )\n                    ),\n                    1234\n                )\n            )\n        );\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeInitiated(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), true);\n        assertEq(localToken.ownerOf(tokenId), address(bridge));\n    }\n\n    function test_bridgeERC721_fromContract_reverts() external {\n        // Bridge the token.\n        vm.etch(alice, hex\"01\");\n        vm.prank(alice);\n        vm.expectRevert(\"ERC721Bridge: account is not externally owned\");\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_localTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert();\n        bridge.bridgeERC721(address(0), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_remoteTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert(\"L1ERC721Bridge: remote token cannot be address(0)\");\n        bridge.bridgeERC721(address(localToken), address(0), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_wrongOwner_reverts() external {\n        // Bridge the token.\n        vm.prank(bob);\n        vm.expectRevert(\"ERC721: transfer from incorrect owner\");\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_succeeds() external {\n        // Expect a call to the messenger.\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeCall(\n                L1Messenger.sendMessage,\n                (\n                    address(otherBridge),\n                    abi.encodeCall(\n                        L2ERC721Bridge.finalizeBridgeERC721,\n                        (address(remoteToken), address(localToken), alice, bob, tokenId, hex\"5678\")\n                    ),\n                    1234\n                )\n            )\n        );\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeInitiated(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            bob,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721To(\n            address(localToken),\n            address(remoteToken),\n            bob,\n            tokenId,\n            1234,\n            hex\"5678\"\n        );\n\n        // Token is locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), true);\n        assertEq(localToken.ownerOf(tokenId), address(bridge));\n    }\n\n    function test_bridgeERC721To_localTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert();\n        bridge.bridgeERC721To(address(0), address(remoteToken), bob, tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_remoteTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert(\"L1ERC721Bridge: remote token cannot be address(0)\");\n        bridge.bridgeERC721To(address(localToken), address(0), bob, tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_wrongOwner_reverts() external {\n        // Bridge the token.\n        vm.prank(bob);\n        vm.expectRevert(\"ERC721: transfer from incorrect owner\");\n        bridge.bridgeERC721To(\n            address(localToken),\n            address(remoteToken),\n            bob,\n            tokenId,\n            1234,\n            hex\"5678\"\n        );\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_finalizeBridgeERC721_succeeds() external {\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeFinalized(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(L1Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L1Messenger));\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_finalizeBridgeERC721_notViaLocalMessenger_reverts() external {\n        // Finalize a withdrawal.\n        vm.prank(alice);\n        vm.expectRevert(\"ERC721Bridge: function can only be called from the other bridge\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_notFromRemoteMessenger_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(L1Messenger.xDomainMessageSender.selector),\n            abi.encode(alice)\n        );\n        vm.prank(address(L1Messenger));\n        vm.expectRevert(\"ERC721Bridge: function can only be called from the other bridge\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_selfToken_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(L1Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L1Messenger));\n        vm.expectRevert(\"L1ERC721Bridge: local token cannot be self\");\n        bridge.finalizeBridgeERC721(\n            address(bridge),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_notEscrowed_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(L1Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L1Messenger));\n        vm.expectRevert(\"L1ERC721Bridge: Token ID is not escrowed in the L1 Bridge\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n}\n"
    },
    "contracts/test/L1StandardBridge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { stdStorage, StdStorage } from \"forge-std/Test.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { KromaPortal } from \"../L1/KromaPortal.sol\";\nimport { L2StandardBridge } from \"../L2/L2StandardBridge.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\n\ncontract L1StandardBridge_Getter_Test is Bridge_Initializer {\n    function test_getters_succeeds() external view {\n        assert(L1Bridge.OTHER_BRIDGE() == L2Bridge);\n        assert(L1Bridge.MESSENGER() == L1Messenger);\n    }\n}\n\ncontract L1StandardBridge_Initialize_Test is Bridge_Initializer {\n    function test_initialize_succeeds() external {\n        assertEq(address(L1Bridge.MESSENGER()), address(L1Messenger));\n\n        assertEq(address(L1Bridge.OTHER_BRIDGE()), Predeploys.L2_STANDARD_BRIDGE);\n\n        assertEq(address(L2Bridge), Predeploys.L2_STANDARD_BRIDGE);\n    }\n}\n\ncontract L1StandardBridge_Initialize_TestFail is Bridge_Initializer {}\n\ncontract L1StandardBridge_Receive_Test is Bridge_Initializer {\n    // receive\n    // - can accept ETH\n    function test_receive_succeeds() external {\n        assertEq(address(portal).balance, 0);\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHBridgeInitiated(alice, alice, 100, hex\"\");\n\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                abi.encodeWithSelector(\n                    StandardBridge.finalizeBridgeETH.selector,\n                    alice,\n                    alice,\n                    100,\n                    hex\"\"\n                ),\n                200_000\n            )\n        );\n\n        vm.prank(alice, alice);\n        (bool success, ) = address(L1Bridge).call{ value: 100 }(hex\"\");\n        assertEq(success, true);\n        assertEq(address(portal).balance, 100);\n    }\n}\n\ncontract L1StandardBridge_Receive_TestFail {}\n\ncontract PreBridgeETH is Bridge_Initializer {\n    function _preBridgeETH() internal {\n        assertEq(address(portal).balance, 0);\n        uint256 nonce = L1Messenger.messageNonce();\n        uint256 version = 0; // Internal constant in the KromaPortal: DEPOSIT_VERSION\n        address l1MessengerAliased = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeETH.selector,\n            alice,\n            alice,\n            500,\n            hex\"dead\"\n        );\n\n        vm.expectCall(\n            address(L1Bridge),\n            500,\n            abi.encodeWithSelector(L1Bridge.bridgeETH.selector, 50000, hex\"dead\")\n        );\n\n        vm.expectCall(\n            address(L1Messenger),\n            500,\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                message,\n                50000\n            )\n        );\n\n        bytes memory innerMessage = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L1Bridge),\n            address(L2Bridge),\n            500,\n            50000,\n            message\n        );\n\n        uint64 baseGas = L1Messenger.baseGas(message, 50000);\n        vm.expectCall(\n            address(portal),\n            500,\n            abi.encodeWithSelector(\n                KromaPortal.depositTransaction.selector,\n                address(L2Messenger),\n                500,\n                baseGas,\n                false,\n                innerMessage\n            )\n        );\n\n        bytes memory opaqueData = abi.encodePacked(\n            uint256(500),\n            uint256(500),\n            baseGas,\n            false,\n            innerMessage\n        );\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHBridgeInitiated(alice, alice, 500, hex\"dead\");\n\n        // KromaPortal emits a TransactionDeposited event on `depositTransaction` call\n        vm.expectEmit(true, true, true, true, address(portal));\n        emit TransactionDeposited(l1MessengerAliased, address(L2Messenger), version, opaqueData);\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L1Messenger));\n        emit SentMessage(address(L2Bridge), address(L1Bridge), 500, message, nonce, 50000);\n\n        vm.prank(alice, alice);\n    }\n}\n\ncontract L1StandardBridge_BridgeETH_Test is PreBridgeETH {\n    // BridgeETH\n    // - emits ETHBridgeInitiated\n    // - calls kromaPortal.depositTransaction\n    // - only EOA\n    // - ETH ends up in the kromaPortal\n    function test_bridgeETH_succeeds() external {\n        _preBridgeETH();\n        L1Bridge.bridgeETH{ value: 500 }(50000, hex\"dead\");\n        assertEq(address(portal).balance, 500);\n    }\n}\n\ncontract L1StandardBridge_BridgeETH_TestFail is Bridge_Initializer {\n    function test_BridgeETH_notEoa_reverts() external {\n        // turn alice into a contract\n        vm.etch(alice, address(L1Token).code);\n\n        vm.expectRevert(\"StandardBridge: function can only be called from an EOA\");\n        vm.prank(alice);\n        L1Bridge.bridgeETH{ value: 1 }(300, hex\"\");\n    }\n}\n\ncontract PreBridgeETHTo is Bridge_Initializer {\n    function _preBridgeETHTo() internal {\n        assertEq(address(portal).balance, 0);\n        uint256 nonce = L1Messenger.messageNonce();\n        uint256 version = 0; // Internal constant in the KromaPortal: DEPOSIT_VERSION\n        address l1MessengerAliased = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        vm.expectCall(\n            address(L1Bridge),\n            600,\n            abi.encodeWithSelector(L1Bridge.bridgeETHTo.selector, bob, 60000, hex\"dead\")\n        );\n\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeETH.selector,\n            alice,\n            bob,\n            600,\n            hex\"dead\"\n        );\n\n        // the L1 bridge should call\n        // L1CrossDomainMessenger.sendMessage\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                message,\n                60000\n            )\n        );\n\n        bytes memory innerMessage = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L1Bridge),\n            address(L2Bridge),\n            600,\n            60000,\n            message\n        );\n\n        uint64 baseGas = L1Messenger.baseGas(message, 60000);\n        vm.expectCall(\n            address(portal),\n            abi.encodeWithSelector(\n                KromaPortal.depositTransaction.selector,\n                address(L2Messenger),\n                600,\n                baseGas,\n                false,\n                innerMessage\n            )\n        );\n\n        bytes memory opaqueData = abi.encodePacked(\n            uint256(600),\n            uint256(600),\n            baseGas,\n            false,\n            innerMessage\n        );\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHBridgeInitiated(alice, bob, 600, hex\"dead\");\n\n        // KromaPortal emits a TransactionDeposited event on `depositTransaction` call\n        vm.expectEmit(true, true, true, true, address(portal));\n        emit TransactionDeposited(l1MessengerAliased, address(L2Messenger), version, opaqueData);\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L1Messenger));\n        emit SentMessage(address(L2Bridge), address(L1Bridge), 600, message, nonce, 60000);\n\n        // deposit eth to bob\n        vm.prank(alice, alice);\n    }\n}\n\ncontract L1StandardBridge_BridgeETHTo_Test is PreBridgeETHTo {\n    // BridgeETHTo\n    // - emits ETHBridgeInitiated\n    // - calls kromaPortal.depositTransaction\n    // - only EOA\n    // - ETH ends up in the kromaPortal\n    function test_bridgeETHTo_succeeds() external {\n        _preBridgeETHTo();\n        L1Bridge.bridgeETHTo{ value: 600 }(bob, 60000, hex\"dead\");\n        assertEq(address(portal).balance, 600);\n    }\n}\n\ncontract L1StandardBridge_BridgeETHTo_TestFail is Bridge_Initializer {}\n\ncontract L1StandardBridge_BridgeERC20_Test is Bridge_Initializer {\n    using stdStorage for StdStorage;\n\n    // bridgeERC20\n    // - updates bridge.deposits\n    // - calls kromaPortal.depositTransaction\n    // - only callable by EOA\n    function test_bridgeERC20_succeeds() external {\n        uint256 nonce = L1Messenger.messageNonce();\n        uint256 version = 0; // Internal constant in the KromaPortal: DEPOSIT_VERSION\n        address l1MessengerAliased = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        // Deal Alice's ERC20 State\n        deal(address(L1Token), alice, 100000, true);\n        vm.prank(alice);\n        L1Token.approve(address(L1Bridge), type(uint256).max);\n\n        // The L1Bridge should transfer alice's tokens to itself\n        vm.expectCall(\n            address(L1Token),\n            abi.encodeWithSelector(ERC20.transferFrom.selector, alice, address(L1Bridge), 100)\n        );\n\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeERC20.selector,\n            address(L2Token),\n            address(L1Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n\n        // the L1 bridge should call L1CrossDomainMessenger.sendMessage\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                message,\n                10000\n            )\n        );\n\n        bytes memory innerMessage = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L1Bridge),\n            address(L2Bridge),\n            0,\n            10000,\n            message\n        );\n\n        uint64 baseGas = L1Messenger.baseGas(message, 10000);\n        vm.expectCall(\n            address(portal),\n            abi.encodeWithSelector(\n                KromaPortal.depositTransaction.selector,\n                address(L2Messenger),\n                0,\n                baseGas,\n                false,\n                innerMessage\n            )\n        );\n\n        bytes memory opaqueData = abi.encodePacked(\n            uint256(0),\n            uint256(0),\n            baseGas,\n            false,\n            innerMessage\n        );\n\n        // ERC20BridgeInitiated event emitted by the StandardBridge\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ERC20BridgeInitiated(address(L1Token), address(L2Token), alice, alice, 100, hex\"\");\n\n        // KromaPortal emits a TransactionDeposited event on `depositTransaction` call\n        vm.expectEmit(true, true, true, true, address(portal));\n        emit TransactionDeposited(l1MessengerAliased, address(L2Messenger), version, opaqueData);\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L1Messenger));\n        emit SentMessage(address(L2Bridge), address(L1Bridge), 0, message, nonce, 10000);\n\n        vm.prank(alice);\n        L1Bridge.bridgeERC20(address(L1Token), address(L2Token), 100, 10000, hex\"\");\n        assertEq(L1Bridge.deposits(address(L1Token), address(L2Token)), 100);\n    }\n}\n\ncontract L1StandardBridge_BridgeERC20_TestFail is Bridge_Initializer {\n    function test_bridgeERC20_notEoa_reverts() external {\n        // turn alice into a contract\n        vm.etch(alice, hex\"ffff\");\n\n        vm.expectRevert(\"StandardBridge: function can only be called from an EOA\");\n        vm.prank(alice, alice);\n        L1Bridge.bridgeERC20(address(0), address(0), 100, 100, hex\"\");\n    }\n}\n\ncontract L1StandardBridge_BridgeERC20To_Test is Bridge_Initializer {\n    // bridgeERC20To\n    // - updates bridge.deposits\n    // - calls kromaPortal.depositTransaction\n    // - callable by a contract\n    function test_bridgeERC20To_succeeds() external {\n        uint256 nonce = L1Messenger.messageNonce();\n        uint256 version = 0; // Internal constant in the KromaPortal: DEPOSIT_VERSION\n        address l1MessengerAliased = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeERC20.selector,\n            address(L2Token),\n            address(L1Token),\n            alice,\n            bob,\n            1000,\n            hex\"\"\n        );\n\n        bytes memory innerMessage = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L1Bridge),\n            address(L2Bridge),\n            0,\n            10000,\n            message\n        );\n\n        uint64 baseGas = L1Messenger.baseGas(message, 10000);\n        bytes memory opaqueData = abi.encodePacked(\n            uint256(0),\n            uint256(0),\n            baseGas,\n            false,\n            innerMessage\n        );\n\n        deal(address(L1Token), alice, 100000, true);\n\n        vm.prank(alice);\n        L1Token.approve(address(L1Bridge), type(uint256).max);\n\n        // ERC20BridgeInitiated event emitted by the StandardBridge\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ERC20BridgeInitiated(address(L1Token), address(L2Token), alice, bob, 1000, hex\"\");\n\n        // KromaPortal emits a TransactionDeposited event on `depositTransaction` call\n        vm.expectEmit(true, true, true, true, address(portal));\n        emit TransactionDeposited(l1MessengerAliased, address(L2Messenger), version, opaqueData);\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L1Messenger));\n        emit SentMessage(address(L2Bridge), address(L1Bridge), 0, message, nonce, 10000);\n\n        // the L1 bridge should call L1CrossDomainMessenger.sendMessage\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                message,\n                10000\n            )\n        );\n        // The L1 XDM should call KromaPortal.depositTransaction\n        vm.expectCall(\n            address(portal),\n            abi.encodeWithSelector(\n                KromaPortal.depositTransaction.selector,\n                address(L2Messenger),\n                0,\n                baseGas,\n                false,\n                innerMessage\n            )\n        );\n\n        vm.expectCall(\n            address(L1Token),\n            abi.encodeWithSelector(ERC20.transferFrom.selector, alice, address(L1Bridge), 1000)\n        );\n\n        vm.prank(alice);\n        L1Bridge.bridgeERC20To(address(L1Token), address(L2Token), bob, 1000, 10000, hex\"\");\n\n        assertEq(L1Bridge.deposits(address(L1Token), address(L2Token)), 1000);\n    }\n}\n\ncontract L1StandardBridge_FinalizeETHWithdrawal_Test is Bridge_Initializer {\n    using stdStorage for StdStorage;\n\n    // finalizeETHWithdrawal\n    // - only callable by L2 bridge\n    function test_finalizeETHWithdrawal_succeeds() external {\n        uint256 aliceBalance = alice.balance;\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHBridgeFinalized(alice, alice, 100, hex\"\");\n\n        vm.expectCall(alice, hex\"\");\n\n        vm.mockCall(\n            address(L1Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        // ensure that the messenger has ETH to call with\n        vm.deal(address(L1Bridge.MESSENGER()), 100);\n        vm.prank(address(L1Bridge.MESSENGER()));\n        L1Bridge.finalizeBridgeETH{ value: 100 }(alice, alice, 100, hex\"\");\n\n        assertEq(address(L1Bridge.MESSENGER()).balance, 0);\n        assertEq(aliceBalance + 100, alice.balance);\n    }\n}\n\ncontract L1StandardBridge_FinalizeETHWithdrawal_TestFail is Bridge_Initializer {}\n\ncontract L1StandardBridge_FinalizeBridgeERC20Withdrawal_Test is Bridge_Initializer {\n    using stdStorage for StdStorage;\n\n    // finalizeBridgeERC20Withdrawal\n    // - updates bridge.deposits\n    // - only callable by L2 bridge\n    function test_finalizeBridgeERC20Withdrawal_succeeds() external {\n        deal(address(L1Token), address(L1Bridge), 100, true);\n\n        uint256 slot = stdstore\n            .target(address(L1Bridge))\n            .sig(\"deposits(address,address)\")\n            .with_key(address(L1Token))\n            .with_key(address(L2Token))\n            .find();\n\n        // Give the L1 bridge some ERC20 tokens\n        vm.store(address(L1Bridge), bytes32(slot), bytes32(uint256(100)));\n        assertEq(L1Bridge.deposits(address(L1Token), address(L2Token)), 100);\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ERC20BridgeFinalized(address(L1Token), address(L2Token), alice, alice, 100, hex\"\");\n\n        vm.expectCall(\n            address(L1Token),\n            abi.encodeWithSelector(ERC20.transfer.selector, alice, 100)\n        );\n\n        vm.mockCall(\n            address(L1Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.prank(address(L1Bridge.MESSENGER()));\n        L1Bridge.finalizeBridgeERC20(address(L1Token), address(L2Token), alice, alice, 100, hex\"\");\n\n        assertEq(L1Token.balanceOf(address(L1Bridge)), 0);\n        assertEq(L1Token.balanceOf(address(alice)), 100);\n    }\n}\n\ncontract L1StandardBridge_FinalizeBridgeERC20Withdrawal_TestFail is Bridge_Initializer {\n    function test_finalizeBridgeERC20Withdrawal_notMessenger_reverts() external {\n        vm.mockCall(\n            address(L1Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.prank(address(28));\n        vm.expectRevert(\"StandardBridge: function can only be called from the other bridge\");\n        L1Bridge.finalizeBridgeERC20(address(L1Token), address(L2Token), alice, alice, 100, hex\"\");\n    }\n\n    function test_finalizeBridgeERC20Withdrawal_notOtherBridge_reverts() external {\n        vm.mockCall(\n            address(L1Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(address(0)))\n        );\n        vm.prank(address(L1Bridge.MESSENGER()));\n        vm.expectRevert(\"StandardBridge: function can only be called from the other bridge\");\n        L1Bridge.finalizeBridgeERC20(address(L1Token), address(L2Token), alice, alice, 100, hex\"\");\n    }\n}\n\ncontract L1StandardBridge_FinalizeBridgeETH_Test is Bridge_Initializer {\n    function test_finalizeBridgeETH_succeeds() external {\n        address messenger = address(L1Bridge.MESSENGER());\n        vm.mockCall(\n            messenger,\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(messenger, 100);\n        vm.prank(messenger);\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHBridgeFinalized(alice, alice, 100, hex\"\");\n\n        L1Bridge.finalizeBridgeETH{ value: 100 }(alice, alice, 100, hex\"\");\n    }\n}\n\ncontract L1StandardBridge_FinalizeBridgeETH_TestFail is Bridge_Initializer {\n    function test_finalizeBridgeETH_incorrectValue_reverts() external {\n        address messenger = address(L1Bridge.MESSENGER());\n        vm.mockCall(\n            messenger,\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(messenger, 100);\n        vm.prank(messenger);\n        vm.expectRevert(\"StandardBridge: amount sent does not match amount required\");\n        L1Bridge.finalizeBridgeETH{ value: 50 }(alice, alice, 100, hex\"\");\n    }\n\n    function test_finalizeBridgeETH_sendToSelf_reverts() external {\n        address messenger = address(L1Bridge.MESSENGER());\n        vm.mockCall(\n            messenger,\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(messenger, 100);\n        vm.prank(messenger);\n        vm.expectRevert(\"StandardBridge: cannot send to self\");\n        L1Bridge.finalizeBridgeETH{ value: 100 }(alice, address(L1Bridge), 100, hex\"\");\n    }\n\n    function test_finalizeBridgeETH_sendToMessenger_reverts() external {\n        address messenger = address(L1Bridge.MESSENGER());\n        vm.mockCall(\n            messenger,\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(messenger, 100);\n        vm.prank(messenger);\n        vm.expectRevert(\"StandardBridge: cannot send to messenger\");\n        L1Bridge.finalizeBridgeETH{ value: 100 }(alice, messenger, 100, hex\"\");\n    }\n}\n"
    },
    "contracts/test/L2CrossDomainMessenger.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { L2CrossDomainMessenger } from \"../L2/L2CrossDomainMessenger.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Messenger_Initializer, Reverter, ConfigurableCaller } from \"./CommonTest.t.sol\";\n\ncontract L2CrossDomainMessenger_Test is Messenger_Initializer {\n    // Receiver address for testing\n    address recipient = address(0xabbaacdc);\n\n    function test_messageVersion_succeeds() external {\n        (, uint16 version) = Encoding.decodeVersionedNonce(L2Messenger.messageNonce());\n        assertEq(version, L2Messenger.MESSAGE_VERSION());\n    }\n\n    function test_sendMessage_succeeds() external {\n        bytes memory xDomainCallData = Encoding.encodeCrossDomainMessage(\n            L2Messenger.messageNonce(),\n            alice,\n            recipient,\n            0,\n            100,\n            hex\"ff\"\n        );\n        vm.expectCall(\n            address(messagePasser),\n            abi.encodeWithSelector(\n                L2ToL1MessagePasser.initiateWithdrawal.selector,\n                address(L1Messenger),\n                L2Messenger.baseGas(hex\"ff\", 100),\n                xDomainCallData\n            )\n        );\n\n        // MessagePassed event\n        vm.expectEmit(true, true, true, true);\n        emit MessagePassed(\n            messagePasser.messageNonce(),\n            address(L2Messenger),\n            address(L1Messenger),\n            0,\n            L2Messenger.baseGas(hex\"ff\", 100),\n            xDomainCallData,\n            Hashing.hashWithdrawal(\n                Types.WithdrawalTransaction({\n                    nonce: messagePasser.messageNonce(),\n                    sender: address(L2Messenger),\n                    target: address(L1Messenger),\n                    value: 0,\n                    gasLimit: L2Messenger.baseGas(hex\"ff\", 100),\n                    data: xDomainCallData\n                })\n            )\n        );\n\n        vm.prank(alice);\n        L2Messenger.sendMessage(recipient, hex\"ff\", uint32(100));\n    }\n\n    function test_sendMessage_twice_succeeds() external {\n        uint256 nonce = L2Messenger.messageNonce();\n        L2Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        L2Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        // the nonce increments for each message sent\n        assertEq(nonce + 2, L2Messenger.messageNonce());\n    }\n\n    function test_xDomainSender_senderNotSet_reverts() external {\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L2Messenger.xDomainMessageSender();\n    }\n\n    function test_relayMessage_v1_reverts() external {\n        address target = address(0xabcd);\n        address sender = address(L1Messenger);\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        // Expect a revert.\n        vm.expectRevert(\"CrossDomainMessenger: only version 0 messages is supported at this time\");\n\n        // Try to relay a v1 message.\n        vm.prank(caller);\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 1 }), // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            hex\"1111\"\n        );\n    }\n\n    function test_relayMessage_succeeds() external {\n        address target = address(0xabcd);\n        address sender = address(L1Messenger);\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        vm.expectCall(target, hex\"1111\");\n\n        vm.prank(caller);\n\n        vm.expectEmit(true, true, true, true);\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            hex\"1111\"\n        );\n\n        emit RelayedMessage(hash);\n\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            hex\"1111\"\n        );\n\n        // the message hash is in the successfulMessages mapping\n        assert(L2Messenger.successfulMessages(hash));\n        // it is not in the received messages mapping\n        assertEq(L2Messenger.failedMessages(hash), false);\n    }\n\n    // relayMessage: should revert if attempting to relay a message sent to an L1 system contract\n    function test_relayMessage_toSystemContract_reverts() external {\n        address target = address(messagePasser);\n        address sender = address(L1Messenger);\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n        bytes memory message = hex\"1111\";\n\n        vm.prank(caller);\n        vm.expectRevert(\"CrossDomainMessenger: message cannot be replayed\");\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            message\n        );\n    }\n\n    // relayMessage: the xDomainMessageSender is reset to the original value\n    function test_xDomainMessageSender_reset_succeeds() external {\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L2Messenger.xDomainMessageSender();\n\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n        vm.prank(caller);\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            address(0),\n            address(0),\n            0,\n            0,\n            hex\"\"\n        );\n\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L2Messenger.xDomainMessageSender();\n    }\n\n    // relayMessage: should send a successful call to the target contract after the first message\n    // fails and ETH gets stuck, but the second message succeeds\n    function test_relayMessage_retry_succeeds() external {\n        address target = address(0xabcd);\n        address sender = address(L1Messenger);\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n        uint256 value = 100;\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        vm.etch(target, address(new Reverter()).code);\n        vm.deal(address(caller), value);\n        vm.prank(caller);\n        L2Messenger.relayMessage{ value: value }(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        assertEq(address(L2Messenger).balance, value);\n        assertEq(address(target).balance, 0);\n        assertEq(L2Messenger.successfulMessages(hash), false);\n        assertEq(L2Messenger.failedMessages(hash), true);\n\n        vm.expectEmit(true, true, true, true);\n\n        emit RelayedMessage(hash);\n\n        vm.etch(target, address(0).code);\n        vm.prank(address(sender));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        assertEq(address(L2Messenger).balance, 0);\n        assertEq(address(target).balance, value);\n        assertEq(L2Messenger.successfulMessages(hash), true);\n        assertEq(L2Messenger.failedMessages(hash), true);\n    }\n}\n"
    },
    "contracts/test/L2ERC721Bridge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport { L1ERC721Bridge } from \"../L1/L1ERC721Bridge.sol\";\nimport { L2ERC721Bridge } from \"../L2/L2ERC721Bridge.sol\";\nimport { KromaMintableERC721 } from \"../universal/KromaMintableERC721.sol\";\nimport { Messenger_Initializer } from \"./CommonTest.t.sol\";\n\ncontract TestERC721 is ERC721 {\n    constructor() ERC721(\"Test\", \"TST\") {}\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n}\n\ncontract TestMintableERC721 is KromaMintableERC721 {\n    constructor(address _bridge, address _remoteToken)\n        KromaMintableERC721(_bridge, 1, _remoteToken, \"Test\", \"TST\")\n    {}\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n}\n\ncontract L2ERC721Bridge_Test is Messenger_Initializer {\n    TestMintableERC721 internal localToken;\n    TestERC721 internal remoteToken;\n    L2ERC721Bridge internal bridge;\n    address internal constant otherBridge = address(0x3456);\n    uint256 internal constant tokenId = 1;\n\n    event ERC721BridgeInitiated(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    event ERC721BridgeFinalized(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    function setUp() public override {\n        super.setUp();\n\n        // Create necessary contracts.\n        bridge = new L2ERC721Bridge(address(L2Messenger), otherBridge);\n        remoteToken = new TestERC721();\n        localToken = new TestMintableERC721(address(bridge), address(remoteToken));\n\n        // Label the bridge so we get nice traces.\n        vm.label(address(bridge), \"L2ERC721Bridge\");\n\n        // Mint alice a token.\n        localToken.mint(alice, tokenId);\n\n        // Approve the bridge to transfer the token.\n        vm.prank(alice);\n        localToken.approve(address(bridge), tokenId);\n    }\n\n    function test_constructor_succeeds() public {\n        assertEq(address(bridge.MESSENGER()), address(L2Messenger));\n        assertEq(address(bridge.OTHER_BRIDGE()), otherBridge);\n    }\n\n    function test_bridgeERC721_succeeds() public {\n        // Expect a call to the messenger.\n        vm.expectCall(\n            address(L2Messenger),\n            abi.encodeCall(\n                L2Messenger.sendMessage,\n                (\n                    address(otherBridge),\n                    abi.encodeCall(\n                        L2ERC721Bridge.finalizeBridgeERC721,\n                        (\n                            address(remoteToken),\n                            address(localToken),\n                            alice,\n                            alice,\n                            tokenId,\n                            hex\"5678\"\n                        )\n                    ),\n                    1234\n                )\n            )\n        );\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeInitiated(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is burned.\n        vm.expectRevert(\"ERC721: invalid token ID\");\n        localToken.ownerOf(tokenId);\n    }\n\n    function test_bridgeERC721_fromContract_reverts() external {\n        // Bridge the token.\n        vm.etch(alice, hex\"01\");\n        vm.prank(alice);\n        vm.expectRevert(\"ERC721Bridge: account is not externally owned\");\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_localTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert();\n        bridge.bridgeERC721(address(0), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_remoteTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert(\"L2ERC721Bridge: remote token cannot be address(0)\");\n        bridge.bridgeERC721(address(localToken), address(0), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_wrongOwner_reverts() external {\n        // Bridge the token.\n        vm.prank(bob);\n        vm.expectRevert(\"L2ERC721Bridge: Withdrawal is not being initiated by NFT owner\");\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_succeeds() external {\n        // Expect a call to the messenger.\n        vm.expectCall(\n            address(L2Messenger),\n            abi.encodeCall(\n                L2Messenger.sendMessage,\n                (\n                    address(otherBridge),\n                    abi.encodeCall(\n                        L1ERC721Bridge.finalizeBridgeERC721,\n                        (address(remoteToken), address(localToken), alice, bob, tokenId, hex\"5678\")\n                    ),\n                    1234\n                )\n            )\n        );\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeInitiated(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            bob,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721To(\n            address(localToken),\n            address(remoteToken),\n            bob,\n            tokenId,\n            1234,\n            hex\"5678\"\n        );\n\n        // Token is burned.\n        vm.expectRevert(\"ERC721: invalid token ID\");\n        localToken.ownerOf(tokenId);\n    }\n\n    function test_bridgeERC721To_localTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert();\n        bridge.bridgeERC721To(address(0), address(remoteToken), bob, tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_remoteTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert(\"L2ERC721Bridge: remote token cannot be address(0)\");\n        bridge.bridgeERC721To(address(localToken), address(0), bob, tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_wrongOwner_reverts() external {\n        // Bridge the token.\n        vm.prank(bob);\n        vm.expectRevert(\"L2ERC721Bridge: Withdrawal is not being initiated by NFT owner\");\n        bridge.bridgeERC721To(\n            address(localToken),\n            address(remoteToken),\n            bob,\n            tokenId,\n            1234,\n            hex\"5678\"\n        );\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_finalizeBridgeERC721_succeeds() external {\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeFinalized(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(L2Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L2Messenger));\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_finalizeBridgeERC721_interfaceNotCompliant_reverts() external {\n        // Create a non-compliant token\n        NonCompliantERC721 nonCompliantToken = new NonCompliantERC721(alice);\n\n        // Bridge the non-compliant token.\n        vm.prank(alice);\n        bridge.bridgeERC721(address(nonCompliantToken), address(0x01), tokenId, 1234, hex\"5678\");\n\n        // Attempt to finalize the withdrawal. Should revert because the token does not claim\n        // to be compliant with the `IKromaMintableERC721` interface.\n        vm.mockCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(L2Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"L2ERC721Bridge: local token interface is not compliant\");\n        bridge.finalizeBridgeERC721(\n            address(address(nonCompliantToken)),\n            address(address(0x01)),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_notViaLocalMessenger_reverts() external {\n        // Finalize a withdrawal.\n        vm.prank(alice);\n        vm.expectRevert(\"ERC721Bridge: function can only be called from the other bridge\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_notFromRemoteMessenger_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(L2Messenger.xDomainMessageSender.selector),\n            abi.encode(alice)\n        );\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"ERC721Bridge: function can only be called from the other bridge\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_selfToken_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(L2Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"L2ERC721Bridge: local token cannot be self\");\n        bridge.finalizeBridgeERC721(\n            address(bridge),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_alreadyExists_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(L2Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"ERC721: token already minted\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n}\n\n/**\n * @dev A non-compliant ERC721 token that does not implement the full ERC721 interface.\n *\n * This is used to test that the bridge will revert if the token does not claim to support\n * the ERC721 interface.\n */\ncontract NonCompliantERC721 {\n    address internal immutable owner;\n\n    address public immutable REMOTE_TOKEN;\n\n    constructor(address _owner) {\n        owner = _owner;\n        REMOTE_TOKEN = address(0x01);\n    }\n\n    function ownerOf(uint256) external view returns (address) {\n        return owner;\n    }\n\n    function burn(address, uint256) external {\n        // Do nothing.\n    }\n\n    function supportsInterface(bytes4) external pure returns (bool) {\n        return false;\n    }\n}\n"
    },
    "contracts/test/L2OutputOracle.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { stdError } from \"forge-std/Test.sol\";\n\nimport { Types } from \"../libraries/Types.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { ValidatorPool } from \"../L1/ValidatorPool.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { L2OutputOracle_Initializer, NextImpl } from \"./CommonTest.t.sol\";\n\ncontract L2OutputOracleTest is L2OutputOracle_Initializer {\n    bytes32 submittedOutput1 = keccak256(abi.encode(1));\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        vm.deal(trusted, requiredBondAmount * 100);\n        vm.prank(trusted);\n        pool.deposit{ value: trusted.balance }();\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(address(oracle.VALIDATOR_POOL()), address(pool));\n        assertEq(oracle.COLOSSEUM(), address(colosseum));\n        assertEq(oracle.SUBMISSION_INTERVAL(), submissionInterval);\n        assertEq(oracle.latestBlockNumber(), startingBlockNumber);\n        assertEq(oracle.startingBlockNumber(), startingBlockNumber);\n        assertEq(oracle.startingTimestamp(), startingTimestamp);\n    }\n\n    function test_constructor_badTimestamp_reverts() external {\n        vm.expectRevert(\"L2OutputOracle: starting L2 timestamp must be less than current time\");\n        new L2OutputOracle({\n            _validatorPool: pool,\n            _colosseum: address(colosseum),\n            _submissionInterval: submissionInterval,\n            _l2BlockTime: l2BlockTime,\n            _startingBlockNumber: startingBlockNumber,\n            _startingTimestamp: block.timestamp + 1,\n            _finalizationPeriodSeconds: 7 days\n        });\n    }\n\n    function test_constructor_l2BlockTimeZero_reverts() external {\n        vm.expectRevert(\"L2OutputOracle: L2 block time must be greater than 0\");\n        new L2OutputOracle({\n            _validatorPool: pool,\n            _colosseum: address(colosseum),\n            _submissionInterval: submissionInterval,\n            _l2BlockTime: 0,\n            _startingBlockNumber: startingBlockNumber,\n            _startingTimestamp: block.timestamp,\n            _finalizationPeriodSeconds: 7 days\n        });\n    }\n\n    function test_constructor_submissionInterval_reverts() external {\n        vm.expectRevert(\"L2OutputOracle: submission interval must be greater than 0\");\n        new L2OutputOracle({\n            _validatorPool: pool,\n            _colosseum: address(colosseum),\n            _submissionInterval: 0,\n            _l2BlockTime: l2BlockTime,\n            _startingBlockNumber: startingBlockNumber,\n            _startingTimestamp: block.timestamp,\n            _finalizationPeriodSeconds: 7 days\n        });\n    }\n\n    /****************\n     * Getter Tests *\n     ****************/\n\n    // Test: latestBlockNumber() should return the correct value\n    function test_latestBlockNumber_succeeds() external {\n        uint256 submittedNumber = oracle.nextBlockNumber();\n\n        // Roll to after the block number we'll submit\n        warpToSubmitTime(submittedNumber);\n        vm.prank(trusted);\n        oracle.submitL2Output(submittedOutput1, submittedNumber, 0, 0);\n        assertEq(oracle.latestBlockNumber(), submittedNumber);\n    }\n\n    // Test: getL2Output() should return the correct value\n    function test_getL2Output_succeeds() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        uint256 nextOutputIndex = oracle.nextOutputIndex();\n        warpToSubmitTime(nextBlockNumber);\n        vm.prank(trusted);\n        oracle.submitL2Output(submittedOutput1, nextBlockNumber, 0, 0);\n\n        Types.CheckpointOutput memory output = oracle.getL2Output(nextOutputIndex);\n        assertEq(output.outputRoot, submittedOutput1);\n        assertEq(output.timestamp, block.timestamp);\n\n        // The block number is larger than the latest submitted output:\n        vm.expectRevert(stdError.indexOOBError);\n        oracle.getL2Output(nextOutputIndex + 1);\n    }\n\n    // Test: getL2OutputIndexAfter() returns correct value when input is exact block\n    function test_getL2OutputIndexAfter_sameBlock_succeeds() external {\n        bytes32 output1 = keccak256(abi.encode(1));\n        uint256 nextBlockNumber1 = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber1);\n        vm.prank(trusted);\n        oracle.submitL2Output(output1, nextBlockNumber1, 0, 0);\n\n        // Querying with exact same block as submitted returns the output.\n        uint256 index1 = oracle.getL2OutputIndexAfter(nextBlockNumber1);\n        assertEq(index1, 0);\n    }\n\n    // Test: getL2OutputIndexAfter() returns correct value when input is previous block\n    function test_getL2OutputIndexAfter_previousBlock_succeeds() external {\n        bytes32 output1 = keccak256(abi.encode(1));\n        uint256 nextBlockNumber1 = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber1);\n        vm.prank(trusted);\n        oracle.submitL2Output(output1, nextBlockNumber1, 0, 0);\n\n        // Querying with previous block returns the output too.\n        uint256 index1 = oracle.getL2OutputIndexAfter(nextBlockNumber1 - 1);\n        assertEq(index1, 0);\n    }\n\n    // Test: getL2OutputIndexAfter() returns correct value during binary search\n    function test_getL2OutputIndexAfter_multipleOutputsExist_succeeds() external {\n        bytes32 output1 = keccak256(abi.encode(1));\n        uint256 nextBlockNumber1 = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber1);\n        vm.prank(trusted);\n        oracle.submitL2Output(output1, nextBlockNumber1, 0, 0);\n\n        bytes32 output2 = keccak256(abi.encode(2));\n        uint256 nextBlockNumber2 = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber2);\n        vm.prank(trusted);\n        oracle.submitL2Output(output2, nextBlockNumber2, 0, 0);\n\n        bytes32 output3 = keccak256(abi.encode(3));\n        uint256 nextBlockNumber3 = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber3);\n        vm.prank(trusted);\n        oracle.submitL2Output(output3, nextBlockNumber3, 0, 0);\n\n        bytes32 output4 = keccak256(abi.encode(4));\n        uint256 nextBlockNumber4 = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber4);\n        vm.prank(trusted);\n        oracle.submitL2Output(output4, nextBlockNumber4, 0, 0);\n\n        // Querying with a block number between the first and second output\n        uint256 index1 = oracle.getL2OutputIndexAfter(nextBlockNumber1 + 1);\n        assertEq(index1, 1);\n\n        // Querying with a block number between the second and third output\n        uint256 index2 = oracle.getL2OutputIndexAfter(nextBlockNumber2 + 1);\n        assertEq(index2, 2);\n\n        // Querying with a block number between the third and fourth output\n        uint256 index3 = oracle.getL2OutputIndexAfter(nextBlockNumber3 + 1);\n        assertEq(index3, 3);\n    }\n\n    // Test: getL2OutputIndexAfter() reverts when no output exists yet\n    function test_getL2OutputIndexAfter_noOutputsExist_reverts() external {\n        vm.expectRevert(\"L2OutputOracle: cannot get output as no outputs have been submitted yet\");\n        oracle.getL2OutputIndexAfter(0);\n    }\n\n    // Test: nextBlockNumber() should return the correct value\n    function test_nextBlockNumber_succeeds() external {\n        assertEq(oracle.nextBlockNumber(), oracle.latestBlockNumber());\n\n        test_submitL2Output_submitAnotherOutput_succeeds();\n\n        assertEq(\n            oracle.nextBlockNumber(),\n            // The return value should match this arithmetic\n            oracle.latestBlockNumber() + oracle.SUBMISSION_INTERVAL()\n        );\n    }\n\n    function test_computeL2Timestamp_succeeds() external {\n        // reverts if timestamp is too low\n        vm.expectRevert(stdError.arithmeticError);\n        oracle.computeL2Timestamp(startingBlockNumber - 1);\n\n        // returns the correct value...\n        // ... for the very first block\n        assertEq(oracle.computeL2Timestamp(startingBlockNumber), startingTimestamp);\n\n        // ... for the first block after the starting block\n        assertEq(\n            oracle.computeL2Timestamp(startingBlockNumber + 1),\n            startingTimestamp + l2BlockTime\n        );\n\n        // ... for some other block number\n        assertEq(\n            oracle.computeL2Timestamp(startingBlockNumber + 96024),\n            startingTimestamp + l2BlockTime * 96024\n        );\n    }\n\n    /*****************************\n     * Submit Tests - Happy Path *\n     *****************************/\n\n    // Test: submitL2Output succeeds when given valid input, and no block hash and number are\n    // specified.\n    function test_submitL2Output_submitAnotherOutput_succeeds() public {\n        startingBlockNumber = oracle.startingBlockNumber();\n        bytes32 submittedOutput2 = keccak256(abi.encode());\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        uint256 nextOutputIndex = oracle.nextOutputIndex();\n        warpToSubmitTime(nextBlockNumber);\n        uint256 submittedNumber = oracle.latestBlockNumber();\n\n        // Ensure the submissionInterval is enforced\n        if (nextBlockNumber == startingBlockNumber) {\n            assertEq(nextBlockNumber, submittedNumber);\n        } else {\n            assertEq(nextBlockNumber, submittedNumber + submissionInterval);\n        }\n\n        vm.roll(nextBlockNumber + 1);\n\n        uint128 finalizedAt = uint128(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS());\n        vm.expectCall(\n            address(oracle.VALIDATOR_POOL()),\n            abi.encodeWithSelector(\n                ValidatorPool.createBond.selector,\n                nextOutputIndex,\n                finalizedAt\n            )\n        );\n        vm.expectEmit(true, true, true, true);\n        emit OutputSubmitted(submittedOutput2, nextOutputIndex, nextBlockNumber, block.timestamp);\n        vm.prank(trusted);\n        oracle.submitL2Output(submittedOutput2, nextBlockNumber, 0, 0);\n    }\n\n    // Test: submitL2Output succeeds when given valid input, and when a block hash and number are\n    // specified for reorg protection.\n    function test_submitWithBlockhashAndHeight_succeeds() external {\n        // Get the number and hash of a previous block in the chain\n        uint256 prevL1BlockNumber = block.number - 1;\n        bytes32 prevL1BlockHash = blockhash(prevL1BlockNumber);\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber);\n\n        vm.prank(trusted);\n        oracle.submitL2Output(\n            nonZeroHash,\n            nextBlockNumber,\n            prevL1BlockHash,\n            prevL1BlockNumber\n        );\n    }\n\n    /***************************\n     * Submit Tests - Sad Path *\n     ***************************/\n\n    // Test: submitL2Output fails if called by a party that is not the validator.\n    function test_submitL2Output_notValidator_reverts() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber);\n\n        vm.prank(address(128));\n        vm.expectRevert(\"L2OutputOracle: only the next selected validator can submit output\");\n        oracle.submitL2Output(nonZeroHash, nextBlockNumber, 0, 0);\n    }\n\n    // Test: submitL2Output fails given a zero blockhash.\n    function test_submitL2Output_emptyOutput_reverts() external {\n        bytes32 outputToSubmit = bytes32(0);\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber);\n        vm.prank(trusted);\n        vm.expectRevert(\"L2OutputOracle: L2 checkpoint output cannot be the zero hash\");\n        oracle.submitL2Output(outputToSubmit, nextBlockNumber, 0, 0);\n    }\n\n    // Test: submitL2Output fails if the block number doesn't match the next expected number.\n    function test_submitL2Output_unexpectedBlockNumber_reverts() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber);\n        vm.prank(trusted);\n        vm.expectRevert(\"L2OutputOracle: block number must be equal to next expected block number\");\n        oracle.submitL2Output(nonZeroHash, nextBlockNumber - 1, 0, 0);\n    }\n\n    // Test: submitL2Output fails if it would have a timestamp in the future.\n    function test_submitL2Output_futureTimetamp_reverts() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        uint256 nextTimestamp = oracle.computeL2Timestamp(nextBlockNumber);\n        vm.warp(nextTimestamp);\n        vm.prank(trusted);\n        vm.expectRevert(\"L2OutputOracle: cannot submit L2 output in the future\");\n        oracle.submitL2Output(nonZeroHash, nextBlockNumber, 0, 0);\n    }\n\n    // Test: submitL2Output fails if a non-existent L1 block hash and number are provided for reorg\n    // protection.\n    function test_submitL2Output_wrongFork_reverts() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber);\n        vm.prank(trusted);\n        vm.expectRevert(\n            \"L2OutputOracle: block hash does not match the hash at the expected height\"\n        );\n        oracle.submitL2Output(\n            nonZeroHash,\n            nextBlockNumber,\n            bytes32(uint256(0x01)),\n            block.number - 1\n        );\n    }\n\n    // Test: submitL2Output fails when given valid input, but the block hash and number do not\n    // match.\n    function test_submitL2Output_unmatchedBlockhash_reverts() external {\n        // Move ahead to block 100 so that we can reference historical blocks\n        vm.roll(100);\n\n        // Get the number and hash of a previous block in the chain\n        uint256 l1BlockNumber = block.number - 1;\n        bytes32 l1BlockHash = blockhash(l1BlockNumber);\n\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber);\n        vm.prank(trusted);\n\n        // This will fail when foundry no longer returns zerod block hashes\n        vm.expectRevert(\n            \"L2OutputOracle: block hash does not match the hash at the expected height\"\n        );\n        oracle.submitL2Output(\n            nonZeroHash,\n            nextBlockNumber,\n            l1BlockHash,\n            l1BlockNumber - 1\n        );\n    }\n\n    /*****************************\n     * Replace Tests - Happy Path *\n     *****************************/\n\n    function test_replaceL2Output_succeeds() external {\n        test_submitL2Output_submitAnotherOutput_succeeds();\n        test_submitL2Output_submitAnotherOutput_succeeds();\n        test_submitL2Output_submitAnotherOutput_succeeds();\n\n        uint256 outputIndex = oracle.latestOutputIndex() - 1;\n        bytes32 newOutputRoot = keccak256(abi.encode(\"new_output\"));\n\n        vm.prank(address(colosseum));\n        vm.expectEmit(true, true, false, false);\n        emit OutputReplaced(outputIndex, newOutputRoot);\n        oracle.replaceL2Output(outputIndex, newOutputRoot, challenger);\n\n        // validate that the output root is replaced\n        Types.CheckpointOutput memory output = oracle.getL2Output(outputIndex);\n        assertEq(newOutputRoot, output.outputRoot);\n        assertEq(challenger, output.submitter);\n    }\n\n    /***************************\n     * Replace Tests - Sad Path *\n     ***************************/\n\n    function test_replaceL2Output_ifNotChallenger_reverts() external {\n        uint256 latestBlockNumber = oracle.latestBlockNumber();\n\n        vm.expectRevert(\"L2OutputOracle: only the colosseum contract can replace an output\");\n        oracle.replaceL2Output(latestBlockNumber, keccak256(abi.encode(\"new_output\")), address(1));\n    }\n\n    function test_replaceL2Output_zeroAddress_reverts() external {\n        uint256 latestBlockNumber = oracle.latestBlockNumber();\n\n        vm.prank(address(colosseum));\n        vm.expectRevert(\"L2OutputOracle: submitter address cannot be zero\");\n        oracle.replaceL2Output(latestBlockNumber, keccak256(abi.encode(\"new_output\")), address(0));\n    }\n\n    function test_replaceL2Output_nonExistent_reverts() external {\n        test_submitL2Output_submitAnotherOutput_succeeds();\n\n        uint256 latestBlockNumber = oracle.latestBlockNumber();\n\n        vm.prank(address(colosseum));\n        vm.expectRevert(\"L2OutputOracle: cannot replace an output after the latest output index\");\n        oracle.replaceL2Output(\n            latestBlockNumber + 1,\n            keccak256(abi.encode(\"new_output\")),\n            challenger\n        );\n    }\n\n    function test_replaceL2Output_finalized_reverts() external {\n        test_submitL2Output_submitAnotherOutput_succeeds();\n\n        // Warp past the finalization period + 1 second\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        uint256 latestOutputIndex = oracle.latestOutputIndex();\n\n        // Try to delete a finalized output\n        vm.prank(address(colosseum));\n        vm.expectRevert(\"L2OutputOracle: cannot replace an output that has already been finalized\");\n        oracle.replaceL2Output(latestOutputIndex, keccak256(abi.encode(\"new_output\")), challenger);\n    }\n}\n\ncontract L2OutputOracleUpgradeable_Test is L2OutputOracle_Initializer {\n    Proxy internal proxy;\n\n    function setUp() public override {\n        super.setUp();\n        proxy = Proxy(payable(address(oracle)));\n    }\n\n    function test_initValuesOnProxy_succeeds() external {\n        assertEq(submissionInterval, oracleImpl.SUBMISSION_INTERVAL());\n        assertEq(l2BlockTime, oracleImpl.L2_BLOCK_TIME());\n        assertEq(startingBlockNumber, oracleImpl.startingBlockNumber());\n        assertEq(startingTimestamp, oracleImpl.startingTimestamp());\n\n        assertEq(address(oracle.VALIDATOR_POOL()), address(pool));\n        assertEq(address(colosseum), oracleImpl.COLOSSEUM());\n    }\n\n    function test_initializeProxy_alreadyInitialized_reverts() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        L2OutputOracle(payable(proxy)).initialize(startingBlockNumber, startingTimestamp);\n    }\n\n    function test_initializeImpl_alreadyInitialized_reverts() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        L2OutputOracle(oracleImpl).initialize(startingBlockNumber, startingTimestamp);\n    }\n\n    function test_upgrading_succeeds() external {\n        // Check an unused slot before upgrading.\n        bytes32 slot21Before = vm.load(address(oracle), bytes32(uint256(21)));\n        assertEq(bytes32(0), slot21Before);\n\n        NextImpl nextImpl = new NextImpl();\n        vm.startPrank(multisig);\n        proxy.upgradeToAndCall(\n            address(nextImpl),\n            abi.encodeWithSelector(NextImpl.initialize.selector)\n        );\n        assertEq(proxy.implementation(), address(nextImpl));\n\n        // Verify that the NextImpl contract initialized its values according as expected\n        bytes32 slot21After = vm.load(address(oracle), bytes32(uint256(21)));\n        bytes32 slot21Expected = NextImpl(address(oracle)).slot21Init();\n        assertEq(slot21Expected, slot21After);\n    }\n}\n"
    },
    "contracts/test/L2StandardBridge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { stdStorage, StdStorage } from \"forge-std/Test.sol\";\n\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { KromaMintableERC20 } from \"../universal/KromaMintableERC20.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\n\ncontract L2StandardBridge_Test is Bridge_Initializer {\n    using stdStorage for StdStorage;\n\n    function test_initialize_succeeds() external {\n        assertEq(address(L2Bridge.MESSENGER()), address(L2Messenger));\n        assertEq(address(L1Bridge.OTHER_BRIDGE()), address(L2Bridge));\n        assertEq(address(L2Bridge.OTHER_BRIDGE()), address(L1Bridge));\n    }\n\n    // receive\n    // - can accept ETH\n    function test_receive_succeeds() external {\n        assertEq(address(messagePasser).balance, 0);\n        vm.prank(alice, alice);\n        (bool success, ) = address(L2Bridge).call{ value: 100 }(hex\"\");\n        assertEq(success, true);\n        assertEq(address(messagePasser).balance, 100);\n    }\n}\n\ncontract PreBridgeERC20 is Bridge_Initializer {\n    function _preBridgeERC20() internal {\n        // Alice has 100 L2Token\n        deal(address(L2Token), alice, 100, true);\n        assertEq(L2Token.balanceOf(alice), 100);\n        uint256 nonce = L2Messenger.messageNonce();\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeERC20.selector,\n            address(L1Token),\n            address(L2Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n        uint64 baseGas = L2Messenger.baseGas(message, 1000);\n        bytes memory withdrawalData = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L2Bridge),\n            address(L1Bridge),\n            0,\n            1000,\n            message\n        );\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction({\n                nonce: nonce,\n                sender: address(L2Messenger),\n                target: address(L1Messenger),\n                value: 0,\n                gasLimit: baseGas,\n                data: withdrawalData\n            })\n        );\n\n        vm.expectCall(\n            address(L2Bridge),\n            abi.encodeWithSelector(\n                L2Bridge.bridgeERC20.selector,\n                address(L2Token),\n                address(L1Token),\n                100,\n                1000,\n                hex\"\"\n            )\n        );\n\n        vm.expectCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L1Bridge),\n                message,\n                1000\n            )\n        );\n\n        vm.expectCall(\n            Predeploys.L2_TO_L1_MESSAGE_PASSER,\n            abi.encodeWithSelector(\n                L2ToL1MessagePasser.initiateWithdrawal.selector,\n                address(L1Messenger),\n                baseGas,\n                withdrawalData\n            )\n        );\n\n        // The L2Bridge should burn the tokens\n        vm.expectCall(\n            address(L2Token),\n            abi.encodeWithSelector(KromaMintableERC20.burn.selector, alice, 100)\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit ERC20BridgeInitiated(address(L2Token), address(L1Token), alice, alice, 100, hex\"\");\n\n        vm.expectEmit(true, true, true, true);\n        emit MessagePassed(\n            nonce,\n            address(L2Messenger),\n            address(L1Messenger),\n            0,\n            baseGas,\n            withdrawalData,\n            withdrawalHash\n        );\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true);\n        emit SentMessage(address(L1Bridge), address(L2Bridge), 0, message, nonce, 1000);\n\n        vm.prank(alice, alice);\n    }\n}\n\ncontract L2StandardBridge_BridgeERC20_Test is PreBridgeERC20 {\n    // BridgeERC20\n    // - token is burned\n    // - emits ERC20BridgeInitiated\n    // - calls Withdrawer.initiateWithdrawal\n    function test_bridgeERC20_succeeds() external {\n        _preBridgeERC20();\n        L2Bridge.bridgeERC20(address(L2Token), address(L1Token), 100, 1000, hex\"\");\n\n        assertEq(L2Token.balanceOf(alice), 0);\n    }\n}\n\ncontract PreBridgeERC20To is Bridge_Initializer {\n    function _preBridgeERC20To() internal {\n        deal(address(L2Token), alice, 100, true);\n        assertEq(L2Token.balanceOf(alice), 100);\n        uint256 nonce = L2Messenger.messageNonce();\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeERC20.selector,\n            address(L1Token),\n            address(L2Token),\n            alice,\n            bob,\n            100,\n            hex\"\"\n        );\n        uint64 baseGas = L2Messenger.baseGas(message, 1000);\n        bytes memory withdrawalData = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L2Bridge),\n            address(L1Bridge),\n            0,\n            1000,\n            message\n        );\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction({\n                nonce: nonce,\n                sender: address(L2Messenger),\n                target: address(L1Messenger),\n                value: 0,\n                gasLimit: baseGas,\n                data: withdrawalData\n            })\n        );\n\n        vm.expectEmit(true, true, true, true, address(L2Bridge));\n        emit ERC20BridgeInitiated(address(L2Token), address(L1Token), alice, bob, 100, hex\"\");\n\n        vm.expectEmit(true, true, true, true, address(messagePasser));\n        emit MessagePassed(\n            nonce,\n            address(L2Messenger),\n            address(L1Messenger),\n            0,\n            baseGas,\n            withdrawalData,\n            withdrawalHash\n        );\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L2Messenger));\n        emit SentMessage(address(L1Bridge), address(L2Bridge), 0, message, nonce, 1000);\n\n        vm.expectCall(\n            address(L2Bridge),\n            abi.encodeWithSelector(\n                L2Bridge.bridgeERC20To.selector,\n                address(L2Token),\n                address(L1Token),\n                bob,\n                100,\n                1000,\n                hex\"\"\n            )\n        );\n\n        vm.expectCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L1Bridge),\n                message,\n                1000\n            )\n        );\n\n        vm.expectCall(\n            Predeploys.L2_TO_L1_MESSAGE_PASSER,\n            abi.encodeWithSelector(\n                L2ToL1MessagePasser.initiateWithdrawal.selector,\n                address(L1Messenger),\n                baseGas,\n                withdrawalData\n            )\n        );\n\n        // The L2Bridge should burn the tokens\n        vm.expectCall(\n            address(L2Token),\n            abi.encodeWithSelector(KromaMintableERC20.burn.selector, alice, 100)\n        );\n\n        vm.prank(alice, alice);\n    }\n}\n\ncontract L2StandardBridge_BridgeERC20To_Test is PreBridgeERC20To {\n    // bridgeERC20To\n    // - token is burned\n    // - emits ERC20BridgeInitiated w/ correct recipient\n    // - calls Withdrawer.initiateWithdrawal\n    function test_bridgeERC20To_succeeds() external {\n        _preBridgeERC20To();\n        L2Bridge.bridgeERC20To(address(L2Token), address(L1Token), bob, 100, 1000, hex\"\");\n        assertEq(L2Token.balanceOf(alice), 0);\n    }\n}\n\ncontract L2StandardBridge_Bridge_Test is Bridge_Initializer {\n    // finalizeDeposit\n    // - only callable by l1Bridge\n    // - supported token pair emits ERC20BridgeFinalized\n    // - invalid deposit calls Withdrawer.initiateWithdrawal\n    function test_finalizeBridgeERC20_succeeds() external {\n        vm.mockCall(\n            address(L2Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.OTHER_BRIDGE()))\n        );\n\n        vm.expectCall(\n            address(L2Token),\n            abi.encodeWithSelector(KromaMintableERC20.mint.selector, alice, 100)\n        );\n\n        vm.expectEmit(true, true, true, true, address(L2Bridge));\n        emit ERC20BridgeFinalized(address(L2Token), address(L1Token), alice, alice, 100, hex\"\");\n\n        vm.prank(address(L2Messenger));\n        L2Bridge.finalizeBridgeERC20(address(L2Token), address(L1Token), alice, alice, 100, hex\"\");\n    }\n\n    function test_finalizeBridgeETH_incorrectValue_reverts() external {\n        vm.mockCall(\n            address(L2Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(address(L2Messenger), 100);\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"StandardBridge: amount sent does not match amount required\");\n        L2Bridge.finalizeBridgeETH{ value: 50 }(alice, alice, 100, hex\"\");\n    }\n\n    function test_finalizeBridgeETH_sendToSelf_reverts() external {\n        vm.mockCall(\n            address(L2Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(address(L2Messenger), 100);\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"StandardBridge: cannot send to self\");\n        L2Bridge.finalizeBridgeETH{ value: 100 }(alice, address(L2Bridge), 100, hex\"\");\n    }\n\n    function test_finalizeBridgeETH_sendToMessenger_reverts() external {\n        vm.mockCall(\n            address(L2Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(address(L2Messenger), 100);\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"StandardBridge: cannot send to messenger\");\n        L2Bridge.finalizeBridgeETH{ value: 100 }(alice, address(L2Messenger), 100, hex\"\");\n    }\n}\n\ncontract L2StandardBridge_FinalizeBridgeETH_Test is Bridge_Initializer {\n    function test_finalizeBridgeETH_succeeds() external {\n        address messenger = address(L2Bridge.MESSENGER());\n        vm.mockCall(\n            messenger,\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(messenger, 100);\n        vm.prank(messenger);\n\n        vm.expectEmit(true, true, true, true);\n        emit ETHBridgeFinalized(alice, alice, 100, hex\"\");\n\n        L2Bridge.finalizeBridgeETH{ value: 100 }(alice, alice, 100, hex\"\");\n    }\n}\n"
    },
    "contracts/test/L2ToL1MessagePasser.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract L2ToL1MessagePasserTest is CommonTest {\n    L2ToL1MessagePasser messagePasser;\n\n    event MessagePassed(\n        uint256 indexed nonce,\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes data,\n        bytes32 withdrawalHash\n    );\n\n    event WithdrawerBalanceBurnt(uint256 indexed amount);\n\n    function setUp() public virtual override {\n        super.setUp();\n        messagePasser = new L2ToL1MessagePasser();\n    }\n\n    function testFuzz_initiateWithdrawal_succeeds(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        uint256 nonce = messagePasser.messageNonce();\n\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction({\n                nonce: nonce,\n                sender: _sender,\n                target: _target,\n                value: _value,\n                gasLimit: _gasLimit,\n                data: _data\n            })\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit MessagePassed(nonce, _sender, _target, _value, _gasLimit, _data, withdrawalHash);\n\n        vm.deal(_sender, _value);\n        vm.prank(_sender);\n        messagePasser.initiateWithdrawal{ value: _value }(_target, _gasLimit, _data);\n\n        assertEq(messagePasser.sentMessages(withdrawalHash), true);\n\n        bytes32 slot = keccak256(bytes.concat(withdrawalHash, bytes32(0)));\n\n        assertEq(vm.load(address(messagePasser), slot), bytes32(uint256(1)));\n    }\n\n    // Test: initiateWithdrawal should emit the correct log when called by a contract\n    function test_initiateWithdrawal_fromContract_succeeds() external {\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction(\n                messagePasser.messageNonce(),\n                address(this),\n                address(4),\n                100,\n                64000,\n                hex\"\"\n            )\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit MessagePassed(\n            messagePasser.messageNonce(),\n            address(this),\n            address(4),\n            100,\n            64000,\n            hex\"\",\n            withdrawalHash\n        );\n\n        vm.deal(address(this), 2**64);\n        messagePasser.initiateWithdrawal{ value: 100 }(address(4), 64000, hex\"\");\n    }\n\n    // Test: initiateWithdrawal should emit the correct log when called by an EOA\n    function test_initiateWithdrawal_fromEOA_succeeds() external {\n        uint256 gasLimit = 64000;\n        address target = address(4);\n        uint256 value = 100;\n        bytes memory data = hex\"ff\";\n        uint256 nonce = messagePasser.messageNonce();\n\n        // EOA emulation\n        vm.prank(alice, alice);\n        vm.deal(alice, 2**64);\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction(nonce, alice, target, value, gasLimit, data)\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit MessagePassed(nonce, alice, target, value, gasLimit, data, withdrawalHash);\n\n        messagePasser.initiateWithdrawal{ value: value }(target, gasLimit, data);\n\n        // the sent messages mapping is filled\n        assertEq(messagePasser.sentMessages(withdrawalHash), true);\n        // the nonce increments\n        assertEq(nonce + 1, messagePasser.messageNonce());\n    }\n\n    // Test: burn should destroy the ETH held in the contract\n    function test_burn_succeeds() external {\n        messagePasser.initiateWithdrawal{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            NON_ZERO_GASLIMIT,\n            NON_ZERO_DATA\n        );\n\n        assertEq(address(messagePasser).balance, NON_ZERO_VALUE);\n        vm.expectEmit(true, false, false, false);\n        emit WithdrawerBalanceBurnt(NON_ZERO_VALUE);\n        messagePasser.burn();\n\n        // The Withdrawer should have no balance\n        assertEq(address(messagePasser).balance, 0);\n    }\n}\n"
    },
    "contracts/test/NodeReader.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { NodeReader } from \"../libraries/NodeReader.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract NodeReader_Test is CommonTest {\n    function test_readUint8_bytestring00() external {\n        NodeReader.Item memory item = NodeReader.toItem(hex\"00\");\n        assertEq(NodeReader.readUint8(item), uint8(0x00));\n    }\n\n    function test_readUint8_bytestring01() external {\n        NodeReader.Item memory item = NodeReader.toItem(hex\"01\");\n        assertEq(NodeReader.readUint8(item), uint8(0x01));\n    }\n\n    function test_readUint8_bytestring7f() external {\n        NodeReader.Item memory item = NodeReader.toItem(hex\"7f\");\n        assertEq(NodeReader.readUint8(item), uint8(0x7f));\n    }\n\n    function test_readUint8_too_short_bytestring() external {\n        vm.expectRevert(\"NodeReader: too short for uint8\");\n        NodeReader.Item memory item = NodeReader.toItem(hex\"\");\n        NodeReader.readUint8(item);\n    }\n\n    function test_readCompressedFlags_length01_and_flag000003() external {\n        NodeReader.Item memory item = NodeReader.toItem(hex\"01030000\");\n        (uint32 compressedFlags, uint8 len) = NodeReader.readCompressedFlags(item);\n        assertEq(compressedFlags, uint32(3));\n        assertEq(len, uint8(1));\n    }\n\n    function test_readCompressedFlags_too_short_byte() external {\n        vm.expectRevert(\"NodeReader: too short for uint32\");\n        NodeReader.Item memory item = NodeReader.toItem(hex\"\");\n        NodeReader.readCompressedFlags(item);\n    }\n\n    function test_readBytes32_32bytesting() external {\n        NodeReader.Item memory item = NodeReader.toItem(\n            hex\"000102030405060708090a0b0c0d0e0f101112131415161718192a2b2c2d2e2f\"\n        );\n        assertEq(\n            NodeReader.readBytes32(item),\n            hex\"000102030405060708090a0b0c0d0e0f101112131415161718192a2b2c2d2e2f\"\n        );\n    }\n\n    function test_readBytes32_too_short_byte() external {\n        vm.expectRevert(\"NodeReader: too short for bytes32\");\n        NodeReader.Item memory item = NodeReader.toItem(hex\"\");\n        NodeReader.readBytes32(item);\n    }\n\n    function test_readBytesN_4bytesting() external {\n        NodeReader.Item memory item = NodeReader.toItem(hex\"0001020304\");\n        assertEq(NodeReader.readBytesN(item, 4), bytes32(uint256(0x010203)));\n    }\n\n    function test_readBytesN_too_short_byte() external {\n        vm.expectRevert(\"NodeReader: too short for n bytes\");\n        NodeReader.Item memory item = NodeReader.toItem(hex\"0001020304\");\n        NodeReader.readBytesN(item, 6);\n    }\n\n    function test_readNode_middle_node() external {\n        bytes memory middleHex = new bytes(65);\n        bytes32 childL = hex\"0000000000000000000000000000000000000000000000000000000000000000\";\n        bytes32 childR = hex\"04470b58d80eeb26da85b2c2db5c254900656fb459c07729f556ff02534ab32a\";\n        assembly {\n            mstore8(add(middleHex, 32), 0)\n            mstore(add(middleHex, 33), childL)\n            mstore(add(middleHex, 65), childR)\n        }\n        NodeReader.Node memory node = NodeReader.readNode(middleHex);\n        assertEq(uint256(node.nodeType), uint256(NodeReader.NodeType.MIDDLE));\n        assertEq(node.childL, childL);\n        assertEq(node.childR, childR);\n    }\n\n    function test_readNode_leaf_node() external {\n        bytes memory leafHex = new bytes(102);\n        bytes32 nodeKey = hex\"7f9d3bbc51d12566ecc6049ca6bf76e32828c22b197405f63a833b566fe7da0a\";\n        bytes32 value = hex\"0000000000000000000000000000000000000000000000000000000000000001\";\n        assembly {\n            mstore8(add(leafHex, 32), 1)\n            mstore(add(leafHex, 33), nodeKey)\n            mstore8(add(leafHex, 65), 1)\n            mstore8(add(leafHex, 66), 1)\n            mstore8(add(leafHex, 67), 0)\n            mstore8(add(leafHex, 68), 0)\n            mstore(add(leafHex, 69), value)\n            mstore8(add(leafHex, 101), 0)\n        }\n        NodeReader.Node memory node = NodeReader.readNode(leafHex);\n        assertEq(uint256(node.nodeType), uint256(NodeReader.NodeType.LEAF));\n        assertEq(node.nodeKey, nodeKey);\n        assertEq(node.compressedFlags, 1);\n        assertEq(node.valuePreimage.length, 1);\n        assertEq(node.valuePreimage[0], value);\n    }\n\n    function test_readNode_empty_node() external {\n        bytes memory emptyHex = new bytes(1);\n        assembly {\n            mstore8(add(emptyHex, 32), 2)\n        }\n        NodeReader.Node memory node = NodeReader.readNode(emptyHex);\n        assertEq(uint256(node.nodeType), uint256(NodeReader.NodeType.EMPTY));\n    }\n\n    function test_readNode_root_node() external {\n        vm.expectRevert(\"NodeReader: unexpected root node type\");\n        bytes memory rootHex = new bytes(1);\n        assembly {\n            mstore8(add(rootHex, 32), 3)\n        }\n        NodeReader.readNode(rootHex);\n    }\n\n    function test_readNode_invalid_node() external {\n        vm.expectRevert(\"NodeReader: invalid node type\");\n        bytes memory invalidHex = new bytes(1);\n        assembly {\n            mstore8(add(invalidHex, 32), 4)\n        }\n        NodeReader.readNode(invalidHex);\n    }\n}\n"
    },
    "contracts/test/Proxy.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\nimport { Test } from \"forge-std/Test.sol\";\n\nimport { Proxy } from \"../universal/Proxy.sol\";\n\ncontract SimpleStorage {\n    mapping(uint256 => uint256) internal store;\n\n    function get(uint256 key) external payable returns (uint256) {\n        return store[key];\n    }\n\n    function set(uint256 key, uint256 value) external payable {\n        store[key] = value;\n    }\n}\n\ncontract Clasher {\n    function upgradeTo(address) external pure {\n        revert(\"upgradeTo\");\n    }\n}\n\ncontract Proxy_Test is Test {\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    address alice = address(64);\n\n    bytes32 internal constant IMPLEMENTATION_KEY =\n        bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1);\n\n    bytes32 internal constant OWNER_KEY = bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1);\n\n    Proxy proxy;\n    SimpleStorage simpleStorage;\n\n    function setUp() external {\n        // Deploy a proxy and simple storage contract as\n        // the implementation\n        proxy = new Proxy(alice);\n        simpleStorage = new SimpleStorage();\n\n        vm.prank(alice);\n        proxy.upgradeTo(address(simpleStorage));\n    }\n\n    function test_implementationKey_succeeds() external {\n        // The hardcoded implementation key should be correct\n        vm.prank(alice);\n        proxy.upgradeTo(address(6));\n\n        bytes32 key = vm.load(address(proxy), IMPLEMENTATION_KEY);\n        assertEq(address(6), Bytes32AddressLib.fromLast20Bytes(key));\n\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(6));\n    }\n\n    function test_ownerKey_succeeds() external {\n        // The hardcoded owner key should be correct\n        vm.prank(alice);\n        proxy.changeAdmin(address(6));\n\n        bytes32 key = vm.load(address(proxy), OWNER_KEY);\n        assertEq(address(6), Bytes32AddressLib.fromLast20Bytes(key));\n\n        vm.prank(address(6));\n        address owner = proxy.admin();\n        assertEq(owner, address(6));\n    }\n\n    function test_proxyCallToImp_notAdmin_succeeds() external {\n        // The implementation does not have a `upgradeTo`\n        // method, calling `upgradeTo` not as the owner\n        // should revert.\n        vm.expectRevert();\n        proxy.upgradeTo(address(64));\n\n        // Call `upgradeTo` as the owner, it should succeed\n        // and emit the `Upgraded` event.\n        vm.expectEmit(true, true, true, true);\n        emit Upgraded(address(64));\n        vm.prank(alice);\n        proxy.upgradeTo(address(64));\n\n        // Get the implementation as the owner\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(64));\n    }\n\n    function test_ownerProxyCall_notAdmin_succeeds() external {\n        // Calling `changeAdmin` not as the owner should revert\n        // as the implementation does not have a `changeAdmin` method.\n        vm.expectRevert();\n        proxy.changeAdmin(address(1));\n\n        // Call `changeAdmin` as the owner, it should succeed\n        // and emit the `AdminChanged` event.\n        vm.expectEmit(true, true, true, true);\n        emit AdminChanged(alice, address(1));\n        vm.prank(alice);\n        proxy.changeAdmin(address(1));\n\n        // Calling `admin` not as the owner should\n        // revert as the implementation does not have\n        // a `admin` method.\n        vm.expectRevert();\n        proxy.admin();\n\n        // Calling `admin` as the owner should work.\n        vm.prank(address(1));\n        address owner = proxy.admin();\n        assertEq(owner, address(1));\n    }\n\n    function test_delegatesToImpl_succeeds() external {\n        // Call the storage setter on the proxy\n        SimpleStorage(address(proxy)).set(1, 1);\n\n        // The key should not be set in the implementation\n        uint256 result = simpleStorage.get(1);\n        assertEq(result, 0);\n        {\n            // The key should be set in the proxy\n            uint256 expect = SimpleStorage(address(proxy)).get(1);\n            assertEq(expect, 1);\n        }\n\n        {\n            // The owner should be able to call through the proxy\n            // when there is not a function selector crash\n            vm.prank(alice);\n            uint256 expect = SimpleStorage(address(proxy)).get(1);\n            assertEq(expect, 1);\n        }\n    }\n\n    function test_upgradeToAndCall_succeeds() external {\n        {\n            // There should be nothing in the current proxy storage\n            uint256 expect = SimpleStorage(address(proxy)).get(1);\n            assertEq(expect, 0);\n        }\n\n        // Deploy a new SimpleStorage\n        simpleStorage = new SimpleStorage();\n\n        // Set the new SimpleStorage as the implementation\n        // and call.\n        vm.expectEmit(true, true, true, true);\n        emit Upgraded(address(simpleStorage));\n        vm.prank(alice);\n        proxy.upgradeToAndCall(\n            address(simpleStorage),\n            abi.encodeWithSelector(simpleStorage.set.selector, 1, 1)\n        );\n\n        // The call should have impacted the state\n        uint256 result = SimpleStorage(address(proxy)).get(1);\n        assertEq(result, 1);\n    }\n\n    function test_upgradeToAndCall_functionDoesNotExist_reverts() external {\n        // Get the current implementation address\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(simpleStorage));\n\n        // Deploy a new SimpleStorage\n        simpleStorage = new SimpleStorage();\n\n        // Set the new SimpleStorage as the implementation\n        // and call. This reverts because the calldata doesn't\n        // match a function on the implementation.\n        vm.expectRevert(\"Proxy: delegatecall to new implementation contract failed\");\n        vm.prank(alice);\n        proxy.upgradeToAndCall(address(simpleStorage), hex\"\");\n\n        // The implementation address should have not\n        // updated because the call to `upgradeToAndCall`\n        // reverted.\n        vm.prank(alice);\n        address postImpl = proxy.implementation();\n        assertEq(impl, postImpl);\n\n        // The attempt to `upgradeToAndCall`\n        // should revert when it is not called by the owner.\n        vm.expectRevert();\n        proxy.upgradeToAndCall(\n            address(simpleStorage),\n            abi.encodeWithSelector(simpleStorage.set.selector, 1, 1)\n        );\n    }\n\n    function test_upgradeToAndCall_isPayable_succeeds() external {\n        // Give alice some funds\n        vm.deal(alice, 1 ether);\n        // Set the implementation and call and send\n        // value.\n        vm.prank(alice);\n        proxy.upgradeToAndCall{ value: 1 ether }(\n            address(simpleStorage),\n            abi.encodeWithSelector(simpleStorage.set.selector, 1, 1)\n        );\n\n        // The implementation address should be correct\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(simpleStorage));\n\n        // The proxy should have a balance\n        assertEq(address(proxy).balance, 1 ether);\n    }\n\n    function test_upgradeTo_clashingFunctionSignatures_succeeds() external {\n        // Clasher has a clashing function with the proxy.\n        Clasher clasher = new Clasher();\n\n        // Set the clasher as the implementation.\n        vm.prank(alice);\n        proxy.upgradeTo(address(clasher));\n\n        {\n            // Assert that the implementation was set properly.\n            vm.prank(alice);\n            address impl = proxy.implementation();\n            assertEq(impl, address(clasher));\n        }\n\n        // Call the clashing function on the proxy\n        // not as the owner so that the call passes through.\n        // The implementation will revert so we can be\n        // sure that the call passed through.\n        vm.expectRevert(bytes(\"upgradeTo\"));\n        proxy.upgradeTo(address(0));\n\n        {\n            // Now call the clashing function as the owner\n            // and be sure that it doesn't pass through to\n            // the implementation.\n            vm.prank(alice);\n            proxy.upgradeTo(address(0));\n            vm.prank(alice);\n            address impl = proxy.implementation();\n            assertEq(impl, address(0));\n        }\n    }\n\n    // Allow for `eth_call` to call proxy methods\n    // by setting \"from\" to `address(0)`.\n    function test_implementation_zeroAddressCaller_succeeds() external {\n        vm.prank(address(0));\n        address impl = proxy.implementation();\n        assertEq(impl, address(simpleStorage));\n    }\n\n    function test_implementation_isZeroAddress_reverts() external {\n        // Set `address(0)` as the implementation.\n        vm.prank(alice);\n        proxy.upgradeTo(address(0));\n\n        (bool success, bytes memory returndata) = address(proxy).call(hex\"\");\n        assertEq(success, false);\n\n        bytes memory err = abi.encodeWithSignature(\n            \"Error(string)\",\n            \"Proxy: implementation not initialized\"\n        );\n\n        assertEq(returndata, err);\n    }\n}\n"
    },
    "contracts/test/ProxyAdmin.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\n\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { ProxyAdmin } from \"../universal/ProxyAdmin.sol\";\nimport { SimpleStorage } from \"./Proxy.t.sol\";\n\ncontract ProxyAdmin_Test is Test {\n    address alice = address(64);\n\n    Proxy proxy;\n\n    ProxyAdmin admin;\n\n    SimpleStorage implementation;\n\n    function setUp() external {\n        // Deploy the proxy admin\n        admin = new ProxyAdmin(alice);\n        // Deploy the standard proxy\n        proxy = new Proxy(address(admin));\n\n        implementation = new SimpleStorage();\n    }\n\n    function test_owner_succeeds() external {\n        assertEq(admin.owner(), alice);\n    }\n\n    function test_getProxyImplementation_succeeds() external {\n        {\n            address impl = admin.getProxyImplementation(payable(proxy));\n            assertEq(impl, address(0));\n        }\n\n        vm.prank(alice);\n        admin.upgrade(payable(proxy), address(implementation));\n\n        {\n            address impl = admin.getProxyImplementation(payable(proxy));\n            assertEq(impl, address(implementation));\n        }\n    }\n\n    function test_getProxyAdmin_succeeds() external {\n        address owner = admin.getProxyAdmin(payable(proxy));\n        assertEq(owner, address(admin));\n    }\n\n    function test_changeProxyAdmin_succeeds() external {\n        vm.prank(alice);\n        admin.changeProxyAdmin(payable(proxy), address(128));\n\n        // The proxy is no longer the admin and can\n        // no longer call the proxy interface.\n        vm.expectRevert(\"Proxy: implementation not initialized\");\n        admin.getProxyAdmin(payable(proxy));\n\n        // Call the proxy contract directly to get the admin.\n        // Different proxy types have different interfaces.\n        vm.prank(address(128));\n        assertEq(Proxy(payable(proxy)).admin(), address(128));\n    }\n\n    function test_upgrade_succeeds() external {\n        vm.prank(alice);\n        admin.upgrade(payable(proxy), address(implementation));\n\n        address impl = admin.getProxyImplementation(payable(proxy));\n        assertEq(impl, address(implementation));\n    }\n\n    function test_upgradeAndCall_succeeds() external {\n        vm.prank(alice);\n        admin.upgradeAndCall(\n            payable(proxy),\n            address(implementation),\n            abi.encodeWithSelector(SimpleStorage.set.selector, 1, 1)\n        );\n\n        address impl = admin.getProxyImplementation(payable(proxy));\n        assertEq(impl, address(implementation));\n\n        uint256 got = SimpleStorage(address(proxy)).get(1);\n        assertEq(got, 1);\n    }\n\n    function test_onlyOwner_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        admin.changeProxyAdmin(payable(proxy), address(0));\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        admin.upgrade(payable(proxy), address(implementation));\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        admin.upgradeAndCall(payable(proxy), address(implementation), hex\"\");\n    }\n}\n"
    },
    "contracts/test/RLP.t.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\n\n/**\n * @title LibRLP\n * @notice Via https://github.com/Rari-Capital/solmate/issues/207.\n */\nlibrary LibRLP {\n    using Bytes32AddressLib for bytes32;\n\n    function computeAddress(address deployer, uint256 nonce) internal pure returns (address) {\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\n        // A one byte integer uses its own value as its length prefix, there is no additional \"0x80 + length\" prefix that comes before it.\n        if (nonce == 0x00)\n            return\n                keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80)))\n                    .fromLast20Bytes();\n        if (nonce <= 0x7f)\n            return\n                keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce)))\n                    .fromLast20Bytes();\n\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\n        if (nonce <= type(uint8).max)\n            return\n                keccak256(\n                    abi.encodePacked(\n                        bytes1(0xd7),\n                        bytes1(0x94),\n                        deployer,\n                        bytes1(0x81),\n                        uint8(nonce)\n                    )\n                ).fromLast20Bytes();\n        if (nonce <= type(uint16).max)\n            return\n                keccak256(\n                    abi.encodePacked(\n                        bytes1(0xd8),\n                        bytes1(0x94),\n                        deployer,\n                        bytes1(0x82),\n                        uint16(nonce)\n                    )\n                ).fromLast20Bytes();\n        if (nonce <= type(uint24).max)\n            return\n                keccak256(\n                    abi.encodePacked(\n                        bytes1(0xd9),\n                        bytes1(0x94),\n                        deployer,\n                        bytes1(0x83),\n                        uint24(nonce)\n                    )\n                ).fromLast20Bytes();\n\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\n        return\n            keccak256(\n                abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce))\n            ).fromLast20Bytes();\n    }\n}\n"
    },
    "contracts/test/ResourceMetering.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\n\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\n\ncontract MeterUser is ResourceMetering {\n    ResourceMetering.ResourceConfig public innerConfig;\n\n    constructor() {\n        initialize();\n        innerConfig = Constants.DEFAULT_RESOURCE_CONFIG();\n    }\n\n    function initialize() public initializer {\n        __ResourceMetering_init();\n    }\n\n    function resourceConfig() public view returns (ResourceMetering.ResourceConfig memory) {\n        return _resourceConfig();\n    }\n\n    function _resourceConfig()\n        internal\n        view\n        override\n        returns (ResourceMetering.ResourceConfig memory)\n    {\n        return innerConfig;\n    }\n\n    function use(uint64 _amount) public metered(_amount) {}\n\n    function set(\n        uint128 _prevBaseFee,\n        uint64 _prevBoughtGas,\n        uint64 _prevBlockNum\n    ) public {\n        params = ResourceMetering.ResourceParams({\n            prevBaseFee: _prevBaseFee,\n            prevBoughtGas: _prevBoughtGas,\n            prevBlockNum: _prevBlockNum\n        });\n    }\n\n    function setParams(ResourceMetering.ResourceConfig memory newConfig) public {\n        innerConfig = newConfig;\n    }\n}\n\n/**\n * @title ResourceConfig\n * @notice The tests are based on the default config values. It is expected that\n *         the config values used in these tests are ran in production.\n */\ncontract ResourceMetering_Test is Test {\n    MeterUser internal meter;\n    uint64 initialBlockNum;\n\n    function setUp() public {\n        meter = new MeterUser();\n        initialBlockNum = uint64(block.number);\n    }\n\n    function test_meter_initialResourceParams_succeeds() external {\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n        ResourceMetering.ResourceConfig memory rcfg = meter.resourceConfig();\n\n        assertEq(prevBaseFee, rcfg.minimumBaseFee);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum);\n    }\n\n    function test_meter_updateParamsNoChange_succeeds() external {\n        meter.use(0); // equivalent to just updating the base fee and block number\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n        meter.use(0);\n        (uint128 postBaseFee, uint64 postBoughtGas, uint64 postBlockNum) = meter.params();\n\n        assertEq(postBaseFee, prevBaseFee);\n        assertEq(postBoughtGas, prevBoughtGas);\n        assertEq(postBlockNum, prevBlockNum);\n    }\n\n    function test_meter_updateOneEmptyBlock_succeeds() external {\n        vm.roll(initialBlockNum + 1);\n        meter.use(0);\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, 1 gwei);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum + 1);\n    }\n\n    function test_meter_updateTwoEmptyBlocks_succeeds() external {\n        vm.roll(initialBlockNum + 2);\n        meter.use(0);\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, 1 gwei);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum + 2);\n    }\n\n    function test_meter_updateTenEmptyBlocks_succeeds() external {\n        vm.roll(initialBlockNum + 10);\n        meter.use(0);\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, 1 gwei);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum + 10);\n    }\n\n    function test_meter_updateNoGasDelta_succeeds() external {\n        ResourceMetering.ResourceConfig memory rcfg = meter.resourceConfig();\n        uint256 target = uint256(rcfg.maxResourceLimit) / uint256(rcfg.elasticityMultiplier);\n        meter.use(uint64(target));\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, 1000000000);\n        assertEq(prevBoughtGas, target);\n        assertEq(prevBlockNum, initialBlockNum);\n    }\n\n    function test_meter_useMax_succeeds() external {\n        ResourceMetering.ResourceConfig memory rcfg = meter.resourceConfig();\n        uint64 target = uint64(rcfg.maxResourceLimit) / uint64(rcfg.elasticityMultiplier);\n        uint64 elasticityMultiplier = uint64(rcfg.elasticityMultiplier);\n        meter.use(target * elasticityMultiplier);\n\n        (, uint64 prevBoughtGas, ) = meter.params();\n        assertEq(prevBoughtGas, target * elasticityMultiplier);\n\n        vm.roll(initialBlockNum + 1);\n        meter.use(0);\n        (uint128 postBaseFee, , ) = meter.params();\n        assertEq(postBaseFee, 2125000000);\n    }\n\n    /**\n     * @notice This tests that the metered modifier reverts if\n     *         the ResourceConfig baseFeeMaxChangeDenominator\n     *         is set to 1.\n     *         Since the metered modifier internally calls\n     *         solmate's powWad function, it will revert\n     *         with the error string \"UNEXPECTED\" since the\n     *         first parameter will be computed as 0.\n     */\n    function test_meter_denominatorEq1_reverts() external {\n        ResourceMetering.ResourceConfig memory rcfg = meter.resourceConfig();\n        uint64 target = uint64(rcfg.maxResourceLimit) / uint64(rcfg.elasticityMultiplier);\n        uint64 elasticityMultiplier = uint64(rcfg.elasticityMultiplier);\n        rcfg.baseFeeMaxChangeDenominator = 1;\n        meter.setParams(rcfg);\n        meter.use(target * elasticityMultiplier);\n\n        (, uint64 prevBoughtGas, ) = meter.params();\n        assertEq(prevBoughtGas, target * elasticityMultiplier);\n\n        vm.roll(initialBlockNum + 2);\n\n        vm.expectRevert(\"UNDEFINED\");\n        meter.use(0);\n    }\n\n    function test_meter_useMoreThanMax_reverts() external {\n        ResourceMetering.ResourceConfig memory rcfg = meter.resourceConfig();\n        uint64 target = uint64(rcfg.maxResourceLimit) / uint64(rcfg.elasticityMultiplier);\n        uint64 elasticityMultiplier = uint64(rcfg.elasticityMultiplier);\n\n        vm.expectRevert(\"ResourceMetering: cannot buy more gas than available gas limit\");\n        meter.use(target * elasticityMultiplier + 1);\n    }\n\n    // Demonstrates that the resource metering arithmetic can tolerate very large gaps between\n    // deposits.\n    function testFuzz_meter_largeBlockDiff_succeeds(uint64 _amount, uint256 _blockDiff) external {\n        // This test fails if the following line is commented out.\n        // At 12 seconds per block, this number is effectively unreachable.\n        vm.assume(_blockDiff < 433576281058164217753225238677900874458691);\n\n        ResourceMetering.ResourceConfig memory rcfg = meter.resourceConfig();\n        uint64 target = uint64(rcfg.maxResourceLimit) / uint64(rcfg.elasticityMultiplier);\n        uint64 elasticityMultiplier = uint64(rcfg.elasticityMultiplier);\n\n        vm.assume(_amount < target * elasticityMultiplier);\n        vm.roll(initialBlockNum + _blockDiff);\n        meter.use(_amount);\n    }\n}\n\n/**\n * @title CustomMeterUser\n * @notice A simple wrapper around `ResourceMetering` that allows the initial\n *         params to be set in the constructor.\n */\ncontract CustomMeterUser is ResourceMetering {\n    uint256 public startGas;\n    uint256 public endGas;\n\n    constructor(\n        uint128 _prevBaseFee,\n        uint64 _prevBoughtGas,\n        uint64 _prevBlockNum\n    ) {\n        params = ResourceMetering.ResourceParams({\n            prevBaseFee: _prevBaseFee,\n            prevBoughtGas: _prevBoughtGas,\n            prevBlockNum: _prevBlockNum\n        });\n    }\n\n    function _resourceConfig()\n        internal\n        pure\n        override\n        returns (ResourceMetering.ResourceConfig memory)\n    {\n        return Constants.DEFAULT_RESOURCE_CONFIG();\n    }\n\n    function use(uint64 _amount) public returns (uint256) {\n        uint256 initialGas = gasleft();\n        _metered(_amount, initialGas);\n        return initialGas - gasleft();\n    }\n}\n\n/**\n * @title ArtifactResourceMetering_Test\n * @notice A table test that sets the state of the ResourceParams and then requests\n *         various amounts of gas. This test ensures that a wide range of values\n *         can safely be used with the `ResourceMetering` contract.\n *         It also writes a CSV file to disk that includes useful information\n *         about how much gas is used and how expensive it is in USD terms to\n *         purchase the deposit gas.\n */\ncontract ArtifactResourceMetering_Test is Test {\n    uint128 internal minimumBaseFee;\n    uint128 internal maximumBaseFee;\n    uint64 internal maxResourceLimit;\n    uint64 internal targetResourceLimit;\n\n    string internal outfile;\n\n    // keccak256(abi.encodeWithSignature(\"Error(string)\", \"ResourceMetering: cannot buy more gas than available gas limit\"))\n    bytes32 internal cannotBuyMoreGas =\n        0x84edc668cfd5e050b8999f43ff87a1faaa93e5f935b20bc1dd4d3ff157ccf429;\n    // keccak256(abi.encodeWithSignature(\"Panic(uint256)\", 0x11))\n    bytes32 internal overflowErr =\n        0x1ca389f2c8264faa4377de9ce8e14d6263ef29c68044a9272d405761bab2db27;\n    // keccak256(hex\"\")\n    bytes32 internal emptyReturnData =\n        0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n    /**\n     * @notice Sets up the tests by getting constants from the ResourceMetering\n     *         contract.\n     */\n    function setUp() public {\n        vm.roll(1_000_000);\n\n        MeterUser base = new MeterUser();\n        ResourceMetering.ResourceConfig memory rcfg = base.resourceConfig();\n        minimumBaseFee = uint128(rcfg.minimumBaseFee);\n        maximumBaseFee = rcfg.maximumBaseFee;\n        maxResourceLimit = uint64(rcfg.maxResourceLimit);\n        targetResourceLimit = uint64(rcfg.maxResourceLimit) / uint64(rcfg.elasticityMultiplier);\n\n        outfile = string.concat(vm.projectRoot(), \"/.resource-metering.csv\");\n        try vm.removeFile(outfile) {} catch {}\n    }\n\n    /**\n     * @notice Generate a CSV file. The call to `meter` should be called with at\n     *         most the L1 block gas limit. Without specifying the amount of\n     *         gas, it can take very long to execute.\n     */\n    function test_meter_generateArtifact_succeeds() external {\n        vm.writeLine(\n            outfile,\n            \"prevBaseFee,prevBoughtGas,prevBlockNumDiff,l1BaseFee,requestedGas,gasConsumed,ethPrice,usdCost,success\"\n        );\n\n        // prevBaseFee value in ResourceParams\n        uint128[] memory prevBaseFees = new uint128[](5);\n        prevBaseFees[0] = minimumBaseFee;\n        prevBaseFees[1] = maximumBaseFee;\n        prevBaseFees[2] = uint128(50 gwei);\n        prevBaseFees[3] = uint128(100 gwei);\n        prevBaseFees[4] = uint128(200 gwei);\n\n        // prevBoughtGas value in ResourceParams\n        uint64[] memory prevBoughtGases = new uint64[](1);\n        prevBoughtGases[0] = uint64(0);\n\n        // prevBlockNum diff, simulates blocks with no deposits when non zero\n        uint64[] memory prevBlockNumDiffs = new uint64[](2);\n        prevBlockNumDiffs[0] = 0;\n        prevBlockNumDiffs[1] = 1;\n\n        // The amount of L2 gas that a user requests\n        uint64[] memory requestedGases = new uint64[](3);\n        requestedGases[0] = maxResourceLimit;\n        requestedGases[1] = targetResourceLimit;\n        requestedGases[2] = uint64(100_000);\n\n        // The L1 base fee\n        uint256[] memory l1BaseFees = new uint256[](4);\n        l1BaseFees[0] = 1 gwei;\n        l1BaseFees[1] = 50 gwei;\n        l1BaseFees[2] = 75 gwei;\n        l1BaseFees[3] = 100 gwei;\n\n        // USD price of 1 ether\n        uint256[] memory ethPrices = new uint256[](2);\n        ethPrices[0] = 1600;\n        ethPrices[1] = 3200;\n\n        // Iterate over all of the test values and run a test\n        for (uint256 i; i < prevBaseFees.length; i++) {\n            for (uint256 j; j < prevBoughtGases.length; j++) {\n                for (uint256 k; k < prevBlockNumDiffs.length; k++) {\n                    for (uint256 l; l < requestedGases.length; l++) {\n                        for (uint256 m; m < l1BaseFees.length; m++) {\n                            for (uint256 n; n < ethPrices.length; n++) {\n                                uint256 snapshotId = vm.snapshot();\n\n                                uint128 prevBaseFee = prevBaseFees[i];\n                                uint64 prevBoughtGas = prevBoughtGases[j];\n                                uint64 prevBlockNumDiff = prevBlockNumDiffs[k];\n                                uint64 requestedGas = requestedGases[l];\n                                uint256 l1BaseFee = l1BaseFees[m];\n                                uint256 ethPrice = ethPrices[n];\n                                string memory result = \"success\";\n\n                                vm.fee(l1BaseFee);\n\n                                CustomMeterUser meter = new CustomMeterUser({\n                                    _prevBaseFee: prevBaseFee,\n                                    _prevBoughtGas: prevBoughtGas,\n                                    _prevBlockNum: uint64(block.number)\n                                });\n\n                                vm.roll(block.number + prevBlockNumDiff);\n\n                                // Call the metering code and catch the various\n                                // types of errors.\n                                uint256 gasConsumed = 0;\n                                try meter.use{ gas: 30_000_000 }(requestedGas) returns (\n                                    uint256 _gasConsumed\n                                ) {\n                                    gasConsumed = _gasConsumed;\n                                } catch (bytes memory err) {\n                                    bytes32 hash = keccak256(err);\n                                    if (hash == cannotBuyMoreGas) {\n                                        result = \"ResourceMetering: cannot buy more gas than available gas limit\";\n                                    } else if (hash == overflowErr) {\n                                        result = \"arithmetic overflow/underflow\";\n                                    } else if (hash == emptyReturnData) {\n                                        result = \"out of gas\";\n                                    } else {\n                                        result = \"UNKNOWN ERROR\";\n                                    }\n                                }\n\n                                // Compute the USD cost of the gas used\n                                uint256 usdCost = (gasConsumed * l1BaseFee * ethPrice) / 1 ether;\n\n                                vm.writeLine(\n                                    outfile,\n                                    string.concat(\n                                        vm.toString(prevBaseFee),\n                                        \",\",\n                                        vm.toString(prevBoughtGas),\n                                        \",\",\n                                        vm.toString(prevBlockNumDiff),\n                                        \",\",\n                                        vm.toString(l1BaseFee),\n                                        \",\",\n                                        vm.toString(requestedGas),\n                                        \",\",\n                                        vm.toString(gasConsumed),\n                                        \",\",\n                                        \"$\",\n                                        vm.toString(ethPrice),\n                                        \",\",\n                                        \"$\",\n                                        vm.toString(usdCost),\n                                        \",\",\n                                        result\n                                    )\n                                );\n\n                                assertTrue(vm.revertTo(snapshotId));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/test/SafeCall.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract SafeCall_Test is CommonTest {\n    function testFuzz_call_succeeds(\n        address from,\n        address to,\n        uint256 gas,\n        uint64 value,\n        bytes memory data\n    ) external {\n        vm.assume(from.balance == 0);\n        vm.assume(to.balance == 0);\n        // no precompiles (mainnet)\n        assumeNoPrecompiles(to, 1);\n        // don't call the vm\n        vm.assume(to != address(vm));\n        vm.assume(from != address(vm));\n        // don't call the console\n        vm.assume(to != address(0x000000000000000000636F6e736F6c652e6c6f67));\n        // don't call the create2 deployer\n        vm.assume(to != address(0x4e59b44847b379578588920cA78FbF26c0B4956C));\n        // don't call the default test contract\n        vm.assume(to != address(0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f));\n\n        assertEq(from.balance, 0, \"from balance is 0\");\n        vm.deal(from, value);\n        assertEq(from.balance, value, \"from balance not dealt\");\n\n        uint256[2] memory balancesBefore = [from.balance, to.balance];\n\n        vm.expectCall(to, value, data);\n        vm.prank(from);\n        bool success = SafeCall.call(to, gas, value, data);\n\n        assertTrue(success, \"call not successful\");\n        if (from == to) {\n            assertEq(from.balance, balancesBefore[0], \"Self-send did not change balance\");\n        } else {\n            assertEq(from.balance, balancesBefore[0] - value, \"from balance not drained\");\n            assertEq(to.balance, balancesBefore[1] + value, \"to balance received\");\n        }\n    }\n\n    function testFuzz_callWithMinGas_hasEnough_succeeds(\n        address from,\n        address to,\n        uint64 minGas,\n        uint64 value,\n        bytes memory data\n    ) external {\n        vm.assume(from.balance == 0);\n        vm.assume(to.balance == 0);\n        // no precompiles (mainnet)\n        assumeNoPrecompiles(to, 1);\n        // don't call the vm\n        vm.assume(to != address(vm));\n        vm.assume(from != address(vm));\n        // don't call the console\n        vm.assume(to != address(0x000000000000000000636F6e736F6c652e6c6f67));\n        // don't call the create2 deployer\n        vm.assume(to != address(0x4e59b44847b379578588920cA78FbF26c0B4956C));\n        // don't call the default test contract\n        vm.assume(to != address(0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f));\n\n        assertEq(from.balance, 0, \"from balance is 0\");\n        vm.deal(from, value);\n        assertEq(from.balance, value, \"from balance not dealt\");\n\n        // Bound minGas to [0, l1_block_gas_limit]\n        minGas = uint64(bound(minGas, 0, 30_000_000));\n\n        uint256[2] memory balancesBefore = [from.balance, to.balance];\n\n        vm.expectCallMinGas(to, value, minGas, data);\n        vm.prank(from);\n        bool success = SafeCall.callWithMinGas(to, minGas, value, data);\n\n        assertTrue(success, \"call not successful\");\n        if (from == to) {\n            assertEq(from.balance, balancesBefore[0], \"Self-send did not change balance\");\n        } else {\n            assertEq(from.balance, balancesBefore[0] - value, \"from balance not drained\");\n            assertEq(to.balance, balancesBefore[1] + value, \"to balance received\");\n        }\n    }\n\n    function test_callWithMinGas_noLeakageLow_succeeds() external {\n        SimpleSafeCaller caller = new SimpleSafeCaller();\n\n        for (uint64 i = 40_000; i < 100_000; i++) {\n            uint256 snapshot = vm.snapshot();\n\n            // 65_907 is the exact amount of gas required to make the safe call\n            // successfully.\n            if (i < 65_907) {\n                assertFalse(caller.makeSafeCall(i, 25_000));\n            } else {\n                vm.expectCallMinGas(\n                    address(caller),\n                    0,\n                    25_000,\n                    abi.encodeWithSelector(caller.setA.selector, 1)\n                );\n                assertTrue(caller.makeSafeCall(i, 25_000));\n            }\n\n            assertTrue(vm.revertTo(snapshot));\n        }\n    }\n\n    function test_callWithMinGas_noLeakageHigh_succeeds() external {\n        SimpleSafeCaller caller = new SimpleSafeCaller();\n\n        for (uint64 i = 15_200_000; i < 15_300_000; i++) {\n            uint256 snapshot = vm.snapshot();\n\n            // 15_278_606 is the exact amount of gas required to make the safe call\n            // successfully.\n            if (i < 15_278_606) {\n                assertFalse(caller.makeSafeCall(i, 15_000_000));\n            } else {\n                vm.expectCallMinGas(\n                    address(caller),\n                    0,\n                    15_000_000,\n                    abi.encodeWithSelector(caller.setA.selector, 1)\n                );\n                assertTrue(caller.makeSafeCall(i, 15_000_000));\n            }\n\n            assertTrue(vm.revertTo(snapshot));\n        }\n    }\n}\n\ncontract SimpleSafeCaller {\n    uint256 public a;\n\n    function makeSafeCall(uint64 gas, uint64 minGas) external returns (bool) {\n        return\n            SafeCall.call(\n                address(this),\n                gas,\n                0,\n                abi.encodeWithSelector(this.makeSafeCallMinGas.selector, minGas)\n            );\n    }\n\n    function makeSafeCallMinGas(uint64 minGas) external returns (bool) {\n        return\n            SafeCall.callWithMinGas(\n                address(this),\n                minGas,\n                0,\n                abi.encodeWithSelector(this.setA.selector, 1)\n            );\n    }\n\n    function setA(uint256 _a) external {\n        a = _a;\n    }\n}\n"
    },
    "contracts/test/SecurityCouncil.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { SecurityCouncil_Initializer } from \"./CommonTest.t.sol\";\nimport { Types } from \"../libraries/Types.sol\";\n\ncontract SecurityCouncilTest is SecurityCouncil_Initializer {\n    /**\n     *  Events\n     */\n    event Confirmation(address indexed sender, uint256 indexed transactionId);\n    event Revocation(address indexed sender, uint256 indexed transactionId);\n    event Submission(uint256 indexed transactionId);\n    event Execution(uint256 indexed transactionId);\n    event ExecutionFailure(uint256 indexed transactionId);\n    event OwnerAddition(address indexed owner);\n    event OwnerRemoval(address indexed owner);\n    event RequirementChange(uint256 required);\n    event ValidationRequested(\n        uint256 indexed transactionId,\n        bytes32 outputRoot,\n        uint256 l2BlockNumber\n    );\n    event DeletionRequested(uint256 indexed transactionId, uint256 indexed outputIndex);\n\n    function test_initialize_succeeds() external {\n        address[] memory _owners = securityCouncil.getOwners();\n        for (uint256 i = 0; i < _owners.length; i++) {\n            assertEq(securityCouncil.owners(i), _owners[i]);\n        }\n\n        assertEq(securityCouncil.COLOSSEUM(), colosseumAddr);\n        assertEq(securityCouncil.numConfirmationsRequired(), NUM_CONFIRMATIONS_REQUIRED);\n        assertEq(securityCouncil.getTransactionCount(true, true), 0);\n    }\n\n    function test_submitTransaction_reverts() external {\n        vm.prank(makeAddr(\"not owner\"));\n        vm.expectRevert(\"MultiSigWallet: owner does not exist\");\n        securityCouncil.submitTransaction(owners[0], 0, bytes(\"anydata\"));\n    }\n\n    function test_submitTransaction_succeeds() external {\n        // submit dummy transaction\n        vm.prank(address(owners[0]));\n        vm.expectEmit(true, false, false, false);\n        emit Submission(0);\n        uint256 txId = securityCouncil.submitTransaction(owners[0], 0, bytes(\"anydata\"));\n\n        // check transaction count increased\n        Types.MultiSigTransaction memory t;\n        (t.destination, t.executed, t.value, t.data) = securityCouncil.transactions(txId);\n        assertEq(t.destination, owners[0]);\n        assertEq(t.executed, false);\n        assertEq(t.value, 0);\n        assertEq(t.data, bytes(\"anydata\"));\n\n        uint256 txCount = securityCouncil.transactionCount();\n        assertEq(txCount, 1);\n    }\n\n    function test_confirmTransaction_reverts() external {\n        // submit dummy transaction\n        vm.prank(address(owners[0]));\n        uint256 txId = securityCouncil.submitTransaction(owners[0], 0, bytes(\"anydata\"));\n\n        // check revert confirm transaction\n        vm.expectRevert();\n        vm.prank(makeAddr(\"not owner\"));\n        securityCouncil.confirmTransaction(txId);\n    }\n\n    function test_confirmTransaction_succeeds() external {\n        // submit dummy transaction\n        vm.prank(address(owners[0]));\n        uint256 txId = securityCouncil.submitTransaction(owners[0], 0, bytes(\"anydata\"));\n\n        // check transaction confirmed\n        address[] memory confirmList;\n        confirmList = securityCouncil.getConfirmations(txId);\n        assertEq(confirmList.length, 1);\n\n        // check transaction not executed\n        Types.MultiSigTransaction memory t;\n        (t.destination, t.executed, t.value, t.data) = securityCouncil.transactions(txId);\n        assertEq(t.executed, false);\n\n        // confirm transaction\n        vm.expectEmit(true, false, false, false);\n        emit Confirmation(owners[1], txId);\n        vm.prank(owners[1]);\n        securityCouncil.confirmTransaction(txId);\n\n        // check transaction confirmed\n        confirmList = securityCouncil.getConfirmations(txId);\n        assertEq(confirmList.length, 2);\n\n        // check transaction executed\n        (t.destination, t.executed, t.value, t.data) = securityCouncil.transactions(txId);\n        assertEq(t.executed, true);\n    }\n\n    function test_revokeConfirmation_succeeds() external {\n        // submit dummy transaction\n        vm.prank(address(owners[0]));\n        uint256 txId = securityCouncil.submitTransaction(owners[0], 0, bytes(\"anydata\"));\n\n        // revoke confirmation\n        vm.expectEmit(true, false, false, false);\n        emit Revocation(owners[0], txId);\n        vm.prank(owners[0]);\n        securityCouncil.revokeConfirmation(txId);\n\n        // check confirmation revoked\n        address[] memory confirmList;\n        confirmList = securityCouncil.getConfirmations(txId);\n        assertEq(confirmList.length, 0);\n    }\n\n    function test_executeTransaction_succeeds() external {\n        // submit dummy transaction\n        vm.prank(address(owners[0]));\n        uint256 txId = securityCouncil.submitTransaction(owners[0], 0, bytes(\"anydata\"));\n\n        // confirm transaction to execute\n        vm.prank(owners[1]);\n        securityCouncil.confirmTransaction(txId);\n\n        // check transaction count increased\n        Types.MultiSigTransaction memory t;\n        (t.destination, t.executed, t.value, t.data) = securityCouncil.transactions(txId);\n        assertEq(t.executed, true);\n    }\n\n    function test_requestValidation_reverts() external {\n        vm.prank(makeAddr(\"not colosseum\"));\n        vm.expectRevert(\"SecurityCouncil: only the colosseum contract can be a sender\");\n        securityCouncil.requestValidation(bytes32(0), 0, bytes(\"anydata\"));\n    }\n\n    function test_requestValidation_succeeds() external {\n        // request output validation\n        bytes32 outputRoot = bytes32(\"dummy output root\");\n        uint128 l2BlockNumber = 3;\n        vm.prank(colosseumAddr);\n        vm.expectEmit(true, false, false, false);\n        emit ValidationRequested(0, outputRoot, l2BlockNumber);\n        securityCouncil.requestValidation(outputRoot, l2BlockNumber, bytes(\"anydata\"));\n    }\n\n    function test_executeValidateTransaction_succeeds() external {\n        // request output validation\n        bytes32 outputRoot = bytes32(\"dummy output root\");\n        uint128 l2BlockNumber = 3;\n        uint256 txId = 0;\n        vm.prank(colosseumAddr);\n        vm.expectEmit(true, false, false, false);\n        emit ValidationRequested(txId, outputRoot, l2BlockNumber);\n        securityCouncil.requestValidation(outputRoot, l2BlockNumber, bytes(\"anydata\"));\n\n        // check transaction not executed\n        Types.MultiSigTransaction memory t;\n        (t.destination, t.executed, t.value, t.data) = securityCouncil.transactions(txId);\n        assertEq(t.executed, false);\n\n        // confirm transaction to execute\n        vm.prank(owners[0]);\n        securityCouncil.confirmTransaction(txId);\n        vm.prank(owners[1]);\n        securityCouncil.confirmTransaction(txId);\n\n        // check transaction confirmed\n        address[] memory confirmList;\n        confirmList = securityCouncil.getConfirmations(txId);\n        assertEq(confirmList.length, 2);\n\n        // check transaction executed\n        (t.destination, t.executed, t.value, t.data) = securityCouncil.transactions(txId);\n        assertEq(t.executed, true);\n    }\n\n    function test_requestDeletion_succeeds() external {\n        // request output deletion\n        uint256 _outputIndex = 1;\n        uint256 txId = 0;\n        vm.prank(owners[0]);\n        vm.expectEmit(true, true, false, false);\n        emit DeletionRequested(txId, _outputIndex);\n        securityCouncil.requestDeletion(_outputIndex, false);\n\n        // check transaction not executed\n        Types.MultiSigTransaction memory t;\n        (t.destination, t.executed, t.value, t.data) = securityCouncil.transactions(txId);\n        assertEq(t.executed, false);\n\n        // confirm transaction to execute\n        vm.prank(owners[1]);\n        securityCouncil.confirmTransaction(txId);\n\n        // check transaction confirmed\n        address[] memory confirmList;\n        confirmList = securityCouncil.getConfirmations(txId);\n        assertEq(confirmList.length, 2);\n\n        // check transaction executed\n        (t.destination, t.executed, t.value, t.data) = securityCouncil.transactions(txId);\n        assertEq(t.executed, true);\n    }\n\n    function test_requestDeletion_alreadyRequested_reverts() external {\n        // request output deletion\n        uint256 _outputIndex = 1;\n        vm.prank(owners[0]);\n        vm.expectEmit(true, true, false, false);\n        emit DeletionRequested(0, _outputIndex);\n        securityCouncil.requestDeletion(_outputIndex, false);\n\n        // try to request the same output index\n        vm.prank(owners[0]);\n        vm.expectRevert(\"SecurityCouncil: the output has already been requested to be deleted\");\n        securityCouncil.requestDeletion(_outputIndex, false);\n    }\n\n    function test_requestDeletion_force_succeeds() external {\n        // request output deletion\n        uint256 _outputIndex = 1;\n        vm.prank(owners[0]);\n        vm.expectEmit(true, true, false, false);\n        emit DeletionRequested(0, _outputIndex);\n        securityCouncil.requestDeletion(_outputIndex, false);\n\n        // try to request the same output index\n        vm.prank(owners[0]);\n        vm.expectEmit(true, true, false, false);\n        emit DeletionRequested(1, _outputIndex);\n        securityCouncil.requestDeletion(_outputIndex, true);\n    }\n}\n"
    },
    "contracts/test/Semver.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\n/**\n * @notice Test the Semver contract that is used for semantic versioning\n *         of various contracts.\n */\ncontract Semver_Test is CommonTest {\n    /**\n     * @notice Global semver contract deployed in setUp. This is used in\n     *         the test cases.\n     */\n    Semver semver;\n\n    /**\n     * @notice Deploy a Semver contract\n     */\n    function setUp() public virtual override {\n        super.setUp();\n        semver = new Semver(7, 8, 0);\n    }\n\n    /**\n     * @notice Test the version getter\n     */\n    function test_version_succeeds() external {\n        assertEq(semver.version(), \"7.8.0\");\n    }\n\n    /**\n     * @notice Since the versions are all immutable, they should\n     *         be able to be accessed from behind a proxy without needing\n     *         to initialize the contract.\n     */\n    function test_behindProxy_succeeds() external {\n        Proxy proxy = new Proxy(alice);\n        vm.prank(alice);\n        proxy.upgradeTo(address(semver));\n\n        assertEq(Semver(address(proxy)).version(), \"7.8.0\");\n    }\n}\n"
    },
    "contracts/test/StandardBridge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { KromaMintableERC20 } from \"../universal/KromaMintableERC20.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\n/**\n * @title StandardBridgeTester\n * @notice Simple wrapper around the StandardBridge contract that exposes\n *         internal functions so they can be more easily tested directly.\n */\ncontract StandardBridgeTester is StandardBridge {\n    constructor(address payable _messenger, address payable _otherBridge)\n        StandardBridge(_messenger, _otherBridge)\n    {}\n\n    function isKromaMintableERC20(address _token) external view returns (bool) {\n        return _isKromaMintableERC20(_token);\n    }\n\n    function isCorrectTokenPair(address _mintableToken, address _otherToken)\n        external\n        view\n        returns (bool)\n    {\n        return _isCorrectTokenPair(_mintableToken, _otherToken);\n    }\n\n    receive() external payable override {}\n}\n\n/**\n * @title StandardBridge_Stateless_Test\n * @notice Tests internal functions that require no existing state or contract\n *         interactions with the messenger.\n */\ncontract StandardBridge_Stateless_Test is CommonTest {\n    StandardBridgeTester internal bridge;\n    KromaMintableERC20 internal mintable;\n    ERC20 internal erc20;\n\n    function setUp() public override {\n        super.setUp();\n\n        bridge = new StandardBridgeTester({\n            _messenger: payable(address(0)),\n            _otherBridge: payable(address(0))\n        });\n\n        mintable = new KromaMintableERC20({\n            _bridge: address(0),\n            _remoteToken: address(0),\n            _name: \"Stonks\",\n            _symbol: \"STONK\"\n        });\n\n        erc20 = new ERC20(\"Altcoin\", \"ALT\");\n    }\n\n    /**\n     * @notice Test coverage for identifying KromaMintableERC20 tokens.\n     *         This function should return true for\n     *         KromaMintableERC20 tokens and false for any accounts that\n     *         do not implement the interface.\n     */\n    function test_isKromaMintableERC20_succeeds() external {\n        // Both the modern and legacy mintable tokens should return true\n        assertTrue(bridge.isKromaMintableERC20(address(mintable)));\n        // A regular ERC20 should return false\n        assertFalse(bridge.isKromaMintableERC20(address(erc20)));\n        // Non existent contracts should return false and not revert\n        assertEq(address(0x20).code.length, 0);\n        assertFalse(bridge.isKromaMintableERC20(address(0x20)));\n    }\n\n    /**\n     * @notice Test coverage of isCorrectTokenPair under different types of\n     *         tokens.\n     */\n    function test_isCorrectTokenPair_succeeds() external {\n        // Modern + known to be correct remote token\n        assertTrue(bridge.isCorrectTokenPair(address(mintable), mintable.REMOTE_TOKEN()));\n        // Modern + known to be incorrect remote token\n        assertTrue(mintable.REMOTE_TOKEN() != address(0x20));\n        assertFalse(bridge.isCorrectTokenPair(address(mintable), address(0x20)));\n    }\n}\n"
    },
    "contracts/test/SystemConfig.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { SystemConfig } from \"../L1/SystemConfig.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract SystemConfig_Init is CommonTest {\n    SystemConfig sysConf;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({\n            maxResourceLimit: 20_000_000,\n            elasticityMultiplier: 10,\n            baseFeeMaxChangeDenominator: 8,\n            minimumBaseFee: 1 gwei,\n            systemTxMaxGas: 1_000_000,\n            maximumBaseFee: type(uint128).max\n        });\n\n        sysConf = new SystemConfig({\n            _owner: alice,\n            _overhead: 2100,\n            _scalar: 1000000,\n            _batcherHash: bytes32(hex\"abcd\"),\n            _gasLimit: 30_000_000,\n            _unsafeBlockSigner: address(1),\n            _config: config,\n            _validatorRewardScalar: 5000\n        });\n    }\n}\n\ncontract SystemConfig_Initialize_TestFail is SystemConfig_Init {\n    function test_initialize_lowGasLimit_reverts() external {\n        uint64 minimumGasLimit = sysConf.minimumGasLimit();\n\n        ResourceMetering.ResourceConfig memory cfg = ResourceMetering.ResourceConfig({\n            maxResourceLimit: 20_000_000,\n            elasticityMultiplier: 10,\n            baseFeeMaxChangeDenominator: 8,\n            minimumBaseFee: 1 gwei,\n            systemTxMaxGas: 1_000_000,\n            maximumBaseFee: type(uint128).max\n        });\n\n        vm.expectRevert(\"SystemConfig: gas limit too low\");\n\n        new SystemConfig({\n            _owner: alice,\n            _overhead: 0,\n            _scalar: 0,\n            _batcherHash: bytes32(hex\"\"),\n            _gasLimit: minimumGasLimit - 1,\n            _unsafeBlockSigner: address(1),\n            _config: cfg,\n            _validatorRewardScalar: 5000\n        });\n    }\n}\n\ncontract SystemConfig_Setters_TestFail is SystemConfig_Init {\n    function test_setBatcherHash_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sysConf.setBatcherHash(bytes32(hex\"\"));\n    }\n\n    function test_setGasConfig_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sysConf.setGasConfig(0, 0);\n    }\n\n    function test_setGasLimit_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sysConf.setGasLimit(0);\n    }\n\n    function test_setUnsafeBlockSigner_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sysConf.setUnsafeBlockSigner(address(0x20));\n    }\n\n    function test_setResourceConfig_notOwner_reverts() external {\n        ResourceMetering.ResourceConfig memory config = Constants.DEFAULT_RESOURCE_CONFIG();\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sysConf.setResourceConfig(config);\n    }\n\n    function test_setResourceConfig_badMinMax_reverts() external {\n        ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({\n            maxResourceLimit: 20_000_000,\n            elasticityMultiplier: 10,\n            baseFeeMaxChangeDenominator: 8,\n            systemTxMaxGas: 1_000_000,\n            minimumBaseFee: 2 gwei,\n            maximumBaseFee: 1 gwei\n        });\n        vm.prank(sysConf.owner());\n        vm.expectRevert(\"SystemConfig: min base fee must be less than max base\");\n        sysConf.setResourceConfig(config);\n    }\n\n    function test_setResourceConfig_zeroDenominator_reverts() external {\n        ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({\n            maxResourceLimit: 20_000_000,\n            elasticityMultiplier: 10,\n            baseFeeMaxChangeDenominator: 0,\n            systemTxMaxGas: 1_000_000,\n            minimumBaseFee: 1 gwei,\n            maximumBaseFee: 2 gwei\n        });\n        vm.prank(sysConf.owner());\n        vm.expectRevert(\"SystemConfig: denominator must be larger than 1\");\n        sysConf.setResourceConfig(config);\n    }\n\n    function test_setResourceConfig_lowGasLimit_reverts() external {\n        uint64 gasLimit = sysConf.gasLimit();\n\n        ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({\n            maxResourceLimit: uint32(gasLimit),\n            elasticityMultiplier: 10,\n            baseFeeMaxChangeDenominator: 8,\n            systemTxMaxGas: uint32(gasLimit),\n            minimumBaseFee: 1 gwei,\n            maximumBaseFee: 2 gwei\n        });\n        vm.prank(sysConf.owner());\n        vm.expectRevert(\"SystemConfig: gas limit too low\");\n        sysConf.setResourceConfig(config);\n    }\n\n    function test_setResourceConfig_badPrecision_reverts() external {\n        ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({\n            maxResourceLimit: 20_000_000,\n            elasticityMultiplier: 11,\n            baseFeeMaxChangeDenominator: 8,\n            systemTxMaxGas: 1_000_000,\n            minimumBaseFee: 1 gwei,\n            maximumBaseFee: 2 gwei\n        });\n        vm.prank(sysConf.owner());\n        vm.expectRevert(\"SystemConfig: precision loss with target resource limit\");\n        sysConf.setResourceConfig(config);\n    }\n\n    function test_setValidatorRewardScalar_outOfRange_reverts() external {\n        vm.prank(sysConf.owner());\n        vm.expectRevert(\"SystemConfig: the max value of validator reward scalar has been exceeded\");\n        sysConf.setValidatorRewardScalar(type(uint32).max);\n    }\n}\n\ncontract SystemConfig_Setters_Test is SystemConfig_Init {\n    event ConfigUpdate(\n        uint256 indexed version,\n        SystemConfig.UpdateType indexed updateType,\n        bytes data\n    );\n\n    function testFuzz_setBatcherHash_succeeds(bytes32 newBatcherHash) external {\n        vm.expectEmit(true, true, true, true);\n        emit ConfigUpdate(0, SystemConfig.UpdateType.BATCHER, abi.encode(newBatcherHash));\n\n        vm.prank(sysConf.owner());\n        sysConf.setBatcherHash(newBatcherHash);\n        assertEq(sysConf.batcherHash(), newBatcherHash);\n    }\n\n    function testFuzz_setGasConfig_succeeds(uint256 newOverhead, uint256 newScalar) external {\n        vm.expectEmit(true, true, true, true);\n        emit ConfigUpdate(\n            0,\n            SystemConfig.UpdateType.GAS_CONFIG,\n            abi.encode(newOverhead, newScalar)\n        );\n\n        vm.prank(sysConf.owner());\n        sysConf.setGasConfig(newOverhead, newScalar);\n        assertEq(sysConf.overhead(), newOverhead);\n        assertEq(sysConf.scalar(), newScalar);\n    }\n\n    function testFuzz_setGasLimit_succeeds(uint64 newGasLimit) external {\n        uint64 minimumGasLimit = sysConf.minimumGasLimit();\n        newGasLimit = uint64(\n            bound(uint256(newGasLimit), uint256(minimumGasLimit), uint256(type(uint64).max))\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit ConfigUpdate(0, SystemConfig.UpdateType.GAS_LIMIT, abi.encode(newGasLimit));\n\n        vm.prank(sysConf.owner());\n        sysConf.setGasLimit(newGasLimit);\n        assertEq(sysConf.gasLimit(), newGasLimit);\n    }\n\n    function testFuzz_setUnsafeBlockSigner_succeeds(address newUnsafeSigner) external {\n        vm.expectEmit(true, true, true, true);\n        emit ConfigUpdate(\n            0,\n            SystemConfig.UpdateType.UNSAFE_BLOCK_SIGNER,\n            abi.encode(newUnsafeSigner)\n        );\n\n        vm.prank(sysConf.owner());\n        sysConf.setUnsafeBlockSigner(newUnsafeSigner);\n        assertEq(sysConf.unsafeBlockSigner(), newUnsafeSigner);\n    }\n\n    function testFuzz_setValidatorRewardScalar_succeeds(uint256 validatorRewardScalar) external {\n        validatorRewardScalar = bound(\n            validatorRewardScalar,\n            0,\n            Constants.VALIDATOR_REWARD_DENOMINATOR\n        );\n        vm.expectEmit(true, true, true, true);\n        emit ConfigUpdate(\n            0,\n            SystemConfig.UpdateType.VALIDATOR_REWARD_SCALAR,\n            abi.encode(validatorRewardScalar)\n        );\n\n        vm.prank(sysConf.owner());\n        sysConf.setValidatorRewardScalar(validatorRewardScalar);\n        assertEq(sysConf.validatorRewardScalar(), validatorRewardScalar);\n    }\n}\n"
    },
    "contracts/test/UpgradeGovernor.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UpgradeGovernor_Initializer } from \"./CommonTest.t.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\n\ncontract UpgradeGovernorTest is UpgradeGovernor_Initializer {\n    uint256 blockNumber = 0;\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    function setUp() public virtual override {\n        super.setUp();\n        _roll(1);\n        // minting to guardians\n        vm.prank(owner);\n        securityCouncilToken.safeMint(guardian1, baseUri);\n        vm.prank(owner);\n        securityCouncilToken.safeMint(guardian2, baseUri);\n\n        vm.prank(guardian1);\n        securityCouncilToken.delegate(guardian1);\n        vm.prank(guardian2);\n        securityCouncilToken.delegate(guardian2);\n\n        assertEq(securityCouncilToken.balanceOf(guardian1), 1);\n        assertEq(securityCouncilToken.balanceOf(guardian2), 1);\n        assertEq(securityCouncilToken.getVotes(guardian1), 1);\n        assertEq(securityCouncilToken.getVotes(guardian2), 1);\n        assertEq(securityCouncilToken.owner(), owner);\n\n        _roll(1);\n    }\n\n    function test_initialize_succeeds() external {\n        // check securityCouncilToken\n        assertEq(securityCouncilToken.symbol(), \"KSC\");\n\n        // check timeLock\n        bytes32 PROPOSER_ROLE = timeLock.PROPOSER_ROLE();\n        bytes32 EXECUTOR_ROLE = timeLock.EXECUTOR_ROLE();\n        bytes32 ADMIN_ROLE = timeLock.TIMELOCK_ADMIN_ROLE();\n        assertTrue(timeLock.hasRole(PROPOSER_ROLE, address(upgradeGovernor)));\n        assertTrue(timeLock.hasRole(EXECUTOR_ROLE, address(upgradeGovernor)));\n        assertTrue(timeLock.hasRole(ADMIN_ROLE, address(upgradeGovernor)));\n\n        // check upgradeGovernor\n        assertEq(address(upgradeGovernor.token()), address(securityCouncilToken));\n        assertEq(upgradeGovernor.timelock(), address(timeLock));\n        assertEq(upgradeGovernor.votingDelay(), initialVotingDelay);\n        assertEq(upgradeGovernor.votingPeriod(), initialVotingPeriod);\n        assertEq(upgradeGovernor.proposalThreshold(), initialProposalThreshold);\n\n        // check proxy admin\n        vm.startPrank(address(upgradeGovernor));\n        assertEq(Proxy(payable(address(upgradeGovernor))).admin(), address(upgradeGovernor));\n        assertEq(Proxy(payable(address(securityCouncilToken))).admin(), address(upgradeGovernor));\n        assertEq(Proxy(payable(address(timeLock))).admin(), address(upgradeGovernor));\n        vm.stopPrank();\n    }\n\n    function _createProposal() private returns (uint256) {\n        address[] memory targetContracts = new address[](1);\n        targetContracts[0] = address(upgradeGovernor);\n        uint256[] memory values = new uint256[](1);\n        values[0] = 0;\n        bytes[] memory callDatas = new bytes[](1);\n        callDatas[0] = abi.encodeCall(upgradeGovernor.setVotingDelay, 10);\n        vm.prank(guardian1);\n        uint256 proposalId = upgradeGovernor.propose(\n            targetContracts,\n            values,\n            callDatas,\n            \"test proposal\"\n        );\n        _roll(1);\n        return proposalId;\n    }\n\n    function _queue() private returns (uint256) {\n        address[] memory targetContracts = new address[](1);\n        targetContracts[0] = address(upgradeGovernor);\n        uint256[] memory values = new uint256[](1);\n        values[0] = 0;\n        bytes[] memory callDatas = new bytes[](1);\n        callDatas[0] = abi.encodeCall(upgradeGovernor.setVotingDelay, 10);\n        vm.prank(guardian1);\n        uint256 queuedId = upgradeGovernor.queue(\n            targetContracts,\n            values,\n            callDatas,\n            _hashDescription(\"test proposal\")\n        );\n        return queuedId;\n    }\n\n    function _execute() private returns (uint256) {\n        address[] memory targetContracts = new address[](1);\n        targetContracts[0] = address(upgradeGovernor);\n        uint256[] memory values = new uint256[](1);\n        values[0] = 0;\n        bytes[] memory callDatas = new bytes[](1);\n        callDatas[0] = abi.encodeCall(upgradeGovernor.setVotingDelay, 10);\n        vm.prank(guardian1);\n        uint256 executedId = upgradeGovernor.execute(\n            targetContracts,\n            values,\n            callDatas,\n            _hashDescription(\"test proposal\")\n        );\n        return executedId;\n    }\n\n    function _hashDescription(string memory desc) private pure returns (bytes32) {\n        return keccak256(bytes(desc));\n    }\n\n    function _roll(uint256 addBlockNumber) private {\n        blockNumber += addBlockNumber;\n        vm.roll(blockNumber);\n    }\n\n    function test_createProposal_tokenThreshold_reverts() external {\n        address[] memory targetContracts = new address[](1);\n        targetContracts[0] = address(upgradeGovernor);\n        uint256[] memory values = new uint256[](1);\n        values[0] = 0;\n        bytes[] memory callDatas = new bytes[](1);\n        callDatas[0] = abi.encodeCall(upgradeGovernor.setVotingDelay, 10);\n        vm.expectRevert(\"Governor: proposer votes below proposal threshold\");\n        vm.prank(notGuardian);\n        upgradeGovernor.propose(targetContracts, values, callDatas, \"test proposal\");\n    }\n\n    function test_createProposal_succeeds() external {\n        address[] memory targetContracts = new address[](1);\n        targetContracts[0] = address(upgradeGovernor);\n        uint256[] memory values = new uint256[](1);\n        values[0] = 0;\n        bytes[] memory callDatas = new bytes[](1);\n        callDatas[0] = abi.encodeCall(upgradeGovernor.setVotingDelay, 10);\n        vm.prank(guardian1);\n        uint256 proposalId = upgradeGovernor.propose(\n            targetContracts,\n            values,\n            callDatas,\n            \"test proposal\"\n        );\n        uint8 state = uint8(upgradeGovernor.state(proposalId));\n        assertEq(state, uint8(ProposalState.Pending));\n    }\n\n    function test_voteProposal_overPeriod_reverts() external {\n        uint256 proposalId = _createProposal();\n        _roll(initialVotingPeriod);\n        vm.prank(guardian1);\n        vm.expectRevert(\"Governor: vote not currently active\");\n        upgradeGovernor.castVote(proposalId, 1);\n        uint8 state = uint8(upgradeGovernor.state(proposalId));\n        assertEq(state, uint8(ProposalState.Defeated));\n    }\n\n    function test_voteProposal_succeeds() external {\n        uint256 proposalId = _createProposal();\n        vm.prank(guardian1);\n        uint256 voted = upgradeGovernor.castVote(proposalId, 1);\n        assertEq(voted, securityCouncilToken.balanceOf(guardian1));\n\n        uint8 state = uint8(upgradeGovernor.state(proposalId));\n        assertEq(state, uint8(ProposalState.Active));\n\n        _roll(initialVotingPeriod);\n        state = uint8(upgradeGovernor.state(proposalId));\n        assertEq(state, uint8(ProposalState.Succeeded));\n    }\n\n    function test_queueProposal_succeeds() external {\n        uint256 proposalId = _createProposal();\n\n        // vote\n        vm.prank(guardian1);\n        upgradeGovernor.castVote(proposalId, 1);\n        _roll(initialVotingPeriod);\n\n        uint256 queuedId = _queue();\n        assertEq(proposalId, queuedId);\n\n        uint8 state = uint8(upgradeGovernor.state(proposalId));\n        assertEq(state, uint8(ProposalState.Queued));\n    }\n\n    function test_executeProposal_succeeds() external {\n        uint256 proposalId = _createProposal();\n\n        // vote\n        vm.prank(guardian1);\n        upgradeGovernor.castVote(proposalId, 1);\n        _roll(initialVotingPeriod);\n\n        _queue();\n        vm.warp(minDelaySeconds + 1);\n        uint256 executedId = _execute();\n        assertEq(proposalId, executedId);\n\n        uint8 state = uint8(upgradeGovernor.state(proposalId));\n        assertEq(state, uint8(ProposalState.Executed));\n\n        uint256 votingDelay = upgradeGovernor.votingDelay();\n        assertEq(votingDelay, 10);\n    }\n}\n"
    },
    "contracts/test/ValidatorPool.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { KromaPortal } from \"../L1/KromaPortal.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { ValidatorPool } from \"../L1/ValidatorPool.sol\";\nimport { ZKMerkleTrie } from \"../L1/ZKMerkleTrie.sol\";\nimport { ValidatorRewardVault } from \"../L2/ValidatorRewardVault.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { L2OutputOracle_Initializer } from \"./CommonTest.t.sol\";\n\ncontract MockL2OutputOracle is L2OutputOracle {\n    constructor(ValidatorPool _validatorPool, address _colosseum)\n        L2OutputOracle(_validatorPool, _colosseum, 1800, 2, 0, 0, 7 days)\n    {}\n\n    function addOutput(bytes32 _outputRoot, uint256 _l2BlockNumber) external payable {\n        l2Outputs.push(\n            Types.CheckpointOutput({\n                submitter: msg.sender,\n                outputRoot: _outputRoot,\n                timestamp: uint128(block.timestamp),\n                l2BlockNumber: uint128(_l2BlockNumber)\n            })\n        );\n    }\n\n    function replaceOutput(uint256 _outputIndex, bytes32 _outputRoot) external {\n        l2Outputs[_outputIndex] = Types.CheckpointOutput({\n            submitter: msg.sender,\n            outputRoot: _outputRoot,\n            timestamp: uint128(block.timestamp),\n            l2BlockNumber: l2Outputs[_outputIndex].l2BlockNumber\n        });\n    }\n}\n\n// Test the implementations of the ValidatorPool\ncontract ValidatorPoolTest is L2OutputOracle_Initializer {\n    MockL2OutputOracle mockOracle;\n    KromaPortal portal;\n\n    uint256 internal finalizationPeriodSeconds;\n\n    event Bonded(\n        address indexed submitter,\n        uint256 indexed outputIndex,\n        uint128 amount,\n        uint128 expiresAt\n    );\n\n    event BondIncreased(uint256 indexed outputIndex, address indexed challenger, uint128 amount);\n    event PendingBondAdded(uint256 indexed outputIndex, address indexed challenger, uint128 amount);\n    event PendingBondReleased(\n        uint256 indexed outputIndex,\n        address indexed challenger,\n        address indexed recipient,\n        uint128 amount\n    );\n    event Unbonded(uint256 indexed outputIndex, address indexed recipient, uint128 amount);\n\n    function setUp() public override {\n        super.setUp();\n\n        finalizationPeriodSeconds = oracle.FINALIZATION_PERIOD_SECONDS();\n\n        address oracleAddress = address(oracle);\n        MockL2OutputOracle mockOracleImpl = new MockL2OutputOracle(pool, address(challenger));\n        vm.prank(multisig);\n        Proxy(payable(oracleAddress)).upgradeTo(address(mockOracleImpl));\n        mockOracle = MockL2OutputOracle(oracleAddress);\n\n        portal = pool.PORTAL();\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(address(pool.L2_ORACLE()), address(oracle));\n        assertEq(pool.TRUSTED_VALIDATOR(), trusted);\n        assertEq(pool.REQUIRED_BOND_AMOUNT(), requiredBondAmount);\n        assertEq(pool.MAX_UNBOND(), maxUnbond);\n        assertEq(pool.ROUND_DURATION(), roundDuration);\n    }\n\n    function test_deposit_succeeds() public {\n        uint256 trustedBalance = trusted.balance;\n\n        vm.prank(trusted);\n        pool.deposit{ value: requiredBondAmount }();\n        assertEq(pool.balanceOf(trusted), requiredBondAmount);\n        assertEq(trusted.balance, trustedBalance - requiredBondAmount);\n        assertTrue(pool.isValidator(trusted));\n        assertEq(pool.validatorCount(), 1);\n\n        vm.prank(asserter);\n        pool.deposit{ value: requiredBondAmount }();\n        assertEq(pool.balanceOf(asserter), requiredBondAmount);\n        assertTrue(pool.isValidator(asserter));\n        assertEq(pool.validatorCount(), 2);\n    }\n\n    function test_deposit_alreadyValidator_succeeds() external {\n        test_deposit_succeeds();\n\n        uint256 count = pool.validatorCount();\n        address nextValidator = pool.nextValidator();\n        uint256 deposits = pool.balanceOf(nextValidator);\n\n        uint256 prevBalance = nextValidator.balance;\n        uint256 depositAmount = 1;\n\n        vm.prank(nextValidator);\n        pool.deposit{ value: depositAmount }();\n        assertEq(pool.balanceOf(trusted), deposits + depositAmount);\n        assertEq(nextValidator.balance, prevBalance - depositAmount);\n        assertTrue(pool.isValidator(trusted));\n        assertEq(pool.validatorCount(), count);\n    }\n\n    function test_deposit_insufficientBalances_reverts() external {\n        vm.deal(asserter, 0);\n        vm.prank(asserter);\n        vm.expectRevert();\n        pool.deposit{ value: requiredBondAmount }();\n    }\n\n    function test_withdraw_loseValidatorEligibility_succeeds() external {\n        test_deposit_succeeds();\n\n        uint256 count = pool.validatorCount();\n        address nextValidator = pool.nextValidator();\n        uint256 deposits = pool.balanceOf(nextValidator);\n\n        uint256 prevBalance = nextValidator.balance;\n        uint256 withdrawalAmount = 1;\n\n        vm.prank(nextValidator);\n        pool.withdraw(withdrawalAmount);\n        assertEq(pool.balanceOf(nextValidator), deposits - withdrawalAmount);\n        assertEq(nextValidator.balance, prevBalance + withdrawalAmount);\n        assertFalse(pool.isValidator(nextValidator));\n        assertEq(pool.validatorCount(), count - 1);\n    }\n\n    function test_withdraw_all_succeeds() external {\n        test_deposit_succeeds();\n\n        uint256 count = pool.validatorCount();\n        address nextValidator = pool.nextValidator();\n        uint256 deposits = pool.balanceOf(nextValidator);\n\n        uint256 prevBalance = nextValidator.balance;\n\n        vm.prank(nextValidator);\n        pool.withdraw(deposits);\n        assertEq(pool.balanceOf(nextValidator), 0);\n        assertEq(nextValidator.balance, prevBalance + deposits);\n        assertFalse(pool.isValidator(nextValidator));\n        assertEq(pool.validatorCount(), count - 1);\n    }\n\n    function test_withdraw_maintainValidatorEligibility_succeeds() external {\n        uint256 trustedBalance = trusted.balance;\n        uint256 depositAmount = requiredBondAmount * 2;\n\n        vm.prank(trusted);\n        pool.deposit{ value: depositAmount }();\n        assertEq(pool.balanceOf(trusted), depositAmount);\n        assertEq(trusted.balance, trustedBalance - depositAmount);\n        assertTrue(pool.isValidator(trusted));\n        assertEq(pool.validatorCount(), 1);\n\n        trustedBalance = trusted.balance;\n        uint256 withdrawalAmount = requiredBondAmount;\n\n        vm.prank(trusted);\n        pool.withdraw(withdrawalAmount);\n        assertEq(pool.balanceOf(trusted), withdrawalAmount);\n        assertEq(trusted.balance, trustedBalance + withdrawalAmount);\n        assertTrue(pool.isValidator(trusted));\n        assertEq(pool.validatorCount(), 1);\n    }\n\n    function test_createBond_succeeds() public {\n        test_deposit_succeeds();\n\n        uint256 nextOutputIndex = oracle.nextOutputIndex();\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        bytes32 outputRoot = keccak256(abi.encode(nextBlockNumber));\n        address validator = pool.nextValidator();\n\n        warpToSubmitTime(nextBlockNumber);\n\n        vm.prank(validator);\n        mockOracle.addOutput(outputRoot, nextBlockNumber);\n\n        uint128 expiresAt = uint128(block.timestamp + finalizationPeriodSeconds);\n        vm.prank(address(oracle));\n        vm.expectEmit(true, true, false, true, address(pool));\n        emit Bonded(validator, nextOutputIndex, uint128(requiredBondAmount), expiresAt);\n        pool.createBond(nextOutputIndex, expiresAt);\n        assertEq(pool.balanceOf(validator), 0);\n        assertFalse(pool.isValidator(validator));\n        assertEq(pool.getBond(nextOutputIndex).amount, uint128(requiredBondAmount));\n        assertEq(pool.getBond(nextOutputIndex).expiresAt, expiresAt);\n    }\n\n    function test_createBond_unbondBefore_succeeds() external {\n        test_createBond_succeeds();\n\n        Types.CheckpointOutput memory firstOutput = oracle.getL2Output(0);\n        Types.Bond memory firstBond = pool.getBond(0);\n        // warp to the expiration time of the first bond.\n        vm.warp(firstBond.expiresAt);\n\n        uint256 nextOutputIndex = oracle.nextOutputIndex();\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        bytes32 outputRoot = keccak256(abi.encode(nextBlockNumber));\n        address validator = pool.nextValidator();\n        if (validator == Constants.VALIDATOR_PUBLIC_ROUND_ADDRESS) {\n            validator = asserter;\n        }\n\n        // deposit again & append new output\n        vm.startPrank(validator);\n        mockOracle.addOutput(outputRoot, nextBlockNumber);\n        pool.deposit{ value: requiredBondAmount }();\n        vm.stopPrank();\n\n        uint128 expiresAt = uint128(block.timestamp + finalizationPeriodSeconds);\n        vm.prank(address(oracle));\n        vm.expectEmit(true, true, false, true, address(pool));\n        emit Unbonded(0, firstOutput.submitter, uint128(firstBond.amount));\n        pool.createBond(nextOutputIndex, expiresAt);\n        assertEq(pool.balanceOf(firstOutput.submitter), requiredBondAmount);\n\n        // check whether bond is deleted\n        vm.expectRevert(\"ValidatorPool: the bond does not exist\");\n        pool.getBond(0);\n    }\n\n    function test_createBond_senderNotL2OO_reverts() external {\n        test_deposit_succeeds();\n\n        vm.prank(trusted);\n        vm.expectRevert(\"ValidatorPool: sender is not L2OutputOracle\");\n        pool.createBond(0, uint128(block.timestamp + finalizationPeriodSeconds));\n    }\n\n    function test_createBond_existsBond_reverts() external {\n        test_createBond_succeeds();\n\n        uint256 outputIndex = oracle.latestOutputIndex();\n        Types.Bond memory bond = pool.getBond(outputIndex);\n        assertTrue(bond.expiresAt > 0);\n\n        Types.CheckpointOutput memory output = oracle.getL2Output(outputIndex);\n\n        vm.prank(output.submitter);\n        pool.deposit{ value: requiredBondAmount }();\n\n        vm.prank(address(oracle));\n        vm.expectRevert(\"ValidatorPool: bond of the given output index already exists\");\n        pool.createBond(outputIndex, uint128(block.timestamp + finalizationPeriodSeconds));\n    }\n\n    function test_createBond_insufficientBalances_reverts() external {\n        uint256 nextOutputIndex = oracle.nextOutputIndex();\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        bytes32 outputRoot = keccak256(abi.encode(nextBlockNumber));\n        address validator = pool.nextValidator();\n\n        warpToSubmitTime(nextBlockNumber);\n\n        vm.prank(validator);\n        mockOracle.addOutput(outputRoot, nextBlockNumber);\n\n        uint128 expiresAt = uint128(block.timestamp + finalizationPeriodSeconds);\n        vm.prank(address(oracle));\n        vm.expectRevert(\"ValidatorPool: insufficient balances\");\n        pool.createBond(nextOutputIndex, expiresAt);\n    }\n\n    function test_unbond_succeeds() public {\n        test_createBond_succeeds();\n\n        uint256 outputIndex = oracle.latestOutputIndex();\n        Types.CheckpointOutput memory output = oracle.getL2Output(outputIndex);\n        Types.Bond memory bond = pool.getBond(outputIndex);\n\n        // warp to the time the output is finalized and the bond is expires.\n        vm.warp(bond.expiresAt);\n\n        vm.expectEmit(true, true, false, true, address(pool));\n        emit Unbonded(outputIndex, output.submitter, bond.amount);\n        vm.expectCall(\n            address(pool.PORTAL()),\n            abi.encodeWithSelector(\n                KromaPortal.depositTransactionByValidatorPool.selector,\n                Predeploys.VALIDATOR_REWARD_VAULT,\n                pool.VAULT_REWARD_GAS_LIMIT(),\n                abi.encodeWithSelector(\n                    ValidatorRewardVault.reward.selector,\n                    output.submitter,\n                    output.l2BlockNumber\n                )\n            )\n        );\n        vm.prank(trusted);\n        pool.unbond();\n        assertEq(pool.balanceOf(output.submitter), uint256(bond.amount));\n    }\n\n    function test_unbond_multipleBonds_succeeds() public {\n        uint256 tries = 2;\n        uint256 deposit = requiredBondAmount * tries;\n        vm.prank(trusted);\n        pool.deposit{ value: deposit }();\n\n        // submit 2 outputs, only trusted can submit outputs before at least one unbond.\n        uint256 blockNumber = 0;\n        uint128 expiresAt = 0;\n        for (uint256 i = 0; i < tries; i++) {\n            blockNumber = oracle.nextBlockNumber();\n            warpToSubmitTime(blockNumber);\n            expiresAt = uint128(block.timestamp + finalizationPeriodSeconds);\n            assertEq(pool.nextValidator(), trusted);\n            vm.prank(trusted);\n            mockOracle.addOutput(keccak256(abi.encode(blockNumber)), blockNumber);\n            vm.prank(address(oracle));\n            pool.createBond(i, expiresAt);\n            assertEq(pool.balanceOf(trusted), deposit - requiredBondAmount * (i + 1));\n        }\n\n        uint256 firstOutputIndex = 0;\n        Types.CheckpointOutput memory firstOutput = oracle.getL2Output(firstOutputIndex);\n        Types.Bond memory firstBond = pool.getBond(firstOutputIndex);\n\n        uint256 secondOutputIndex = 1;\n        Types.CheckpointOutput memory secondOutput = oracle.getL2Output(secondOutputIndex);\n        Types.Bond memory secondBond = pool.getBond(secondOutputIndex);\n\n        // warp to the time the second output is finalized and the two bonds are expired.\n        vm.warp(secondBond.expiresAt);\n\n        vm.expectEmit(true, true, false, true, address(pool));\n        emit Unbonded(firstOutputIndex, firstOutput.submitter, firstBond.amount);\n        vm.expectCall(\n            address(pool.PORTAL()),\n            abi.encodeWithSelector(\n                KromaPortal.depositTransactionByValidatorPool.selector,\n                Predeploys.VALIDATOR_REWARD_VAULT,\n                pool.VAULT_REWARD_GAS_LIMIT(),\n                abi.encodeWithSelector(\n                    ValidatorRewardVault.reward.selector,\n                    firstOutput.submitter,\n                    firstOutput.l2BlockNumber\n                )\n            )\n        );\n        vm.expectEmit(true, true, false, true, address(pool));\n        emit Unbonded(secondOutputIndex, secondOutput.submitter, secondBond.amount);\n        vm.expectCall(\n            address(pool.PORTAL()),\n            abi.encodeWithSelector(\n                KromaPortal.depositTransactionByValidatorPool.selector,\n                Predeploys.VALIDATOR_REWARD_VAULT,\n                pool.VAULT_REWARD_GAS_LIMIT(),\n                abi.encodeWithSelector(\n                    ValidatorRewardVault.reward.selector,\n                    secondOutput.submitter,\n                    secondOutput.l2BlockNumber\n                )\n            )\n        );\n        vm.prank(trusted);\n        pool.unbond();\n\n        // check whether bonds are deleted and trusted balance has increased.\n        for (uint256 i = 0; i < tries; i++) {\n            vm.expectRevert(\"ValidatorPool: the bond does not exist\");\n            pool.getBond(i);\n        }\n        assertEq(pool.balanceOf(trusted), deposit);\n    }\n\n    function test_unbond_maxUnbond_succeeds() public {\n        uint256 tries = maxUnbond + 1;\n        uint256 deposit = requiredBondAmount * tries;\n        vm.prank(trusted);\n        pool.deposit{ value: deposit }();\n\n        // submit (maxUnbond + 1) outputs, only trusted can submit outputs before at least one unbond.\n        uint256 blockNumber = 0;\n        uint128 expiresAt = 0;\n        for (uint256 i = 0; i < tries; i++) {\n            blockNumber = oracle.nextBlockNumber();\n            warpToSubmitTime(blockNumber);\n            expiresAt = uint128(block.timestamp + finalizationPeriodSeconds);\n            assertEq(pool.nextValidator(), trusted);\n            vm.prank(trusted);\n            mockOracle.addOutput(keccak256(abi.encode(blockNumber)), blockNumber);\n            vm.prank(address(oracle));\n            pool.createBond(i, expiresAt);\n            assertEq(pool.balanceOf(trusted), deposit - requiredBondAmount * (i + 1));\n        }\n\n        uint256 outputIndex = oracle.latestOutputIndex();\n        Types.Bond memory bond = pool.getBond(outputIndex);\n\n        // warp to the time the latest output is finalized and all bonds are expired.\n        vm.warp(bond.expiresAt);\n\n        vm.prank(trusted);\n        pool.unbond();\n\n        // check whether maxUnbond number of bonds are deleted and the last one is not.\n        for (uint256 i = 0; i < tries - 1; i++) {\n            vm.expectRevert(\"ValidatorPool: the bond does not exist\");\n            pool.getBond(i);\n        }\n        bond = pool.getBond(tries - 1);\n        assertEq(bond.amount, requiredBondAmount);\n    }\n\n    function test_unbond_notExpired_reverts() external {\n        test_createBond_succeeds();\n\n        vm.expectRevert(\"ValidatorPool: no bond that can be unbond\");\n        pool.unbond();\n    }\n\n    function test_unbond_noBond_reverts() external {\n        vm.expectRevert(\"ValidatorPool: no bond that can be unbond\");\n        pool.unbond();\n    }\n\n    function test_addPendingBond_succeeds() public {\n        test_createBond_succeeds();\n\n        uint256 outputIndex = oracle.latestOutputIndex();\n        Types.Bond memory bond = pool.getBond(outputIndex);\n\n        vm.prank(challenger);\n        pool.deposit{ value: bond.amount }();\n\n        vm.prank(oracle.COLOSSEUM());\n        vm.expectEmit(true, true, false, true, address(pool));\n        emit PendingBondAdded(outputIndex, challenger, bond.amount);\n        pool.addPendingBond(outputIndex, challenger);\n\n        // check bond state\n        assertEq(pool.getPendingBond(outputIndex, challenger), bond.amount);\n        assertEq(pool.balanceOf(challenger), 0);\n    }\n\n    function test_addPendingBond_noBond_reverts() external {\n        vm.prank(oracle.COLOSSEUM());\n        vm.expectRevert(\"ValidatorPool: the output is already finalized\");\n        pool.addPendingBond(0, challenger);\n    }\n\n    function test_addPendingBond_insufficientBalances_reverts() external {\n        test_createBond_succeeds();\n\n        uint256 outputIndex = oracle.latestOutputIndex();\n\n        vm.prank(oracle.COLOSSEUM());\n        vm.expectRevert(\"ValidatorPool: insufficient balances\");\n        pool.addPendingBond(outputIndex, challenger);\n    }\n\n    function test_increaseBond_succeeds() public {\n        test_addPendingBond_succeeds();\n\n        uint256 prevScBalance = pool.balanceOf(pool.SECURITY_COUNCIL());\n\n        uint256 outputIndex = oracle.latestOutputIndex();\n        Types.Bond memory prevBond = pool.getBond(outputIndex);\n        uint128 pendingBond = pool.getPendingBond(outputIndex, challenger);\n        uint128 tax = pendingBond * 20 / 100; // 20% tax\n        uint128 increased = pendingBond - tax;\n\n        vm.prank(oracle.COLOSSEUM());\n        vm.expectEmit(true, true, false, false);\n        emit BondIncreased(outputIndex, challenger, increased);\n        pool.increaseBond(outputIndex, challenger);\n\n        // check bond state\n        assertEq(pool.getBond(outputIndex).amount, prevBond.amount + increased);\n        assertEq(pool.balanceOf(challenger), 0);\n\n        // check security council balance\n        assertEq(pool.balanceOf(pool.SECURITY_COUNCIL()), prevScBalance + tax);\n    }\n\n    function test_increaseBond_noBond_reverts() external {\n        vm.prank(oracle.COLOSSEUM());\n        vm.expectRevert(\"ValidatorPool: the output is already finalized\");\n        pool.increaseBond(0, challenger);\n    }\n\n    function test_increaseBond_noPendingBond_reverts() external {\n        test_createBond_succeeds();\n\n        vm.prank(oracle.COLOSSEUM());\n        vm.expectRevert(\"ValidatorPool: the pending bond does not exist\");\n        pool.increaseBond(0, challenger);\n    }\n\n    function test_releasePendingBond_succeeds() external {\n        test_addPendingBond_succeeds();\n\n        uint256 outputIndex = oracle.latestOutputIndex();\n        uint128 pendingBond = pool.getPendingBond(outputIndex, challenger);\n\n        vm.prank(oracle.COLOSSEUM());\n        vm.expectEmit(true, true, false, true, address(pool));\n        emit PendingBondReleased(outputIndex, challenger, challenger, pendingBond);\n        pool.releasePendingBond(outputIndex, challenger, challenger);\n\n        assertEq(pool.balanceOf(challenger), pendingBond);\n\n        vm.expectRevert(\"ValidatorPool: the pending bond does not exist\");\n        pool.getPendingBond(outputIndex, challenger);\n    }\n\n    function test_releasePendingBond_noPendingBond_succeeds() external {\n        vm.prank(oracle.COLOSSEUM());\n        vm.expectRevert(\"ValidatorPool: the pending bond does not exist\");\n        pool.releasePendingBond(0, challenger, challenger);\n    }\n\n    function test_getBond_succeeds() external {\n        test_createBond_succeeds();\n\n        uint256 outputIndex = oracle.latestOutputIndex();\n        Types.Bond memory bond = pool.getBond(outputIndex);\n\n        assertTrue(bond.amount > 0);\n        assertTrue(bond.expiresAt > block.timestamp);\n    }\n\n    function test_getBond_noBond_reverts() external {\n        vm.expectRevert(\"ValidatorPool: the bond does not exist\");\n        pool.getBond(0);\n    }\n\n    function test_balanceOf_succeeds() external {\n        vm.prank(trusted);\n        pool.deposit{ value: 1 }();\n\n        assertEq(pool.balanceOf(trusted), 1);\n        assertEq(pool.balanceOf(asserter), 0);\n        assertEq(pool.balanceOf(challenger), 0);\n    }\n\n    function test_isValidator_succeeds() external {\n        vm.prank(trusted);\n        pool.deposit{ value: requiredBondAmount }();\n        vm.prank(asserter);\n        pool.deposit{ value: requiredBondAmount - 1 }();\n\n        assertTrue(pool.isValidator(trusted));\n        assertFalse(pool.isValidator(asserter));\n        assertFalse(pool.isValidator(challenger));\n    }\n\n    function test_validatorCount_succeeds() external {\n        vm.prank(trusted);\n        pool.deposit{ value: requiredBondAmount }();\n        assertEq(pool.validatorCount(), 1);\n\n        vm.prank(asserter);\n        pool.deposit{ value: requiredBondAmount }();\n        assertEq(pool.validatorCount(), 2);\n\n        vm.prank(challenger);\n        pool.deposit{ value: requiredBondAmount - 1 }();\n        assertEq(pool.validatorCount(), 2);\n    }\n\n    function test_nextValidator_succeeds() external {\n        // deposit funds\n        vm.prank(trusted);\n        pool.deposit{ value: requiredBondAmount * 10 }();\n        vm.prank(asserter);\n        pool.deposit{ value: requiredBondAmount * 10 }();\n\n        address prev = pool.nextValidator();\n        assertEq(prev, trusted);\n\n        uint256 tries = 10;\n        uint256 outputIndex = 0;\n        uint256 blockNumber = 0;\n        uint128 expiresAt = 0;\n\n        // submit 10 outputs\n        for (uint256 i = 0; i < tries; i++) {\n            outputIndex = oracle.nextOutputIndex();\n            blockNumber = oracle.nextBlockNumber();\n            warpToSubmitTime(blockNumber);\n            expiresAt = uint128(block.timestamp + finalizationPeriodSeconds);\n            vm.prank(pool.nextValidator());\n            mockOracle.addOutput(keccak256(abi.encode(blockNumber)), blockNumber);\n            vm.prank(address(oracle));\n            pool.createBond(outputIndex, expiresAt);\n        }\n\n        // warp to first finalization time and submit new output\n        warpToSubmitTime(oracle.nextBlockNumber());\n        outputIndex = oracle.nextOutputIndex();\n        blockNumber = (expiresAt / oracle.L2_BLOCK_TIME()) - 1;\n        vm.warp(expiresAt);\n        expiresAt = uint128(block.timestamp + finalizationPeriodSeconds);\n        vm.prank(pool.nextValidator());\n        mockOracle.addOutput(keccak256(abi.encode(blockNumber)), blockNumber);\n        vm.prank(address(oracle));\n        pool.createBond(outputIndex, expiresAt);\n\n        bool changed = false;\n        for (uint256 i = 0; i < tries - 1; i++) {\n            // check the next validator has changed\n            if (pool.nextValidator() != prev) {\n                changed = true;\n                break;\n            }\n\n            prev = pool.nextValidator();\n            // submit next output and finalize prev output\n            outputIndex = oracle.nextOutputIndex();\n            blockNumber = oracle.nextBlockNumber();\n            warpToSubmitTime(blockNumber);\n            expiresAt = uint128(block.timestamp + finalizationPeriodSeconds);\n            vm.prank(pool.nextValidator());\n            mockOracle.addOutput(keccak256(abi.encode(blockNumber)), blockNumber);\n            vm.prank(address(oracle));\n            pool.createBond(outputIndex, expiresAt);\n        }\n\n        assertTrue(changed, \"the next validator has not changed\");\n\n        // warp to public round\n        uint256 l2Timestamp = oracle.computeL2Timestamp(oracle.nextBlockNumber() + 1);\n        vm.warp(l2Timestamp + roundDuration + 1);\n        assertEq(pool.nextValidator(), Constants.VALIDATOR_PUBLIC_ROUND_ADDRESS);\n    }\n\n    function test_securityCouncilCannotBeValidator_succeeds() external {\n        address sc = pool.SECURITY_COUNCIL();\n        uint256 depositAmount = pool.REQUIRED_BOND_AMOUNT() * 100;\n        vm.deal(sc, depositAmount + 1 ether);\n\n        vm.prank(sc);\n        pool.deposit{value: depositAmount}();\n        assertEq(pool.balanceOf(sc), depositAmount);\n        assertFalse(pool.isValidator(sc));\n    }\n}\n"
    },
    "contracts/test/ValidatorRewardVault.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { ValidatorRewardVault } from \"../L2/ValidatorRewardVault.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\n\ncontract ValidatorRewardVault_Test is Bridge_Initializer {\n    ValidatorRewardVault internal vault =\n        ValidatorRewardVault(payable(Predeploys.VALIDATOR_REWARD_VAULT));\n    address internal constant recipient = address(256);\n    uint256 internal constant l2BlockNumber = 1800;\n\n    uint256 internal rewardDivider = 0;\n\n    event Rewarded(address indexed validator, uint256 indexed l2BlockNumber, uint256 amount);\n\n    event Withdrawal(uint256 value, address to, address from);\n\n    function setUp() public override {\n        super.setUp();\n\n        rewardDivider = oracle.FINALIZATION_PERIOD_SECONDS() / (submissionInterval * l2BlockTime);\n\n        vm.etch(\n            Predeploys.VALIDATOR_REWARD_VAULT,\n            address(new ValidatorRewardVault(address(pool), rewardDivider)).code\n        );\n        vm.label(Predeploys.VALIDATOR_REWARD_VAULT, \"ValidatorRewardVault\");\n    }\n\n    function test_minWithdrawalAmount_succeeds() external {\n        assertEq(vault.MIN_WITHDRAWAL_AMOUNT(), 10 ether);\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(vault.RECIPIENT(), address(0));\n        assertEq(vault.VALIDATOR_POOL(), address(pool));\n        assertEq(vault.REWARD_DIVIDER(), rewardDivider);\n    }\n\n    function test_receive_succeeds() external {\n        uint256 balance = address(vault).balance;\n\n        vm.prank(alice);\n        (bool success, ) = address(vault).call{ value: 100 }(hex\"\");\n\n        assertEq(success, true);\n        assertEq(address(vault).balance, balance + 100);\n    }\n\n    function test_reward_succeeds() external {\n        vm.deal(address(vault), vault.MIN_WITHDRAWAL_AMOUNT());\n\n        uint256 reserved = vault.totalReserved();\n        uint256 balance = vault.balanceOf(recipient);\n        uint256 rewardAmount = (address(vault).balance - reserved) / rewardDivider;\n\n        vm.expectEmit(true, true, false, false, address(Predeploys.VALIDATOR_REWARD_VAULT));\n        emit Rewarded(recipient, l2BlockNumber, rewardAmount);\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(pool)));\n        vault.reward(recipient, l2BlockNumber);\n        // Check the balance was increased.\n        assertEq(vault.balanceOf(recipient), balance + rewardAmount);\n        assertEq(vault.totalReserved(), reserved + rewardAmount);\n    }\n\n    function test_reward_senderNotValidatorPool_reverts() external {\n        vm.expectRevert(\"ValidatorRewardVault: function can only be called from the ValidatorPool\");\n        vault.reward(address(0), 0);\n    }\n\n    function test_reward_zeroValidatorAddress_reverts() external {\n        vm.expectRevert(\"ValidatorRewardVault: validator address cannot be 0\");\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(pool)));\n        vault.reward(address(0), 0);\n    }\n\n    function test_reward_alreadyPaidBlockNumber_reverts() external {\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(pool)));\n        vault.reward(recipient, l2BlockNumber);\n\n        vm.expectRevert(\n            \"ValidatorRewardVault: the reward has already been paid for the L2 block number\"\n        );\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(pool)));\n        vault.reward(recipient, l2BlockNumber);\n    }\n\n    function test_withdraw_succeeds() external {\n        vm.deal(address(vault), vault.REWARD_DIVIDER() * vault.MIN_WITHDRAWAL_AMOUNT());\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(pool)));\n        vault.reward(recipient, l2BlockNumber);\n\n        uint256 amount = vault.balanceOf(recipient);\n        uint256 reserved = vault.totalReserved();\n\n        // No ether has been withdrawn yet\n        assertEq(vault.totalProcessed(), 0);\n\n        vm.expectEmit(true, true, true, true, address(Predeploys.VALIDATOR_REWARD_VAULT));\n        emit Withdrawal(amount, recipient, recipient);\n\n        // The entire vault's balance is withdrawn\n        vm.expectCall(\n            Predeploys.L2_STANDARD_BRIDGE,\n            amount,\n            abi.encodeWithSelector(\n                StandardBridge.bridgeETHTo.selector,\n                recipient,\n                35_000,\n                bytes(\"\")\n            )\n        );\n\n        vm.prank(recipient);\n        vault.withdraw();\n        // The withdrawal was successful\n        assertEq(vault.totalProcessed(), amount);\n        // Check the total determined reward amount was decreased.\n        assertEq(vault.totalReserved(), reserved - amount);\n    }\n\n    function test_withdraw_notEnough_reverts() external {\n        assert(vault.balanceOf(recipient) < vault.MIN_WITHDRAWAL_AMOUNT());\n\n        vm.expectRevert(\n            \"ValidatorRewardVault: withdrawal amount must be greater than minimum withdrawal amount\"\n        );\n        vm.prank(recipient);\n        vault.withdraw();\n    }\n\n    function test_balanceOf_succeeds() external {\n        uint256 vaultBalance = vault.MIN_WITHDRAWAL_AMOUNT();\n        vm.deal(address(vault), vaultBalance);\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(pool)));\n        vault.reward(recipient, l2BlockNumber);\n\n        uint256 expectedBalance = vaultBalance / vault.REWARD_DIVIDER();\n        assertEq(vault.balanceOf(recipient), expectedBalance);\n    }\n}\n"
    },
    "contracts/test/ZKMerkleTrie.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Portal_Initializer } from \"./CommonTest.t.sol\";\n\ncontract ZKMerkleTrie_Test is Portal_Initializer {\n    function test_verifyInclustionProof_valid_0() external {\n        bytes[] memory proofs = new bytes[](2);\n        proofs[\n            0\n        ] = hex\"012098f5fb9e239eab3ceac3f27b81e481dc3124d55ffed523a839ee8446b64864010100000000000000000000000000000000000000000000000000000000000000003039202098f5fb9e239eab3ceac3f27b81e481dc3124d55ffed523a839ee8446b64864\";\n        proofs[\n            1\n        ] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n        assertTrue(\n            zkMerkleTrie.verifyInclusionProof(\n                hex\"0000000000000000000000000000000000000000000000000000000000000000\",\n                hex\"0000000000000000000000000000000000000000000000000000000000003039\",\n                proofs,\n                hex\"1a71d0943087a54143a948ccb9d9f0bd07c99d3a4899c9ceeb890976c32186c1\"\n            )\n        );\n    }\n\n    function test_verifyInclustionProof_valid_1() external {\n        bytes[] memory proofs = new bytes[](8);\n        proofs[\n            0\n        ] = hex\"000ab62fdcebb5220c92b96d38cef426d805217d1760140b2b1eebecd436c8fcc50f3dcecebf602601ceb35f1996e70c802634bb3d7ccbc7ad6b923e00066e8b00\";\n        proofs[\n            1\n        ] = hex\"0006be779477fdea72fc037851ef2baa70afdeff1075cfaa3b4f385e9d2336afd42583e724fe0eb10e675ab6be869557ca5d2f9fc13de9274a0a1742236e349caf\";\n        proofs[\n            2\n        ] = hex\"000ded681649ba8fee8a5cb411c9a2d1c525e796ca2566cebf2c0244c2a66491662c67be5020784f6a1eb8d7f1bfc7d921455e231d9bd9f171dffa4202763e2d28\";\n        proofs[\n            3\n        ] = hex\"0009543051b94eaaf3560c2f33cd8bf9a9b93f712b1f9b41ab67cab4f12733a67d167c33ebb5960ce90cf4042434bc4f9cd75c5ecc46e250c5c4b06a76a4627b2b\";\n        proofs[\n            4\n        ] = hex\"0010c440dc7007099878005966c61e751fe67bafcdb37615213c8ff9d111b4f7251167fcaa928ceeb39b9318cea6306ac2cd6252f6ef8d96cfeffd937810b29b1a\";\n        proofs[\n            5\n        ] = hex\"00271dd669b4787c31020d57ee2b2e56ff139994b52bf56ecc9f7432a272ce5f78032d185fae0284cbf7292557e98dfd08dea8b108eb6e4289d803d2b7d2e74644\";\n        proofs[\n            6\n        ] = hex\"0109d279cfc7bcba04074acfebd9974c1d2c9516b2c1f18ec34ac3ed422158c8a8010100000000000000000000000000000000000000000000000000000000000000000018200e9449cefab8e4070797d09578e909e10a0ce4374ea5e4d4c608c2e11961af68\";\n        proofs[\n            7\n        ] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n        assertFalse(\n            zkMerkleTrie.verifyInclusionProof(\n                hex\"0000000000000000000000000000000000000000000000000000000000000005\",\n                hex\"0000000000000000000000000000000000000000000000000000000000000032\",\n                proofs,\n                hex\"0ef999685f185097340822d0b30f846398e641087ba3bcff823ed87538038943\"\n            )\n        );\n    }\n\n    function test_verifyInclustionProof_valid_2() external {\n        bytes[] memory proofs = new bytes[](8);\n        proofs[\n            0\n        ] = hex\"000ab62fdcebb5220c92b96d38cef426d805217d1760140b2b1eebecd436c8fcc50f3dcecebf602601ceb35f1996e70c802634bb3d7ccbc7ad6b923e00066e8b00\";\n        proofs[\n            1\n        ] = hex\"0006be779477fdea72fc037851ef2baa70afdeff1075cfaa3b4f385e9d2336afd42583e724fe0eb10e675ab6be869557ca5d2f9fc13de9274a0a1742236e349caf\";\n        proofs[\n            2\n        ] = hex\"0017c443967900c45fb5b11c7a40cfc8e4aa5c699f2f80add51e3cf998ed9872b80022374777da27caa6013c01e2cb3b2d974a998a4f38f2f25baa3c87ad12a007\";\n        proofs[\n            3\n        ] = hex\"0024622a111942a41d45c768f89da131621e0fa266b9b7e324d33e458702a2987e0e67ba58319668fa44fe1f5e20f5a7978e6577bcb1b9809e101224c2988edd38\";\n        proofs[\n            4\n        ] = hex\"00139b85edf9b10c2b2330eb06a1eeb66f2058a8d9cd6fea738157f951e8079905068c3814e7511d563e5bfea099e5368ee7a8e38e4856e85b45b33339621ff50c\";\n        proofs[\n            5\n        ] = hex\"000b1bb0d1d5eaa0e39a52d08db2e92b79294959ea25cef6757a4d54bff691fb902ee69c6f3bb0450146447b2f9865d2e396b7b9e7b37d7f2ff181c85941ef98cf\";\n        proofs[\n            6\n        ] = hex\"0117f011179feb4d1c750e4c139df9e5d1940dffa118c8d489c852389aa7afaf460101000000000000000000000000000000000000000000000000000000000000000000062017f011179feb4d1c750e4c139df9e5d1940dffa118c8d489c852389aa7afaf46\";\n        proofs[\n            7\n        ] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n        assertTrue(\n            zkMerkleTrie.verifyInclusionProof(\n                hex\"101e368776582e57ab3d116ffe2517c0a585cd5b23174b01e275c2d8329c3d83\",\n                hex\"0000000000000000000000000000000000000000000000000000000000000006\",\n                proofs,\n                hex\"0ef999685f185097340822d0b30f846398e641087ba3bcff823ed87538038943\"\n            )\n        );\n    }\n\n    function test_verifyInclustionProof_valid_3() external {\n        bytes[] memory proofs = new bytes[](9);\n        proofs[\n            0\n        ] = hex\"000ab62fdcebb5220c92b96d38cef426d805217d1760140b2b1eebecd436c8fcc50f3dcecebf602601ceb35f1996e70c802634bb3d7ccbc7ad6b923e00066e8b00\";\n        proofs[\n            1\n        ] = hex\"00064ef83727d84baa6f69e7b6d2aa09c06a0a684aee47027b0b364011ec29a61617909e79d23c9ffd920c6e0cb9929782348bcd170d8a5d806467fbcf9d56b437\";\n        proofs[\n            2\n        ] = hex\"0016b9762acc15c49266ff4561a8975cbd5e132ad5129caa0b811b374cff9480101152ad4e5c71d0348e3b9041315496011ab29e79a54851d0d79d7d03dd2423c8\";\n        proofs[\n            3\n        ] = hex\"0017ae8d541b010b836adb59a87754efee7740f33b96520754ca5f6f6ae9d3b73e09827fa4836bb60157a2e4e358d897b23d735c3b23f55490e76f2e6ae2b68b04\";\n        proofs[\n            4\n        ] = hex\"0016c3abb95e2baec8aab3dc244eac879d60ac0ef6275cd4fa5c3a526049fdeb8c11b76fb8c45df3936b13c24dff4da46b947a2844f06ac6221e8c8eb7feb32970\";\n        proofs[\n            5\n        ] = hex\"000ccffa8b08f54fc92c60c9c19f379d5759ecdd8fded0b24c2266be5a6fafb7c4295abf4ea1b55932420231efee9fe391a90b3fb077aee16e26ebba7997795e7f\";\n        proofs[\n            6\n        ] = hex\"0014ed76b6e85369cd2549423310e621bbcbcac05402162d085be4368168ca506b0000000000000000000000000000000000000000000000000000000000000000\";\n        proofs[7] = hex\"02\";\n        proofs[\n            8\n        ] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n        assertFalse(\n            zkMerkleTrie.verifyInclusionProof(\n                hex\"bc36789e7a1e281436464229828f817d6612f7b477d66591ff96a9e064bcc98a\",\n                hex\"0000000000000000000000000000000000000000000000000000000000000032\",\n                proofs,\n                hex\"0ef999685f185097340822d0b30f846398e641087ba3bcff823ed87538038943\"\n            )\n        );\n    }\n\n    function test_verifyInclustionProof_valid_4() external {\n        bytes[] memory proofs = new bytes[](13);\n        proofs[\n            0\n        ] = hex\"0007cbd8ed414f4c32c8f24bcd4a092ca1fc48c5dc95acb388fa3c08ec3422be2f11dd580249f54d7db79ee465707fa4e23c4287a4649248df30583903858aa90d\";\n        proofs[\n            1\n        ] = hex\"0023baa0bbc530f48f150951aa7670aa3c8f6570a5c763c05413a3e12a6c0b7cce10f98a7af3a8a73a3a20af4a000ef3663712967ec273a58e9ade9e661394c9d6\";\n        proofs[\n            2\n        ] = hex\"00284ac3e3a591145890ace584756f6ba06c701f395c8db9d0313adcdaf954270b006c473617966db462b9fd00299d683a15c0b74454ca7ac3ef2d8aa087ac7dac\";\n        proofs[\n            3\n        ] = hex\"00296063f48eb3a4f4ff8fdc10316f114be5bedfbf79c9c86d325f92ff877a1a532ff1456213f17f8b67c69ea1821714fc7fb5073bf7c1fc4f77adaec58d083c6e\";\n        proofs[\n            4\n        ] = hex\"002c58643b19811246202ac95ce7122cf63eb17687e12a670542c2bd76546184ef02acd9795883b244ab8c5c9b232c7a6f598ab360bcd5b6fdab4ca93250b74ce8\";\n        proofs[\n            5\n        ] = hex\"00015421c239dc34b78b2fa31b208aa368cd1eae4b98aa10ae03bc2c5b80cdd8ef2d6c19f2f3b16de567490f18819cae1e3f4ea29d2bc5c34400276cf57f0e3b63\";\n        proofs[\n            6\n        ] = hex\"002d961fc76c9c30673b93f089451bce1d3af8ada972ad8c735f60cd0e145751801962d7c2d9d222562ae4476172398601558339c4414a807d280ec23938fa6d78\";\n        proofs[\n            7\n        ] = hex\"0000000000000000000000000000000000000000000000000000000000000000000949fcaefea105109e6bd0c339373e06d8a7856fc82c3185041642ed42f07585\";\n        proofs[\n            8\n        ] = hex\"0014660f419e10516425d4f78bbf7457cfd1381fff1223606dc530792059176c3f20ae2c31258e0712e4e39ecd2eae272ec13fadb2f057027e7fad2b378fc249f6\";\n        proofs[\n            9\n        ] = hex\"00163340375c6665b9878b1443e55b943de727fd6ccb1647ec9ca2e09a0f6b81110000000000000000000000000000000000000000000000000000000000000000\";\n        proofs[\n            10\n        ] = hex\"00224e3507691f5789978473cf4a307908f5a08761112466f1cf970bc8fad921d9258216ceb8dffd636ddc9570e526bc6741d8f76e8f2d8cb843104656c8a93ae5\";\n        proofs[\n            11\n        ] = hex\"011fd5bbabb0ebd74c646925592018a1f5d06dd11a6b5be33f025241736e454087010100000000000000000000000000000000000000000000000000000000000000000005201fd5bbabb0ebd74c646925592018a1f5d06dd11a6b5be33f025241736e454087\";\n        proofs[\n            12\n        ] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n        assertTrue(\n            zkMerkleTrie.verifyInclusionProof(\n                hex\"2b232c97452f0950c94e2539fdc7e69d21166113cf7a9bcb99b220a3fe5d720a\",\n                hex\"0000000000000000000000000000000000000000000000000000000000000005\",\n                proofs,\n                hex\"122f20d691c10bf842b594733bdc73e6a67a131def85ef444ce58a18cc4cd757\"\n            )\n        );\n    }\n\n    function test_verifyInclustionProof_valid_5() external {\n        bytes[] memory proofs = new bytes[](11);\n        proofs[\n            0\n        ] = hex\"00284ec4ede7c4da8296ce6d515233c2eea76fd5c07116c56949fda88770fad4b811b40ba55c3d2ec14871670b38cec7c71ea67ddb0ceaa0fea936e8b6fd8e0511\";\n        proofs[\n            1\n        ] = hex\"000d12650b10e106a7644599be80c71ab31cf093d7f99c34d866315ca1c12972022409d4725c6af5e20a9e32a61d79e85571181d65c45dc10bfc11ba2857923830\";\n        proofs[\n            2\n        ] = hex\"00296bec9e31b0aa1c5128fca361dd3875609520c9b0c8e7dd73bda2a1313c18d72eed91ecfef85e13834fda24ddf9060a69eec25abba55115c517de9f8a4ee9ec\";\n        proofs[\n            3\n        ] = hex\"00131748240aea4f74ae3be5a6a9f11d6bbb3129241f36de98275c32423592de8b16c111e32818a1cdc9b30d4855817e3193945bbf2594291bb229d85d2ed81658\";\n        proofs[\n            4\n        ] = hex\"001cdea41e120cf4086d178996edcf44e2003f2d0225cbac864c7e60af23540f2f010f74b267d3bd19343889f0d2a525d7054c007e507c5ca0164be42f72215ff6\";\n        proofs[\n            5\n        ] = hex\"000ac5febcd01ab220937cef032f250f499fe68911bc094ebe5c7b8abb59e41dc6191416975dbc10cf89f6428771b2251e9023598fcbc59ad33be4f05c6e7b8eec\";\n        proofs[\n            6\n        ] = hex\"0026080a7dc62fc9fafc28adb4775111ee0d6818d6fc07375f751f602f0708a17f211fc5be39244df796912c7360f30219760366342a9c4306d710ec2bd2b5db39\";\n        proofs[\n            7\n        ] = hex\"0013867a8f88775425fc040b935515ce4966f9492956f96e7355fadfba44e1f67d0000000000000000000000000000000000000000000000000000000000000000\";\n        proofs[\n            8\n        ] = hex\"00233da726018d913514b4dd9398bc1a01c98b0a8ef4c33dc20efae3c38e1fe1912ef80e02108f98b180588ae6580404cfb5fb52b22ebfa1345da5654587b5aec5\";\n        proofs[\n            9\n        ] = hex\"012f6fdd1ad0dd1863abaa7b339f6f56b17a97720aeddd790f4507b95a5ef6df55010100000000000000000000000000000000000000000000000000000000000000000005202f6fdd1ad0dd1863abaa7b339f6f56b17a97720aeddd790f4507b95a5ef6df55\";\n        proofs[\n            10\n        ] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n        assertTrue(\n            zkMerkleTrie.verifyInclusionProof(\n                hex\"e2689cd4a84e23ad2f564004f1c9013e9589d260bde6380aba3ca7e09e4df40c\",\n                hex\"0000000000000000000000000000000000000000000000000000000000000005\",\n                proofs,\n                hex\"2f362a32462155cc2f9d2d7aa2f70c0c80cd3ff834c69de7bcc4fb2d493b0e9b\"\n            )\n        );\n    }\n\n    // Real withdrawal example\n    function test_verifyInclustionProof_valid_6() external {\n        bytes[] memory proofs = new bytes[](7);\n        proofs[\n            0\n        ] = hex\"002c4b1cef0d03c37f45c631f7fc85ea4b78eeb096708ea63bd810463e246f13d40eb41f1061285f9c13a21519bdb76cba404832d33945ad471fa215153d9b020d\";\n        proofs[\n            1\n        ] = hex\"0000000000000000000000000000000000000000000000000000000000000000001dc169aab556ca90e4a7c3365ab27ba5ca93d222cd9e25e3ae1e38b7bf3a9e94\";\n        proofs[\n            2\n        ] = hex\"0007dcec580d43183a7dbe05d3a5a1f8b3ce38d5bb22676dfa1439ab44219de2a0036b366d8dcd20a1872355bb66868eb50f78599e926963ca33d35b8535e9525b\";\n        proofs[\n            3\n        ] = hex\"0000000000000000000000000000000000000000000000000000000000000000001747ce9cfac94135832e7e7d983a44e894446ca8ff1e6bda10ebcdaae36eba3d\";\n        proofs[\n            4\n        ] = hex\"0020438463bdf532b3eaa113e69847b469b76425d47195ed7a41462a79ba6511f715cb3972fcd254f29388ca61de787fe3654d776941fb4eaf00a946e8d4c73720\";\n        proofs[\n            5\n        ] = hex\"0105a0af8df2be333495be279be0eb5ef7da41b240832f2d74d34631333cebc3ee0101000000000000000000000000000000000000000000000000000000000000000000012085359a58748add24fbe1c5aedbd158736f50a45baf8715b9f32c9432ea7c179a\";\n        proofs[\n            6\n        ] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n        assertTrue(\n            zkMerkleTrie.verifyInclusionProof(\n                hex\"85359a58748add24fbe1c5aedbd158736f50a45baf8715b9f32c9432ea7c179a\",\n                hex\"0000000000000000000000000000000000000000000000000000000000000001\",\n                proofs,\n                hex\"2830ab4d0fa292abe8f69ac23b8d98a9f9a950ace6ae50d0f77eefa01a644cb1\"\n            )\n        );\n    }\n}\n"
    },
    "contracts/test/invariants/CrossDomainMessenger.t.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { StdUtils } from \"forge-std/StdUtils.sol\";\nimport { Vm } from \"forge-std/Vm.sol\";\n\nimport { Constants } from \"../../libraries/Constants.sol\";\nimport { Encoding } from \"../../libraries/Encoding.sol\";\nimport { Hashing } from \"../../libraries/Hashing.sol\";\nimport { Predeploys } from \"../../libraries/Predeploys.sol\";\nimport { Types } from \"../../libraries/Types.sol\";\nimport { L1CrossDomainMessenger } from \"../../L1/L1CrossDomainMessenger.sol\";\nimport { KromaPortal } from \"../../L1/KromaPortal.sol\";\nimport { Messenger_Initializer } from \"../CommonTest.t.sol\";\n\ncontract RelayActor is StdUtils {\n    // Storage slot of the l2Sender\n    uint256 constant senderSlotIndex = 50;\n\n    uint256 public numHashes;\n    bytes32[] public hashes;\n    bool public reverted = false;\n\n    KromaPortal portal;\n    L1CrossDomainMessenger xdm;\n    Vm vm;\n    bool doFail;\n\n    constructor(\n        KromaPortal _portal,\n        L1CrossDomainMessenger _xdm,\n        Vm _vm,\n        bool _doFail\n    ) {\n        portal = _portal;\n        xdm = _xdm;\n        vm = _vm;\n        doFail = _doFail;\n    }\n\n    /**\n     * Relays a message to the `L1CrossDomainMessenger` with a random `_value`, and `_message`.\n     */\n    function relay(uint8 _value, bytes memory _message) external {\n        address target = address(0x04); // ID precompile\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        // Set the minimum gas limit to the cost of the identity precompile's execution for\n        // the given message.\n        // ID Precompile cost can be determined by calculating: 15 + 3 * data_word_length\n        uint32 minGasLimit = uint32(15 + 3 * ((_message.length + 31) / 32));\n\n        // set the value of portal.l2Sender() to be the L2 Cross Domain Messenger.\n        vm.store(address(portal), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n\n        // Restrict the value to the range of [0, 1]\n        // This is just so we get variance of calls with and without value. The ID precompile\n        // will not reject value being sent to it.\n        _value = _value % 2;\n\n        // If the message should succeed, supply it `baseGas`. If not, supply it an amount of\n        // gas that is too low to complete the call.\n        uint256 gas = doFail\n            ? bound(minGasLimit, 60_000, 80_000)\n            : xdm.baseGas(_message, minGasLimit);\n\n        // Compute the cross domain message hash and store it in `hashes`.\n        bytes32 _hash = Hashing.hashCrossDomainMessageV0(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            _value,\n            minGasLimit,\n            _message\n        );\n        hashes.push(_hash);\n        numHashes += 1;\n\n        // Make sure we've got a fresh message.\n        vm.assume(xdm.successfulMessages(_hash) == false && xdm.failedMessages(_hash) == false);\n\n        // Act as the kroma portal and call `relayMessage` on the `L1CrossDomainMessenger` with\n        // the outer min gas limit.\n        vm.startPrank(address(portal));\n        if (!doFail) {\n            vm.expectCallMinGas(address(0x04), _value, minGasLimit, _message);\n        }\n        try\n            xdm.relayMessage{ gas: gas, value: _value }(\n                Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n                sender,\n                target,\n                _value,\n                minGasLimit,\n                _message\n            )\n        {} catch {\n            // If any of these calls revert, set `reverted` to true to fail the invariant test.\n            // NOTE: This is to get around forge's invariant fuzzer ignoring reverted calls\n            // to this function.\n            reverted = true;\n        }\n        vm.stopPrank();\n    }\n}\n\ncontract XDM_MinGasLimits is Messenger_Initializer {\n    RelayActor actor;\n\n    function init(bool doFail) public virtual {\n        // Set up the `L1CrossDomainMessenger` and `KromaPortal` contracts.\n        super.setUp();\n\n        // Deploy a relay actor\n        actor = new RelayActor(portal, L1Messenger, vm, doFail);\n\n        // Give the portal some ether to send to `relayMessage`\n        vm.deal(address(portal), type(uint128).max);\n\n        // Target the `RelayActor` contract\n        targetContract(address(actor));\n\n        // Don't allow the estimation address to be the sender\n        excludeSender(Constants.ESTIMATION_ADDRESS);\n\n        // Target the actor's `relay` function\n        bytes4[] memory selectors = new bytes4[](1);\n        selectors[0] = actor.relay.selector;\n        targetSelector(FuzzSelector({ addr: address(actor), selectors: selectors }));\n    }\n}\n\ncontract XDM_MinGasLimits_Succeeds is XDM_MinGasLimits {\n    function setUp() public override {\n        // Don't fail\n        super.init(false);\n    }\n\n    /**\n     * @custom:invariant A call to `relayMessage` should succeed if at least the minimum gas limit\n     *                   can be supplied to the target context, there is enough gas to complete\n     *                   execution of `relayMessage` after the target context's execution is\n     *                   finished, and the target context did not revert.\n     *\n     * There are two minimum gas limits here:\n     *\n     * - The outer min gas limit is for the call from the `KromaPortal` to the\n     * `L1CrossDomainMessenger`,  and it can be retrieved by calling the xdm's `baseGas` function\n     * with the `message` and inner limit.\n     *\n     * - The inner min gas limit is for the call from the `L1CrossDomainMessenger` to the target\n     * contract.\n     */\n    function invariant_minGasLimits() external {\n        uint256 length = actor.numHashes();\n        for (uint256 i = 0; i < length; ++i) {\n            bytes32 hash = actor.hashes(i);\n            // The message hash is set in the successfulMessages mapping\n            assertTrue(L1Messenger.successfulMessages(hash));\n            // The message hash is not set in the failedMessages mapping\n            assertFalse(L1Messenger.failedMessages(hash));\n        }\n        assertFalse(actor.reverted());\n    }\n}\n\ncontract XDM_MinGasLimits_Reverts is XDM_MinGasLimits {\n    function setUp() public override {\n        // Do fail\n        super.init(true);\n    }\n\n    /**\n     * @custom:invariant A call to `relayMessage` should assign the message hash to the\n     *                   `failedMessages` mapping if not enough gas is supplied to forward\n     *                   `minGasLimit` to the target context or if there is not enough gas to\n     *                   complete execution of `relayMessage` after the target context's execution\n     *                   is finished.\n     *\n     * There are two minimum gas limits here:\n     *\n     * - The outer min gas limit is for the call from the `KromaPortal` to the\n     * `L1CrossDomainMessenger`,  and it can be retrieved by calling the xdm's `baseGas` function\n     * with the `message` and inner limit.\n     *\n     * - The inner min gas limit is for the call from the `L1CrossDomainMessenger` to the target\n     * contract.\n     */\n    function invariant_minGasLimits() external {\n        uint256 length = actor.numHashes();\n        for (uint256 i = 0; i < length; ++i) {\n            bytes32 hash = actor.hashes(i);\n            // The message hash is not set in the successfulMessages mapping\n            assertFalse(L1Messenger.successfulMessages(hash));\n            // The message hash is set in the failedMessages mapping\n            assertTrue(L1Messenger.failedMessages(hash));\n        }\n        assertFalse(actor.reverted());\n    }\n}\n"
    },
    "contracts/test/invariants/KromaPortal.t.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Types } from \"../../libraries/Types.sol\";\nimport { Portal_Initializer } from \"../CommonTest.t.sol\";\n\ncontract KromaPortal_Invariant_Harness is Portal_Initializer {\n    // Reusable default values for a test withdrawal\n    Types.WithdrawalTransaction _defaultTx;\n\n    uint256 _submittedOutputIndex;\n    uint256 _submittedBlockNumber;\n    bytes32 _stateRoot;\n    bytes32 _storageRoot;\n    bytes32 _outputRoot;\n    bytes32 _withdrawalHash;\n    bytes[] _withdrawalProof;\n    Types.OutputRootProof internal _outputRootProof;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        _defaultTx = Types.WithdrawalTransaction({\n            nonce: 0,\n            sender: alice,\n            target: bob,\n            value: 100,\n            gasLimit: 100_000,\n            data: hex\"\"\n        });\n        // Get withdrawal proof data we can use for testing.\n        (_stateRoot, _storageRoot, _outputRoot, _withdrawalHash, _withdrawalProof) = ffi\n            .getProveWithdrawalTransactionInputs(_defaultTx);\n\n        // Setup a dummy output root proof for reuse.\n        _outputRootProof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: _stateRoot,\n            messagePasserStorageRoot: _storageRoot,\n            blockHash: bytes32(uint256(0)),\n            nextBlockHash: bytes32(uint256(0))\n        });\n        _submittedBlockNumber = oracle.nextBlockNumber();\n        _submittedOutputIndex = oracle.nextOutputIndex();\n\n        // Configure the oracle to return the output root we've prepared.\n        vm.warp(oracle.computeL2Timestamp(_submittedBlockNumber) + 1);\n        vm.prank(trusted);\n        oracle.submitL2Output(_outputRoot, _submittedBlockNumber, 0, 0);\n\n        // Warp beyond the finalization period for the block we've submitted.\n        vm.warp(\n            oracle.getL2Output(_submittedOutputIndex).timestamp +\n                oracle.FINALIZATION_PERIOD_SECONDS() +\n                1\n        );\n        // Fund the portal so that we can withdraw ETH.\n        vm.deal(address(portal), 0xFFFFFFFF);\n    }\n}\n\ncontract KromaPortal_CannotTimeTravel is KromaPortal_Invariant_Harness {\n    function setUp() public override {\n        super.setUp();\n\n        // Prove the withdrawal transaction\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Set the target contract to the portal proxy\n        targetContract(address(portal));\n        // Exclude the proxy multisig from the senders so that the proxy cannot be upgraded\n        excludeSender(address(multisig));\n    }\n\n    /**\n     * @custom:invariant `finalizeWithdrawalTransaction` should revert if the finalization\n     * period has not elapsed.\n     *\n     * A withdrawal that has been proven should not be able to be finalized until after\n     * the finalization period has elapsed.\n     */\n    function invariant_cannotFinalizeBeforePeriodHasPassed() external {\n        vm.expectRevert(\"KromaPortal: proven withdrawal finalization period has not elapsed\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n    }\n}\n\ncontract KromaPortal_CannotFinalizeTwice is KromaPortal_Invariant_Harness {\n    function setUp() public override {\n        super.setUp();\n\n        // Prove the withdrawal transaction\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Warp past the finalization period.\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Finalize the withdrawal transaction.\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        // Set the target contract to the portal proxy\n        targetContract(address(portal));\n        // Exclude the proxy multisig from the senders so that the proxy cannot be upgraded\n        excludeSender(address(multisig));\n    }\n\n    /**\n     * @custom:invariant `finalizeWithdrawalTransaction` should revert if the withdrawal\n     * has already been finalized.\n     *\n     * Ensures that there is no chain of calls that can be made that allows a withdrawal\n     * to be finalized twice.\n     */\n    function invariant_cannotFinalizeTwice() external {\n        vm.expectRevert(\"KromaPortal: withdrawal has already been finalized\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n    }\n}\n\ncontract KromaPortal_CanAlwaysFinalizeAfterWindow is KromaPortal_Invariant_Harness {\n    function setUp() public override {\n        super.setUp();\n\n        // Prove the withdrawal transaction\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Warp past the finalization period.\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Set the target contract to the portal proxy\n        targetContract(address(portal));\n        // Exclude the proxy multisig from the senders so that the proxy cannot be upgraded\n        excludeSender(address(multisig));\n    }\n\n    /**\n     * @custom:invariant A withdrawal should **always** be able to be finalized\n     * `FINALIZATION_PERIOD_SECONDS` after it was successfully proven.\n     *\n     * This invariant asserts that there is no chain of calls that can be made that\n     * will prevent a withdrawal from being finalized exactly `FINALIZATION_PERIOD_SECONDS`\n     * after it was successfully proven.\n     */\n    function invariant_canAlwaysFinalize() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        assertEq(address(bob).balance, bobBalanceBefore + _defaultTx.value);\n    }\n}\n"
    },
    "contracts/test/invariants/L2OutputOracle.t.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Vm } from \"forge-std/Vm.sol\";\n\nimport { L2OutputOracle } from \"../../L1/L2OutputOracle.sol\";\nimport { L2OutputOracle_Initializer } from \"../CommonTest.t.sol\";\n\ncontract L2OutputOracle_Validator {\n    L2OutputOracle internal oracle;\n    Vm internal vm;\n\n    constructor(L2OutputOracle _oracle, Vm _vm) {\n        oracle = _oracle;\n        vm = _vm;\n    }\n\n    /**\n     * @dev Allows the actor to submit an L2 output to the `L2OutputOracle`\n     */\n    function submitL2Output(\n        bytes32 _outputRoot,\n        uint256 _l2BlockNumber,\n        bytes32 _l1BlockHash,\n        uint256 _l1BlockNumber\n    ) external {\n        // Act as the validator and submit a new output.\n        vm.prank(oracle.VALIDATOR_POOL().nextValidator());\n        oracle.submitL2Output(_outputRoot, _l2BlockNumber, _l1BlockHash, _l1BlockNumber);\n    }\n}\n\ncontract L2OutputOracle_MonotonicBlockNumIncrease_Invariant is L2OutputOracle_Initializer {\n    L2OutputOracle_Validator internal actor;\n\n    function setUp() public override {\n        super.setUp();\n\n        // Create a proposer actor.\n        actor = new L2OutputOracle_Validator(oracle, vm);\n\n        // Set the target contract to the validator actor\n        targetContract(address(actor));\n\n        // Set the target selector for `submitL2Output`\n        // `submitL2Output` is the only function we care about, as it is the only function\n        // that can modify the `l2Outputs` array in the oracle.\n        bytes4[] memory selectors = new bytes4[](1);\n        selectors[0] = actor.submitL2Output.selector;\n        FuzzSelector memory selector = FuzzSelector({ addr: address(actor), selectors: selectors });\n        targetSelector(selector);\n    }\n\n    /**\n     * @custom:invariant The block number of the checkpoint output should monotonically\n     * increase.\n     *\n     * When a new output is submitted, it should never be allowed to correspond to a block\n     * number that is less than the current output.\n     */\n    function invariant_monotonicBlockNumIncrease() external {\n        // Assert that the block number of checkpoint output must monotonically increase.\n        assertTrue(oracle.nextBlockNumber() >= oracle.latestBlockNumber());\n    }\n}\n"
    },
    "contracts/test/invariants/SafeCall.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { StdUtils } from \"forge-std/StdUtils.sol\";\nimport { Test } from \"forge-std/Test.sol\";\nimport { Vm } from \"forge-std/Vm.sol\";\n\nimport { SafeCall } from \"../../libraries/SafeCall.sol\";\n\ncontract SafeCall_Succeeds_Invariants is Test {\n    SafeCaller_Actor actor;\n\n    function setUp() public {\n        // Create a new safe caller actor.\n        actor = new SafeCaller_Actor(vm, false);\n\n        // Set the caller to this contract\n        targetSender(address(this));\n\n        // Target the safe caller actor.\n        targetContract(address(actor));\n\n        // Give the actor some ETH to work with\n        vm.deal(address(actor), type(uint128).max);\n    }\n\n    /**\n     * @custom:invariant If `callWithMinGas` performs a call, then it must always\n     * provide at least the specified minimum gas limit to the subcontext.\n     *\n     * If the check for remaining gas in `SafeCall.callWithMinGas` passes, the\n     * subcontext of the call below it must be provided at least `minGas` gas.\n     */\n    function invariant_callWithMinGas_alwaysForwardsMinGas_succeeds() public {\n        assertEq(actor.numCalls(), 0, \"no failed calls allowed\");\n    }\n\n    function performSafeCallMinGas(address to, uint64 minGas) external payable {\n        SafeCall.callWithMinGas(to, minGas, msg.value, hex\"\");\n    }\n}\n\ncontract SafeCall_Fails_Invariants is Test {\n    SafeCaller_Actor actor;\n\n    function setUp() public {\n        // Create a new safe caller actor.\n        actor = new SafeCaller_Actor(vm, true);\n\n        // Set the caller to this contract\n        targetSender(address(this));\n\n        // Target the safe caller actor.\n        targetContract(address(actor));\n\n        // Give the actor some ETH to work with\n        vm.deal(address(actor), type(uint128).max);\n    }\n\n    /**\n     * @custom:invariant `callWithMinGas` reverts if there is not enough gas to pass\n     * to the subcontext.\n     *\n     * If there is not enough gas in the callframe to ensure that `callWithMinGas`\n     * can provide the specified minimum gas limit to the subcontext of the call,\n     * then `callWithMinGas` must revert.\n     */\n    function invariant_callWithMinGas_neverForwardsMinGas_reverts() public {\n        assertEq(actor.numCalls(), 0, \"no successful calls allowed\");\n    }\n\n    function performSafeCallMinGas(address to, uint64 minGas) external payable {\n        SafeCall.callWithMinGas(to, minGas, msg.value, hex\"\");\n    }\n}\n\ncontract SafeCaller_Actor is StdUtils {\n    bool internal immutable FAILS;\n\n    Vm internal vm;\n    uint256 public numCalls;\n\n    constructor(Vm _vm, bool _fails) {\n        vm = _vm;\n        FAILS = _fails;\n    }\n\n    function performSafeCallMinGas(\n        uint64 gas,\n        uint64 minGas,\n        address to,\n        uint8 value\n    ) external {\n        // Only send to EOAs - we exclude the console as it has no code but reverts when called\n        // with a selector that doesn't exist due to the foundry hook.\n        vm.assume(to.code.length == 0 && to != 0x000000000000000000636F6e736F6c652e6c6f67);\n\n        // Bound the minimum gas amount to [2500, type(uint48).max]\n        minGas = uint64(bound(minGas, 2500, type(uint48).max));\n        if (FAILS) {\n            // Bound the gas passed to [minGas, ((minGas * 64) / 63)]\n            gas = uint64(bound(gas, minGas, (minGas * 64) / 63));\n        } else {\n            // Bound the gas passed to\n            // [((minGas * 64) / 63) + 40_000 + 1000, type(uint64).max]\n            // The extra 1000 gas is to account for the gas used by the `SafeCall.call` call\n            // itself.\n            gas = uint64(bound(gas, ((minGas * 64) / 63) + 40_000 + 1000, type(uint64).max));\n        }\n\n        vm.expectCallMinGas(to, value, minGas, hex\"\");\n        bool success = SafeCall.call(\n            msg.sender,\n            gas,\n            value,\n            abi.encodeWithSelector(\n                SafeCall_Succeeds_Invariants.performSafeCallMinGas.selector,\n                to,\n                minGas\n            )\n        );\n\n        if (success && FAILS) numCalls++;\n        if (!FAILS && !success) numCalls++;\n    }\n}\n"
    },
    "contracts/test/invariants/SystemConfig.t.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\n\nimport { SystemConfig } from \"../../L1/SystemConfig.sol\";\nimport { ResourceMetering } from \"../../L1/ResourceMetering.sol\";\nimport { Constants } from \"../../libraries/Constants.sol\";\n\ncontract SystemConfig_GasLimitLowerBound_Invariant is Test {\n    SystemConfig public config;\n\n    function setUp() public {\n        ResourceMetering.ResourceConfig memory cfg = Constants.DEFAULT_RESOURCE_CONFIG();\n\n        config = new SystemConfig({\n            _owner: address(0xbeef),\n            _overhead: 2100,\n            _scalar: 1000000,\n            _batcherHash: bytes32(hex\"abcd\"),\n            _gasLimit: 30_000_000,\n            _unsafeBlockSigner: address(1),\n            _config: cfg,\n            _validatorRewardScalar: 5000\n        });\n\n        // Set the target contract to the `config`\n        targetContract(address(config));\n        // Set the target sender to the `config`'s owner (0xbeef)\n        targetSender(address(0xbeef));\n        // Set the target selector for `setGasLimit`\n        // `setGasLimit` is the only function we care about, as it is the only function\n        // that can modify the gas limit within the SystemConfig.\n        bytes4[] memory selectors = new bytes4[](1);\n        selectors[0] = config.setGasLimit.selector;\n        FuzzSelector memory selector = FuzzSelector({\n            addr: address(config),\n            selectors: selectors\n        });\n        targetSelector(selector);\n    }\n\n    /**\n     * @custom:invariant The gas limit of the `SystemConfig` contract can never be lower\n     * than the hard-coded lower bound.\n     */\n    function invariant_gasLimitLowerBound() external {\n        assertTrue(config.gasLimit() >= config.minimumGasLimit());\n    }\n}\n"
    },
    "contracts/test/testdata/ColosseumTestData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport { Hashing } from \"../../libraries/Hashing.sol\";\nimport { Types } from \"../../libraries/Types.sol\";\nimport { RLPWriter } from \"../../libraries/rlp/RLPWriter.sol\";\nimport { Colosseum } from \"../../L1/Colosseum.sol\";\n\nlibrary ColosseumTestData {\n    uint256 internal constant INVALID_BLOCK_NUMBER = 21;\n    bytes32 internal constant PREV_OUTPUT_ROOT =\n    0x3c9d33fa590f4d8eb95fe443b19a6bc75589b41ed046974eb6c9e6cfc7f6c434;\n    bytes32 internal constant TARGET_OUTPUT_ROOT =\n    0xf0058a33473e206a4f27e67f06686cba60afc22eb09fbe5cc737357d158dcff5;\n\n    function outputRootProof()\n        internal\n        pure\n        returns (Types.OutputRootProof memory, Types.OutputRootProof memory)\n    {\n        Types.OutputRootProof memory src = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: 0x2ecc9f95421c4f8c6acfd73a9983b021e79b381c9e80991b9b45da927c926c4f,\n            messagePasserStorageRoot: 0x24f53397bd92b66fda812b6e1191a00b60fc8e304033518006cbeedcab7f2127,\n            blockHash: 0x2d8d7264743ac0648b2b0fae0137cb0f77b2a952f5583a2cc6abf0c72f4f1b80,\n            nextBlockHash: 0x5cd3ba48964223516867ee8036fb0121c095d93a4301084f3fa37d811655d1e8\n        });\n\n        Types.OutputRootProof memory dst = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: 0x1370c09d12e3aefefbe29bcecaa9a1adac759ee1b6657065f8e103f56b364037,\n            messagePasserStorageRoot: 0x24f53397bd92b66fda812b6e1191a00b60fc8e304033518006cbeedcab7f2127,\n            blockHash: 0x5cd3ba48964223516867ee8036fb0121c095d93a4301084f3fa37d811655d1e8,\n            nextBlockHash: 0xf7cda4b3b93fbdd37eac444fd3341ac1d8627ba861d706f272e947579121fb53\n        });\n\n        return (src, dst);\n    }\n\n    function publicInput() internal pure returns (Types.PublicInput memory) {\n        bytes32[] memory txHashes = new bytes32[](1);\n        txHashes[0] = 0x1b4e7140b64e559cb810400bcce47580db4e51243f9ecae5dd8a123937d23cb2;\n\n        return\n            Types.PublicInput({\n                blockHash: 0x5cd3ba48964223516867ee8036fb0121c095d93a4301084f3fa37d811655d1e8,\n                parentHash: 0x2d8d7264743ac0648b2b0fae0137cb0f77b2a952f5583a2cc6abf0c72f4f1b80,\n                timestamp: 0x64e4b763,\n                number: 0x15,\n                gasLimit: 0x1c9c380,\n                baseFee: 0x3a61b96,\n                transactionsRoot: 0x2bd4ac406e80d8401dcd8a3770eac5630ff2883931d1acc6fdd86ece3a23c4d9,\n                stateRoot: 0x1370c09d12e3aefefbe29bcecaa9a1adac759ee1b6657065f8e103f56b364037,\n                withdrawalsRoot: 0x0,\n                txHashes: txHashes\n            });\n    }\n\n    function blockHeaderRLP() internal pure returns (Types.BlockHeaderRLP memory) {\n        return\n            Types.BlockHeaderRLP({\n                uncleHash: RLPWriter.writeBytes(\n                    hex\"1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\"\n                ),\n                coinbase: RLPWriter.writeAddress(address(0)),\n                receiptsRoot: RLPWriter.writeBytes(\n                    hex\"f75fc90d6167f310f60db885364953174fcd99a498b8629ea197074022a0eb67\"\n                ),\n                logsBloom: RLPWriter.writeBytes(\n                    hex\"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n                ),\n                difficulty: RLPWriter.writeUint(0),\n                gasUsed: RLPWriter.writeUint(0x10371),\n                extraData: RLPWriter.writeBytes(hex\"\"),\n                mixHash: RLPWriter.writeBytes(\n                    hex\"0000000000000000000000000000000000000000000000000000000000000000\"\n                ),\n                nonce: RLPWriter.writeBytes(hex\"0000000000000000\")\n            });\n    }\n\n    struct ProofPair {\n        uint256[] proof;\n        uint256[] pair;\n    }\n\n    function proofAndPair() internal pure returns (ProofPair memory pp) {\n        pp.proof = new uint256[](145);\n        pp.proof[0] = 0x14c50f059f948fb82b9e76e75884877a06c2510fc90267e5f04bd8165a377918;\n        pp.proof[1] = 0x11cdf627471c75a2e5d455d85d36172e98645d75012ae64f2dd4817cbc66889e;\n        pp.proof[2] = 0x0bbb8c343825fd2345aef9c855ff332fde1b8deacb51472d4314ec56b8ff8c78;\n        pp.proof[3] = 0x254d62d4d7dfb64fd6c4a5af9e477fe099ccf6b782ccceca8a7b57232fe6defa;\n        pp.proof[4] = 0x12b2485b1c5bff6eb433968532b390a2dfd3edd13b1bc0221054c233fb56c22d;\n        pp.proof[5] = 0x168b891bad4ede54b2e0edb5a07fc4c9558690a6006961e88fb9d986975c0ebf;\n        pp.proof[6] = 0x1d4253f0fc2ee61a928b0196cb5dfd8b38345ec1b3b29976d2b0769349b860a2;\n        pp.proof[7] = 0x23a5b9824838dc295894c9a507872f3cdb2123db0d1fee20a17b12b73bccb4fc;\n        pp.proof[8] = 0x0120fb1f75d7bbf6a07c979e011cae543ebb8c5bfe155fb5182a11551136a538;\n        pp.proof[9] = 0x11f35e7a75c433399dbacbaf4ccb012569274c3fd9726bd83cd4aeb23ba6758e;\n        pp.proof[10] = 0x1c86fa133b1692125918bf395dab3cc34c47334d38117086e0baf0ddc75e17c3;\n        pp.proof[11] = 0x1d40c3cd5e1ba6a0682d037d9089ca2bfee29ef39203a9419ed20c66dec7209d;\n        pp.proof[12] = 0x1ea70d703f358dbd04ecead3c992cd17527cb2c86ef7d89c8f7b1265245cb96a;\n        pp.proof[13] = 0x2d0ad99b5dfc411ea27ca3e333f44767f19d522508bac5be9457172b6ea0b0c3;\n        pp.proof[14] = 0x0f227fa0e9838a16fa72937b9ade38bf004a28ddfa3c97c619cf320421927282;\n        pp.proof[15] = 0x141f74b2930e63ff2324d7a9c426e49854e2b93011e17695b0f4f34e1f9e4738;\n        pp.proof[16] = 0x2dc7ea838174550808e24705ab8a71b8bc4e2f14dd6806515209ed03cb003f8d;\n        pp.proof[17] = 0x09caad18203956ef432dea3d34a8400cf1fb8252f6f376f036f3edf96728abf2;\n        pp.proof[18] = 0x294cf9b800a2951b89c60f2cd5341c70ad5adbc5be77d24427f096a04f238e9b;\n        pp.proof[19] = 0x2d8ffaee7c1fc66413271d9286e21afec7270235777648b60edda6a190a8e2ad;\n        pp.proof[20] = 0x1cc118ec0d69b418c733252730fe24ed8f4812a8a1b5a4263b6d1d098638027e;\n        pp.proof[21] = 0x0fcc1c37bc582347a5667608ef12b45d6721dfddbffc12f901a97b9e215bf150;\n        pp.proof[22] = 0x1f18cef49c9fc4ff825e40a200e1d7a8a7ab5860313e68c8e7ee977380b89da9;\n        pp.proof[23] = 0x1dc9eef95089441381388fc9d12fb42684cbd4cfda30c410daad4e82aebe8881;\n        pp.proof[24] = 0x127c49eecc28e44a5af8cbb56dca1a9ab7280b37d5dba29af6b3b4395943ac93;\n        pp.proof[25] = 0x0ba7508b4f2dcdb08e552b3504b1ebbb69b4e2c5a42220a7a94496762f944e3d;\n        pp.proof[26] = 0x2a0118d47072a40b7e63dbcc926a30c09b5753d19c1738a7679386be6d87528c;\n        pp.proof[27] = 0x09570c853c99d08c43fab2644e2179334f0d35b27b2a18b79e147749575e00af;\n        pp.proof[28] = 0x0538555f0e3f36bee47f2fc4206da542a7be39d8d46d092d58d5afeadec72b96;\n        pp.proof[29] = 0x15a4682121ce1419a998081186d6f5ab9459d7a369cc560b0569a9eebf971b57;\n        pp.proof[30] = 0x1ae3c28032c1038e7542362c1982c6688d2278a9e98ab54b5f8a2dc5755981c7;\n        pp.proof[31] = 0x12d276bdf2fa5b5845a160dab2b87f7ceec887085e41e77a45e8c6ea42299ebe;\n        pp.proof[32] = 0x2e81389b7bc027e7031bbd49f7531f2d39cd8defe65958b7a071984621ad7f06;\n        pp.proof[33] = 0x249b935f2f12fda0773e3d1bb8defa99ea3bc8e780188cef2d3b6d9563bdbb5e;\n        pp.proof[34] = 0x0caa76c0bdfb3ebdbc7c6e19dbe19fabda40d6b4b686780c996cedc1c1e65fb3;\n        pp.proof[35] = 0x2f325ad6bb7a72aa6aadaa34e94c21d98d5d0b66f53b34ad6857fa038eaf6d07;\n        pp.proof[36] = 0x056fe1224689b37468b68b97c86dc3648cebf0508224bc943d92607f0bcead06;\n        pp.proof[37] = 0x01844e599680df7391c801df0b794da30170b7b008c1e541294addfccf56ba85;\n        pp.proof[38] = 0x2abb1bf778032d48270b6afcafd2fe95c7f936877de9cf04876be1104dcf5dc6;\n        pp.proof[39] = 0x0ffb2ba3d2d9ec1870f3fe560065a5d09783398abfd14fa569dc4e30f7ce989c;\n        pp.proof[40] = 0x0c2aeac516bf1a5cd3b5366da058060d314a709d6f021d5b5a3ab182f49a5890;\n        pp.proof[41] = 0x02ae5d1d32ed2dd667f4852f84468dcdb9ce88c737b67bc0bece07159f42116e;\n        pp.proof[42] = 0x063d79dfb1c483b8451bca43a08677cf00715ad84194281a6c9f074efe5e3365;\n        pp.proof[43] = 0x15fac5e9231a1033c02695fbe74a038f7be5d0b44012fe9ba07a869305ce7b;\n        pp.proof[44] = 0x2e5b852d712f881b2486277995d949d23572ed66e6b6385f960b40ac57095ec7;\n        pp.proof[45] = 0x06a0e17df223ce4c77b5cd8de34b69d340fb8d70ba2cc60f9265892df3f26348;\n        pp.proof[46] = 0x26ae0ca4fa8904534b2e863f5fc3b08fe5b6c35d6abc6aa45fb307168a29e8f2;\n        pp.proof[47] = 0xc4747cd121ff0ec033ccf695485a57341b1d4e90d7390f84a1f8b68ed01991;\n        pp.proof[48] = 0x2ad31a2d846263b07c2cf23e1778e67c3723f6792a9303c543ed84d78e2ea9eb;\n        pp.proof[49] = 0x18296b6d7e1d1c157fdafcbc9d5cab2094c9443332a10b134bebe6f160dedac4;\n        pp.proof[50] = 0x08afa0336916563aa662efd9ef9c37035607adcd92bed226b63acfc05cc24a03;\n        pp.proof[51] = 0x0653ee17a110e9cef3095226c4c0e18fc9065b3f39e9ce5b60dab59b132fed42;\n        pp.proof[52] = 0x091e52cc1a0fd062a09eca2340266d7dfe5e89106fcdf4971e15f8e924b827ff;\n        pp.proof[53] = 0x0d277a7be4d7649cac44db56440b63541c2b063f62a8e99a8594a320db684ee0;\n        pp.proof[54] = 0x2b58b06b41f2589df7eb3906c9722caa28febcf961bbeaa9507df1152fd50f7b;\n        pp.proof[55] = 0x0a053457788d010b39400a2ebdba7e1cb27d032012566d3a33550a1fab3785e4;\n        pp.proof[56] = 0x01;\n        pp.proof[57] = 0x02;\n        pp.proof[58] = 0x1620cb0e0f4d66f65a1bbe094bad13f555b6fa6bffd44562754f321ad97b4e4c;\n        pp.proof[59] = 0x15f658c3b6e1fbf48112008daba74e9d2fe02e36e23117cf1ea7cc6669172efd;\n        pp.proof[60] = 0x04ce8427ca30bf2b4fbbf1611ae4e31690a5df4dfcb09eeb0274585fff80d56f;\n        pp.proof[61] = 0x06e7162378f1bd2c92a10c11519946f5001520ea9a8c53d604833027a5203a7f;\n        pp.proof[62] = 0x1a34dbfc0f5bc92cb666a277c7484a4da857e3ac2a1534f9795034d0cf09fdea;\n        pp.proof[63] = 0x1d557db7d105266e64d07ce7fc249320158a0d2eed7b9909f6882977756ba9fa;\n        pp.proof[64] = 0x0afb18785c3c5fd661d27f2bf0753d6f5e6b5473987890c7d4393820ccda4f0a;\n        pp.proof[65] = 0x18ac705555052290e73e347a7bfbbd03282df7a87f527617a66874e896edaee2;\n        pp.proof[66] = 0x27018d6991181683da66de5b419f789e5fa2d6dde2a70e58db8e61da28484a94;\n        pp.proof[67] = 0x2cb3bba179ad7321d292a0e322f8b00758c9eacd5abcf33f346e8fc7aee9e91b;\n        pp.proof[68] = 0xa52536074edd09176e384561c3e0e7af4797581fa2e976cc83673d27306bfd;\n        pp.proof[69] = 0x2d3ac4d8e279c65b1aa59d271c1c9085fb88a0915450736a5351abf2932b8170;\n        pp.proof[70] = 0x2222cbc38560152e0818df47a272e6882510de2e78f6bed5ac2a4776e9959c28;\n        pp.proof[71] = 0x0916be206c6eece6dec86522f25ac0af7ae369ae5194990f5ed5d9b30c3127b6;\n        pp.proof[72] = 0x0cf4f2c620b3e529cbc98c0903dcfd8a0138fd1873b1a349675aa4571c885a4e;\n        pp.proof[73] = 0x1d085279e2a5b0997133ec7a2ddb4ccb3167d6fe89a487925af902158e3b1100;\n        pp.proof[74] = 0x26b2278b7cc7ed2a6df1b37cb82ef98e623e9c3174d0435f79fb22bea3534d31;\n        pp.proof[75] = 0x2d7741ccbc7bb0e3acec6c4bd39cf67fa69cbca8f945c0fd7edb7612f38785b3;\n        pp.proof[76] = 0x0b8f2dd371953e26582e1d752d30c4ce821faff09e5bb1dae8990e4f24ab4a59;\n        pp.proof[77] = 0x0c259012bb07d07f79fac53e94a220a6dc760893c92b5f31597b79beb1053ea2;\n        pp.proof[78] = 0x1b05dfea4a38896b9003b0b9ed1818cd811bedd0cd6f963036d55322d9645f07;\n        pp.proof[79] = 0x2c53f648fc4c656e1f98a028e27a16cc401e8b862819c68ca6637ba638abeb0c;\n        pp.proof[80] = 0x05d027ee5fcd0f4a1605799235472467bdc444560465f312e9728629175d031c;\n        pp.proof[81] = 0x14388a198fc454ed7a8451818c5a8b8f09f0a153e6d9c86260b53034ee9946b2;\n        pp.proof[82] = 0x01c7082cd20253a7ae2914a16224bf95076007bf52a528f5cfb2489efa6e4120;\n        pp.proof[83] = 0x25baf9ad929b5aa422de4161a72e2f78a003f4e71a9fc1daba9258576705c39d;\n        pp.proof[84] = 0x236f544542f9974ef0c51a89d13b89d6a87705e1571eb34a40bb4d0212525718;\n        pp.proof[85] = 0x20906080fd564b60bea3196411731e3354d4e36a12a213baaeeb2e4e08401ea6;\n        pp.proof[86] = 0x0236bb41b600d7a40f82e2701d8532a9be1bc5d3dd63f4a209412843ce9b1682;\n        pp.proof[87] = 0x1c1cb5a2154efb69ecc40319db10ee207e31f83cd367db1e8811217f6499d9c2;\n        pp.proof[88] = 0x1412e9b9a2ed61eb32d79fe25c0f9a47e529e9b4f64b6013da3e22b7315ae14b;\n        pp.proof[89] = 0x20906080fd564b60bea3196411731e3354d4e36a12a213baaeeb2e4e08401ea6;\n        pp.proof[90] = 0x01;\n        pp.proof[91] = 0x221ee6f66dd7348eff846b5590d381ea8cb8f0ca0e80e1e949a34c2c2b4a0b11;\n        pp.proof[92] = 0x137ea3f2498d9f054296b1a95334311c620748cbccbb730520939bba1d113a35;\n        pp.proof[93] = 0x0c2246bc97be14e0b2d5f47fc9f4370ccd55e22ce28adc912085f171fd4e07cf;\n        pp.proof[94] = 0x1c0b82f01d6cf6f9ecd936244def3692cbe4e4abe43aa15599fa321cb588013e;\n        pp.proof[95] = 0x1229ead07018b7a62066887fbd59b17bd13112a39d59227f45f5d5790d3f970f;\n        pp.proof[96] = 0x1aa264fd55c35b07dddb436255864bd3894e862058eb7dd121f4ef97c6810b64;\n        pp.proof[97] = 0x10ecdfb779e2268ed72def773412a66f38cf5decaa8158bb4c01112e699ba62f;\n        pp.proof[98] = 0x049e5ead6a1d83eedc0b207203d10a451de72c028bd496e0f14ff18f4ba79a39;\n        pp.proof[99] = 0x169a133b7eecfac28476701d37b453ce0d986fc8cb34132812cbb714da48283a;\n        pp.proof[100] = 0x077a7d08ec14eabb50279063b7d24164810860f6b3a605ffe24f836f7749a556;\n        pp.proof[101] = 0x2a1664b44de1b7f6ac2cecbecb2f54b03462b3f305883593049a15cd7e33746d;\n        pp.proof[102] = 0x052f5f8f9668dfe04ec03cd7ec39bce2dff6ef730e0100ce334c2c98f906d1b7;\n        pp.proof[103] = 0x06d025885a04ada39e890e7db27ab5c2a90a7f5c9a9cc4d717f5a551e9b9b242;\n        pp.proof[104] = 0x296d0218c88ed41adf9c3f0f944f7ea6248f1ed438ffdf77d51961e2c2ee98d9;\n        pp.proof[105] = 0x01295c2c30506bce5e37d054803b48c8041a91bd93030d0b3192d0f715710f04;\n        pp.proof[106] = 0x04332a31ec11ffa8ddd98fe953663d8b80290ae5bed36e43231c3efe4b8e4162;\n        pp.proof[107] = 0x2673af9280bcb0498646d3cf78618018493daba0c9e15bb0c941f9e1f1ca497d;\n        pp.proof[108] = 0x1a50054bdc81d27e5cdb79d83e05e85a56232a1c130d9603f9d31089d993b5e8;\n        pp.proof[109] = 0x0e58cb9d2c096e8f058991f884ab765163d50f5494b833b9398b61c5728e9c9a;\n        pp.proof[110] = 0x2afd2c55cd975028a61c6d3855ae99ac8e97a00303ae89f32fd7990b1d83753d;\n        pp.proof[111] = 0x28511e5d57604f51601bb4898cb35ae6f9b3f21e5d9b28bc993f62265f5ca666;\n        pp.proof[112] = 0x14452f472272ecdfb34b51e8c0b7dd953abea37f8578a0ade1d26027044d097e;\n        pp.proof[113] = 0x180d46b4eb145617a39c42e8c870a691c6200e6c14b9bbe1699342f282dffcd9;\n        pp.proof[114] = 0x060d964f05b3d8b92410b05324a64719312568b3a7ada2eb51c826c317654ee5;\n        pp.proof[115] = 0x0c8f22f7591f9668fe2ab9a13ad14cf530611584d740228e27475ff426419c7b;\n        pp.proof[116] = 0x2b982362597dd8e09d31ff3bff3ec706dc38915acc248150b9c16b6d114f4d28;\n        pp.proof[117] = 0x2bfe3f955f517d0eab0d2973cead3109ba858ed5f19e6ee0841b1d3903a03cce;\n        pp.proof[118] = 0x178ef555294aa4ac896ed3a6ec4c69b667f906212bb580728a846cf87ea3ba9e;\n        pp.proof[119] = 0x0922cfffce57069b575b6aa86fa1169aa48fbb4d15fe871f2b63fe788498d3f6;\n        pp.proof[120] = 0x07a5c404278b81dd19896f03edbca9b482cd694ad764ec010f3f3d6fd87861f6;\n        pp.proof[121] = 0x07d2f52e44fb6bb5bc93f5369d1c6c23d0ede7a71458f0650232d2543706df4f;\n        pp.proof[122] = 0x11062839fae397f30ce308d118af6c6e8db2c65d770e20545cac5cd8c00946a0;\n        pp.proof[123] = 0x187379626ba408f04171bd6f2c7c926afcc8ddf1deee1d68162b3a4133b88607;\n        pp.proof[124] = 0x2a892a9b0649f36b7475005e953cb0938e8197e6d80c10c080a9ec25418cae0a;\n        pp.proof[125] = 0x0e2da727caba364de2c876ff4a5080f39cf60aa4fc5f99421b00db6e2c141818;\n        pp.proof[126] = 0x06a32d3c886ba50c30c3f78bd8e04946fd7a00d1a0da6fbcf929a43eb494aae5;\n        pp.proof[127] = 0xb6e9de94ceffbc2c86fe27a3be0d9be9b7daac31d429d13c5fca2f88141c28;\n        pp.proof[128] = 0x28e15f62b6363ebc0e77ad618883eec57c8d62118a44ed846ad3f3a3debc3647;\n        pp.proof[129] = 0x269e80d7f3464b165e80b9f517a31b199c0714be8556cb81b08fa4cd83007bde;\n        pp.proof[130] = 0x025493598acf62c5bf5e33f835b38d90aa85656e88b802873019494c8211ded9;\n        pp.proof[131] = 0x301fd8478e9b663edf2ca1d8c449808f86f681b27921b9a4fe11d4ef6200a39e;\n        pp.proof[132] = 0x0b7fdca9e1f4a2850a301b0ae7eef5a97349e3e10799181873e9bc7b6bb63771;\n        pp.proof[133] = 0x2eddc283edae0822690630f8cfa1cf8e2d3d22d7ce9d61f8b549b6314b4843a6;\n        pp.proof[134] = 0x1a5b6e70e43ab498773add7b267ae69589a50789c2f55da08f91e8262ed09593;\n        pp.proof[135] = 0x1954c733721193def0c255f86ff069aecdede42a1b5686e59baeae3221c8d08f;\n        pp.proof[136] = 0x2d2870e2203674b9fa9292304554b5a13bd3fbd42db90b160a8ff70c0250addd;\n        pp.proof[137] = 0x16f733190da516ba5f2550c032bf4744923c4d57f252f4374354ba8bed45cb56;\n        pp.proof[138] = 0x2496308b5b17e051248ba572bf9dbf064430c66a92576e3b7e38c866ee00cfe6;\n        pp.proof[139] = 0x10c8a06b1948d1d0fe58859bb6f27a8ce360e637ccc9d4c1cd357c59f81c8f47;\n        pp.proof[140] = 0x11f97d03587a4758918905531b2f4fe588c2d1c0cd1186eb0b6fe6f73455996a;\n        pp.proof[141] = 0x1f90cfe687885c24d38933dafbd4221d92a9f12b0652330f303e9f06cd9a075e;\n        pp.proof[142] = 0x2979a10070eb65d9a02b7fb7b8845e754d06a4fb84e2c5b37740bd2eb5036947;\n        pp.proof[143] = 0x251de342b3462dd763fe07b981e72cea3b6efbdb090acd81a0ea12bd9a71640c;\n        pp.proof[144] = 0x054e118c224e76380187d538d2681c02096fd08591c59671e306ceedce157332;\n\n        pp.pair = new uint256[](4);\n        pp.pair[0] = 14119124678741543360965253109586640170283614103124486812109378806144402533094;\n        pp.pair[1] = 12548950483584623620603349073407576839334870676019418739835777953580858712635;\n        pp.pair[2] = 10827110964341816746239032535351704854196268529594961376201932521276612187501;\n        pp.pair[3] = 4665480746868900290271721039472532000546562051861887949450510736473526247645;\n\n        return pp;\n    }\n\n    struct Account {\n        uint64 nonce;\n        uint256 balance;\n        bytes32 storageRoot;\n        bytes32 codeHash;\n    }\n\n    function merkleProof() internal pure returns (Account memory, bytes[] memory) {\n        Account memory account = Account({\n            nonce: 0,\n            balance: 0,\n            storageRoot: 0x24f53397bd92b66fda812b6e1191a00b60fc8e304033518006cbeedcab7f2127,\n            codeHash: 0x1f958654ab06a152993e7a0ae7b6dbb0d4b19265cc9337b8789fe1353bd9dc35\n        });\n        bytes[] memory proof = new bytes[](13);\n        proof[0] = hex\"001d70e33820638e04e2a9edff096ef8a372067f654795d98810db23d4aa05650d0a7cae21b7fd43b77b12d45602e15180298ba59195186ad8b84685bd4df131c6\";\n        proof[1] = hex\"0009c507e2a822ac5a2e95760cbd5348f34c04148c5e2bc10f064632d424b53a1a29fc543090f1b44ab0ba6f939c9e8c9d329c614de53e2f38ec7457842b980ff2\";\n        proof[2] = hex\"0021e148200d68427f4cd748b40d577a3ebc24f29dba6a51690cb56625632735f5047b12ada42bc39c3f53a187bdd7cb98db773a6c0475cb7cf813861296273c51\";\n        proof[3] = hex\"002bf1dc335fbd3c6252fa426d647d20ff86181a1a3ac1f4c53122b5a853436a5900d62fc393b0150bfe7c840be535455215e921f99f673f440d5ddba5cc55ac07\";\n        proof[4] = hex\"00188f4a9b605caa246413179613bffe6c4efcd717d4d68a2dbc531123c8d2a4531d12fb4a76dc568a4655d2e360e9bdcd9f86542d6f7d327e3140477c92aa2920\";\n        proof[5] = hex\"00244f31e0a770ed9dbdf583a0e0dbe036f5f9476c3cc761e18b2a475a96bcc10809387d2d4be643d4d8df653dcb8495eebc36eba91f993f78fe843a799a6d0fb9\";\n        proof[6] = hex\"0008f993e0df87a04e71f72a3a237c909e2381eacf176b279925d333ee7b1e36ed03c30671a87c81a313a035fdbe052cc592ae0a604bcf87a5cf163d5a43104574\";\n        proof[7] = hex\"00202aa398b4bd976d7c165b2c7bfa6e4b695f18ff78e4cb544dbb0fbab8c6537e15c1089ff56ee758ec382a55a21b76c08ebf64d6a78d7e6ff442793536607510\";\n        proof[8] = hex\"0000000000000000000000000000000000000000000000000000000000000000002e957b48192277673a8dde0549358d09d3f9ad6e8db14e08f4fed46f96021a74\";\n        proof[9] = hex\"002325a334c56feef28306cece9e3867165ee117aab1c831fe04db286a1b4ff2c80000000000000000000000000000000000000000000000000000000000000000\";\n        proof[10] = hex\"00218476186a36a2ddf003ef59459478f44e0cea1ac32870dafca118331259b05f23618448c7fab9e44d30c44be6777aa390c25ad138fde11d22bdefd05f43838b\";\n        proof[11] = hex\"012de4ca10cb48fa7ae483633127295fecab2f03da9355f4ca12ca0c820096f9c304040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001f958654ab06a152993e7a0ae7b6dbb0d4b19265cc9337b8789fe1353bd9dc3524f53397bd92b66fda812b6e1191a00b60fc8e304033518006cbeedcab7f2127202de4ca10cb48fa7ae483633127295fecab2f03da9355f4ca12ca0c820096f9c3\";\n        proof[12] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n\n        return (account, proof);\n    }\n}\n"
    },
    "contracts/universal/CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    PausableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\n\n/**\n * @custom:upgradeable\n * @title CrossDomainMessenger\n * @notice CrossDomainMessenger is a base contract that provides the core logic for the L1 and L2\n *         cross-chain messenger contracts. It's designed to be a universal interface that only\n *         needs to be extended slightly to provide low-level message passing functionality on each\n *         chain it's deployed on. Currently only designed for message passing between two paired\n *         chains and does not support one-to-many interactions.\n *\n *         Any changes to this contract MUST result in a semver bump for contracts that inherit it.\n */\nabstract contract CrossDomainMessenger is PausableUpgradeable {\n    /**\n     * @notice Current message version identifier.\n     */\n    uint16 public constant MESSAGE_VERSION = 0;\n\n    /**\n     * @notice Constant overhead added to the base gas for a message.\n     */\n    uint64 public constant RELAY_CONSTANT_OVERHEAD = 200_000;\n\n    /**\n     * @notice Numerator for dynamic overhead added to the base gas for a message.\n     */\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR = 64;\n\n    /**\n     * @notice Denominator for dynamic overhead added to the base gas for a message.\n     */\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR = 63;\n\n    /**\n     * @notice Extra gas added to base gas for each byte of calldata in a message.\n     */\n    uint64 public constant MIN_GAS_CALLDATA_OVERHEAD = 16;\n\n    /**\n     * @notice Gas reserved for performing the external call in `relayMessage`.\n     */\n    uint64 public constant RELAY_CALL_OVERHEAD = 40_000;\n\n    /**\n     * @notice Gas reserved for finalizing the execution of `relayMessage` after the safe call.\n     */\n    uint64 public constant RELAY_RESERVED_GAS = 40_000;\n\n    /**\n     * @notice Gas reserved for the execution between the `hasMinGas` check and the external\n     *         call in `relayMessage`.\n     */\n    uint64 public constant RELAY_GAS_CHECK_BUFFER = 5_000;\n\n    /**\n     * @notice Address of the paired CrossDomainMessenger contract on the other chain.\n     */\n    address public immutable OTHER_MESSENGER;\n\n    /**\n     * @notice Mapping of message hashes to boolean receipt values. Note that a message will only\n     *         be present in this mapping if it has successfully been relayed on this chain, and\n     *         can therefore not be relayed again.\n     */\n    mapping(bytes32 => bool) public successfulMessages;\n\n    /**\n     * @notice Address of the sender of the currently executing message on the other chain. If the\n     *         value of this variable is the default value (0x00000000...dead) then no message is\n     *         currently being executed. Use the xDomainMessageSender getter which will throw an\n     *         error if this is the case.\n     */\n    address internal xDomainMsgSender;\n\n    /**\n     * @notice Nonce for the next message to be sent, without the message version applied. Use the\n     *         messageNonce getter which will insert the message version into the nonce to give you\n     *         the actual nonce to be used for the message.\n     */\n    uint240 internal msgNonce;\n\n    /**\n     * @notice Mapping of message hashes to a boolean if and only if the message has failed to be\n     *         executed at least once. A message will not be present in this mapping if it\n     *         successfully executed on the first attempt.\n     */\n    mapping(bytes32 => bool) public failedMessages;\n\n    /**\n     * @notice Reserve extra slots in the storage layout for future upgrades.\n     *         A gap size of 45 was chosen here, so that the first slot used in a child contract\n     *         would be a multiple of 50.\n     */\n    uint256[45] private __gap;\n\n    /**\n     * @notice Emitted whenever a message is sent to the other chain.\n     *\n     * @param target       Address of the recipient of the message.\n     * @param sender       Address of the sender of the message.\n     * @param value        ETH value sent along with the message to the recipient.\n     * @param message      Message to trigger the recipient address with.\n     * @param messageNonce Unique nonce attached to the message.\n     * @param gasLimit     Minimum gas limit that the message can be executed with.\n     */\n    event SentMessage(\n        address indexed target,\n        address indexed sender,\n        uint256 value,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n\n    /**\n     * @notice Emitted whenever a message is successfully relayed on this chain.\n     *\n     * @param msgHash Hash of the message that was relayed.\n     */\n    event RelayedMessage(bytes32 indexed msgHash);\n\n    /**\n     * @notice Emitted whenever a message fails to be relayed on this chain.\n     *\n     * @param msgHash Hash of the message that failed to be relayed.\n     */\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /**\n     * @param _otherMessenger Address of the messenger on the paired chain.\n     */\n    constructor(address _otherMessenger) {\n        OTHER_MESSENGER = _otherMessenger;\n    }\n\n    /**\n     * @notice Sends a message to some target address on the other chain. Note that if the call\n     *         always reverts, then the message will be unrelayable, and any ETH sent will be\n     *         permanently locked. The same will occur if the target on the other chain is\n     *         considered unsafe (see the _isUnsafeTarget() function).\n     *\n     * @param _target      Target contract or wallet address.\n     * @param _message     Message to trigger the target address with.\n     * @param _minGasLimit Minimum gas limit that the message can be executed with.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _minGasLimit\n    ) external payable {\n        // Triggers a message to the other messenger. Note that the amount of gas provided to the\n        // message is the amount of gas requested by the user PLUS the base gas value. We want to\n        // guarantee the property that the call to the target contract will always have at least\n        // the minimum gas limit specified by the user.\n        _sendMessage(\n            OTHER_MESSENGER,\n            baseGas(_message, _minGasLimit),\n            msg.value,\n            abi.encodeWithSelector(\n                this.relayMessage.selector,\n                messageNonce(),\n                msg.sender,\n                _target,\n                msg.value,\n                _minGasLimit,\n                _message\n            )\n        );\n\n        emit SentMessage(_target, msg.sender, msg.value, _message, messageNonce(), _minGasLimit);\n\n        unchecked {\n            ++msgNonce;\n        }\n    }\n\n    /**\n     * @notice Relays a message that was sent by the other CrossDomainMessenger contract. Can only\n     *         be executed via cross-chain call from the other messenger OR if the message was\n     *         already received once and is currently being replayed.\n     *\n     * @param _nonce       Nonce of the message being relayed.\n     * @param _sender      Address of the user who sent the message.\n     * @param _target      Address that the message is targeted at.\n     * @param _value       ETH value to send with the message.\n     * @param _minGasLimit Minimum amount of gas that the message can be executed with.\n     * @param _message     Message to send to the target.\n     */\n    function relayMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _minGasLimit,\n        bytes calldata _message\n    ) external payable {\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\n        require(\n            version < 1,\n            \"CrossDomainMessenger: only version 0 messages is supported at this time\"\n        );\n\n        // We use the v0 message hash as the unique identifier for the message because it commits\n        // to the value and minimum gas limit of the message.\n        bytes32 versionedHash = Hashing.hashCrossDomainMessageV0(\n            _nonce,\n            _sender,\n            _target,\n            _value,\n            _minGasLimit,\n            _message\n        );\n\n        if (_isOtherMessenger()) {\n            // These properties should always hold when the message is first submitted (as\n            // opposed to being replayed).\n            assert(msg.value == _value);\n            assert(!failedMessages[versionedHash]);\n        } else {\n            require(\n                msg.value == 0,\n                \"CrossDomainMessenger: value must be zero unless message is from a system address\"\n            );\n\n            require(\n                failedMessages[versionedHash],\n                \"CrossDomainMessenger: message cannot be replayed\"\n            );\n        }\n\n        require(\n            _isUnsafeTarget(_target) == false,\n            \"CrossDomainMessenger: cannot send message to blocked system address\"\n        );\n\n        require(\n            successfulMessages[versionedHash] == false,\n            \"CrossDomainMessenger: message has already been relayed\"\n        );\n\n        // If there is not enough gas left to perform the external call and finish the execution,\n        // return early and assign the message to the failedMessages mapping.\n        // We are asserting that we have enough gas to:\n        // 1. Call the target contract (_minGasLimit + RELAY_CALL_OVERHEAD + RELAY_GAS_CHECK_BUFFER)\n        //   1.a. The RELAY_CALL_OVERHEAD is included in `hasMinGas`.\n        // 2. Finish the execution after the external call (RELAY_RESERVED_GAS).\n        //\n        // If `xDomainMsgSender` is not the default L2 sender, this function\n        // is being re-entered. This marks the message as failed to allow it to be replayed.\n        if (\n            !SafeCall.hasMinGas(_minGasLimit, RELAY_RESERVED_GAS + RELAY_GAS_CHECK_BUFFER) ||\n            xDomainMsgSender != Constants.DEFAULT_L2_SENDER\n        ) {\n            failedMessages[versionedHash] = true;\n            emit FailedRelayedMessage(versionedHash);\n\n            // Revert in this case if the transaction was triggered by the estimation address. This\n            // should only be possible during gas estimation or we have bigger problems. Reverting\n            // here will make the behavior of gas estimation change such that the gas limit\n            // computed will be the amount required to relay the message, even if that amount is\n            // greater than the minimum gas limit specified by the user.\n            if (tx.origin == Constants.ESTIMATION_ADDRESS) {\n                revert(\"CrossDomainMessenger: failed to relay message\");\n            }\n\n            return;\n        }\n\n        xDomainMsgSender = _sender;\n        bool success = SafeCall.call(_target, gasleft() - RELAY_RESERVED_GAS, _value, _message);\n        xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\n\n        if (success) {\n            successfulMessages[versionedHash] = true;\n            emit RelayedMessage(versionedHash);\n        } else {\n            failedMessages[versionedHash] = true;\n            emit FailedRelayedMessage(versionedHash);\n\n            // Revert in this case if the transaction was triggered by the estimation address. This\n            // should only be possible during gas estimation or we have bigger problems. Reverting\n            // here will make the behavior of gas estimation change such that the gas limit\n            // computed will be the amount required to relay the message, even if that amount is\n            // greater than the minimum gas limit specified by the user.\n            if (tx.origin == Constants.ESTIMATION_ADDRESS) {\n                revert(\"CrossDomainMessenger: failed to relay message\");\n            }\n        }\n    }\n\n    /**\n     * @notice Retrieves the address of the contract or wallet that initiated the currently\n     *         executing message on the other chain. Will throw an error if there is no message\n     *         currently being executed. Allows the recipient of a call to see who triggered it.\n     *\n     * @return Address of the sender of the currently executing message on the other chain.\n     */\n    function xDomainMessageSender() external view returns (address) {\n        require(\n            xDomainMsgSender != Constants.DEFAULT_L2_SENDER,\n            \"CrossDomainMessenger: xDomainMessageSender is not set\"\n        );\n\n        return xDomainMsgSender;\n    }\n\n    /**\n     * @notice Retrieves the next message nonce. Message version will be added to the upper two\n     *         bytes of the message nonce. Message version allows us to treat messages as having\n     *         different structures.\n     *\n     * @return Nonce of the next message to be sent, with added message version.\n     */\n    function messageNonce() public view returns (uint256) {\n        return Encoding.encodeVersionedNonce(msgNonce, MESSAGE_VERSION);\n    }\n\n    /**\n     * @notice Computes the amount of gas required to guarantee that a given message will be\n     *         received on the other chain without running out of gas. Guaranteeing that a message\n     *         will not run out of gas is important because this ensures that a message can always\n     *         be replayed on the other chain if it fails to execute completely.\n     *\n     * @param _message     Message to compute the amount of required gas for.\n     * @param _minGasLimit Minimum desired gas limit when message goes to target.\n     *\n     * @return Amount of gas required to guarantee message receipt.\n     */\n    function baseGas(bytes calldata _message, uint32 _minGasLimit) public pure returns (uint64) {\n        return\n            // Constant overhead\n            RELAY_CONSTANT_OVERHEAD +\n            // Calldata overhead\n            (uint64(_message.length) * MIN_GAS_CALLDATA_OVERHEAD) +\n            // Dynamic overhead (EIP-150)\n            ((_minGasLimit * MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR) /\n                MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR) +\n            // Gas reserved for the worst-case cost of 3/5 of the `CALL` opcode's dynamic gas\n            // factors. (Conservative)\n            RELAY_CALL_OVERHEAD +\n            // Relay reserved gas (to ensure execution of `relayMessage` completes after the\n            // subcontext finishes executing) (Conservative)\n            RELAY_RESERVED_GAS +\n            // Gas reserved for the execution between the `hasMinGas` check and the `CALL`\n            // opcode. (Conservative)\n            RELAY_GAS_CHECK_BUFFER;\n    }\n\n    /**\n     * @notice Intializer.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __CrossDomainMessenger_init() internal onlyInitializing {\n        xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\n    }\n\n    /**\n     * @notice Sends a low-level message to the other messenger. Needs to be implemented by child\n     *         contracts because the logic for this depends on the network where the messenger is\n     *         being deployed.\n     *\n     * @param _to       Recipient of the message on the other chain.\n     * @param _gasLimit Minimum gas limit the message can be executed with.\n     * @param _value    Amount of ETH to send with the message.\n     * @param _data     Message data.\n     */\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal virtual;\n\n    /**\n     * @notice Checks whether the message is coming from the other messenger. Implemented by child\n     *         contracts because the logic for this depends on the network where the messenger is\n     *         being deployed.\n     *\n     * @return Whether the message is coming from the other messenger.\n     */\n    function _isOtherMessenger() internal view virtual returns (bool);\n\n    /**\n     * @notice Checks whether a given call target is a system address that could cause the\n     *         messenger to peform an unsafe action. This is NOT a mechanism for blocking user\n     *         addresses. This is ONLY used to prevent the execution of messages to specific\n     *         system addresses that could cause security issues, e.g., having the\n     *         CrossDomainMessenger send messages to itself.\n     *\n     * @param _target Address of the contract to check.\n     *\n     * @return Whether or not the address is an unsafe system address.\n     */\n    function _isUnsafeTarget(address _target) internal view virtual returns (bool);\n}\n"
    },
    "contracts/universal/ERC721Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { CrossDomainMessenger } from \"./CrossDomainMessenger.sol\";\n\n/**\n * @title ERC721Bridge\n * @notice ERC721Bridge is a base contract for the L1 and L2 ERC721 bridges.\n */\nabstract contract ERC721Bridge {\n    /**\n     * @notice Messenger contract on this domain.\n     */\n    CrossDomainMessenger public immutable MESSENGER;\n\n    /**\n     * @notice Address of the bridge on the other network.\n     */\n    address public immutable OTHER_BRIDGE;\n\n    /**\n     * @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\n     */\n    uint256[49] private __gap;\n\n    /**\n     * @notice Emitted when an ERC721 bridge to the other network is initiated.\n     *\n     * @param localToken  Address of the token on this domain.\n     * @param remoteToken Address of the token on the remote domain.\n     * @param from        Address that initiated bridging action.\n     * @param to          Address to receive the token.\n     * @param tokenId     ID of the specific token deposited.\n     * @param extraData   Extra data for use on the client-side.\n     */\n    event ERC721BridgeInitiated(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    /**\n     * @notice Emitted when an ERC721 bridge from the other network is finalized.\n     *\n     * @param localToken  Address of the token on this domain.\n     * @param remoteToken Address of the token on the remote domain.\n     * @param from        Address that initiated bridging action.\n     * @param to          Address to receive the token.\n     * @param tokenId     ID of the specific token deposited.\n     * @param extraData   Extra data for use on the client-side.\n     */\n    event ERC721BridgeFinalized(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    /**\n     * @notice Ensures that the caller is a cross-chain message from the other bridge.\n     */\n    modifier onlyOtherBridge() {\n        require(\n            msg.sender == address(MESSENGER) && MESSENGER.xDomainMessageSender() == OTHER_BRIDGE,\n            \"ERC721Bridge: function can only be called from the other bridge\"\n        );\n        _;\n    }\n\n    /**\n     * @param _messenger   Address of the CrossDomainMessenger on this network.\n     * @param _otherBridge Address of the ERC721 bridge on the other network.\n     */\n    constructor(address _messenger, address _otherBridge) {\n        require(_messenger != address(0), \"ERC721Bridge: messenger cannot be address(0)\");\n        require(_otherBridge != address(0), \"ERC721Bridge: other bridge cannot be address(0)\");\n\n        MESSENGER = CrossDomainMessenger(_messenger);\n        OTHER_BRIDGE = _otherBridge;\n    }\n\n    /**\n     * @notice Initiates a bridge of an NFT to the caller's account on the other chain. Note that\n     *         this function can only be called by EOAs. Smart contract wallets should use the\n     *         `bridgeERC721To` function after ensuring that the recipient address on the remote\n     *         chain exists. Also note that the current owner of the token on this chain must\n     *         approve this contract to operate the NFT before it can be bridged.\n     *         **WARNING**: Do not bridge an ERC721 that was originally deployed on Kroma. This\n     *         bridge only supports ERC721s originally deployed on Ethereum. Users will need to\n     *         wait for the one-week challenge period to elapse before their Kroma-native NFT\n     *         can be refunded on L2.\n     *\n     * @param _localToken  Address of the ERC721 on this domain.\n     * @param _remoteToken Address of the ERC721 on the remote domain.\n     * @param _tokenId     Token ID to bridge.\n     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.\n     * @param _extraData   Optional data to forward to the other chain. Data supplied here will not\n     *                     be used to execute any code on the other chain and is only emitted as\n     *                     extra data for the convenience of off-chain tooling.\n     */\n    function bridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        uint256 _tokenId,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external {\n        // Modifier requiring sender to be EOA. This prevents against a user error that would occur\n        // if the sender is a smart contract wallet that has a different address on the remote chain\n        // (or doesn't have an address on the remote chain at all). The user would fail to receive\n        // the NFT if they use this function because it sends the NFT to the same address as the\n        // caller. This check could be bypassed by a malicious contract via initcode, but it takes\n        // care of the user error we want to avoid.\n        require(!Address.isContract(msg.sender), \"ERC721Bridge: account is not externally owned\");\n\n        _initiateBridgeERC721(\n            _localToken,\n            _remoteToken,\n            msg.sender,\n            msg.sender,\n            _tokenId,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @notice Initiates a bridge of an NFT to some recipient's account on the other chain. Note\n     *         that the current owner of the token on this chain must approve this contract to\n     *         operate the NFT before it can be bridged.\n     *         **WARNING**: Do not bridge an ERC721 that was originally deployed on Kroma. This\n     *         bridge only supports ERC721s originally deployed on Ethereum. Users will need to\n     *         wait for the one-week challenge period to elapse before their Kroma-native NFT\n     *         can be refunded on L2.\n     *\n     * @param _localToken  Address of the ERC721 on this domain.\n     * @param _remoteToken Address of the ERC721 on the remote domain.\n     * @param _to          Address to receive the token on the other domain.\n     * @param _tokenId     Token ID to bridge.\n     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.\n     * @param _extraData   Optional data to forward to the other chain. Data supplied here will not\n     *                     be used to execute any code on the other chain and is only emitted as\n     *                     extra data for the convenience of off-chain tooling.\n     */\n    function bridgeERC721To(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _tokenId,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external {\n        require(_to != address(0), \"ERC721Bridge: nft recipient cannot be address(0)\");\n\n        _initiateBridgeERC721(\n            _localToken,\n            _remoteToken,\n            msg.sender,\n            _to,\n            _tokenId,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @notice Internal function for initiating a token bridge to the other domain.\n     *\n     * @param _localToken  Address of the ERC721 on this domain.\n     * @param _remoteToken Address of the ERC721 on the remote domain.\n     * @param _from        Address of the sender on this domain.\n     * @param _to          Address to receive the token on the other domain.\n     * @param _tokenId     Token ID to bridge.\n     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.\n     * @param _extraData   Optional data to forward to the other domain. Data supplied here will\n     *                     not be used to execute any code on the other domain and is only emitted\n     *                     as extra data for the convenience of off-chain tooling.\n     */\n    function _initiateBridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) internal virtual;\n}\n"
    },
    "contracts/universal/FeeVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { L2StandardBridge } from \"../L2/L2StandardBridge.sol\";\n\n/**\n * @title FeeVault\n * @notice The FeeVault contract contains the basic logic for the various different vault contracts\n *         used to hold fee revenue generated by the L2 system.\n */\nabstract contract FeeVault {\n    /**\n     * @notice Emits each time that a withdrawal occurs.\n     *\n     * @param value Amount that was withdrawn (in wei).\n     * @param to    Address that the funds were sent to.\n     * @param from  Address that triggered the withdrawal.\n     */\n    event Withdrawal(uint256 value, address to, address from);\n\n    /**\n     * @notice Minimum balance before a withdrawal can be triggered.\n     */\n    uint256 public immutable MIN_WITHDRAWAL_AMOUNT;\n\n    /**\n     * @notice Wallet that will receive the fees on L1.\n     */\n    address public immutable RECIPIENT;\n\n    /**\n     * @notice The minimum gas limit for the FeeVault withdrawal transaction.\n     */\n    uint32 internal constant WITHDRAWAL_MIN_GAS = 35_000;\n\n    /**\n     * @notice Total amount of wei processed by the contract.\n     */\n    uint256 public totalProcessed;\n\n    /**\n     * @param _recipient           Wallet that will receive the fees on L1.\n     * @param _minWithdrawalAmount Minimum balance before a withdrawal can be triggered.\n     */\n    constructor(address _recipient, uint256 _minWithdrawalAmount) {\n        MIN_WITHDRAWAL_AMOUNT = _minWithdrawalAmount;\n        RECIPIENT = _recipient;\n    }\n\n    /**\n     * @notice Allow the contract to receive ETH.\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Triggers a withdrawal of funds to the L1 fee wallet.\n     */\n    function withdraw() external virtual {\n        require(\n            address(this).balance >= MIN_WITHDRAWAL_AMOUNT,\n            \"FeeVault: withdrawal amount must be greater than minimum withdrawal amount\"\n        );\n\n        uint256 value = address(this).balance;\n        totalProcessed += value;\n\n        emit Withdrawal(value, RECIPIENT, msg.sender);\n\n        L2StandardBridge(payable(Predeploys.L2_STANDARD_BRIDGE)).bridgeETHTo{ value: value }(\n            RECIPIENT,\n            WITHDRAWAL_MIN_GAS,\n            bytes(\"\")\n        );\n    }\n}\n"
    },
    "contracts/universal/IKromaMintableERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title IKromaMintableERC20\n * @notice This interface is available on the KromaMintableERC20 contract. We declare it as a\n *         separate interface so that it can be used in custom implementations of\n *         KromaMintableERC20.\n */\ninterface IKromaMintableERC20 {\n    function REMOTE_TOKEN() external view returns (address);\n\n    function BRIDGE() external view returns (address);\n\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n}\n"
    },
    "contracts/universal/IKromaMintableERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {\n    IERC721Enumerable\n} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\n\n/**\n * @title IKromaMintableERC721\n * @notice Interface for contracts that are compatible with the KromaMintableERC721 standard.\n *         Tokens that follow this standard can be easily transferred across the ERC721 bridge.\n */\ninterface IKromaMintableERC721 is IERC721Enumerable {\n    /**\n     * @notice Emitted when a token is minted.\n     *\n     * @param account Address of the account the token was minted to.\n     * @param tokenId Token ID of the minted token.\n     */\n    event Mint(address indexed account, uint256 tokenId);\n\n    /**\n     * @notice Emitted when a token is burned.\n     *\n     * @param account Address of the account the token was burned from.\n     * @param tokenId Token ID of the burned token.\n     */\n    event Burn(address indexed account, uint256 tokenId);\n\n    /**\n     * @notice Mints some token ID for a user, checking first that contract recipients\n     *         are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * @param _to      Address of the user to mint the token for.\n     * @param _tokenId Token ID to mint.\n     */\n    function safeMint(address _to, uint256 _tokenId) external;\n\n    /**\n     * @notice Burns a token ID from a user.\n     *\n     * @param _from    Address of the user to burn the token from.\n     * @param _tokenId Token ID to burn.\n     */\n    function burn(address _from, uint256 _tokenId) external;\n\n    /**\n     * @notice Chain ID of the chain where the remote token is deployed.\n     */\n    function REMOTE_CHAIN_ID() external view returns (uint256);\n\n    /**\n     * @notice Address of the token on the remote domain.\n     */\n    function REMOTE_TOKEN() external view returns (address);\n\n    /**\n     * @notice Address of the ERC721 bridge on this network.\n     */\n    function BRIDGE() external view returns (address);\n\n    /**\n     * @notice Chain ID of the chain where the remote token is deployed.\n     */\n    function remoteChainId() external view returns (uint256);\n\n    /**\n     * @notice Address of the token on the remote domain.\n     */\n    function remoteToken() external view returns (address);\n\n    /**\n     * @notice Address of the ERC721 bridge on this network.\n     */\n    function bridge() external view returns (address);\n}\n"
    },
    "contracts/universal/IMultiSigWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title IMultiSigWallet\n * @notice Interface for contracts that are compatible with the Safe legacy MultiSigWallet.\n */\ninterface IMultiSigWallet {\n    /**\n     * @notice Emitted when anyone confirm a transaction.\n     *\n     * @param sender        Owner of address that confirm a transaction.\n     * @param transactionId Index of transaction confirmed.\n     */\n    event Confirmation(address indexed sender, uint256 indexed transactionId);\n\n    /**\n     * @notice Emitted when anyone revoke a transaction.\n     *\n     * @param sender        Owner of address that revoke a transaction.\n     * @param transactionId Index of transaction revoked.\n     */\n    event Revocation(address indexed sender, uint256 indexed transactionId);\n\n    /**\n     * @notice Emitted when anyone submit a transaction.\n     *\n     * @param transactionId Index of transaction submitted.\n     */\n    event Submission(uint256 indexed transactionId);\n\n    /**\n     * @notice Emitted when transaction is executed.\n     *\n     * @param transactionId Index of transaction executed.\n     */\n    event Execution(uint256 indexed transactionId);\n\n    /**\n     * @notice Emitted when transaction is executed but failed.\n     *\n     * @param transactionId Index of transaction failed to execute.\n     */\n    event ExecutionFailure(uint256 indexed transactionId);\n\n    /**\n     * @notice Emitted when an owner address is added.\n     *\n     * @param owner Owner address that added.\n     */\n    event OwnerAddition(address indexed owner);\n\n    /**\n     * @notice Emitted when an owner address is removed.\n     *\n     * @param owner Owner address that removed.\n     */\n    event OwnerRemoval(address indexed owner);\n\n    /**\n     * @notice Emitted when a requirement changed\n     *\n     * @param required Required value that changed.\n     */\n    event RequirementChange(uint256 required);\n\n    /**\n     * @notice Allows to add a new owner. Transaction has to be sent by wallet.\n     *\n     * @param _owner Address of new owner.\n     */\n    function addOwner(address _owner) external;\n\n    /**\n     * @notice Allows to remove an owner. Transaction has to be sent by wallet.\n     *\n     * @param _owner Address of owner.\n     */\n    function removeOwner(address _owner) external;\n\n    /**\n     * @notice Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n     *\n     * @param _owner    Address of owner to be replaced.\n     * @param _newOwner Address of new owner.\n     */\n    function replaceOwner(address _owner, address _newOwner) external;\n\n    /**\n     * @notice Allows to change the number of required confirmations.\n     *         Transaction has to be sent by wallet.\n     *\n     * @param _required Number of required confirmations.\n     */\n    function changeRequirement(uint256 _required) external;\n\n    /**\n     * @notice Allows an owner to submit and confirm a transaction.\n     *\n     * @param _destination Transaction target address.\n     * @param _value       Transaction ether value.\n     * @param _data        Transaction data payload.\n     *\n     * @return Returns transaction ID.\n     */\n    function submitTransaction(\n        address _destination,\n        uint256 _value,\n        bytes memory _data\n    ) external returns (uint256);\n\n    /**\n     * @notice Allows an owner to confirm a transaction.\n     *\n     * @param _transactionId Transaction ID.\n     */\n    function confirmTransaction(uint256 _transactionId) external;\n\n    /**\n     * @notice Allows an owner to revoke a confirmation for a transaction.\n     *\n     * @param _transactionId Transaction ID.\n     */\n    function revokeConfirmation(uint256 _transactionId) external;\n\n    /**\n     * @notice Allows anyone to execute a confirmed transaction.\n     *\n     * @param _transactionId Transaction ID.\n     */\n    function executeTransaction(uint256 _transactionId) external;\n\n    /**\n     * @notice Returns the confirmation status of a transaction.\n     *\n     * @param _transactionId Transaction ID.\n     *\n     * @return Confirmation status.\n     */\n    function isConfirmed(uint256 _transactionId) external view returns (bool);\n\n    /**\n     * @notice Returns number of confirmations of a transaction.\n     *\n     * @param _transactionId Transaction ID.\n     *\n     * @return Number of confirmations.\n     */\n    function getConfirmationCount(uint256 _transactionId) external view returns (uint256);\n\n    /**\n     * @notice Returns total number of transactions after filters are applied.\n     *\n     * @param _pending  Whether include pending transactions.\n     * @param _executed Whether include executed transactions.\n     *\n     * @return Total number of transactions after filters are applied.\n     */\n    function getTransactionCount(bool _pending, bool _executed) external view returns (uint256);\n\n    /**\n     * @notice Returns list of owners.\n     *\n     * @return The list of owner addresses.\n     */\n    function getOwners() external view returns (address[] memory);\n\n    /**\n     * @notice Returns a list of owners who have confirmed the transaction.\n     *\n     * @param _transactionId Transaction ID.\n     *\n     * @return Returns array of owner addresses.\n     */\n    function getConfirmations(uint256 _transactionId) external view returns (address[] memory);\n\n    /**\n     * @notice Returns the list of transaction IDs in defined range.\n     *\n     * @param _from     The starting index of transaction array.\n     * @param _to       The ending index of the transaction array.\n     * @param _pending  Whether include pending transactions.\n     * @param _executed Whether include executed transactions.\n     *\n     * @return List of the transaction IDs in a defined range.\n     */\n    function getTransactionIds(\n        uint256 _from,\n        uint256 _to,\n        bool _pending,\n        bool _executed\n    ) external view returns (uint256[] memory);\n}\n"
    },
    "contracts/universal/KromaMintableERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport { Semver } from \"../universal/Semver.sol\";\nimport { IKromaMintableERC20 } from \"./IKromaMintableERC20.sol\";\n\n/**\n * @title KromaMintableERC20\n * @notice KromaMintableERC20 is a standard extension of the base ERC20 token contract designed\n *         to allow the StandardBridge contracts to mint and burn tokens. This makes it possible to\n *         use a KromaMintableRC20 as the L2 representation of an L1 token, or vice-versa.\n *         Designed to be backwards compatible with the older StandardL2ERC20 token which was only\n *         meant for use on L2.\n */\ncontract KromaMintableERC20 is IKromaMintableERC20, ERC20, Semver {\n    /**\n     * @notice Address of the corresponding version of this token on the remote chain.\n     */\n    address public immutable REMOTE_TOKEN;\n\n    /**\n     * @notice Address of the StandardBridge on this network.\n     */\n    address public immutable BRIDGE;\n\n    /**\n     * @notice Emitted whenever tokens are minted for an account.\n     *\n     * @param account Address of the account tokens are being minted for.\n     * @param amount  Amount of tokens minted.\n     */\n    event Mint(address indexed account, uint256 amount);\n\n    /**\n     * @notice Emitted whenever tokens are burned from an account.\n     *\n     * @param account Address of the account tokens are being burned from.\n     * @param amount  Amount of tokens burned.\n     */\n    event Burn(address indexed account, uint256 amount);\n\n    /**\n     * @notice A modifier that only allows the bridge to call\n     */\n    modifier onlyBridge() {\n        require(msg.sender == BRIDGE, \"KromaMintableERC20: only bridge can mint and burn\");\n        _;\n    }\n\n    /**\n    * @custom:semver 0.1.0\n     *\n     * @param _bridge      Address of the L2 standard bridge.\n     * @param _remoteToken Address of the corresponding L1 token.\n     * @param _name        ERC20 name.\n     * @param _symbol      ERC20 symbol.\n     */\n    constructor(\n        address _bridge,\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) Semver(0, 1, 0) {\n        REMOTE_TOKEN = _remoteToken;\n        BRIDGE = _bridge;\n    }\n\n    /**\n     * @notice Allows the StandardBridge on this network to mint tokens.\n     *\n     * @param _to     Address to mint tokens to.\n     * @param _amount Amount of tokens to mint.\n     */\n    function mint(address _to, uint256 _amount)\n        external\n        virtual\n        override(IKromaMintableERC20)\n        onlyBridge\n    {\n        _mint(_to, _amount);\n        emit Mint(_to, _amount);\n    }\n\n    /**\n     * @notice Allows the StandardBridge on this network to burn tokens.\n     *\n     * @param _from   Address to burn tokens from.\n     * @param _amount Amount of tokens to burn.\n     */\n    function burn(address _from, uint256 _amount)\n        external\n        virtual\n        override(IKromaMintableERC20)\n        onlyBridge\n    {\n        _burn(_from, _amount);\n        emit Burn(_from, _amount);\n    }\n\n    /**\n     * @notice ERC165 interface check function.\n     *\n     * @param _interfaceId Interface ID to check.\n     *\n     * @return Whether or not the interface is supported by this contract.\n     */\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool) {\n        bytes4 iface1 = type(IERC165).interfaceId;\n        // Interface corresponding to the updated KromaMintableERC20 (this contract).\n        bytes4 iface2 = type(IKromaMintableERC20).interfaceId;\n        return _interfaceId == iface1 || _interfaceId == iface2;\n    }\n}\n"
    },
    "contracts/universal/KromaMintableERC20Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/* Contract Imports */\nimport { KromaMintableERC20 } from \"../universal/KromaMintableERC20.sol\";\nimport { Semver } from \"./Semver.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeployed 0x420000000000000000000000000000000000000B\n * @title KromaMintableERC20Factory\n * @notice KromaMintableERC20Factory is a factory contract that generates KromaMintableERC20\n *         contracts on the network it's deployed to. Simplifies the deployment process for users\n *         who may be less familiar with deploying smart contracts. Designed to be backwards\n *         compatible with the older StandardL2ERC20Factory contract.\n */\ncontract KromaMintableERC20Factory is Semver {\n    /**\n     * @notice Address of the StandardBridge on this chain.\n     */\n    address public immutable BRIDGE;\n\n    /**\n     * @notice Emitted whenever a new KromaMintableERC20 is created.\n     *\n     * @param localToken  Address of the created token on the local chain.\n     * @param remoteToken Address of the corresponding token on the remote chain.\n     * @param deployer    Address of the account that deployed the token.\n     */\n    event KromaMintableERC20Created(\n        address indexed localToken,\n        address indexed remoteToken,\n        address deployer\n    );\n\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @notice The semver MUST be bumped any time that there is a change in\n     *         the KromaMintableERC20 token contract since this contract\n     *         is responsible for deploying KromaMintableERC20 contracts.\n     *\n     * @param _bridge Address of the StandardBridge on this chain.\n     */\n    constructor(address _bridge) Semver(0, 1, 0) {\n        BRIDGE = _bridge;\n    }\n\n    /**\n     * @notice Creates an instance of the KromaMintableERC20 contract.\n     *\n     * @param _remoteToken Address of the token on the remote chain.\n     * @param _name        ERC20 name.\n     * @param _symbol      ERC20 symbol.\n     *\n     * @return Address of the newly created token.\n     */\n    function createKromaMintableERC20(\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) public returns (address) {\n        require(\n            _remoteToken != address(0),\n            \"KromaMintableERC20Factory: must provide remote token address\"\n        );\n\n        address localToken = address(\n            new KromaMintableERC20(BRIDGE, _remoteToken, _name, _symbol)\n        );\n\n        emit KromaMintableERC20Created(localToken, _remoteToken, msg.sender);\n\n        return localToken;\n    }\n}\n"
    },
    "contracts/universal/KromaMintableERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {\n    ERC721Enumerable\n} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport { Semver } from \"../universal/Semver.sol\";\nimport { IKromaMintableERC721 } from \"./IKromaMintableERC721.sol\";\n\n/**\n * @title KromaMintableERC721\n * @notice This contract is the remote representation for some token that lives on another network,\n *         typically a Kroma representation of an Ethereum-based token. Standard reference\n *         implementation that can be extended or modified according to your needs.\n */\ncontract KromaMintableERC721 is ERC721Enumerable, IKromaMintableERC721, Semver {\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    uint256 public immutable REMOTE_CHAIN_ID;\n\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    address public immutable REMOTE_TOKEN;\n\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    address public immutable BRIDGE;\n\n    /**\n     * @notice Base token URI for this token.\n     */\n    string public baseTokenURI;\n\n    /**\n     * @notice Modifier that prevents callers other than the bridge from calling the function.\n     */\n    modifier onlyBridge() {\n        require(msg.sender == BRIDGE, \"KromaMintableERC721: only bridge can call this function\");\n        _;\n    }\n\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _bridge        Address of the bridge on this network.\n     * @param _remoteChainId Chain ID where the remote token is deployed.\n     * @param _remoteToken   Address of the corresponding token on the other network.\n     * @param _name          ERC721 name.\n     * @param _symbol        ERC721 symbol.\n     */\n    constructor(\n        address _bridge,\n        uint256 _remoteChainId,\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) Semver(0, 1, 0) {\n        require(_bridge != address(0), \"KromaMintableERC721: bridge cannot be address(0)\");\n        require(_remoteChainId != 0, \"KromaMintableERC721: remote chain id cannot be zero\");\n        require(\n            _remoteToken != address(0),\n            \"KromaMintableERC721: remote token cannot be address(0)\"\n        );\n\n        REMOTE_CHAIN_ID = _remoteChainId;\n        REMOTE_TOKEN = _remoteToken;\n        BRIDGE = _bridge;\n\n        // Creates a base URI in the format specified by EIP-681:\n        // https://eips.ethereum.org/EIPS/eip-681\n        baseTokenURI = string(\n            abi.encodePacked(\n                \"ethereum:\",\n                Strings.toHexString(uint160(_remoteToken), 20),\n                \"@\",\n                Strings.toString(_remoteChainId),\n                \"/tokenURI?uint256=\"\n            )\n        );\n    }\n\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    function remoteChainId() external view returns (uint256) {\n        return REMOTE_CHAIN_ID;\n    }\n\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    function remoteToken() external view returns (address) {\n        return REMOTE_TOKEN;\n    }\n\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    function bridge() external view returns (address) {\n        return BRIDGE;\n    }\n\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    function safeMint(address _to, uint256 _tokenId) external virtual onlyBridge {\n        _safeMint(_to, _tokenId);\n\n        emit Mint(_to, _tokenId);\n    }\n\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    function burn(address _from, uint256 _tokenId) external virtual onlyBridge {\n        _burn(_tokenId);\n\n        emit Burn(_from, _tokenId);\n    }\n\n    /**\n     * @notice Checks if a given interface ID is supported by this contract.\n     *\n     * @param _interfaceId The interface ID to check.\n     *\n     * @return True if the interface ID is supported, false otherwise.\n     */\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        override(ERC721Enumerable, IERC165)\n        returns (bool)\n    {\n        bytes4 iface1 = type(IERC165).interfaceId;\n        bytes4 iface2 = type(IKromaMintableERC721).interfaceId;\n        return\n            _interfaceId == iface1 ||\n            _interfaceId == iface2 ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /**\n     * @notice Returns the base token URI.\n     *\n     * @return Base token URI.\n     */\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseTokenURI;\n    }\n}\n"
    },
    "contracts/universal/KromaMintableERC721Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { KromaMintableERC721 } from \"./KromaMintableERC721.sol\";\nimport { Semver } from \"./Semver.sol\";\n\n/**\n * @title KromaMintableERC721Factory\n * @notice Factory contract for creating KromaMintableERC721 contracts.\n */\ncontract KromaMintableERC721Factory is Semver {\n    /**\n     * @notice Address of the ERC721 bridge on this network.\n     */\n    address public immutable BRIDGE;\n\n    /**\n     * @notice Chain ID for the remote network.\n     */\n    uint256 public immutable REMOTE_CHAIN_ID;\n\n    /**\n     * @notice Tracks addresses created by this factory.\n     */\n    mapping(address => bool) public isKromaMintableERC721;\n\n    /**\n     * @notice Emitted whenever a new KromaMintableERC721 contract is created.\n     *\n     * @param localToken  Address of the token on the this domain.\n     * @param remoteToken Address of the token on the remote domain.\n     * @param deployer    Address of the initiator of the deployment\n     */\n    event KromaMintableERC721Created(\n        address indexed localToken,\n        address indexed remoteToken,\n        address deployer\n    );\n\n    /**\n     * @custom:semver 0.1.0\n     * @notice The semver MUST be bumped any time that there is a change in\n     *         the KromaMintableERC721 token contract since this contract\n     *         is responsible for deploying KromaMintableERC721 contracts.\n     *\n     * @param _bridge Address of the ERC721 bridge on this network.\n     * @param _remoteChainId Chain ID for the remote network.\n     */\n    constructor(address _bridge, uint256 _remoteChainId) Semver(0, 1, 0) {\n        BRIDGE = _bridge;\n        REMOTE_CHAIN_ID = _remoteChainId;\n    }\n\n    /**\n     * @notice Creates an instance of the standard ERC721.\n     *\n     * @param _remoteToken Address of the corresponding token on the other domain.\n     * @param _name        ERC721 name.\n     * @param _symbol      ERC721 symbol.\n     */\n    function createKromaMintableERC721(\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) external returns (address) {\n        require(\n            _remoteToken != address(0),\n            \"KromaMintableERC721Factory: L1 token address cannot be address(0)\"\n        );\n\n        address localToken = address(\n            new KromaMintableERC721(BRIDGE, REMOTE_CHAIN_ID, _remoteToken, _name, _symbol)\n        );\n\n        isKromaMintableERC721[localToken] = true;\n        emit KromaMintableERC721Created(localToken, _remoteToken, msg.sender);\n\n        return localToken;\n    }\n}\n"
    },
    "contracts/universal/KromaSoulBoundERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721VotesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\";\n\n/**\n * @title IERC5192\n * @notice Interface for contracts that are compatible with the ERC721 standard.\n */\ninterface IERC5192 {\n    /**\n     * @notice Emitted when the locking status is changed to locked.\n     * @dev If a token is minted and the status is locked, this event should be emitted.\n     * @param tokenId The identifier for a token.\n     */\n    event Locked(uint256 tokenId);\n\n    /**\n     * @notice Emitted when the locking status is changed to unlocked.\n     * @dev If a token is minted and the status is unlocked, this event should be emitted.\n     * @param tokenId The identifier for a token.\n     */\n    event Unlocked(uint256 tokenId);\n\n    /**\n     * @notice Returns the locking status of an Soulbound Token\n     * @dev SBTs assigned to zero address are considered invalid, and queries about them do throw.\n     * @param tokenId The identifier for an SBT.\n     */\n    function locked(uint256 tokenId) external view returns (bool);\n}\n\nabstract contract KromaSoulBoundERC721 is\n    Initializable,\n    IERC5192,\n    ERC721Upgradeable,\n    ERC721EnumerableUpgradeable,\n    ERC721URIStorageUpgradeable,\n    PausableUpgradeable,\n    OwnableUpgradeable,\n    ERC721BurnableUpgradeable,\n    EIP712Upgradeable,\n    ERC721VotesUpgradeable\n{\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    CountersUpgradeable.Counter private _tokenIdCounter;\n    bool private isLocked;\n\n    error ErrLocked();\n    error ErrNotFound();\n\n    modifier checkLock() {\n        if (isLocked) revert ErrLocked();\n        _;\n    }\n\n    /**\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @param _name   ERC721 name.\n     * @param _symbol ERC721 symbol.\n     * @param _owner  Owner of token.\n     */\n    function __KromaSoulBoundERC721_init(\n        string memory _name,\n        string memory _symbol,\n        address _owner\n    ) internal onlyInitializing {\n        __KromaSoulBoundERC721_init_unchained(true);\n        __ERC721_init(_name, _symbol);\n        __ERC721Enumerable_init();\n        __ERC721URIStorage_init();\n        __Pausable_init();\n        __ERC721Burnable_init();\n        __EIP712_init(_name, \"1\");\n        __ERC721Votes_init();\n        _transferOwnership(_owner);\n    }\n\n    function __KromaSoulBoundERC721_init_unchained(bool _isLocked) internal onlyInitializing {\n        isLocked = _isLocked;\n    }\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    function safeMint(address to, string memory uri) public onlyOwner {\n        uint256 tokenId = _tokenIdCounter.current();\n        _tokenIdCounter.increment();\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, uri);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 batchSize\n    ) internal override(ERC721Upgradeable, ERC721EnumerableUpgradeable) whenNotPaused {\n        super._beforeTokenTransfer(from, to, tokenId, batchSize);\n    }\n\n    function locked(uint256 tokenId) external view returns (bool) {\n        if (!_exists(tokenId)) revert ErrNotFound();\n        return isLocked;\n    }\n\n    // The following functions are overridden cause required by Solidity.\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 batchSize\n    ) internal override(ERC721Upgradeable, ERC721VotesUpgradeable) {\n        super._afterTokenTransfer(from, to, tokenId, batchSize);\n    }\n\n    function _burn(uint256 tokenId)\n        internal\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n    {\n        super._burn(tokenId);\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public override(IERC721Upgradeable, ERC721Upgradeable) checkLock {\n        super.safeTransferFrom(from, to, tokenId, data);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override(IERC721Upgradeable, ERC721Upgradeable) checkLock {\n        super.safeTransferFrom(from, to, tokenId);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override(IERC721Upgradeable, ERC721Upgradeable) checkLock {\n        super.transferFrom(from, to, tokenId);\n    }\n\n    function approve(address approved, uint256 tokenId)\n        public\n        virtual\n        override(IERC721Upgradeable, ERC721Upgradeable)\n        checkLock\n    {\n        super.approve(approved, tokenId);\n    }\n\n    function setApprovalForAll(address operator, bool approved)\n        public\n        override(IERC721Upgradeable, ERC721Upgradeable)\n        checkLock\n    {\n        super.setApprovalForAll(operator, approved);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, ERC721EnumerableUpgradeable, ERC721URIStorageUpgradeable)\n        returns (bool)\n    {\n        return interfaceId == type(IERC5192).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/universal/MultiSigWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    ReentrancyGuardUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { IMultiSigWallet } from \"./IMultiSigWallet.sol\";\n\n/**\n * @custom:upgradeable\n * @title MultiSigWallet\n * @notice This contract implements `IMultiSigWallet`.\n *         Allows multiple parties to agree on transactions before execution.\n */\nabstract contract MultiSigWallet is IMultiSigWallet, ReentrancyGuardUpgradeable {\n    /**\n     * @notice A mapping of transactions submitted.\n     */\n    mapping(uint256 => Types.MultiSigTransaction) public transactions;\n\n    /**\n     * @notice A mapping of confirmations.\n     */\n    mapping(uint256 => mapping(address => bool)) public confirmations;\n\n    /**\n     * @notice A mapping that indicates whether someone is an owner or not.\n     */\n    mapping(address => bool) public isOwner;\n\n    /**\n     * @notice A list of owners.\n     */\n    address[] public owners;\n\n    /**\n     * @notice The number of confirmations required to execute a transaction.\n     */\n    uint256 public numConfirmationsRequired;\n\n    /**\n     * @notice The number of transactions submitted.\n     */\n    uint256 public transactionCount;\n\n    /**\n     * @notice Only allow this contract to call the functions.\n     *         This ensures that function is only executed through a multisig-based process.\n     */\n    modifier onlyWallet() {\n        require(\n            msg.sender == address(this),\n            \"MultiSigWallet: only allow this contract to call the functions\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Ensure that the caller is not owner.\n     *\n     * @param _addr Address resource requested.\n     */\n    modifier ownerDoesNotExist(address _addr) {\n        require(!isOwner[_addr], \"MultiSigWallet: owner exists\");\n        _;\n    }\n\n    /**\n     * @notice Ensure that the caller is owner.\n     *\n     * @param _addr Address resource requested.\n     */\n    modifier ownerExists(address _addr) {\n        require(isOwner[_addr], \"MultiSigWallet: owner does not exist\");\n        _;\n    }\n\n    /**\n     * @notice Ensure that the transaction exists.\n     *\n     * @param _transactionId Index of submitted transaction requested.\n     */\n    modifier transactionExists(uint256 _transactionId) {\n        require(\n            transactions[_transactionId].destination != address(0),\n            \"MultiSigWallet: transaction does not exist\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Ensure that the transaction with id and owner is confirmed.\n     *\n     * @param _transactionId Index of submitted transaction requested.\n     * @param _owner         Address resource requested.\n     */\n    modifier confirmed(uint256 _transactionId, address _owner) {\n        require(\n            confirmations[_transactionId][_owner],\n            \"MultiSigWallet: transaction with id and owner is not confirmed\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Ensure that the transaction with id and owner is not confirmed.\n     *\n     * @param _transactionId Index of submitted transaction requested.\n     * @param _owner         Address resource requested.\n     */\n    modifier notConfirmed(uint256 _transactionId, address _owner) {\n        require(\n            !confirmations[_transactionId][_owner],\n            \"MultiSigWallet: transaction with id and owner is confirmed\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Ensure that the transaction is not executed.\n     *\n     * @param _transactionId Index of submitted transaction requested.\n     */\n    modifier notExecuted(uint256 _transactionId) {\n        require(\n            !transactions[_transactionId].executed,\n            \"MultiSigWallet: transaction with id is already executed\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Ensure that the address is not zero address.\n     *\n     * @param _addr Address resource requested.\n     */\n    modifier validAddress(address _addr) {\n        require(_addr != address(0), \"MultiSigWallet: address is not valid\");\n        _;\n    }\n\n    /**\n     * @notice Ensure that the number of confirmations required is valid.\n     *\n     * @param _ownerCount               Number of owners.\n     * @param _numConfirmationsRequired Number of required confirmations.\n     */\n    modifier validNumConfirmations(uint256 _ownerCount, uint256 _numConfirmationsRequired) {\n        require(\n            _numConfirmationsRequired <= _ownerCount &&\n                _numConfirmationsRequired != 0 &&\n                _ownerCount != 0,\n            \"MultiSigWallet: number of required confirmation is not valid\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Initializer.\n     *\n     * @param _owners                   List of initial owners.\n     * @param _numConfirmationsRequired Number of required confirmations.\n     */\n    function initialize(address[] memory _owners, uint256 _numConfirmationsRequired)\n        public\n        onlyInitializing\n        validNumConfirmations(_owners.length, _numConfirmationsRequired)\n    {\n        __ReentrancyGuard_init_unchained();\n        for (uint256 i = 0; i < _owners.length; ) {\n            address owner = _owners[i];\n            require(!isOwner[owner], \"MultiSigWallet: owner already exists\");\n            require(owner != address(0), \"MultiSigWallet: invalid owner address\");\n            isOwner[owner] = true;\n\n            unchecked {\n                ++i;\n            }\n        }\n        owners = _owners;\n        numConfirmationsRequired = _numConfirmationsRequired;\n    }\n\n    /**\n     * @inheritdoc IMultiSigWallet\n     */\n    function addOwner(address _owner)\n        external\n        validAddress(_owner)\n        onlyWallet\n        ownerDoesNotExist(_owner)\n    {\n        isOwner[_owner] = true;\n        owners.push(_owner);\n        emit OwnerAddition(_owner);\n    }\n\n    /**\n     * @inheritdoc IMultiSigWallet\n     */\n    function removeOwner(address _owner) external onlyWallet ownerExists(_owner) {\n        isOwner[_owner] = false;\n        // find & delete item\n        for (uint256 i = 0; i < owners.length - 1; ) {\n            if (owners[i] == _owner) {\n                owners[i] = owners[owners.length - 1];\n                owners.pop();\n                break;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (numConfirmationsRequired > owners.length) {\n            _changeNumConfirmationRequirement(owners.length);\n        }\n        emit OwnerRemoval(_owner);\n    }\n\n    /**\n     * @inheritdoc IMultiSigWallet\n     */\n    function replaceOwner(address _owner, address _newOwner)\n        external\n        onlyWallet\n        validAddress(_newOwner)\n        ownerExists(_owner)\n        ownerDoesNotExist(_newOwner)\n    {\n        for (uint256 i = 0; i < owners.length; ) {\n            if (owners[i] == _owner) {\n                owners[i] = _newOwner;\n                break;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        isOwner[_owner] = false;\n        isOwner[_newOwner] = true;\n        emit OwnerRemoval(_owner);\n        emit OwnerAddition(_newOwner);\n    }\n\n    /**\n     * @notice Allows to change number of confirmations required.\n     *\n     * @param _numConfirmationsRequired Number of required confirmations.\n     */\n    function _changeNumConfirmationRequirement(uint256 _numConfirmationsRequired)\n        internal\n        validNumConfirmations(owners.length, _numConfirmationsRequired)\n    {\n        numConfirmationsRequired = _numConfirmationsRequired;\n    }\n\n    /**\n     * @inheritdoc IMultiSigWallet\n     */\n    function changeRequirement(uint256 _numConfirmationsRequired) external onlyWallet {\n        _changeNumConfirmationRequirement(_numConfirmationsRequired);\n        emit RequirementChange(_numConfirmationsRequired);\n    }\n\n    /**\n     * @inheritdoc IMultiSigWallet\n     */\n    function submitTransaction(\n        address _destination,\n        uint256 _value,\n        bytes memory _data\n    ) public virtual ownerExists(msg.sender) returns (uint256) {\n        uint256 transactionId = _addTransaction(_destination, _value, _data);\n        _confirmTransaction(transactionId);\n        return transactionId;\n    }\n\n    /**\n     * @inheritdoc IMultiSigWallet\n     */\n    function confirmTransaction(uint256 _transactionId) public virtual ownerExists(msg.sender) {\n        _confirmTransaction(_transactionId);\n    }\n\n    /**\n     * @notice Allows an owner to confirm a transaction.\n     *\n     * @param _transactionId Transaction ID.\n     */\n    function _confirmTransaction(uint256 _transactionId)\n        internal\n        transactionExists(_transactionId)\n        notConfirmed(_transactionId, msg.sender)\n    {\n        confirmations[_transactionId][msg.sender] = true;\n        emit Confirmation(msg.sender, _transactionId);\n        _executeTransaction(_transactionId);\n    }\n\n    /**\n     * @inheritdoc IMultiSigWallet\n     */\n    function revokeConfirmation(uint256 _transactionId)\n        external\n        virtual\n        ownerExists(msg.sender)\n        confirmed(_transactionId, msg.sender)\n        notExecuted(_transactionId)\n    {\n        confirmations[_transactionId][msg.sender] = false;\n        emit Revocation(msg.sender, _transactionId);\n    }\n\n    /**\n     * @notice Internal functions. Execute a confirmed transaction.\n     *\n     * @param _transactionId Transaction ID.\n     */\n    function _executeTransaction(uint256 _transactionId)\n        internal\n        notExecuted(_transactionId)\n        nonReentrant\n    {\n        if (_isConfirmed(_transactionId)) {\n            Types.MultiSigTransaction storage txn = transactions[_transactionId];\n            txn.executed = true;\n            bool success = SafeCall.call(txn.destination, gasleft(), txn.value, txn.data);\n            require(success, \"MultiSigWallet: call transaction failed\");\n            emit Execution(_transactionId);\n        }\n    }\n\n    /**\n     * @inheritdoc IMultiSigWallet\n     */\n    function executeTransaction(uint256 _transactionId) external ownerExists(msg.sender) {\n        _executeTransaction(_transactionId);\n    }\n\n    /**\n     * @notice Internal functions. Returns the confirmation status of a transaction.\n     *\n     * @param _transactionId Transaction ID.\n     *\n     * @return Confirmation status.\n     */\n    function _isConfirmed(uint256 _transactionId) internal view returns (bool) {\n        uint256 count = 0;\n        mapping(address => bool) storage confirmation = confirmations[_transactionId];\n        for (uint256 i = 0; i < owners.length; ) {\n            if (confirmation[owners[i]]) {\n                count += 1;\n            }\n            if (count == numConfirmationsRequired) {\n                return true;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @inheritdoc IMultiSigWallet\n     */\n    function isConfirmed(uint256 _transactionId) external view returns (bool) {\n        return _isConfirmed(_transactionId);\n    }\n\n    /**\n     * @notice Adds a new transaction to the transaction mapping, if transaction does not exist yet.\n     *\n     * @param _destination Transaction target address.\n     * @param _value       Transaction ether value.\n     * @param _data        Transaction data payload.\n     *\n     * @return transactionId Returns transaction ID.\n     */\n    function _addTransaction(\n        address _destination,\n        uint256 _value,\n        bytes memory _data\n    ) internal validAddress(_destination) returns (uint256 transactionId) {\n        transactionId = transactionCount;\n        transactions[transactionId] = Types.MultiSigTransaction({\n            destination: _destination,\n            value: _value,\n            data: _data,\n            executed: false\n        });\n        transactionCount += 1;\n        emit Submission(transactionId);\n    }\n\n    /**\n     * @inheritdoc IMultiSigWallet\n     */\n    function getConfirmationCount(uint256 _transactionId) external view returns (uint256) {\n        uint256 count = 0;\n        mapping(address => bool) storage confirmation = confirmations[_transactionId];\n        for (uint256 i = 0; i < owners.length; ) {\n            if (confirmation[owners[i]]) {\n                unchecked {\n                    ++count;\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * @inheritdoc IMultiSigWallet\n     */\n    function getTransactionCount(bool _pending, bool _executed) external view returns (uint256) {\n        bool executed;\n        uint256 count = 0;\n        for (uint256 i = 0; i < transactionCount; ) {\n            executed = transactions[i].executed;\n            if ((_pending && !executed) || (_executed && executed)) {\n                unchecked {\n                    ++count;\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * @inheritdoc IMultiSigWallet\n     */\n    function getOwners() external view returns (address[] memory) {\n        return owners;\n    }\n\n    /**\n     * @inheritdoc IMultiSigWallet\n     */\n    function getConfirmations(uint256 _transactionId) external view returns (address[] memory) {\n        address[] memory confirmationsTemp = new address[](owners.length);\n        uint256 count = 0;\n        uint256 i;\n        mapping(address => bool) storage confirmation = confirmations[_transactionId];\n        for (i = 0; i < owners.length; ) {\n            if (confirmation[owners[i]]) {\n                confirmationsTemp[count] = owners[i];\n                unchecked {\n                    ++count;\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n        address[] memory _confirmations = new address[](count);\n        for (i = 0; i < count; ) {\n            _confirmations[i] = confirmationsTemp[i];\n\n            unchecked {\n                ++i;\n            }\n        }\n        return _confirmations;\n    }\n\n    /**\n     * @inheritdoc IMultiSigWallet\n     */\n    function getTransactionIds(\n        uint256 _from,\n        uint256 _to,\n        bool _pending,\n        bool _executed\n    ) external view returns (uint256[] memory) {\n        bool executed;\n        uint256 count = 0;\n        uint256 i = 0;\n        uint256[] memory _transactionIdsTemp = new uint256[](_to - _from);\n        Types.MultiSigTransaction memory transaction;\n        for (i = _from; i < _to; ) {\n            transaction = transactions[i];\n            executed = transaction.executed;\n            if ((_pending && !executed) || (_executed && executed)) {\n                _transactionIdsTemp[count] = i;\n                unchecked {\n                    ++count;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        uint256[] memory _transactionIds = new uint256[](count);\n        for (i = 0; i < count; ) {\n            _transactionIds[i] = _transactionIdsTemp[i];\n\n            unchecked {\n                ++i;\n            }\n        }\n        return _transactionIds;\n    }\n}\n"
    },
    "contracts/universal/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title Proxy\n * @notice Proxy is a transparent proxy that passes through the call if the caller is the owner or\n *         if the caller is address(0), meaning that the call originated from an off-chain\n *         simulation.\n */\ncontract Proxy {\n    /**\n     * @notice The storage slot that holds the address of the implementation.\n     *         bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\n     */\n    bytes32 internal constant IMPLEMENTATION_KEY =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @notice The storage slot that holds the address of the owner.\n     *         bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\n     */\n    bytes32 internal constant OWNER_KEY =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @notice An event that is emitted each time the implementation is changed. This event is part\n     *         of the EIP-1967 specification.\n     *\n     * @param implementation The address of the implementation contract\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @notice An event that is emitted each time the owner is upgraded. This event is part of the\n     *         EIP-1967 specification.\n     *\n     * @param previousAdmin The previous owner of the contract\n     * @param newAdmin      The new owner of the contract\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @notice A modifier that reverts if not called by the owner or by address(0) to allow\n     *         eth_call to interact with this proxy without needing to use low-level storage\n     *         inspection. We assume that nobody is able to trigger calls from address(0) during\n     *         normal EVM execution.\n     */\n    modifier proxyCallIfNotAdmin() {\n        if (msg.sender == _getAdmin() || msg.sender == address(0)) {\n            _;\n        } else {\n            // This WILL halt the call frame on completion.\n            _doProxyCall();\n        }\n    }\n\n    /**\n     * @notice Sets the initial admin during contract deployment. Admin address is stored at the\n     *         EIP-1967 admin storage slot so that accidental storage collision with the\n     *         implementation is not possible.\n     *\n     * @param _admin Address of the initial contract admin. Admin as the ability to access the\n     *               transparent proxy interface.\n     */\n    constructor(address _admin) {\n        _changeAdmin(_admin);\n    }\n\n    // slither-disable-next-line locked-ether\n    receive() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    // slither-disable-next-line locked-ether\n    fallback() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    /**\n     * @notice Set the implementation contract address. The code at the given address will execute\n     *         when this contract is called.\n     *\n     * @param _implementation Address of the implementation contract.\n     */\n    function upgradeTo(address _implementation) public virtual proxyCallIfNotAdmin {\n        _setImplementation(_implementation);\n    }\n\n    /**\n     * @notice Set the implementation and call a function in a single transaction. Useful to ensure\n     *         atomic execution of initialization-based upgrades.\n     *\n     * @param _implementation Address of the implementation contract.\n     * @param _data           Calldata to delegatecall the new implementation with.\n     */\n    function upgradeToAndCall(\n        address _implementation,\n        bytes calldata _data\n    ) public payable virtual proxyCallIfNotAdmin returns (bytes memory) {\n        _setImplementation(_implementation);\n        (bool success, bytes memory returndata) = _implementation.delegatecall(_data);\n        require(success, \"Proxy: delegatecall to new implementation contract failed\");\n        return returndata;\n    }\n\n    /**\n     * @notice Changes the owner of the proxy contract. Only callable by the owner.\n     *\n     * @param _admin New owner of the proxy contract.\n     */\n    function changeAdmin(address _admin) public virtual proxyCallIfNotAdmin {\n        _changeAdmin(_admin);\n    }\n\n    /**\n     * @notice Gets the owner of the proxy contract.\n     *\n     * @return Owner address.\n     */\n    function admin() public virtual proxyCallIfNotAdmin returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @notice Queries the implementation address.\n     *\n     * @return Implementation address.\n     */\n    function implementation() public virtual proxyCallIfNotAdmin returns (address) {\n        return _getImplementation();\n    }\n\n    /**\n     * @notice Sets the implementation address.\n     *\n     * @param _implementation New implementation address.\n     */\n    function _setImplementation(address _implementation) internal {\n        assembly {\n            sstore(IMPLEMENTATION_KEY, _implementation)\n        }\n        emit Upgraded(_implementation);\n    }\n\n    /**\n     * @notice Changes the owner of the proxy contract.\n     *\n     * @param _admin New owner of the proxy contract.\n     */\n    function _changeAdmin(address _admin) internal {\n        address previous = _getAdmin();\n        assembly {\n            sstore(OWNER_KEY, _admin)\n        }\n        emit AdminChanged(previous, _admin);\n    }\n\n    /**\n     * @notice Performs the proxy call via a delegatecall.\n     */\n    function _doProxyCall() internal {\n        address impl = _getImplementation();\n        require(impl != address(0), \"Proxy: implementation not initialized\");\n\n        assembly {\n            // Copy calldata into memory at 0x0....calldatasize.\n            calldatacopy(0x0, 0x0, calldatasize())\n\n            // Perform the delegatecall, make sure to pass all available gas.\n            let success := delegatecall(gas(), impl, 0x0, calldatasize(), 0x0, 0x0)\n\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\n            // overwrite the calldata that we just copied into memory but that doesn't really\n            // matter because we'll be returning in a second anyway.\n            returndatacopy(0x0, 0x0, returndatasize())\n\n            // Success == 0 means a revert. We'll revert too and pass the data up.\n            if iszero(success) {\n                revert(0x0, returndatasize())\n            }\n\n            // Otherwise we'll just return and pass the data up.\n            return(0x0, returndatasize())\n        }\n    }\n\n    /**\n     * @notice Queries the implementation address.\n     *\n     * @return Implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        address impl;\n        assembly {\n            impl := sload(IMPLEMENTATION_KEY)\n        }\n        return impl;\n    }\n\n    /**\n     * @notice Queries the owner of the proxy contract.\n     *\n     * @return Owner address.\n     */\n    function _getAdmin() internal view returns (address) {\n        address owner;\n        assembly {\n            owner := sload(OWNER_KEY)\n        }\n        return owner;\n    }\n}\n"
    },
    "contracts/universal/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { Proxy } from \"./Proxy.sol\";\n\n/**\n * @title IStaticERC1967Proxy\n * @notice IStaticERC1967Proxy is a static version of the ERC1967 proxy interface.\n */\ninterface IStaticERC1967Proxy {\n    function implementation() external view returns (address);\n\n    function admin() external view returns (address);\n}\n\n/**\n * @title ProxyAdmin\n * @notice This is an auxiliary contract meant to be assigned as the admin of an ERC1967 Proxy,\n *         based on the OpenZeppelin implementation.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @param _owner Address of the initial owner of this contract.\n     */\n    constructor(address _owner) Ownable() {\n        _transferOwnership(_owner);\n    }\n\n    /**\n     * @notice Returns the implementation of the given proxy address.\n     *\n     * @param _proxy Address of the proxy to get the implementation of.\n     *\n     * @return Address of the implementation of the proxy.\n     */\n    function getProxyImplementation(address _proxy) external view returns (address) {\n        return IStaticERC1967Proxy(_proxy).implementation();\n    }\n\n    /**\n     * @notice Returns the admin of the given proxy address.\n     *\n     * @param _proxy Address of the proxy to get the admin of.\n     *\n     * @return Address of the admin of the proxy.\n     */\n    function getProxyAdmin(address payable _proxy) external view returns (address) {\n        return IStaticERC1967Proxy(_proxy).admin();\n    }\n\n    /**\n     * @notice Updates the admin of the given proxy address.\n     *\n     * @param _proxy    Address of the proxy to update.\n     * @param _newAdmin Address of the new proxy admin.\n     */\n    function changeProxyAdmin(address payable _proxy, address _newAdmin) external onlyOwner {\n        Proxy(_proxy).changeAdmin(_newAdmin);\n    }\n\n    /**\n     * @notice Changes a proxy's implementation contract.\n     *\n     * @param _proxy          Address of the proxy to upgrade.\n     * @param _implementation Address of the new implementation address.\n     */\n    function upgrade(address payable _proxy, address _implementation) public onlyOwner {\n        Proxy(_proxy).upgradeTo(_implementation);\n    }\n\n    /**\n     * @notice Changes a proxy's implementation contract and delegatecalls the new implementation\n     *         with some given data. Useful for atomic upgrade-and-initialize calls.\n     *\n     * @param _proxy          Address of the proxy to upgrade.\n     * @param _implementation Address of the new implementation address.\n     * @param _data           Data to trigger the new implementation with.\n     */\n    function upgradeAndCall(\n        address payable _proxy,\n        address _implementation,\n        bytes memory _data\n    ) external payable onlyOwner {\n        Proxy(_proxy).upgradeToAndCall{ value: msg.value }(_implementation, _data);\n    }\n}\n"
    },
    "contracts/universal/Semver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\n/**\n * @title Semver\n * @notice Semver is a simple contract for managing contract versions.\n */\ncontract Semver {\n    /**\n     * @notice Contract version number (major).\n     */\n    uint256 private immutable MAJOR_VERSION;\n\n    /**\n     * @notice Contract version number (minor).\n     */\n    uint256 private immutable MINOR_VERSION;\n\n    /**\n     * @notice Contract version number (patch).\n     */\n    uint256 private immutable PATCH_VERSION;\n\n    /**\n     * @param _major Version number (major).\n     * @param _minor Version number (minor).\n     * @param _patch Version number (patch).\n     */\n    constructor(\n        uint256 _major,\n        uint256 _minor,\n        uint256 _patch\n    ) {\n        MAJOR_VERSION = _major;\n        MINOR_VERSION = _minor;\n        PATCH_VERSION = _patch;\n    }\n\n    /**\n     * @notice Returns the full semver contract version.\n     *\n     * @return Semver contract version as a string.\n     */\n    function version() public view virtual returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    Strings.toString(MAJOR_VERSION),\n                    \".\",\n                    Strings.toString(MINOR_VERSION),\n                    \".\",\n                    Strings.toString(PATCH_VERSION)\n                )\n            );\n    }\n}\n"
    },
    "contracts/universal/StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { CrossDomainMessenger } from \"./CrossDomainMessenger.sol\";\nimport { IKromaMintableERC20 } from \"./IKromaMintableERC20.sol\";\nimport { KromaMintableERC20 } from \"./KromaMintableERC20.sol\";\n\n/**\n * @custom:upgradeable\n * @title StandardBridge\n * @notice StandardBridge is a base contract for the L1 and L2 standard ERC20 bridges. It handles\n *         the core bridging logic, including escrowing tokens that are native to the local chain\n *         and minting/burning tokens that are native to the remote chain.\n */\nabstract contract StandardBridge {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice The L2 gas limit set when eth is depoisited using the receive() function.\n     */\n    uint32 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 200_000;\n\n    /**\n     * @notice Messenger contract on this domain.\n     */\n    CrossDomainMessenger public immutable MESSENGER;\n\n    /**\n     * @notice Corresponding bridge on the other domain.\n     */\n    StandardBridge public immutable OTHER_BRIDGE;\n\n    /**\n     * @notice Mapping that stores deposits for a given pair of local and remote tokens.\n     */\n    mapping(address => mapping(address => uint256)) public deposits;\n\n    /**\n     * @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\n     *         A gap size of 49 was chosen here, so that the first slot used in a child contract\n     *         would be a multiple of 50.\n     */\n    uint256[49] private __gap;\n\n    /**\n     * @notice Emitted when an ETH bridge is initiated to the other chain.\n     *\n     * @param from      Address of the sender.\n     * @param to        Address of the receiver.\n     * @param amount    Amount of ETH sent.\n     * @param extraData Extra data sent with the transaction.\n     */\n    event ETHBridgeInitiated(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @notice Emitted when an ETH bridge is finalized on this chain.\n     *\n     * @param from      Address of the sender.\n     * @param to        Address of the receiver.\n     * @param amount    Amount of ETH sent.\n     * @param extraData Extra data sent with the transaction.\n     */\n    event ETHBridgeFinalized(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @notice Emitted when an ERC20 bridge is initiated to the other chain.\n     *\n     * @param localToken  Address of the ERC20 on this chain.\n     * @param remoteToken Address of the ERC20 on the remote chain.\n     * @param from        Address of the sender.\n     * @param to          Address of the receiver.\n     * @param amount      Amount of the ERC20 sent.\n     * @param extraData   Extra data sent with the transaction.\n     */\n    event ERC20BridgeInitiated(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @notice Emitted when an ERC20 bridge is finalized on this chain.\n     *\n     * @param localToken  Address of the ERC20 on this chain.\n     * @param remoteToken Address of the ERC20 on the remote chain.\n     * @param from        Address of the sender.\n     * @param to          Address of the receiver.\n     * @param amount      Amount of the ERC20 sent.\n     * @param extraData   Extra data sent with the transaction.\n     */\n    event ERC20BridgeFinalized(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @notice Only allow EOAs to call the functions. Note that this is not safe against contracts\n     *         calling code within their constructors, but also doesn't really matter since we're\n     *         just trying to prevent users accidentally depositing with smart contract wallets.\n     */\n    modifier onlyEOA() {\n        require(\n            !Address.isContract(msg.sender),\n            \"StandardBridge: function can only be called from an EOA\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Ensures that the caller is a cross-chain message from the other bridge.\n     */\n    modifier onlyOtherBridge() {\n        require(\n            msg.sender == address(MESSENGER) &&\n                MESSENGER.xDomainMessageSender() == address(OTHER_BRIDGE),\n            \"StandardBridge: function can only be called from the other bridge\"\n        );\n        _;\n    }\n\n    /**\n     * @param _messenger   Address of CrossDomainMessenger on this network.\n     * @param _otherBridge Address of the other StandardBridge contract.\n     */\n    constructor(address payable _messenger, address payable _otherBridge) {\n        MESSENGER = CrossDomainMessenger(_messenger);\n        OTHER_BRIDGE = StandardBridge(_otherBridge);\n    }\n\n    /**\n     * @notice Allows EOAs to bridge ETH by sending directly to the bridge.\n     *         Must be implemented by contracts that inherit.\n     */\n    receive() external payable virtual;\n\n    /**\n     * @notice Sends ETH to the sender's address on the other chain.\n     *\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function bridgeETH(uint32 _minGasLimit, bytes calldata _extraData) public payable onlyEOA {\n        _initiateBridgeETH(msg.sender, msg.sender, msg.value, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @notice Sends ETH to a receiver's address on the other chain. Note that if ETH is sent to a\n     *         smart contract and the call fails, the ETH will be temporarily locked in the\n     *         StandardBridge on the other chain until the call is replayed. If the call cannot be\n     *         replayed with any amount of gas (call always reverts), then the ETH will be\n     *         permanently locked in the StandardBridge on the other chain. ETH will also\n     *         be locked if the receiver is the other bridge, because finalizeBridgeETH will revert\n     *         in that case.\n     *\n     * @param _to          Address of the receiver.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function bridgeETHTo(\n        address _to,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) public payable {\n        _initiateBridgeETH(msg.sender, _to, msg.value, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @notice Sends ERC20 tokens to the sender's address on the other chain. Note that if the\n     *         ERC20 token on the other chain does not recognize the local token as the correct\n     *         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\n     *         this chain.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _amount      Amount of local tokens to deposit.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function bridgeERC20(\n        address _localToken,\n        address _remoteToken,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) public onlyEOA {\n        _initiateBridgeERC20(\n            _localToken,\n            _remoteToken,\n            msg.sender,\n            msg.sender,\n            _amount,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @notice Sends ERC20 tokens to a receiver's address on the other chain. Note that if the\n     *         ERC20 token on the other chain does not recognize the local token as the correct\n     *         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\n     *         this chain.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of local tokens to deposit.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function bridgeERC20To(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) public {\n        _initiateBridgeERC20(\n            _localToken,\n            _remoteToken,\n            msg.sender,\n            _to,\n            _amount,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @notice Finalizes an ETH bridge on this chain. Can only be triggered by the other\n     *         StandardBridge contract on the remote chain.\n     *\n     * @param _from      Address of the sender.\n     * @param _to        Address of the receiver.\n     * @param _amount    Amount of ETH being bridged.\n     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will\n     *                   not be triggered with this data, but it will be emitted and can be used\n     *                   to identify the transaction.\n     */\n    function finalizeBridgeETH(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _extraData\n    ) public payable onlyOtherBridge {\n        require(msg.value == _amount, \"StandardBridge: amount sent does not match amount required\");\n        require(_to != address(this), \"StandardBridge: cannot send to self\");\n        require(_to != address(MESSENGER), \"StandardBridge: cannot send to messenger\");\n\n        emit ETHBridgeFinalized(_from, _to, _amount, _extraData);\n\n        bool success = SafeCall.call(_to, gasleft(), _amount, hex\"\");\n        require(success, \"StandardBridge: ETH transfer failed\");\n    }\n\n    /**\n     * @notice Finalizes an ERC20 bridge on this chain. Can only be triggered by the other\n     *         StandardBridge contract on the remote chain.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _from        Address of the sender.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of the ERC20 being bridged.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function finalizeBridgeERC20(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _extraData\n    ) public onlyOtherBridge {\n        if (_isKromaMintableERC20(_localToken)) {\n            require(\n                _isCorrectTokenPair(_localToken, _remoteToken),\n                \"StandardBridge: wrong remote token for Kroma Mintable ERC20 local token\"\n            );\n\n            KromaMintableERC20(_localToken).mint(_to, _amount);\n        } else {\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] - _amount;\n            IERC20(_localToken).safeTransfer(_to, _amount);\n        }\n\n        emit ERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n    }\n\n    /**\n     * @notice Initiates a bridge of ETH through the CrossDomainMessenger.\n     *\n     * @param _from        Address of the sender.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of ETH being bridged.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function _initiateBridgeETH(\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes memory _extraData\n    ) internal {\n        require(\n            msg.value == _amount,\n            \"StandardBridge: bridging ETH must include sufficient ETH value\"\n        );\n\n        emit ETHBridgeInitiated(_from, _to, _amount, _extraData);\n\n        MESSENGER.sendMessage{ value: _amount }(\n            address(OTHER_BRIDGE),\n            abi.encodeWithSelector(\n                this.finalizeBridgeETH.selector,\n                _from,\n                _to,\n                _amount,\n                _extraData\n            ),\n            _minGasLimit\n        );\n    }\n\n    /**\n     * @notice Sends ERC20 tokens to a receiver's address on the other chain.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of local tokens to deposit.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function _initiateBridgeERC20(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes memory _extraData\n    ) internal {\n        if (_isKromaMintableERC20(_localToken)) {\n            require(\n                _isCorrectTokenPair(_localToken, _remoteToken),\n                \"StandardBridge: wrong remote token for Kroma Mintable ERC20 local token\"\n            );\n\n            KromaMintableERC20(_localToken).burn(_from, _amount);\n        } else {\n            IERC20(_localToken).safeTransferFrom(_from, address(this), _amount);\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] + _amount;\n        }\n\n        emit ERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n\n        MESSENGER.sendMessage(\n            address(OTHER_BRIDGE),\n            abi.encodeWithSelector(\n                this.finalizeBridgeERC20.selector,\n                // Because this call will be executed on the remote chain, we reverse the order of\n                // the remote and local token addresses relative to their order in the\n                // finalizeBridgeERC20 function.\n                _remoteToken,\n                _localToken,\n                _from,\n                _to,\n                _amount,\n                _extraData\n            ),\n            _minGasLimit\n        );\n    }\n\n    /**\n     * @notice Checks if a given address is a KromaMintableERC20. Not perfect, but good enough.\n     *         Just the way we like it.\n     *\n     * @param _token Address of the token to check.\n     *\n     * @return True if the token is a KromaMintableERC20.\n     */\n    function _isKromaMintableERC20(address _token) internal view returns (bool) {\n        return ERC165Checker.supportsInterface(_token, type(IKromaMintableERC20).interfaceId);\n    }\n\n    /**\n     * @notice Checks if the \"other token\" is the correct pair token for the KromaMintableERC20.\n     *\n     * @param _mintableToken KromaMintableERC20 to check against.\n     * @param _otherToken    Pair token to check.\n     *\n     * @return True if the other token is the correct pair token for the KromaMintableERC20.\n     */\n    function _isCorrectTokenPair(address _mintableToken, address _otherToken)\n        internal\n        view\n        returns (bool)\n    {\n        return _otherToken == KromaMintableERC20(_mintableToken).REMOTE_TOKEN();\n    }\n}\n"
    },
    "contracts/vendor/AddressAliasHelper.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nlibrary AddressAliasHelper {\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + offset);\n        }\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        unchecked {\n            l1Address = address(uint160(l2Address) - offset);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n\n        if (batchSize > 1) {\n            // Will only trigger during construction. Batch transferring (minting) is not available afterwards.\n            revert(\"ERC721Enumerable: consecutive transfers not supported\");\n        }\n\n        uint256 tokenId = firstTokenId;\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.1) (governance/Governor.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"../token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\nimport \"../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../utils/cryptography/EIP712Upgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../utils/math/SafeCastUpgradeable.sol\";\nimport \"../utils/structs/DoubleEndedQueueUpgradeable.sol\";\nimport \"../utils/AddressUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"./IGovernorUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Core of the governance system, designed to be extended though various modules.\n *\n * This contract is abstract and requires several functions to be implemented in various modules:\n *\n * - A counting module must implement {quorum}, {_quorumReached}, {_voteSucceeded} and {_countVote}\n * - A voting module must implement {_getVotes}\n * - Additionally, {votingPeriod} must also be implemented\n *\n * _Available since v4.3._\n */\nabstract contract GovernorUpgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, EIP712Upgradeable, IGovernorUpgradeable, IERC721ReceiverUpgradeable, IERC1155ReceiverUpgradeable {\n    using DoubleEndedQueueUpgradeable for DoubleEndedQueueUpgradeable.Bytes32Deque;\n\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\n    bytes32 public constant EXTENDED_BALLOT_TYPEHASH =\n        keccak256(\"ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params)\");\n\n    // solhint-disable var-name-mixedcase\n    struct ProposalCore {\n        // --- start retyped from Timers.BlockNumber at offset 0x00 ---\n        uint64 voteStart;\n        address proposer;\n        bytes4 __gap_unused0;\n        // --- start retyped from Timers.BlockNumber at offset 0x20 ---\n        uint64 voteEnd;\n        bytes24 __gap_unused1;\n        // --- Remaining fields starting at offset 0x40 ---------------\n        bool executed;\n        bool canceled;\n    }\n    // solhint-enable var-name-mixedcase\n\n    string private _name;\n\n    /// @custom:oz-retyped-from mapping(uint256 => Governor.ProposalCore)\n    mapping(uint256 => ProposalCore) private _proposals;\n\n    // This queue keeps track of the governor operating on itself. Calls to functions protected by the\n    // {onlyGovernance} modifier needs to be whitelisted in this queue. Whitelisting is set in {_beforeExecute},\n    // consumed by the {onlyGovernance} modifier and eventually reset in {_afterExecute}. This ensures that the\n    // execution of {onlyGovernance} protected calls can only be achieved through successful proposals.\n    DoubleEndedQueueUpgradeable.Bytes32Deque private _governanceCall;\n\n    /**\n     * @dev Restricts a function so it can only be executed through governance proposals. For example, governance\n     * parameter setters in {GovernorSettings} are protected using this modifier.\n     *\n     * The governance executing address may be different from the Governor's own address, for example it could be a\n     * timelock. This can be customized by modules by overriding {_executor}. The executor is only able to invoke these\n     * functions during the execution of the governor's {execute} function, and not under any other circumstances. Thus,\n     * for example, additional timelock proposers are not able to change governance parameters without going through the\n     * governance protocol (since v4.6).\n     */\n    modifier onlyGovernance() {\n        require(_msgSender() == _executor(), \"Governor: onlyGovernance\");\n        if (_executor() != address(this)) {\n            bytes32 msgDataHash = keccak256(_msgData());\n            // loop until popping the expected operation - throw if deque is empty (operation not authorized)\n            while (_governanceCall.popFront() != msgDataHash) {}\n        }\n        _;\n    }\n\n    /**\n     * @dev Sets the value for {name} and {version}\n     */\n    function __Governor_init(string memory name_) internal onlyInitializing {\n        __EIP712_init_unchained(name_, version());\n        __Governor_init_unchained(name_);\n    }\n\n    function __Governor_init_unchained(string memory name_) internal onlyInitializing {\n        _name = name_;\n    }\n\n    /**\n     * @dev Function to receive ETH that will be handled by the governor (disabled if executor is a third party contract)\n     */\n    receive() external payable virtual {\n        require(_executor() == address(this), \"Governor: must send to executor\");\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC165Upgradeable) returns (bool) {\n        bytes4 governorCancelId = this.cancel.selector ^ this.proposalProposer.selector;\n\n        bytes4 governorParamsId = this.castVoteWithReasonAndParams.selector ^\n            this.castVoteWithReasonAndParamsBySig.selector ^\n            this.getVotesWithParams.selector;\n\n        // The original interface id in v4.3.\n        bytes4 governor43Id = type(IGovernorUpgradeable).interfaceId ^\n            type(IERC6372Upgradeable).interfaceId ^\n            governorCancelId ^\n            governorParamsId;\n\n        // An updated interface id in v4.6, with params added.\n        bytes4 governor46Id = type(IGovernorUpgradeable).interfaceId ^ type(IERC6372Upgradeable).interfaceId ^ governorCancelId;\n\n        // For the updated interface id in v4.9, we use governorCancelId directly.\n\n        return\n            interfaceId == governor43Id ||\n            interfaceId == governor46Id ||\n            interfaceId == governorCancelId ||\n            interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IGovernor-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IGovernor-version}.\n     */\n    function version() public view virtual override returns (string memory) {\n        return \"1\";\n    }\n\n    /**\n     * @dev See {IGovernor-hashProposal}.\n     *\n     * The proposal id is produced by hashing the ABI encoded `targets` array, the `values` array, the `calldatas` array\n     * and the descriptionHash (bytes32 which itself is the keccak256 hash of the description string). This proposal id\n     * can be produced from the proposal data which is part of the {ProposalCreated} event. It can even be computed in\n     * advance, before the proposal is submitted.\n     *\n     * Note that the chainId and the governor address are not part of the proposal id computation. Consequently, the\n     * same proposal (with same operation and same description) will have the same id if submitted on multiple governors\n     * across multiple networks. This also means that in order to execute the same operation twice (on the same\n     * governor) the proposer will have to change the description in order to avoid proposal id conflicts.\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual override returns (uint256) {\n        return uint256(keccak256(abi.encode(targets, values, calldatas, descriptionHash)));\n    }\n\n    /**\n     * @dev See {IGovernor-state}.\n     */\n    function state(uint256 proposalId) public view virtual override returns (ProposalState) {\n        ProposalCore storage proposal = _proposals[proposalId];\n\n        if (proposal.executed) {\n            return ProposalState.Executed;\n        }\n\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        }\n\n        uint256 snapshot = proposalSnapshot(proposalId);\n\n        if (snapshot == 0) {\n            revert(\"Governor: unknown proposal id\");\n        }\n\n        uint256 currentTimepoint = clock();\n\n        if (snapshot >= currentTimepoint) {\n            return ProposalState.Pending;\n        }\n\n        uint256 deadline = proposalDeadline(proposalId);\n\n        if (deadline >= currentTimepoint) {\n            return ProposalState.Active;\n        }\n\n        if (_quorumReached(proposalId) && _voteSucceeded(proposalId)) {\n            return ProposalState.Succeeded;\n        } else {\n            return ProposalState.Defeated;\n        }\n    }\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.\n     */\n    function proposalThreshold() public view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev See {IGovernor-proposalSnapshot}.\n     */\n    function proposalSnapshot(uint256 proposalId) public view virtual override returns (uint256) {\n        return _proposals[proposalId].voteStart;\n    }\n\n    /**\n     * @dev See {IGovernor-proposalDeadline}.\n     */\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return _proposals[proposalId].voteEnd;\n    }\n\n    /**\n     * @dev Returns the account that created a given proposal.\n     */\n    function proposalProposer(uint256 proposalId) public view virtual override returns (address) {\n        return _proposals[proposalId].proposer;\n    }\n\n    /**\n     * @dev Amount of votes already cast passes the threshold limit.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Is the proposal successful or not.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Get the voting weight of `account` at a specific `timepoint`, for a vote as described by `params`.\n     */\n    function _getVotes(address account, uint256 timepoint, bytes memory params) internal view virtual returns (uint256);\n\n    /**\n     * @dev Register a vote for `proposalId` by `account` with a given `support`, voting `weight` and voting `params`.\n     *\n     * Note: Support is generic and can represent various things depending on the voting system used.\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory params\n    ) internal virtual;\n\n    /**\n     * @dev Default additional encoded parameters used by castVote methods that don't include them\n     *\n     * Note: Should be overridden by specific implementations to use an appropriate value, the\n     * meaning of the additional params, in the context of that implementation\n     */\n    function _defaultParams() internal view virtual returns (bytes memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IGovernor-propose}. This function has opt-in frontrunning protection, described in {_isValidDescriptionForProposer}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override returns (uint256) {\n        address proposer = _msgSender();\n        require(_isValidDescriptionForProposer(proposer, description), \"Governor: proposer restricted\");\n\n        uint256 currentTimepoint = clock();\n        require(\n            getVotes(proposer, currentTimepoint - 1) >= proposalThreshold(),\n            \"Governor: proposer votes below proposal threshold\"\n        );\n\n        uint256 proposalId = hashProposal(targets, values, calldatas, keccak256(bytes(description)));\n\n        require(targets.length == values.length, \"Governor: invalid proposal length\");\n        require(targets.length == calldatas.length, \"Governor: invalid proposal length\");\n        require(targets.length > 0, \"Governor: empty proposal\");\n        require(_proposals[proposalId].voteStart == 0, \"Governor: proposal already exists\");\n\n        uint256 snapshot = currentTimepoint + votingDelay();\n        uint256 deadline = snapshot + votingPeriod();\n\n        _proposals[proposalId] = ProposalCore({\n            proposer: proposer,\n            voteStart: SafeCastUpgradeable.toUint64(snapshot),\n            voteEnd: SafeCastUpgradeable.toUint64(deadline),\n            executed: false,\n            canceled: false,\n            __gap_unused0: 0,\n            __gap_unused1: 0\n        });\n\n        emit ProposalCreated(\n            proposalId,\n            proposer,\n            targets,\n            values,\n            new string[](targets.length),\n            calldatas,\n            snapshot,\n            deadline,\n            description\n        );\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-execute}.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        ProposalState currentState = state(proposalId);\n        require(\n            currentState == ProposalState.Succeeded || currentState == ProposalState.Queued,\n            \"Governor: proposal not successful\"\n        );\n        _proposals[proposalId].executed = true;\n\n        emit ProposalExecuted(proposalId);\n\n        _beforeExecute(proposalId, targets, values, calldatas, descriptionHash);\n        _execute(proposalId, targets, values, calldatas, descriptionHash);\n        _afterExecute(proposalId, targets, values, calldatas, descriptionHash);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-cancel}.\n     */\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n        require(state(proposalId) == ProposalState.Pending, \"Governor: too late to cancel\");\n        require(_msgSender() == _proposals[proposalId].proposer, \"Governor: only proposer can cancel\");\n        return _cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    /**\n     * @dev Internal execution mechanism. Can be overridden to implement different execution mechanism\n     */\n    function _execute(\n        uint256 /* proposalId */,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        string memory errorMessage = \"Governor: call reverted without message\";\n        for (uint256 i = 0; i < targets.length; ++i) {\n            (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]);\n            AddressUpgradeable.verifyCallResult(success, returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Hook before execution is triggered.\n     */\n    function _beforeExecute(\n        uint256 /* proposalId */,\n        address[] memory targets,\n        uint256[] memory /* values */,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        if (_executor() != address(this)) {\n            for (uint256 i = 0; i < targets.length; ++i) {\n                if (targets[i] == address(this)) {\n                    _governanceCall.pushBack(keccak256(calldatas[i]));\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Hook after execution is triggered.\n     */\n    function _afterExecute(\n        uint256 /* proposalId */,\n        address[] memory /* targets */,\n        uint256[] memory /* values */,\n        bytes[] memory /* calldatas */,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        if (_executor() != address(this)) {\n            if (!_governanceCall.empty()) {\n                _governanceCall.clear();\n            }\n        }\n    }\n\n    /**\n     * @dev Internal cancel mechanism: locks up the proposal timer, preventing it from being re-submitted. Marks it as\n     * canceled to allow distinguishing it from executed proposals.\n     *\n     * Emits a {IGovernor-ProposalCanceled} event.\n     */\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        ProposalState currentState = state(proposalId);\n\n        require(\n            currentState != ProposalState.Canceled &&\n                currentState != ProposalState.Expired &&\n                currentState != ProposalState.Executed,\n            \"Governor: proposal not active\"\n        );\n        _proposals[proposalId].canceled = true;\n\n        emit ProposalCanceled(proposalId);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-getVotes}.\n     */\n    function getVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {\n        return _getVotes(account, timepoint, _defaultParams());\n    }\n\n    /**\n     * @dev See {IGovernor-getVotesWithParams}.\n     */\n    function getVotesWithParams(\n        address account,\n        uint256 timepoint,\n        bytes memory params\n    ) public view virtual override returns (uint256) {\n        return _getVotes(account, timepoint, params);\n    }\n\n    /**\n     * @dev See {IGovernor-castVote}.\n     */\n    function castVote(uint256 proposalId, uint8 support) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReason}.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason);\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReasonAndParams}.\n     */\n    function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params\n    ) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason, params);\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteBySig}.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override returns (uint256) {\n        address voter = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\n            v,\n            r,\n            s\n        );\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReasonAndParamsBySig}.\n     */\n    function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override returns (uint256) {\n        address voter = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(\n                keccak256(\n                    abi.encode(\n                        EXTENDED_BALLOT_TYPEHASH,\n                        proposalId,\n                        support,\n                        keccak256(bytes(reason)),\n                        keccak256(params)\n                    )\n                )\n            ),\n            v,\n            r,\n            s\n        );\n\n        return _castVote(proposalId, voter, support, reason, params);\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function. Uses the _defaultParams().\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason\n    ) internal virtual returns (uint256) {\n        return _castVote(proposalId, account, support, reason, _defaultParams());\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function.\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual returns (uint256) {\n        ProposalCore storage proposal = _proposals[proposalId];\n        require(state(proposalId) == ProposalState.Active, \"Governor: vote not currently active\");\n\n        uint256 weight = _getVotes(account, proposal.voteStart, params);\n        _countVote(proposalId, account, support, weight, params);\n\n        if (params.length == 0) {\n            emit VoteCast(account, proposalId, support, weight, reason);\n        } else {\n            emit VoteCastWithParams(account, proposalId, support, weight, reason, params);\n        }\n\n        return weight;\n    }\n\n    /**\n     * @dev Relays a transaction or function call to an arbitrary target. In cases where the governance executor\n     * is some contract other than the governor itself, like when using a timelock, this function can be invoked\n     * in a governance proposal to recover tokens or Ether that was sent to the governor contract by mistake.\n     * Note that if the executor is simply the governor itself, use of `relay` is redundant.\n     */\n    function relay(address target, uint256 value, bytes calldata data) external payable virtual onlyGovernance {\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        AddressUpgradeable.verifyCallResult(success, returndata, \"Governor: relay reverted without message\");\n    }\n\n    /**\n     * @dev Address through which the governor executes action. Will be overloaded by module that execute actions\n     * through another contract such as a timelock.\n     */\n    function _executor() internal view virtual returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155Received}.\n     */\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @dev Check if the proposer is authorized to submit a proposal with the given description.\n     *\n     * If the proposal description ends with `#proposer=0x???`, where `0x???` is an address written as a hex string\n     * (case insensitive), then the submission of this proposal will only be authorized to said address.\n     *\n     * This is used for frontrunning protection. By adding this pattern at the end of their proposal, one can ensure\n     * that no other address can submit the same proposal. An attacker would have to either remove or change that part,\n     * which would result in a different proposal id.\n     *\n     * If the description does not match this pattern, it is unrestricted and anyone can submit it. This includes:\n     * - If the `0x???` part is not a valid hex string.\n     * - If the `0x???` part is a valid hex string, but does not contain exactly 40 hex digits.\n     * - If it ends with the expected suffix followed by newlines or other whitespace.\n     * - If it ends with some other similar suffix, e.g. `#other=abc`.\n     * - If it does not end with any such suffix.\n     */\n    function _isValidDescriptionForProposer(\n        address proposer,\n        string memory description\n    ) internal view virtual returns (bool) {\n        uint256 len = bytes(description).length;\n\n        // Length is too short to contain a valid proposer suffix\n        if (len < 52) {\n            return true;\n        }\n\n        // Extract what would be the `#proposer=0x` marker beginning the suffix\n        bytes12 marker;\n        assembly {\n            // - Start of the string contents in memory = description + 32\n            // - First character of the marker = len - 52\n            //   - Length of \"#proposer=0x0000000000000000000000000000000000000000\" = 52\n            // - We read the memory word starting at the first character of the marker:\n            //   - (description + 32) + (len - 52) = description + (len - 20)\n            // - Note: Solidity will ignore anything past the first 12 bytes\n            marker := mload(add(description, sub(len, 20)))\n        }\n\n        // If the marker is not found, there is no proposer suffix to check\n        if (marker != bytes12(\"#proposer=0x\")) {\n            return true;\n        }\n\n        // Parse the 40 characters following the marker as uint160\n        uint160 recovered = 0;\n        for (uint256 i = len - 40; i < len; ++i) {\n            (bool isHex, uint8 value) = _tryHexToUint(bytes(description)[i]);\n            // If any of the characters is not a hex digit, ignore the suffix entirely\n            if (!isHex) {\n                return true;\n            }\n            recovered = (recovered << 4) | value;\n        }\n\n        return recovered == uint160(proposer);\n    }\n\n    /**\n     * @dev Try to parse a character from a string as a hex value. Returns `(true, value)` if the char is in\n     * `[0-9a-fA-F]` and `(false, 0)` otherwise. Value is guaranteed to be in the range `0 <= value < 16`\n     */\n    function _tryHexToUint(bytes1 char) private pure returns (bool, uint8) {\n        uint8 c = uint8(char);\n        unchecked {\n            // Case 0-9\n            if (47 < c && c < 58) {\n                return (true, c - 48);\n            }\n            // Case A-F\n            else if (64 < c && c < 71) {\n                return (true, c - 55);\n            }\n            // Case a-f\n            else if (96 < c && c < 103) {\n                return (true, c - 87);\n            }\n            // Else: not a hex char\n            else {\n                return (false, 0);\n            }\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/governance/IGovernorUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/IGovernor.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC165Upgradeable.sol\";\nimport \"../interfaces/IERC6372Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Interface of the {Governor} core.\n *\n * _Available since v4.3._\n */\nabstract contract IGovernorUpgradeable is Initializable, IERC165Upgradeable, IERC6372Upgradeable {\n    function __IGovernor_init() internal onlyInitializing {\n    }\n\n    function __IGovernor_init_unchained() internal onlyInitializing {\n    }\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    /**\n     * @dev Emitted when a proposal is created.\n     */\n    event ProposalCreated(\n        uint256 proposalId,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 voteStart,\n        uint256 voteEnd,\n        string description\n    );\n\n    /**\n     * @dev Emitted when a proposal is canceled.\n     */\n    event ProposalCanceled(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a proposal is executed.\n     */\n    event ProposalExecuted(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a vote is cast without params.\n     *\n     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.\n     */\n    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 weight, string reason);\n\n    /**\n     * @dev Emitted when a vote is cast with params.\n     *\n     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.\n     * `params` are additional encoded parameters. Their interpepretation also depends on the voting module used.\n     */\n    event VoteCastWithParams(\n        address indexed voter,\n        uint256 proposalId,\n        uint8 support,\n        uint256 weight,\n        string reason,\n        bytes params\n    );\n\n    /**\n     * @notice module:core\n     * @dev Name of the governor instance (used in building the ERC712 domain separator).\n     */\n    function name() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Version of the governor instance (used in building the ERC712 domain separator). Default: \"1\"\n     */\n    function version() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev See {IERC6372}\n     */\n    function clock() public view virtual override returns (uint48);\n\n    /**\n     * @notice module:core\n     * @dev See EIP-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual override returns (string memory);\n\n    /**\n     * @notice module:voting\n     * @dev A description of the possible `support` values for {castVote} and the way these votes are counted, meant to\n     * be consumed by UIs to show correct vote options and interpret the results. The string is a URL-encoded sequence of\n     * key-value pairs that each describe one aspect, for example `support=bravo&quorum=for,abstain`.\n     *\n     * There are 2 standard keys: `support` and `quorum`.\n     *\n     * - `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in `GovernorBravo`.\n     * - `quorum=bravo` means that only For votes are counted towards quorum.\n     * - `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.\n     *\n     * If a counting module makes use of encoded `params`, it should  include this under a `params` key with a unique\n     * name that describes the behavior. For example:\n     *\n     * - `params=fractional` might refer to a scheme where votes are divided fractionally between for/against/abstain.\n     * - `params=erc721` might refer to a scheme where specific NFTs are delegated to vote.\n     *\n     * NOTE: The string can be decoded by the standard\n     * https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams[`URLSearchParams`]\n     * JavaScript class.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Hashing function used to (re)build the proposal id from the proposal details..\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Current state of a proposal, following Compound's convention\n     */\n    function state(uint256 proposalId) public view virtual returns (ProposalState);\n\n    /**\n     * @notice module:core\n     * @dev Timepoint used to retrieve user's votes and quorum. If using block number (as per Compound's Comp), the\n     * snapshot is performed at the end of this block. Hence, voting for this proposal starts at the beginning of the\n     * following block.\n     */\n    function proposalSnapshot(uint256 proposalId) public view virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Timepoint at which votes close. If using block number, votes close at the end of this block, so it is\n     * possible to cast a vote during this block.\n     */\n    function proposalDeadline(uint256 proposalId) public view virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev The account that created a proposal.\n     */\n    function proposalProposer(uint256 proposalId) public view virtual returns (address);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay, between the proposal is created and the vote starts. The unit this duration is expressed in depends\n     * on the clock (see EIP-6372) this contract uses.\n     *\n     * This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a\n     * proposal starts.\n     */\n    function votingDelay() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay between the vote start and vote end. The unit this duration is expressed in depends on the clock\n     * (see EIP-6372) this contract uses.\n     *\n     * NOTE: The {votingDelay} can delay the start of the vote. This must be considered when setting the voting\n     * duration compared to the voting delay.\n     */\n    function votingPeriod() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Minimum number of cast voted required for a proposal to be successful.\n     *\n     * NOTE: The `timepoint` parameter corresponds to the snapshot used for counting vote. This allows to scale the\n     * quorum depending on values such as the totalSupply of a token at this timepoint (see {ERC20Votes}).\n     */\n    function quorum(uint256 timepoint) public view virtual returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `account` at a specific `timepoint`.\n     *\n     * Note: this can be implemented in a number of ways, for example by reading the delegated balance from one (or\n     * multiple), {ERC20Votes} tokens.\n     */\n    function getVotes(address account, uint256 timepoint) public view virtual returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `account` at a specific `timepoint` given additional encoded parameters.\n     */\n    function getVotesWithParams(\n        address account,\n        uint256 timepoint,\n        bytes memory params\n    ) public view virtual returns (uint256);\n\n    /**\n     * @notice module:voting\n     * @dev Returns whether `account` has cast a vote on `proposalId`.\n     */\n    function hasVoted(uint256 proposalId, address account) public view virtual returns (bool);\n\n    /**\n     * @dev Create a new proposal. Vote start after a delay specified by {IGovernor-votingDelay} and lasts for a\n     * duration specified by {IGovernor-votingPeriod}.\n     *\n     * Emits a {ProposalCreated} event.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Execute a successful proposal. This requires the quorum to be reached, the vote to be successful, and the\n     * deadline to be reached.\n     *\n     * Emits a {ProposalExecuted} event.\n     *\n     * Note: some module can modify the requirements for execution, for example by adding an additional timelock.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Cancel a proposal. A proposal is cancellable by the proposer, but only while it is Pending state, i.e.\n     * before the vote starts.\n     *\n     * Emits a {ProposalCanceled} event.\n     */\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Cast a vote\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVote(uint256 proposalId, uint8 support) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason and additional encoded parameters\n     *\n     * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.\n     */\n    function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote using the user's cryptographic signature.\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason and additional encoded parameters using the user's cryptographic signature.\n     *\n     * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.\n     */\n    function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/TimelockController.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../access/AccessControlUpgradeable.sol\";\nimport \"../token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"../token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\ncontract TimelockControllerUpgradeable is Initializable, AccessControlUpgradeable, IERC721ReceiverUpgradeable, IERC1155ReceiverUpgradeable {\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELLER_ROLE = keccak256(\"CANCELLER_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when new proposal is scheduled with non-zero salt.\n     */\n    event CallSalt(bytes32 indexed id, bytes32 salt);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with the following parameters:\n     *\n     * - `minDelay`: initial minimum delay for operations\n     * - `proposers`: accounts to be granted proposer and canceller roles\n     * - `executors`: accounts to be granted executor role\n     * - `admin`: optional account to be granted admin role; disable with zero address\n     *\n     * IMPORTANT: The optional admin can aid with initial configuration of roles after deployment\n     * without being subject to delay, but this role should be subsequently renounced in favor of\n     * administration through timelocked proposals. Previous versions of this contract would assign\n     * this admin to the deployer automatically and should be renounced as well.\n     */\n    function __TimelockController_init(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) internal onlyInitializing {\n        __TimelockController_init_unchained(minDelay, proposers, executors, admin);\n    }\n\n    function __TimelockController_init_unchained(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) internal onlyInitializing {\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(CANCELLER_ROLE, TIMELOCK_ADMIN_ROLE);\n\n        // self administration\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n        // optional admin\n        if (admin != address(0)) {\n            _setupRole(TIMELOCK_ADMIN_ROLE, admin);\n        }\n\n        // register proposers and cancellers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _setupRole(PROPOSER_ROLE, proposers[i]);\n            _setupRole(CANCELLER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, AccessControlUpgradeable) returns (bool) {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns whether an id correspond to a registered operation. This\n     * includes both Pending, Ready and Done operations.\n     */\n    function isOperation(bytes32 id) public view virtual returns (bool) {\n        return getTimestamp(id) > 0;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not. Note that a \"pending\" operation may also be \"ready\".\n     */\n    function isOperationPending(bytes32 id) public view virtual returns (bool) {\n        return getTimestamp(id) > _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready for execution. Note that a \"ready\" operation is also \"pending\".\n     */\n    function isOperationReady(bytes32 id) public view virtual returns (bool) {\n        uint256 timestamp = getTimestamp(id);\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view virtual returns (bool) {\n        return getTimestamp(id) == _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns the timestamp at which an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256) {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns the minimum delay for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32) {\n        return keccak256(abi.encode(targets, values, payloads, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits {CallSalt} if salt is nonzero, and {CallScheduled}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n        if (salt != bytes32(0)) {\n            emit CallSalt(id, salt);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits {CallSalt} if salt is nonzero, and one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == payloads.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);\n        }\n        if (salt != bytes32(0)) {\n            emit CallSalt(id, salt);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to become valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        require(!isOperation(id), \"TimelockController: operation already scheduled\");\n        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'canceller' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {\n        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata payload,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, payload, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        _execute(target, value, payload);\n        emit CallExecuted(id, 0, target, value, payload);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == payloads.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            address target = targets[i];\n            uint256 value = values[i];\n            bytes calldata payload = payloads[i];\n            _execute(target, value, payload);\n            emit CallExecuted(id, i, target, value, payload);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     */\n    function _execute(address target, uint256 value, bytes calldata data) internal virtual {\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155Received}.\n     */\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/governance/extensions/GovernorCountingSimpleUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/extensions/GovernorCountingSimple.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../GovernorUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for simple, 3 options, vote counting.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorCountingSimpleUpgradeable is Initializable, GovernorUpgradeable {\n    function __GovernorCountingSimple_init() internal onlyInitializing {\n    }\n\n    function __GovernorCountingSimple_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Supported vote types. Matches Governor Bravo ordering.\n     */\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => bool) hasVoted;\n    }\n\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    /**\n     * @dev See {IGovernor-COUNTING_MODE}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    /**\n     * @dev See {IGovernor-hasVoted}.\n     */\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n\n    /**\n     * @dev Accessor to the internal vote counts.\n     */\n    function proposalVotes(\n        uint256 proposalId\n    ) public view virtual returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n        return (proposalVote.againstVotes, proposalVote.forVotes, proposalVote.abstainVotes);\n    }\n\n    /**\n     * @dev See {Governor-_quorumReached}.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n\n        return quorum(proposalSnapshot(proposalId)) <= proposalVote.forVotes + proposalVote.abstainVotes;\n    }\n\n    /**\n     * @dev See {Governor-_voteSucceeded}. In this module, the forVotes must be strictly over the againstVotes.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n\n        return proposalVote.forVotes > proposalVote.againstVotes;\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo).\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory // params\n    ) internal virtual override {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n\n        require(!proposalVote.hasVoted[account], \"GovernorVotingSimple: vote already cast\");\n        proposalVote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalVote.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalVote.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalVote.abstainVotes += weight;\n        } else {\n            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/extensions/GovernorSettings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../GovernorUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for settings updatable through governance.\n *\n * _Available since v4.4._\n */\nabstract contract GovernorSettingsUpgradeable is Initializable, GovernorUpgradeable {\n    uint256 private _votingDelay;\n    uint256 private _votingPeriod;\n    uint256 private _proposalThreshold;\n\n    event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);\n    event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\n    event ProposalThresholdSet(uint256 oldProposalThreshold, uint256 newProposalThreshold);\n\n    /**\n     * @dev Initialize the governance parameters.\n     */\n    function __GovernorSettings_init(uint256 initialVotingDelay, uint256 initialVotingPeriod, uint256 initialProposalThreshold) internal onlyInitializing {\n        __GovernorSettings_init_unchained(initialVotingDelay, initialVotingPeriod, initialProposalThreshold);\n    }\n\n    function __GovernorSettings_init_unchained(uint256 initialVotingDelay, uint256 initialVotingPeriod, uint256 initialProposalThreshold) internal onlyInitializing {\n        _setVotingDelay(initialVotingDelay);\n        _setVotingPeriod(initialVotingPeriod);\n        _setProposalThreshold(initialProposalThreshold);\n    }\n\n    /**\n     * @dev See {IGovernor-votingDelay}.\n     */\n    function votingDelay() public view virtual override returns (uint256) {\n        return _votingDelay;\n    }\n\n    /**\n     * @dev See {IGovernor-votingPeriod}.\n     */\n    function votingPeriod() public view virtual override returns (uint256) {\n        return _votingPeriod;\n    }\n\n    /**\n     * @dev See {Governor-proposalThreshold}.\n     */\n    function proposalThreshold() public view virtual override returns (uint256) {\n        return _proposalThreshold;\n    }\n\n    /**\n     * @dev Update the voting delay. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {VotingDelaySet} event.\n     */\n    function setVotingDelay(uint256 newVotingDelay) public virtual onlyGovernance {\n        _setVotingDelay(newVotingDelay);\n    }\n\n    /**\n     * @dev Update the voting period. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {VotingPeriodSet} event.\n     */\n    function setVotingPeriod(uint256 newVotingPeriod) public virtual onlyGovernance {\n        _setVotingPeriod(newVotingPeriod);\n    }\n\n    /**\n     * @dev Update the proposal threshold. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {ProposalThresholdSet} event.\n     */\n    function setProposalThreshold(uint256 newProposalThreshold) public virtual onlyGovernance {\n        _setProposalThreshold(newProposalThreshold);\n    }\n\n    /**\n     * @dev Internal setter for the voting delay.\n     *\n     * Emits a {VotingDelaySet} event.\n     */\n    function _setVotingDelay(uint256 newVotingDelay) internal virtual {\n        emit VotingDelaySet(_votingDelay, newVotingDelay);\n        _votingDelay = newVotingDelay;\n    }\n\n    /**\n     * @dev Internal setter for the voting period.\n     *\n     * Emits a {VotingPeriodSet} event.\n     */\n    function _setVotingPeriod(uint256 newVotingPeriod) internal virtual {\n        // voting period must be at least one block long\n        require(newVotingPeriod > 0, \"GovernorSettings: voting period too low\");\n        emit VotingPeriodSet(_votingPeriod, newVotingPeriod);\n        _votingPeriod = newVotingPeriod;\n    }\n\n    /**\n     * @dev Internal setter for the proposal threshold.\n     *\n     * Emits a {ProposalThresholdSet} event.\n     */\n    function _setProposalThreshold(uint256 newProposalThreshold) internal virtual {\n        emit ProposalThresholdSet(_proposalThreshold, newProposalThreshold);\n        _proposalThreshold = newProposalThreshold;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/extensions/GovernorTimelockControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IGovernorTimelockUpgradeable.sol\";\nimport \"../GovernorUpgradeable.sol\";\nimport \"../TimelockControllerUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} that binds the execution process to an instance of {TimelockController}. This adds a\n * delay, enforced by the {TimelockController} to all successful proposal (in addition to the voting duration). The\n * {Governor} needs the proposer (and ideally the executor) roles for the {Governor} to work properly.\n *\n * Using this model means the proposal will be operated by the {TimelockController} and not by the {Governor}. Thus,\n * the assets and permissions must be attached to the {TimelockController}. Any asset sent to the {Governor} will be\n * inaccessible.\n *\n * WARNING: Setting up the TimelockController to have additional proposers besides the governor is very risky, as it\n * grants them powers that they must be trusted or known not to use: 1) {onlyGovernance} functions like {relay} are\n * available to them through the timelock, and 2) approved governance proposals can be blocked by them, effectively\n * executing a Denial of Service attack. This risk will be mitigated in a future release.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorTimelockControlUpgradeable is Initializable, IGovernorTimelockUpgradeable, GovernorUpgradeable {\n    TimelockControllerUpgradeable private _timelock;\n    mapping(uint256 => bytes32) private _timelockIds;\n\n    /**\n     * @dev Emitted when the timelock controller used for proposal execution is modified.\n     */\n    event TimelockChange(address oldTimelock, address newTimelock);\n\n    /**\n     * @dev Set the timelock.\n     */\n    function __GovernorTimelockControl_init(TimelockControllerUpgradeable timelockAddress) internal onlyInitializing {\n        __GovernorTimelockControl_init_unchained(timelockAddress);\n    }\n\n    function __GovernorTimelockControl_init_unchained(TimelockControllerUpgradeable timelockAddress) internal onlyInitializing {\n        _updateTimelock(timelockAddress);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, GovernorUpgradeable) returns (bool) {\n        return interfaceId == type(IGovernorTimelockUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Overridden version of the {Governor-state} function with added support for the `Queued` state.\n     */\n    function state(uint256 proposalId) public view virtual override(IGovernorUpgradeable, GovernorUpgradeable) returns (ProposalState) {\n        ProposalState currentState = super.state(proposalId);\n\n        if (currentState != ProposalState.Succeeded) {\n            return currentState;\n        }\n\n        // core tracks execution, so we just have to check if successful proposal have been queued.\n        bytes32 queueid = _timelockIds[proposalId];\n        if (queueid == bytes32(0)) {\n            return currentState;\n        } else if (_timelock.isOperationDone(queueid)) {\n            return ProposalState.Executed;\n        } else if (_timelock.isOperationPending(queueid)) {\n            return ProposalState.Queued;\n        } else {\n            return ProposalState.Canceled;\n        }\n    }\n\n    /**\n     * @dev Public accessor to check the address of the timelock\n     */\n    function timelock() public view virtual override returns (address) {\n        return address(_timelock);\n    }\n\n    /**\n     * @dev Public accessor to check the eta of a queued proposal\n     */\n    function proposalEta(uint256 proposalId) public view virtual override returns (uint256) {\n        uint256 eta = _timelock.getTimestamp(_timelockIds[proposalId]);\n        return eta == 1 ? 0 : eta; // _DONE_TIMESTAMP (1) should be replaced with a 0 value\n    }\n\n    /**\n     * @dev Function to queue a proposal to the timelock.\n     */\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        require(state(proposalId) == ProposalState.Succeeded, \"Governor: proposal not successful\");\n\n        uint256 delay = _timelock.getMinDelay();\n        _timelockIds[proposalId] = _timelock.hashOperationBatch(targets, values, calldatas, 0, descriptionHash);\n        _timelock.scheduleBatch(targets, values, calldatas, 0, descriptionHash, delay);\n\n        emit ProposalQueued(proposalId, block.timestamp + delay);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Overridden execute function that run the already queued proposal through the timelock.\n     */\n    function _execute(\n        uint256 /* proposalId */,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override {\n        _timelock.executeBatch{value: msg.value}(targets, values, calldatas, 0, descriptionHash);\n    }\n\n    /**\n     * @dev Overridden version of the {Governor-_cancel} function to cancel the timelocked proposal if it as already\n     * been queued.\n     */\n    // This function can reenter through the external call to the timelock, but we assume the timelock is trusted and\n    // well behaved (according to TimelockController) and this will not happen.\n    // slither-disable-next-line reentrancy-no-eth\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override returns (uint256) {\n        uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash);\n\n        if (_timelockIds[proposalId] != 0) {\n            _timelock.cancel(_timelockIds[proposalId]);\n            delete _timelockIds[proposalId];\n        }\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Address through which the governor executes action. In this case, the timelock.\n     */\n    function _executor() internal view virtual override returns (address) {\n        return address(_timelock);\n    }\n\n    /**\n     * @dev Public endpoint to update the underlying timelock instance. Restricted to the timelock itself, so updates\n     * must be proposed, scheduled, and executed through governance proposals.\n     *\n     * CAUTION: It is not recommended to change the timelock while there are other queued governance proposals.\n     */\n    function updateTimelock(TimelockControllerUpgradeable newTimelock) external virtual onlyGovernance {\n        _updateTimelock(newTimelock);\n    }\n\n    function _updateTimelock(TimelockControllerUpgradeable newTimelock) private {\n        emit TimelockChange(address(_timelock), address(newTimelock));\n        _timelock = newTimelock;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/extensions/GovernorVotesQuorumFraction.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./GovernorVotesUpgradeable.sol\";\nimport \"../../utils/CheckpointsUpgradeable.sol\";\nimport \"../../utils/math/SafeCastUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token and a quorum expressed as a\n * fraction of the total supply.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorVotesQuorumFractionUpgradeable is Initializable, GovernorVotesUpgradeable {\n    using CheckpointsUpgradeable for CheckpointsUpgradeable.Trace224;\n\n    uint256 private _quorumNumerator; // DEPRECATED in favor of _quorumNumeratorHistory\n\n    /// @custom:oz-retyped-from Checkpoints.History\n    CheckpointsUpgradeable.Trace224 private _quorumNumeratorHistory;\n\n    event QuorumNumeratorUpdated(uint256 oldQuorumNumerator, uint256 newQuorumNumerator);\n\n    /**\n     * @dev Initialize quorum as a fraction of the token's total supply.\n     *\n     * The fraction is specified as `numerator / denominator`. By default the denominator is 100, so quorum is\n     * specified as a percent: a numerator of 10 corresponds to quorum being 10% of total supply. The denominator can be\n     * customized by overriding {quorumDenominator}.\n     */\n    function __GovernorVotesQuorumFraction_init(uint256 quorumNumeratorValue) internal onlyInitializing {\n        __GovernorVotesQuorumFraction_init_unchained(quorumNumeratorValue);\n    }\n\n    function __GovernorVotesQuorumFraction_init_unchained(uint256 quorumNumeratorValue) internal onlyInitializing {\n        _updateQuorumNumerator(quorumNumeratorValue);\n    }\n\n    /**\n     * @dev Returns the current quorum numerator. See {quorumDenominator}.\n     */\n    function quorumNumerator() public view virtual returns (uint256) {\n        return _quorumNumeratorHistory._checkpoints.length == 0 ? _quorumNumerator : _quorumNumeratorHistory.latest();\n    }\n\n    /**\n     * @dev Returns the quorum numerator at a specific timepoint. See {quorumDenominator}.\n     */\n    function quorumNumerator(uint256 timepoint) public view virtual returns (uint256) {\n        // If history is empty, fallback to old storage\n        uint256 length = _quorumNumeratorHistory._checkpoints.length;\n        if (length == 0) {\n            return _quorumNumerator;\n        }\n\n        // Optimistic search, check the latest checkpoint\n        CheckpointsUpgradeable.Checkpoint224 memory latest = _quorumNumeratorHistory._checkpoints[length - 1];\n        if (latest._key <= timepoint) {\n            return latest._value;\n        }\n\n        // Otherwise, do the binary search\n        return _quorumNumeratorHistory.upperLookupRecent(SafeCastUpgradeable.toUint32(timepoint));\n    }\n\n    /**\n     * @dev Returns the quorum denominator. Defaults to 100, but may be overridden.\n     */\n    function quorumDenominator() public view virtual returns (uint256) {\n        return 100;\n    }\n\n    /**\n     * @dev Returns the quorum for a timepoint, in terms of number of votes: `supply * numerator / denominator`.\n     */\n    function quorum(uint256 timepoint) public view virtual override returns (uint256) {\n        return (token.getPastTotalSupply(timepoint) * quorumNumerator(timepoint)) / quorumDenominator();\n    }\n\n    /**\n     * @dev Changes the quorum numerator.\n     *\n     * Emits a {QuorumNumeratorUpdated} event.\n     *\n     * Requirements:\n     *\n     * - Must be called through a governance proposal.\n     * - New numerator must be smaller or equal to the denominator.\n     */\n    function updateQuorumNumerator(uint256 newQuorumNumerator) external virtual onlyGovernance {\n        _updateQuorumNumerator(newQuorumNumerator);\n    }\n\n    /**\n     * @dev Changes the quorum numerator.\n     *\n     * Emits a {QuorumNumeratorUpdated} event.\n     *\n     * Requirements:\n     *\n     * - New numerator must be smaller or equal to the denominator.\n     */\n    function _updateQuorumNumerator(uint256 newQuorumNumerator) internal virtual {\n        require(\n            newQuorumNumerator <= quorumDenominator(),\n            \"GovernorVotesQuorumFraction: quorumNumerator over quorumDenominator\"\n        );\n\n        uint256 oldQuorumNumerator = quorumNumerator();\n\n        // Make sure we keep track of the original numerator in contracts upgraded from a version without checkpoints.\n        if (oldQuorumNumerator != 0 && _quorumNumeratorHistory._checkpoints.length == 0) {\n            _quorumNumeratorHistory._checkpoints.push(\n                CheckpointsUpgradeable.Checkpoint224({_key: 0, _value: SafeCastUpgradeable.toUint224(oldQuorumNumerator)})\n            );\n        }\n\n        // Set new quorum for future proposals\n        _quorumNumeratorHistory.push(SafeCastUpgradeable.toUint32(clock()), SafeCastUpgradeable.toUint224(newQuorumNumerator));\n\n        emit QuorumNumeratorUpdated(oldQuorumNumerator, newQuorumNumerator);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/extensions/GovernorVotes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../GovernorUpgradeable.sol\";\nimport \"../../interfaces/IERC5805Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token, or since v4.5 an {ERC721Votes} token.\n *\n * _Available since v4.3._\n *\n * @custom:storage-size 51\n */\nabstract contract GovernorVotesUpgradeable is Initializable, GovernorUpgradeable {\n    IERC5805Upgradeable public token;\n\n    function __GovernorVotes_init(IVotesUpgradeable tokenAddress) internal onlyInitializing {\n        __GovernorVotes_init_unchained(tokenAddress);\n    }\n\n    function __GovernorVotes_init_unchained(IVotesUpgradeable tokenAddress) internal onlyInitializing {\n        token = IERC5805Upgradeable(address(tokenAddress));\n    }\n\n    /**\n     * @dev Clock (as specified in EIP-6372) is set to match the token's clock. Fallback to block numbers if the token\n     * does not implement EIP-6372.\n     */\n    function clock() public view virtual override returns (uint48) {\n        try token.clock() returns (uint48 timepoint) {\n            return timepoint;\n        } catch {\n            return SafeCastUpgradeable.toUint48(block.number);\n        }\n    }\n\n    /**\n     * @dev Machine-readable description of the clock as specified in EIP-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual override returns (string memory) {\n        try token.CLOCK_MODE() returns (string memory clockmode) {\n            return clockmode;\n        } catch {\n            return \"mode=blocknumber&from=default\";\n        }\n    }\n\n    /**\n     * Read the voting weight from the token's built in snapshot mechanism (see {Governor-_getVotes}).\n     */\n    function _getVotes(\n        address account,\n        uint256 timepoint,\n        bytes memory /*params*/\n    ) internal view virtual override returns (uint256) {\n        return token.getPastVotes(account, timepoint);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/governance/extensions/IGovernorTimelockUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/extensions/IGovernorTimelock.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IGovernorUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of the {IGovernor} for timelock supporting modules.\n *\n * _Available since v4.3._\n */\nabstract contract IGovernorTimelockUpgradeable is Initializable, IGovernorUpgradeable {\n    function __IGovernorTimelock_init() internal onlyInitializing {\n    }\n\n    function __IGovernorTimelock_init_unchained() internal onlyInitializing {\n    }\n    event ProposalQueued(uint256 proposalId, uint256 eta);\n\n    function timelock() public view virtual returns (address);\n\n    function proposalEta(uint256 proposalId) public view virtual returns (uint256);\n\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256 proposalId);\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/governance/utils/IVotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/utils/IVotes.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n *\n * _Available since v4.5._\n */\ninterface IVotesUpgradeable {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     */\n    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/governance/utils/VotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/utils/Votes.sol)\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/IERC5805Upgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/CountersUpgradeable.sol\";\nimport \"../../utils/CheckpointsUpgradeable.sol\";\nimport \"../../utils/cryptography/EIP712Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This is a base abstract contract that tracks voting units, which are a measure of voting power that can be\n * transferred, and provides a system of vote delegation, where an account can delegate its voting units to a sort of\n * \"representative\" that will pool delegated voting units from different accounts and can then use it to vote in\n * decisions. In fact, voting units _must_ be delegated in order to count as actual votes, and an account has to\n * delegate those votes to itself if it wishes to participate in decisions and does not have a trusted representative.\n *\n * This contract is often combined with a token contract such that voting units correspond to token units. For an\n * example, see {ERC721Votes}.\n *\n * The full history of delegate votes is tracked on-chain so that governance protocols can consider votes as distributed\n * at a particular block number to protect against flash loans and double voting. The opt-in delegate system makes the\n * cost of this history tracking optional.\n *\n * When using this module the derived contract must implement {_getVotingUnits} (for example, make it return\n * {ERC721-balanceOf}), and can use {_transferVotingUnits} to track a change in the distribution of those units (in the\n * previous example, it would be included in {ERC721-_beforeTokenTransfer}).\n *\n * _Available since v4.5._\n */\nabstract contract VotesUpgradeable is Initializable, ContextUpgradeable, EIP712Upgradeable, IERC5805Upgradeable {\n    function __Votes_init() internal onlyInitializing {\n    }\n\n    function __Votes_init_unchained() internal onlyInitializing {\n    }\n    using CheckpointsUpgradeable for CheckpointsUpgradeable.Trace224;\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegation;\n\n    /// @custom:oz-retyped-from mapping(address => Checkpoints.History)\n    mapping(address => CheckpointsUpgradeable.Trace224) private _delegateCheckpoints;\n\n    /// @custom:oz-retyped-from Checkpoints.History\n    CheckpointsUpgradeable.Trace224 private _totalCheckpoints;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based\n     * checkpoints (and voting), in which case {CLOCK_MODE} should be overridden as well to match.\n     */\n    function clock() public view virtual override returns (uint48) {\n        return SafeCastUpgradeable.toUint48(block.number);\n    }\n\n    /**\n     * @dev Machine-readable description of the clock as specified in EIP-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual override returns (string memory) {\n        // Check that the clock was not modified\n        require(clock() == block.number, \"Votes: broken clock mode\");\n        return \"mode=blocknumber&from=default\";\n    }\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) public view virtual override returns (uint256) {\n        return _delegateCheckpoints[account].latest();\n    }\n\n    /**\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.\n     */\n    function getPastVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {\n        require(timepoint < clock(), \"Votes: future lookup\");\n        return _delegateCheckpoints[account].upperLookupRecent(SafeCastUpgradeable.toUint32(timepoint));\n    }\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.\n     */\n    function getPastTotalSupply(uint256 timepoint) public view virtual override returns (uint256) {\n        require(timepoint < clock(), \"Votes: future lookup\");\n        return _totalCheckpoints.upperLookupRecent(SafeCastUpgradeable.toUint32(timepoint));\n    }\n\n    /**\n     * @dev Returns the current total supply of votes.\n     */\n    function _getTotalSupply() internal view virtual returns (uint256) {\n        return _totalCheckpoints.latest();\n    }\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegation[account];\n    }\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual override {\n        address account = _msgSender();\n        _delegate(account, delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"Votes: signature expired\");\n        address signer = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Delegate all of `account`'s voting units to `delegatee`.\n     *\n     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.\n     */\n    function _delegate(address account, address delegatee) internal virtual {\n        address oldDelegate = delegates(account);\n        _delegation[account] = delegatee;\n\n        emit DelegateChanged(account, oldDelegate, delegatee);\n        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));\n    }\n\n    /**\n     * @dev Transfers, mints, or burns voting units. To register a mint, `from` should be zero. To register a burn, `to`\n     * should be zero. Total supply of voting units will be adjusted with mints and burns.\n     */\n    function _transferVotingUnits(address from, address to, uint256 amount) internal virtual {\n        if (from == address(0)) {\n            _push(_totalCheckpoints, _add, SafeCastUpgradeable.toUint224(amount));\n        }\n        if (to == address(0)) {\n            _push(_totalCheckpoints, _subtract, SafeCastUpgradeable.toUint224(amount));\n        }\n        _moveDelegateVotes(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Moves delegated votes from one delegate to another.\n     */\n    function _moveDelegateVotes(address from, address to, uint256 amount) private {\n        if (from != to && amount > 0) {\n            if (from != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    _delegateCheckpoints[from],\n                    _subtract,\n                    SafeCastUpgradeable.toUint224(amount)\n                );\n                emit DelegateVotesChanged(from, oldValue, newValue);\n            }\n            if (to != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    _delegateCheckpoints[to],\n                    _add,\n                    SafeCastUpgradeable.toUint224(amount)\n                );\n                emit DelegateVotesChanged(to, oldValue, newValue);\n            }\n        }\n    }\n\n    function _push(\n        CheckpointsUpgradeable.Trace224 storage store,\n        function(uint224, uint224) view returns (uint224) op,\n        uint224 delta\n    ) private returns (uint224, uint224) {\n        return store.push(SafeCastUpgradeable.toUint32(clock()), op(store.latest(), delta));\n    }\n\n    function _add(uint224 a, uint224 b) private pure returns (uint224) {\n        return a + b;\n    }\n\n    function _subtract(uint224 a, uint224 b) private pure returns (uint224) {\n        return a - b;\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n\n    /**\n     * @dev Returns an address nonce.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev Returns the contract's {EIP712} domain separator.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev Must return the voting units held by an account.\n     */\n    function _getVotingUnits(address) internal view virtual returns (uint256);\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/interfaces/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165Upgradeable.sol\";\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/interfaces/IERC4906Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4906.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"./IERC721Upgradeable.sol\";\n\n/// @title EIP-721 Metadata Update Extension\ninterface IERC4906Upgradeable is IERC165Upgradeable, IERC721Upgradeable {\n    /// @dev This event emits when the metadata of a token is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFT.\n    event MetadataUpdate(uint256 _tokenId);\n\n    /// @dev This event emits when the metadata of a range of tokens is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFTs.\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/interfaces/IERC5267Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC5267Upgradeable {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/interfaces/IERC5805Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5805.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../governance/utils/IVotesUpgradeable.sol\";\nimport \"./IERC6372Upgradeable.sol\";\n\ninterface IERC5805Upgradeable is IERC6372Upgradeable, IVotesUpgradeable {}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/interfaces/IERC6372Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC6372.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC6372Upgradeable {\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() external view returns (uint48);\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() external view returns (string memory);\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/interfaces/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721Upgradeable.sol\";\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[44] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be burned (destroyed).\n */\nabstract contract ERC721BurnableUpgradeable is Initializable, ContextUpgradeable, ERC721Upgradeable {\n    function __ERC721Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _burn(tokenId);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"./IERC721EnumerableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721EnumerableUpgradeable {\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721EnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Upgradeable.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721EnumerableUpgradeable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n\n        if (batchSize > 1) {\n            // Will only trigger during construction. Batch transferring (minting) is not available afterwards.\n            revert(\"ERC721Enumerable: consecutive transfers not supported\");\n        }\n\n        uint256 tokenId = firstTokenId;\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721Upgradeable.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../interfaces/IERC4906Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorageUpgradeable is Initializable, IERC4906Upgradeable, ERC721Upgradeable {\n    function __ERC721URIStorage_init() internal onlyInitializing {\n    }\n\n    function __ERC721URIStorage_init_unchained() internal onlyInitializing {\n    }\n    using StringsUpgradeable for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC165-supportsInterface}\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, IERC165Upgradeable) returns (bool) {\n        return interfaceId == bytes4(0x49064906) || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Emits {MetadataUpdate}.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n\n        emit MetadataUpdate(tokenId);\n    }\n\n    /**\n     * @dev See {ERC721-_burn}. This override additionally checks to see if a\n     * token-specific URI was set for the token, and if so, it deletes the token URI from\n     * the storage mapping.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721VotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/extensions/ERC721Votes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../governance/utils/VotesUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of ERC721 to support voting and delegation as implemented by {Votes}, where each individual NFT counts\n * as 1 vote unit.\n *\n * Tokens do not count as votes until they are delegated, because votes must be tracked which incurs an additional cost\n * on every transfer. Token holders can either delegate to a trusted representative who will decide how to make use of\n * the votes in governance decisions, or they can delegate to themselves to be their own representative.\n *\n * _Available since v4.5._\n */\nabstract contract ERC721VotesUpgradeable is Initializable, ERC721Upgradeable, VotesUpgradeable {\n    function __ERC721Votes_init() internal onlyInitializing {\n    }\n\n    function __ERC721Votes_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {ERC721-_afterTokenTransfer}. Adjusts votes when tokens are transferred.\n     *\n     * Emits a {IVotes-DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override {\n        _transferVotingUnits(from, to, batchSize);\n        super._afterTokenTransfer(from, to, firstTokenId, batchSize);\n    }\n\n    /**\n     * @dev Returns the balance of `account`.\n     *\n     * WARNING: Overriding this function will likely result in incorrect vote tracking.\n     */\n    function _getVotingUnits(address account) internal view virtual override returns (uint256) {\n        return balanceOf(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/CheckpointsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Checkpoints.sol)\n// This file was procedurally generated from scripts/generate/templates/Checkpoints.js.\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SafeCastUpgradeable.sol\";\n\n/**\n * @dev This library defines the `History` struct, for checkpointing values as they change at different points in\n * time, and later looking up past values by block number. See {Votes} as an example.\n *\n * To create a history of checkpoints define a variable type `Checkpoints.History` in your contract, and store a new\n * checkpoint for the current transaction block using the {push} function.\n *\n * _Available since v4.5._\n */\nlibrary CheckpointsUpgradeable {\n    struct History {\n        Checkpoint[] _checkpoints;\n    }\n\n    struct Checkpoint {\n        uint32 _blockNumber;\n        uint224 _value;\n    }\n\n    /**\n     * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one\n     * before it is returned, or zero otherwise. Because the number returned corresponds to that at the end of the\n     * block, the requested block number must be in the past, excluding the current block.\n     */\n    function getAtBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {\n        require(blockNumber < block.number, \"Checkpoints: block not yet mined\");\n        uint32 key = SafeCastUpgradeable.toUint32(blockNumber);\n\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one\n     * before it is returned, or zero otherwise. Similar to {upperLookup} but optimized for the case when the searched\n     * checkpoint is probably \"recent\", defined as being among the last sqrt(N) checkpoints where N is the number of\n     * checkpoints.\n     */\n    function getAtProbablyRecentBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {\n        require(blockNumber < block.number, \"Checkpoints: block not yet mined\");\n        uint32 key = SafeCastUpgradeable.toUint32(blockNumber);\n\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - MathUpgradeable.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Pushes a value onto a History so that it is stored as the checkpoint for the current block.\n     *\n     * Returns previous value and new value.\n     */\n    function push(History storage self, uint256 value) internal returns (uint256, uint256) {\n        return _insert(self._checkpoints, SafeCastUpgradeable.toUint32(block.number), SafeCastUpgradeable.toUint224(value));\n    }\n\n    /**\n     * @dev Pushes a value onto a History, by updating the latest value using binary operation `op`. The new value will\n     * be set to `op(latest, delta)`.\n     *\n     * Returns previous value and new value.\n     */\n    function push(\n        History storage self,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) internal returns (uint256, uint256) {\n        return push(self, op(latest(self), delta));\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(History storage self) internal view returns (uint224) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(\n        History storage self\n    ) internal view returns (bool exists, uint32 _blockNumber, uint224 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._blockNumber, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(History storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            require(last._blockNumber <= key, \"Checkpoint: decreasing keys\");\n\n            // Update or push new checkpoint\n            if (last._blockNumber == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint({_blockNumber: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint({_blockNumber: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._blockNumber > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._blockNumber < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(Checkpoint[] storage self, uint256 pos) private pure returns (Checkpoint storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace224 {\n        Checkpoint224[] _checkpoints;\n    }\n\n    struct Checkpoint224 {\n        uint32 _key;\n        uint224 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace224 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     */\n    function push(Trace224 storage self, uint32 key, uint224 value) internal returns (uint224, uint224) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if there is none.\n     */\n    function lowerLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     */\n    function upperLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high keys).\n     */\n    function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - MathUpgradeable.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace224 storage self) internal view returns (uint224) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace224 storage self) internal view returns (bool exists, uint32 _key, uint224 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint224 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace224 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint224[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint224 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            require(last._key <= key, \"Checkpoint: decreasing keys\");\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint224({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint224({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint224[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint224 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace160 {\n        Checkpoint160[] _checkpoints;\n    }\n\n    struct Checkpoint160 {\n        uint96 _key;\n        uint160 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace160 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     */\n    function push(Trace160 storage self, uint96 key, uint160 value) internal returns (uint160, uint160) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if there is none.\n     */\n    function lowerLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     */\n    function upperLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high keys).\n     */\n    function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - MathUpgradeable.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace160 storage self) internal view returns (uint160) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace160 storage self) internal view returns (bool exists, uint96 _key, uint160 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint160 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace160 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint160[] storage self, uint96 key, uint160 value) private returns (uint160, uint160) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint160 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            require(last._key <= key, \"Checkpoint: decreasing keys\");\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint160({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint160({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint160[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint160 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SignedMathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../interfaces/IERC5267Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 52\n */\nabstract contract EIP712Upgradeable is Initializable, IERC5267Upgradeable {\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /// @custom:oz-renamed-from _HASHED_NAME\n    bytes32 private _hashedName;\n    /// @custom:oz-renamed-from _HASHED_VERSION\n    bytes32 private _hashedVersion;\n\n    string private _name;\n    string private _version;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        _name = name;\n        _version = version;\n\n        // Reset prior values in storage if upgrading\n        _hashedName = 0;\n        _hashedVersion = 0;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {EIP-5267}.\n     *\n     * _Available since v4.9._\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        // If the hashed name and version in storage are non-zero, the contract hasn't been properly initialized\n        // and the EIP712 domain is not reliable, as it will be missing name and version.\n        require(_hashedName == 0 && _hashedVersion == 0, \"EIP712: Uninitialized\");\n\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Name() internal virtual view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Version() internal virtual view returns (string memory) {\n        return _version;\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.\n     */\n    function _EIP712NameHash() internal view returns (bytes32) {\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            // If the name is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.\n            bytes32 hashedName = _hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.\n     */\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            // If the version is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.\n            bytes32 hashedVersion = _hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMathUpgradeable {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/structs/DoubleEndedQueueUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/DoubleEndedQueue.sol)\npragma solidity ^0.8.4;\n\nimport \"../math/SafeCastUpgradeable.sol\";\n\n/**\n * @dev A sequence of items with the ability to efficiently push and pop items (i.e. insert and remove) on both ends of\n * the sequence (called front and back). Among other access patterns, it can be used to implement efficient LIFO and\n * FIFO queues. Storage use is optimized, and all operations are O(1) constant time. This includes {clear}, given that\n * the existing queue contents are left in storage.\n *\n * The struct is called `Bytes32Deque`. Other types can be cast to and from `bytes32`. This data structure can only be\n * used in storage, and not in memory.\n * ```solidity\n * DoubleEndedQueue.Bytes32Deque queue;\n * ```\n *\n * _Available since v4.6._\n */\nlibrary DoubleEndedQueueUpgradeable {\n    /**\n     * @dev An operation (e.g. {front}) couldn't be completed due to the queue being empty.\n     */\n    error Empty();\n\n    /**\n     * @dev An operation (e.g. {at}) couldn't be completed due to an index being out of bounds.\n     */\n    error OutOfBounds();\n\n    /**\n     * @dev Indices are signed integers because the queue can grow in any direction. They are 128 bits so begin and end\n     * are packed in a single storage slot for efficient access. Since the items are added one at a time we can safely\n     * assume that these 128-bit indices will not overflow, and use unchecked arithmetic.\n     *\n     * Struct members have an underscore prefix indicating that they are \"private\" and should not be read or written to\n     * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and\n     * lead to unexpected behavior.\n     *\n     * Indices are in the range [begin, end) which means the first item is at data[begin] and the last item is at\n     * data[end - 1].\n     */\n    struct Bytes32Deque {\n        int128 _begin;\n        int128 _end;\n        mapping(int128 => bytes32) _data;\n    }\n\n    /**\n     * @dev Inserts an item at the end of the queue.\n     */\n    function pushBack(Bytes32Deque storage deque, bytes32 value) internal {\n        int128 backIndex = deque._end;\n        deque._data[backIndex] = value;\n        unchecked {\n            deque._end = backIndex + 1;\n        }\n    }\n\n    /**\n     * @dev Removes the item at the end of the queue and returns it.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function popBack(Bytes32Deque storage deque) internal returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 backIndex;\n        unchecked {\n            backIndex = deque._end - 1;\n        }\n        value = deque._data[backIndex];\n        delete deque._data[backIndex];\n        deque._end = backIndex;\n    }\n\n    /**\n     * @dev Inserts an item at the beginning of the queue.\n     */\n    function pushFront(Bytes32Deque storage deque, bytes32 value) internal {\n        int128 frontIndex;\n        unchecked {\n            frontIndex = deque._begin - 1;\n        }\n        deque._data[frontIndex] = value;\n        deque._begin = frontIndex;\n    }\n\n    /**\n     * @dev Removes the item at the beginning of the queue and returns it.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function popFront(Bytes32Deque storage deque) internal returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 frontIndex = deque._begin;\n        value = deque._data[frontIndex];\n        delete deque._data[frontIndex];\n        unchecked {\n            deque._begin = frontIndex + 1;\n        }\n    }\n\n    /**\n     * @dev Returns the item at the beginning of the queue.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function front(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 frontIndex = deque._begin;\n        return deque._data[frontIndex];\n    }\n\n    /**\n     * @dev Returns the item at the end of the queue.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function back(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 backIndex;\n        unchecked {\n            backIndex = deque._end - 1;\n        }\n        return deque._data[backIndex];\n    }\n\n    /**\n     * @dev Return the item at a position in the queue given by `index`, with the first item at 0 and last item at\n     * `length(deque) - 1`.\n     *\n     * Reverts with `OutOfBounds` if the index is out of bounds.\n     */\n    function at(Bytes32Deque storage deque, uint256 index) internal view returns (bytes32 value) {\n        // int256(deque._begin) is a safe upcast\n        int128 idx = SafeCastUpgradeable.toInt128(int256(deque._begin) + SafeCastUpgradeable.toInt256(index));\n        if (idx >= deque._end) revert OutOfBounds();\n        return deque._data[idx];\n    }\n\n    /**\n     * @dev Resets the queue back to being empty.\n     *\n     * NOTE: The current items are left behind in storage. This does not affect the functioning of the queue, but misses\n     * out on potential gas refunds.\n     */\n    function clear(Bytes32Deque storage deque) internal {\n        deque._begin = 0;\n        deque._end = 0;\n    }\n\n    /**\n     * @dev Returns the number of items in the queue.\n     */\n    function length(Bytes32Deque storage deque) internal view returns (uint256) {\n        // The interface preserves the invariant that begin <= end so we assume this will not overflow.\n        // We also assume there are at most int256.max items in the queue.\n        unchecked {\n            return uint256(int256(deque._end) - int256(deque._begin));\n        }\n    }\n\n    /**\n     * @dev Returns true if the queue is empty.\n     */\n    function empty(Bytes32Deque storage deque) internal view returns (bool) {\n        return deque._end <= deque._begin;\n    }\n}\n"
    },
    "node_modules/@rari-capital/solmate/src/utils/Bytes32AddressLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Library for converting between addresses and bytes32 values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\nlibrary Bytes32AddressLib {\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue));\n    }\n}\n"
    },
    "node_modules/@rari-capital/solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\n        return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.\n    }\n\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is < 0.5 we return zero. This happens when\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n            if (x <= -42139678854452767551) return 0;\n\n            // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\n            // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\n            if (x >= 135305999368893231589) revert(\"EXP_OVERFLOW\");\n\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5**18;\n\n            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // k is in the range [-61, 195].\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // p is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range (0.09, 0.25) * 2**96.\n\n            // We now need to multiply r by:\n            // * the scale factor s = ~6.031367120.\n            // * the 2**k factor from the range reduction.\n            // * the 1e18 / 2**96 factor for base conversion.\n            // We do this all at once, with an intermediate result in 2**213\n            // basis, so the final right shift is always by a positive amount.\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n        }\n    }\n\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            require(x > 0, \"UNDEFINED\");\n\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n            // We do this by multiplying by 2**96 / 10**18. But since\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n            // and add ln(2**96 / 10**18) at the end.\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            int256 k = int256(log2(uint256(x))) - 96;\n            x <<= uint256(159 - k);\n            x = int256(uint256(x) >> 159);\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // p is made monic, we will multiply by a scale factor later.\n            int256 p = x + 3273285459638523848632254066296;\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\n            p = p * x - (795164235651350426258249787498 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            // q is monic by convention.\n            int256 q = x + 5573035233440673466300451813936;\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial is known not to have zeros in the domain.\n                // No scaling required because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r is in the range (0, 0.125) * 2**96\n\n            // Finalization, we need to:\n            // * multiply by the scale factor s = 5.549…\n            // * add ln(2**96 / 10**18)\n            // * add k * ln(2)\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\n\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n            r *= 1677202110996718588342820967067443963516166;\n            // add ln(2) * k * 5e18 * 2**192\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n            // base conversion: mul 2**18 / 2**192\n            r >>= 174;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        require(x > 0, \"UNDEFINED\");\n\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\n            r := or(r, lt(0x1, shr(r, x)))\n        }\n    }\n}\n"
    },
    "node_modules/ds-test/src/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.0;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool private _failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function failed() public returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            bool globalFailed = false;\n            if (hasHEVMContext()) {\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\n                    abi.encodePacked(\n                        bytes4(keccak256(\"load(address,bytes32)\")),\n                        abi.encode(HEVM_ADDRESS, bytes32(\"failed\"))\n                    )\n                );\n                globalFailed = abi.decode(retdata, (bool));\n            }\n            return globalFailed;\n        }\n    } \n\n    function fail() internal {\n        if (hasHEVMContext()) {\n            (bool status, ) = HEVM_ADDRESS.call(\n                abi.encodePacked(\n                    bytes4(keccak256(\"store(address,bytes32,bytes32)\")),\n                    abi.encode(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x01)))\n                )\n            );\n            status; // Silence compiler warnings\n        }\n        _failed = true;\n    }\n\n    function hasHEVMContext() internal view returns (bool) {\n        uint256 hevmCodeSize = 0;\n        assembly {\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\n        }\n        return hevmCodeSize > 0;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Expected\", b);\n            emit log_named_string(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", b);\n            emit log_named_bytes(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "node_modules/forge-std/src/Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {StdStorage} from \"./StdStorage.sol\";\nimport {Vm, VmSafe} from \"./Vm.sol\";\n\nabstract contract CommonBase {\n    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.\n    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(\"hevm cheat code\"))));\n    // console.sol and console2.sol work by executing a staticcall to this address.\n    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;\n    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.\n    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(\"foundry default caller\"))));\n    // Address of the test contract, deployed by the DEFAULT_SENDER.\n    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\n    // Deterministic deployment address of the Multicall3 contract.\n    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    Vm internal constant vm = Vm(VM_ADDRESS);\n    StdStorage internal stdstore;\n}\n\nabstract contract TestBase is CommonBase {}\n\nabstract contract ScriptBase is CommonBase {\n    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);\n}\n"
    },
    "node_modules/forge-std/src/StdAssertions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {DSTest} from \"ds-test/test.sol\";\nimport {stdMath} from \"./StdMath.sol\";\n\nabstract contract StdAssertions is DSTest {\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertFalse(bool data, string memory err) internal virtual {\n        assertTrue(!data, err);\n    }\n\n    function assertEq(bool a, bool b) internal virtual {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bool]\");\n            emit log_named_string(\"      Left\", a ? \"true\" : \"false\");\n            emit log_named_string(\"     Right\", b ? \"true\" : \"false\");\n            fail();\n        }\n    }\n\n    function assertEq(bool a, bool b, string memory err) internal virtual {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes memory a, bytes memory b) internal virtual {\n        assertEq0(a, b);\n    }\n\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal virtual {\n        assertEq0(a, b, err);\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [uint[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [int[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [address[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    // Legacy helper\n    function assertEqUint(uint256 a, uint256 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"      Left\", a);\n            emit log_named_uint(\"     Right\", b);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_decimal_uint(\"      Left\", a, decimals);\n            emit log_named_decimal_uint(\"     Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max Delta\", maxDelta, decimals);\n            emit log_named_decimal_uint(\"     Delta\", delta, decimals);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\n        }\n    }\n\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int(\"       Left\", a);\n            emit log_named_int(\"      Right\", b);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_decimal_int(\"      Left\", a, decimals);\n            emit log_named_decimal_int(\"     Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max Delta\", maxDelta, decimals);\n            emit log_named_decimal_uint(\"     Delta\", delta, decimals);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"        Left\", a);\n            emit log_named_uint(\"       Right\", b);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_decimal_uint(\"        Left\", a, decimals);\n            emit log_named_decimal_uint(\"       Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals,\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\n        }\n    }\n\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int(\"        Left\", a);\n            emit log_named_int(\"       Right\", b);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_decimal_int(\"        Left\", a, decimals);\n            emit log_named_decimal_int(\"       Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\n        }\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {\n        assertEqCall(target, callDataA, target, callDataB, true);\n    }\n\n    function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)\n        internal\n        virtual\n    {\n        assertEqCall(targetA, callDataA, targetB, callDataB, true);\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)\n        internal\n        virtual\n    {\n        assertEqCall(target, callDataA, target, callDataB, strictRevertData);\n    }\n\n    function assertEqCall(\n        address targetA,\n        bytes memory callDataA,\n        address targetB,\n        bytes memory callDataB,\n        bool strictRevertData\n    ) internal virtual {\n        (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);\n        (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);\n\n        if (successA && successB) {\n            assertEq(returnDataA, returnDataB, \"Call return data does not match\");\n        }\n\n        if (!successA && !successB && strictRevertData) {\n            assertEq(returnDataA, returnDataB, \"Call revert data does not match\");\n        }\n\n        if (!successA && successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call revert data\", returnDataA);\n            emit log_named_bytes(\" Right call return data\", returnDataB);\n            fail();\n        }\n\n        if (successA && !successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call return data\", returnDataA);\n            emit log_named_bytes(\" Right call revert data\", returnDataB);\n            fail();\n        }\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdChains.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n/**\n * StdChains provides information about EVM compatible chains that can be used in scripts/tests.\n * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are\n * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of\n * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the\n * alias used in this contract, which can be found as the first argument to the\n * `setChainWithDefaultRpcUrl` call in the `initialize` function.\n *\n * There are two main ways to use this contract:\n *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or\n *      `setChain(string memory chainAlias, Chain memory chain)`\n *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.\n *\n * The first time either of those are used, chains are initialized with the default set of RPC URLs.\n * This is done in `initialize`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in\n * `defaultRpcUrls`.\n *\n * The `setChain` function is straightforward, and it simply saves off the given chain data.\n *\n * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say\n * we want to retrieve `mainnet`'s RPC URL:\n *   - If you haven't set any mainnet chain info with `setChain`, you haven't specified that\n *     chain in `foundry.toml` and no env var is set, the default data and RPC URL will be returned.\n *   - If you have set a mainnet RPC URL in `foundry.toml` it will return that, if valid (e.g. if\n *     a URL is given or if an environment variable is given and that environment variable exists).\n *     Otherwise, the default data is returned.\n *   - If you specified data with `setChain` it will return that.\n *\n * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.\n */\nabstract contract StdChains {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private initialized;\n\n    struct ChainData {\n        string name;\n        uint256 chainId;\n        string rpcUrl;\n    }\n\n    struct Chain {\n        // The chain name.\n        string name;\n        // The chain's Chain ID.\n        uint256 chainId;\n        // The chain's alias. (i.e. what gets specified in `foundry.toml`).\n        string chainAlias;\n        // A default RPC endpoint for this chain.\n        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and\n        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy\n        // usage as you will be throttled and this is a disservice to others who need this endpoint.\n        string rpcUrl;\n    }\n\n    // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.\n    mapping(string => Chain) private chains;\n    // Maps from the chain's alias to it's default RPC URL.\n    mapping(string => string) private defaultRpcUrls;\n    // Maps from a chain ID to it's alias.\n    mapping(uint256 => string) private idToAlias;\n\n    bool private fallbackToDefaultRpcUrls = true;\n\n    // The RPC URL will be fetched from config or defaultRpcUrls if possible.\n    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {\n        require(bytes(chainAlias).length != 0, \"StdChains getChain(string): Chain alias cannot be the empty string.\");\n\n        initialize();\n        chain = chains[chainAlias];\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(string): Chain with alias \\\"\", chainAlias, \"\\\" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {\n        require(chainId != 0, \"StdChains getChain(uint256): Chain ID cannot be 0.\");\n        initialize();\n        string memory chainAlias = idToAlias[chainId];\n\n        chain = chains[chainAlias];\n\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(uint256): Chain with ID \", vm.toString(chainId), \" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {\n        require(\n            bytes(chainAlias).length != 0,\n            \"StdChains setChain(string,ChainData): Chain alias cannot be the empty string.\"\n        );\n\n        require(chain.chainId != 0, \"StdChains setChain(string,ChainData): Chain ID cannot be 0.\");\n\n        initialize();\n        string memory foundAlias = idToAlias[chain.chainId];\n\n        require(\n            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),\n            string(\n                abi.encodePacked(\n                    \"StdChains setChain(string,ChainData): Chain ID \",\n                    vm.toString(chain.chainId),\n                    \" already used by \\\"\",\n                    foundAlias,\n                    \"\\\".\"\n                )\n            )\n        );\n\n        uint256 oldChainId = chains[chainAlias].chainId;\n        delete idToAlias[oldChainId];\n\n        chains[chainAlias] =\n            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});\n        idToAlias[chain.chainId] = chainAlias;\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, Chain memory chain) internal virtual {\n        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));\n    }\n\n    function _toUpper(string memory str) private pure returns (string memory) {\n        bytes memory strb = bytes(str);\n        bytes memory copy = new bytes(strb.length);\n        for (uint256 i = 0; i < strb.length; i++) {\n            bytes1 b = strb[i];\n            if (b >= 0x61 && b <= 0x7A) {\n                copy[i] = bytes1(uint8(b) - 32);\n            } else {\n                copy[i] = b;\n            }\n        }\n        return string(copy);\n    }\n\n    // lookup rpcUrl, in descending order of priority:\n    // current -> config (foundry.toml) -> environment variable -> default\n    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain) private returns (Chain memory) {\n        if (bytes(chain.rpcUrl).length == 0) {\n            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {\n                chain.rpcUrl = configRpcUrl;\n            } catch (bytes memory err) {\n                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), \"_RPC_URL\"));\n                if (fallbackToDefaultRpcUrls) {\n                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);\n                } else {\n                    chain.rpcUrl = vm.envString(envName);\n                }\n                // distinguish 'not found' from 'cannot read'\n                bytes memory notFoundError =\n                    abi.encodeWithSignature(\"CheatCodeError\", string(abi.encodePacked(\"invalid rpc url \", chainAlias)));\n                if (keccak256(notFoundError) != keccak256(err) || bytes(chain.rpcUrl).length == 0) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, err), mload(err))\n                    }\n                }\n            }\n        }\n        return chain;\n    }\n\n    function setFallbackToDefaultRpcUrls(bool useDefault) internal {\n        fallbackToDefaultRpcUrls = useDefault;\n    }\n\n    function initialize() private {\n        if (initialized) return;\n\n        initialized = true;\n\n        // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`\n        setChainWithDefaultRpcUrl(\"anvil\", ChainData(\"Anvil\", 31337, \"http://127.0.0.1:8545\"));\n        setChainWithDefaultRpcUrl(\n            \"mainnet\", ChainData(\"Mainnet\", 1, \"https://mainnet.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"goerli\", ChainData(\"Goerli\", 5, \"https://goerli.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"sepolia\", ChainData(\"Sepolia\", 11155111, \"https://sepolia.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b\")\n        );\n        setChainWithDefaultRpcUrl(\"optimism\", ChainData(\"Optimism\", 10, \"https://mainnet.optimism.io\"));\n        setChainWithDefaultRpcUrl(\"optimism_goerli\", ChainData(\"Optimism Goerli\", 420, \"https://goerli.optimism.io\"));\n        setChainWithDefaultRpcUrl(\"arbitrum_one\", ChainData(\"Arbitrum One\", 42161, \"https://arb1.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"arbitrum_one_goerli\", ChainData(\"Arbitrum One Goerli\", 421613, \"https://goerli-rollup.arbitrum.io/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\"arbitrum_nova\", ChainData(\"Arbitrum Nova\", 42170, \"https://nova.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\"polygon\", ChainData(\"Polygon\", 137, \"https://polygon-rpc.com\"));\n        setChainWithDefaultRpcUrl(\n            \"polygon_mumbai\", ChainData(\"Polygon Mumbai\", 80001, \"https://rpc-mumbai.maticvigil.com\")\n        );\n        setChainWithDefaultRpcUrl(\"avalanche\", ChainData(\"Avalanche\", 43114, \"https://api.avax.network/ext/bc/C/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"avalanche_fuji\", ChainData(\"Avalanche Fuji\", 43113, \"https://api.avax-test.network/ext/bc/C/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain\", ChainData(\"BNB Smart Chain\", 56, \"https://bsc-dataseed1.binance.org\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain_testnet\",\n            ChainData(\"BNB Smart Chain Testnet\", 97, \"https://rpc.ankr.com/bsc_testnet_chapel\")\n        );\n        setChainWithDefaultRpcUrl(\"gnosis_chain\", ChainData(\"Gnosis Chain\", 100, \"https://rpc.gnosischain.com\"));\n    }\n\n    // set chain info, with priority to chainAlias' rpc url in foundry.toml\n    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {\n        string memory rpcUrl = chain.rpcUrl;\n        defaultRpcUrls[chainAlias] = rpcUrl;\n        chain.rpcUrl = \"\";\n        setChain(chainAlias, chain);\n        chain.rpcUrl = rpcUrl; // restore argument\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdCheats.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {Vm} from \"./Vm.sol\";\n\nabstract contract StdCheatsSafe {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private gasMeteringOff;\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawTx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        // json value name = function\n        string functionSig;\n        bytes32 hash;\n        // json value name = tx\n        RawTx1559Detail txDetail;\n        // json value name = type\n        string opcode;\n    }\n\n    struct RawTx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        bytes gas;\n        bytes nonce;\n        address to;\n        bytes txType;\n        bytes value;\n    }\n\n    struct Tx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        bytes32 hash;\n        Tx1559Detail txDetail;\n        string opcode;\n    }\n\n    struct Tx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 nonce;\n        address to;\n        uint256 txType;\n        uint256 value;\n    }\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct TxLegacy {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        string hash;\n        string opcode;\n        TxDetailLegacy transaction;\n    }\n\n    struct TxDetailLegacy {\n        AccessList[] accessList;\n        uint256 chainId;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 gasPrice;\n        bytes32 hash;\n        uint256 nonce;\n        bytes1 opcode;\n        bytes32 r;\n        bytes32 s;\n        uint256 txType;\n        address to;\n        uint8 v;\n        uint256 value;\n    }\n\n    struct AccessList {\n        address accessAddress;\n        bytes32[] storageKeys;\n    }\n\n    // Data structures to parse Receipt objects from the broadcast artifact.\n    // The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawReceipt {\n        bytes32 blockHash;\n        bytes blockNumber;\n        address contractAddress;\n        bytes cumulativeGasUsed;\n        bytes effectiveGasPrice;\n        address from;\n        bytes gasUsed;\n        RawReceiptLog[] logs;\n        bytes logsBloom;\n        bytes status;\n        address to;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n    }\n\n    struct Receipt {\n        bytes32 blockHash;\n        uint256 blockNumber;\n        address contractAddress;\n        uint256 cumulativeGasUsed;\n        uint256 effectiveGasPrice;\n        address from;\n        uint256 gasUsed;\n        ReceiptLog[] logs;\n        bytes logsBloom;\n        uint256 status;\n        address to;\n        bytes32 transactionHash;\n        uint256 transactionIndex;\n    }\n\n    // Data structures to parse the entire broadcast artifact, assuming the\n    // transactions conform to EIP1559.\n\n    struct EIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        Receipt[] receipts;\n        uint256 timestamp;\n        Tx1559[] transactions;\n        TxReturn[] txReturns;\n    }\n\n    struct RawEIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        RawReceipt[] receipts;\n        TxReturn[] txReturns;\n        uint256 timestamp;\n        RawTx1559[] transactions;\n    }\n\n    struct RawReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        bytes blockNumber;\n        bytes data;\n        bytes logIndex;\n        bool removed;\n        bytes32[] topics;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n        bytes transactionLogIndex;\n    }\n\n    struct ReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        uint256 blockNumber;\n        bytes data;\n        uint256 logIndex;\n        bytes32[] topics;\n        uint256 transactionIndex;\n        uint256 transactionLogIndex;\n        bool removed;\n    }\n\n    struct TxReturn {\n        string internalType;\n        string value;\n    }\n\n    function assumeNoPrecompiles(address addr) internal virtual {\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        assumeNoPrecompiles(addr, chainId);\n    }\n\n    function assumeNoPrecompiles(address addr, uint256 chainId) internal pure virtual {\n        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific\n        // address), but the same rationale for excluding them applies so we include those too.\n\n        // These should be present on all EVM-compatible chains.\n        vm.assume(addr < address(0x1) || addr > address(0x9));\n\n        // forgefmt: disable-start\n        if (chainId == 10 || chainId == 420) {\n            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21\n            vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));\n        } else if (chainId == 42161 || chainId == 421613) {\n            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains\n            vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));\n        } else if (chainId == 43114 || chainId == 43113) {\n            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59\n            vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));\n            vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));\n            vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));\n        }\n        // forgefmt: disable-end\n    }\n\n    function readEIP1559ScriptArtifact(string memory path)\n        internal\n        view\n        virtual\n        returns (EIP1559ScriptArtifact memory)\n    {\n        string memory data = vm.readFile(path);\n        bytes memory parsedData = vm.parseJson(data);\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\n        EIP1559ScriptArtifact memory artifact;\n        artifact.libraries = rawArtifact.libraries;\n        artifact.path = rawArtifact.path;\n        artifact.timestamp = rawArtifact.timestamp;\n        artifact.pending = rawArtifact.pending;\n        artifact.txReturns = rawArtifact.txReturns;\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\n        return artifact;\n    }\n\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\n        for (uint256 i; i < rawTxs.length; i++) {\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\n        }\n        return txs;\n    }\n\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {\n        Tx1559 memory transaction;\n        transaction.arguments = rawTx.arguments;\n        transaction.contractName = rawTx.contractName;\n        transaction.functionSig = rawTx.functionSig;\n        transaction.hash = rawTx.hash;\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\n        transaction.opcode = rawTx.opcode;\n        return transaction;\n    }\n\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\n        internal\n        pure\n        virtual\n        returns (Tx1559Detail memory)\n    {\n        Tx1559Detail memory txDetail;\n        txDetail.data = rawDetail.data;\n        txDetail.from = rawDetail.from;\n        txDetail.to = rawDetail.to;\n        txDetail.nonce = _bytesToUint(rawDetail.nonce);\n        txDetail.txType = _bytesToUint(rawDetail.txType);\n        txDetail.value = _bytesToUint(rawDetail.value);\n        txDetail.gas = _bytesToUint(rawDetail.gas);\n        txDetail.accessList = rawDetail.accessList;\n        return txDetail;\n    }\n\n    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".transactions\");\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\n        return rawToConvertedEIPTx1559s(rawTxs);\n    }\n\n    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".transactions[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\n        return rawToConvertedEIPTx1559(rawTx);\n    }\n\n    // Analogous to readTransactions, but for receipts.\n    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".receipts\");\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\n        return rawToConvertedReceipts(rawReceipts);\n    }\n\n    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".receipts[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\n        return rawToConvertedReceipt(rawReceipt);\n    }\n\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\n        for (uint256 i; i < rawReceipts.length; i++) {\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\n        }\n        return receipts;\n    }\n\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {\n        Receipt memory receipt;\n        receipt.blockHash = rawReceipt.blockHash;\n        receipt.to = rawReceipt.to;\n        receipt.from = rawReceipt.from;\n        receipt.contractAddress = rawReceipt.contractAddress;\n        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);\n        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);\n        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);\n        receipt.status = _bytesToUint(rawReceipt.status);\n        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);\n        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\n        receipt.logsBloom = rawReceipt.logsBloom;\n        receipt.transactionHash = rawReceipt.transactionHash;\n        return receipt;\n    }\n\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\n        internal\n        pure\n        virtual\n        returns (ReceiptLog[] memory)\n    {\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\n        for (uint256 i; i < rawLogs.length; i++) {\n            logs[i].logAddress = rawLogs[i].logAddress;\n            logs[i].blockHash = rawLogs[i].blockHash;\n            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);\n            logs[i].data = rawLogs[i].data;\n            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);\n            logs[i].topics = rawLogs[i].topics;\n            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);\n            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);\n            logs[i].removed = rawLogs[i].removed;\n        }\n        return logs;\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes): Deployment failed.\");\n    }\n\n    function deployCode(string memory what) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string): Deployment failed.\");\n    }\n\n    /// @dev deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes,uint256): Deployment failed.\");\n    }\n\n    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,uint256): Deployment failed.\");\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal virtual returns (address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    function deriveRememberKey(string memory mnemonic, uint32 index)\n        internal\n        virtual\n        returns (address who, uint256 privateKey)\n    {\n        privateKey = vm.deriveKey(mnemonic, index);\n        who = vm.rememberKey(privateKey);\n    }\n\n    function _bytesToUint(bytes memory b) private pure returns (uint256) {\n        require(b.length <= 32, \"StdCheats _bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    function isFork() internal view virtual returns (bool status) {\n        try vm.activeFork() {\n            status = true;\n        } catch (bytes memory) {}\n    }\n\n    modifier skipWhenForking() {\n        if (!isFork()) {\n            _;\n        }\n    }\n\n    modifier skipWhenNotForking() {\n        if (isFork()) {\n            _;\n        }\n    }\n\n    modifier noGasMetering() {\n        vm.pauseGasMetering();\n        // To prevent turning gas monitoring back on with nested functions that use this modifier,\n        // we check if gasMetering started in the off position. If it did, we don't want to turn\n        // it back on until we exit the top level function that used the modifier\n        //\n        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.\n        // funcA will have `gasStartedOff` as false, funcB will have it as true,\n        // so we only turn metering back on at the end of the funcA\n        bool gasStartedOff = gasMeteringOff;\n        gasMeteringOff = true;\n\n        _;\n\n        // if gas metering was on when this modifier was called, turn it back on at the end\n        if (!gasStartedOff) {\n            gasMeteringOff = false;\n            vm.resumeGasMetering();\n        }\n    }\n\n    // a cheat for fuzzing addresses that are payable only\n    // see https://github.com/foundry-rs/foundry/issues/3631\n    function assumePayable(address addr) internal virtual {\n        (bool success,) = payable(addr).call{value: 0}(\"\");\n        vm.assume(success);\n    }\n}\n\n// Wrappers around cheatcodes to avoid footguns\nabstract contract StdCheats is StdCheatsSafe {\n    using stdStorage for StdStorage;\n\n    StdStorage private stdstore;\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal virtual {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) internal virtual {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender, origin);\n    }\n\n    function hoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender);\n    }\n\n    function startHoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function startHoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function changePrank(address msgSender) internal virtual {\n        vm.stopPrank();\n        vm.startPrank(msgSender);\n    }\n\n    function changePrank(address msgSender, address txOrigin) internal virtual {\n        vm.stopPrank();\n        vm.startPrank(msgSender, txOrigin);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal virtual {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal virtual {\n        deal(token, to, give, false);\n    }\n\n    // Set the balance of an account for any ERC1155 token\n    // Use the alternative signature to update `totalSupply`\n    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {\n        dealERC1155(token, to, id, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);\n        }\n    }\n\n    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x00fdd58e, to, id));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0xbd85b039, id));\n            require(\n                totSupData.length != 0,\n                \"StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.\"\n            );\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);\n        }\n    }\n\n    function dealERC721(address token, address to, uint256 id) internal virtual {\n        // check if token id is already minted and the actual owner.\n        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));\n        require(successMinted, \"StdCheats deal(address,address,uint,bool): id not minted.\");\n\n        // get owner current balance\n        (, bytes memory fromBalData) = token.call(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));\n        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));\n\n        // get new user current balance\n        (, bytes memory toBalData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 toPrevBal = abi.decode(toBalData, (uint256));\n\n        // update balances\n        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);\n\n        // update owner\n        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdError.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n}\n"
    },
    "node_modules/forge-std/src/StdInvariant.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\ncontract StdInvariant {\n    struct FuzzSelector {\n        address addr;\n        bytes4[] selectors;\n    }\n\n    address[] private _excludedContracts;\n    address[] private _excludedSenders;\n    address[] private _targetedContracts;\n    address[] private _targetedSenders;\n\n    string[] private _excludedArtifacts;\n    string[] private _targetedArtifacts;\n\n    FuzzSelector[] private _targetedArtifactSelectors;\n    FuzzSelector[] private _targetedSelectors;\n\n    // Functions for users:\n    // These are intended to be called in tests.\n\n    function excludeContract(address newExcludedContract_) internal {\n        _excludedContracts.push(newExcludedContract_);\n    }\n\n    function excludeSender(address newExcludedSender_) internal {\n        _excludedSenders.push(newExcludedSender_);\n    }\n\n    function excludeArtifact(string memory newExcludedArtifact_) internal {\n        _excludedArtifacts.push(newExcludedArtifact_);\n    }\n\n    function targetArtifact(string memory newTargetedArtifact_) internal {\n        _targetedArtifacts.push(newTargetedArtifact_);\n    }\n\n    function targetArtifactSelector(FuzzSelector memory newTargetedArtifactSelector_) internal {\n        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);\n    }\n\n    function targetContract(address newTargetedContract_) internal {\n        _targetedContracts.push(newTargetedContract_);\n    }\n\n    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {\n        _targetedSelectors.push(newTargetedSelector_);\n    }\n\n    function targetSender(address newTargetedSender_) internal {\n        _targetedSenders.push(newTargetedSender_);\n    }\n\n    // Functions for forge:\n    // These are called by forge to run invariant tests and don't need to be called in tests.\n\n    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {\n        excludedArtifacts_ = _excludedArtifacts;\n    }\n\n    function excludeContracts() public view returns (address[] memory excludedContracts_) {\n        excludedContracts_ = _excludedContracts;\n    }\n\n    function excludeSenders() public view returns (address[] memory excludedSenders_) {\n        excludedSenders_ = _excludedSenders;\n    }\n\n    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {\n        targetedArtifacts_ = _targetedArtifacts;\n    }\n\n    function targetArtifactSelectors() public view returns (FuzzSelector[] memory targetedArtifactSelectors_) {\n        targetedArtifactSelectors_ = _targetedArtifactSelectors;\n    }\n\n    function targetContracts() public view returns (address[] memory targetedContracts_) {\n        targetedContracts_ = _targetedContracts;\n    }\n\n    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {\n        targetedSelectors_ = _targetedSelectors;\n    }\n\n    function targetSenders() public view returns (address[] memory targetedSenders_) {\n        targetedSenders_ = _targetedSenders;\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdJson.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n// Helpers for parsing and writing JSON files\n// To parse:\n// ```\n// using stdJson for string;\n// string memory json = vm.readFile(\"some_peth\");\n// json.parseUint(\"<json_path>\");\n// ```\n// To write:\n// ```\n// using stdJson for string;\n// string memory json = \"deploymentArtifact\";\n// Contract contract = new Contract();\n// json.serialize(\"contractAddress\", address(contract));\n// json = json.serialize(\"deploymentTimes\", uint(1));\n// // store the stringified JSON to the 'json' variable we have been using as a key\n// // as we won't need it any longer\n// string memory json2 = \"finalArtifact\";\n// string memory final = json2.serialize(\"depArtifact\", json);\n// final.write(\"<some_path>\");\n// ```\n\nlibrary stdJson {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {\n        return vm.parseJson(json, key);\n    }\n\n    function readUint(string memory json, string memory key) internal returns (uint256) {\n        return vm.parseJsonUint(json, key);\n    }\n\n    function readUintArray(string memory json, string memory key) internal returns (uint256[] memory) {\n        return vm.parseJsonUintArray(json, key);\n    }\n\n    function readInt(string memory json, string memory key) internal returns (int256) {\n        return vm.parseJsonInt(json, key);\n    }\n\n    function readIntArray(string memory json, string memory key) internal returns (int256[] memory) {\n        return vm.parseJsonIntArray(json, key);\n    }\n\n    function readBytes32(string memory json, string memory key) internal returns (bytes32) {\n        return vm.parseJsonBytes32(json, key);\n    }\n\n    function readBytes32Array(string memory json, string memory key) internal returns (bytes32[] memory) {\n        return vm.parseJsonBytes32Array(json, key);\n    }\n\n    function readString(string memory json, string memory key) internal returns (string memory) {\n        return vm.parseJsonString(json, key);\n    }\n\n    function readStringArray(string memory json, string memory key) internal returns (string[] memory) {\n        return vm.parseJsonStringArray(json, key);\n    }\n\n    function readAddress(string memory json, string memory key) internal returns (address) {\n        return vm.parseJsonAddress(json, key);\n    }\n\n    function readAddressArray(string memory json, string memory key) internal returns (address[] memory) {\n        return vm.parseJsonAddressArray(json, key);\n    }\n\n    function readBool(string memory json, string memory key) internal returns (bool) {\n        return vm.parseJsonBool(json, key);\n    }\n\n    function readBoolArray(string memory json, string memory key) internal returns (bool[] memory) {\n        return vm.parseJsonBoolArray(json, key);\n    }\n\n    function readBytes(string memory json, string memory key) internal returns (bytes memory) {\n        return vm.parseJsonBytes(json, key);\n    }\n\n    function readBytesArray(string memory json, string memory key) internal returns (bytes[] memory) {\n        return vm.parseJsonBytesArray(json, key);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function write(string memory jsonKey, string memory path) internal {\n        vm.writeJson(jsonKey, path);\n    }\n\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\n        vm.writeJson(jsonKey, path, valueKey);\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN) {\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n        }\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nstruct StdStorage {\n    mapping(address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping(address => mapping(bytes4 => mapping(bytes32 => bool))) finds;\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\nlibrary stdStorageSafe {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);\n    event WARNING_UninitedSlot(address who, uint256 slot);\n\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(StdStorage storage self) internal returns (uint256) {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        vm.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\n        }\n\n        (bytes32[] memory reads,) = vm.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = vm.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(\n                    false,\n                    \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\"\n                );\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                // store\n                vm.store(who, reads[i], bytes32(hex\"1337\"));\n                bool success;\n                bytes memory rdat;\n                {\n                    (success, rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32 * field_depth);\n                }\n\n                if (success && fdat == bytes32(hex\"1337\")) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    vm.store(who, reads[i], prev);\n                    break;\n                }\n                vm.store(who, reads[i], prev);\n            }\n        } else {\n            revert(\"stdStorage find(StdStorage): No storage use detected for target.\");\n        }\n\n        require(\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],\n            \"stdStorage find(StdStorage): Slot(s) not found.\"\n        );\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        address t = self._target;\n        uint256 s = find(self);\n        return abi.encode(vm.load(t, bytes32(s)));\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n\nlibrary stdStorage {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return stdStorageSafe.sigs(sigStr);\n    }\n\n    function find(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.find(self);\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        return stdStorageSafe.target(self, _target);\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, who);\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, amt);\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, key);\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        return stdStorageSafe.depth(self, _depth);\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(StdStorage storage self, bytes32 set) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\n        }\n        bytes32 curr = vm.load(who, slot);\n\n        if (fdat != curr) {\n            require(\n                false,\n                \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\"\n            );\n        }\n        vm.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return stdStorageSafe.read_bytes32(self);\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        return stdStorageSafe.read_bool(self);\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return stdStorageSafe.read_address(self);\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.read_uint(self);\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return stdStorageSafe.read_int(self);\n    }\n\n    // Private function so needs to be copied over\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    // Private function so needs to be copied over\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdStyle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nlibrary StdStyle {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    string constant RED = \"\\u001b[91m\";\n    string constant GREEN = \"\\u001b[92m\";\n    string constant YELLOW = \"\\u001b[93m\";\n    string constant BLUE = \"\\u001b[94m\";\n    string constant MAGENTA = \"\\u001b[95m\";\n    string constant CYAN = \"\\u001b[96m\";\n    string constant BOLD = \"\\u001b[1m\";\n    string constant DIM = \"\\u001b[2m\";\n    string constant ITALIC = \"\\u001b[3m\";\n    string constant UNDERLINE = \"\\u001b[4m\";\n    string constant INVERSE = \"\\u001b[7m\";\n    string constant RESET = \"\\u001b[0m\";\n\n    function styleConcat(string memory style, string memory self) private pure returns (string memory) {\n        return string(abi.encodePacked(style, self, RESET));\n    }\n\n    function red(string memory self) internal pure returns (string memory) {\n        return styleConcat(RED, self);\n    }\n\n    function red(uint256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(int256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(address self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(bool self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes(bytes memory self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes32(bytes32 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function green(string memory self) internal pure returns (string memory) {\n        return styleConcat(GREEN, self);\n    }\n\n    function green(uint256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(int256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(address self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(bool self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes(bytes memory self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes32(bytes32 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function yellow(string memory self) internal pure returns (string memory) {\n        return styleConcat(YELLOW, self);\n    }\n\n    function yellow(uint256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(int256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(address self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(bool self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes(bytes memory self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes32(bytes32 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function blue(string memory self) internal pure returns (string memory) {\n        return styleConcat(BLUE, self);\n    }\n\n    function blue(uint256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(int256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(address self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(bool self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes(bytes memory self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes32(bytes32 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function magenta(string memory self) internal pure returns (string memory) {\n        return styleConcat(MAGENTA, self);\n    }\n\n    function magenta(uint256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(int256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(address self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(bool self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes(bytes memory self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes32(bytes32 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function cyan(string memory self) internal pure returns (string memory) {\n        return styleConcat(CYAN, self);\n    }\n\n    function cyan(uint256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(int256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(address self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(bool self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes(bytes memory self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes32(bytes32 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function bold(string memory self) internal pure returns (string memory) {\n        return styleConcat(BOLD, self);\n    }\n\n    function bold(uint256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(int256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(address self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(bool self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes(bytes memory self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes32(bytes32 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function dim(string memory self) internal pure returns (string memory) {\n        return styleConcat(DIM, self);\n    }\n\n    function dim(uint256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(int256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(address self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(bool self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes(bytes memory self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes32(bytes32 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function italic(string memory self) internal pure returns (string memory) {\n        return styleConcat(ITALIC, self);\n    }\n\n    function italic(uint256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(int256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(address self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(bool self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes(bytes memory self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes32(bytes32 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function underline(string memory self) internal pure returns (string memory) {\n        return styleConcat(UNDERLINE, self);\n    }\n\n    function underline(uint256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(int256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(address self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(bool self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes(bytes memory self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes32(bytes32 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function inverse(string memory self) internal pure returns (string memory) {\n        return styleConcat(INVERSE, self);\n    }\n\n    function inverse(uint256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(int256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(address self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(bool self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes(bytes memory self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes32(bytes32 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {IMulticall3} from \"./interfaces/IMulticall3.sol\";\n// TODO Remove import.\nimport {VmSafe} from \"./Vm.sol\";\n\nabstract contract StdUtils {\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTANTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n    uint256 private constant INT256_MIN_ABS =\n        57896044618658097711785492504343953926634992332820282019728792003956564819968;\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\n        require(min <= max, \"StdUtils bound(uint256,uint256,uint256): Max is less than min.\");\n        // If x is between min and max, return x directly. This is to ensure that dictionary values\n        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188\n        if (x >= min && x <= max) return x;\n\n        uint256 size = max - min + 1;\n\n        // If the value is 0, 1, 2, 3, warp that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.\n        // This helps ensure coverage of the min/max values.\n        if (x <= 3 && size > x) return min + x;\n        if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);\n\n        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.\n        if (x > max) {\n            uint256 diff = x - max;\n            uint256 rem = diff % size;\n            if (rem == 0) return max;\n            result = min + rem - 1;\n        } else if (x < min) {\n            uint256 diff = min - x;\n            uint256 rem = diff % size;\n            if (rem == 0) return min;\n            result = max - rem + 1;\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal view virtual returns (uint256 result) {\n        result = _bound(x, min, max);\n        console2_log(\"Bound Result\", result);\n    }\n\n    function bound(int256 x, int256 min, int256 max) internal view virtual returns (int256 result) {\n        require(min <= max, \"StdUtils bound(int256,int256,int256): Max is less than min.\");\n\n        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:\n        // int256 : -(2**255) ~ (2**255 - 1)\n        // uint256:     0     ~ (2**256 - 1)\n        // So, add 2**255, INT256_MIN_ABS to the integer values.\n        //\n        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.\n        // So, use `~uint256(x) + 1` instead.\n        uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);\n        uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);\n        uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);\n\n        uint256 y = _bound(_x, _min, _max);\n\n        // To move it back to int256 value, subtract INT256_MIN_ABS at here.\n        result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);\n        console2_log(\"Bound result\", vm.toString(result));\n    }\n\n    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {\n        require(b.length <= 32, \"StdUtils bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\n    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {\n        // forgefmt: disable-start\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\n        // A one byte integer uses its own value as its length prefix, there is no additional \"0x80 + length\" prefix that comes before it.\n        if (nonce == 0x00)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));\n        if (nonce <= 0x7f)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));\n\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\n        if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));\n        if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));\n        if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));\n        // forgefmt: disable-end\n\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\n        return addressFromLast20Bytes(\n            keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce)))\n        );\n    }\n\n    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)\n        internal\n        pure\n        virtual\n        returns (address)\n    {\n        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initcodeHash)));\n    }\n\n    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {\n        return computeCreate2Address(salt, initCodeHash, CREATE2_FACTORY);\n    }\n\n    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {\n        return hashInitCode(creationCode, \"\");\n    }\n\n    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    /// @param args the ABI-encoded arguments to the constructor of C\n    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(creationCode, args));\n    }\n\n    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.\n    function getTokenBalances(address token, address[] memory addresses)\n        internal\n        virtual\n        returns (uint256[] memory balances)\n    {\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdUtils getTokenBalances(address,address[]): Token address is not a contract.\");\n\n        // ABI encode the aggregate call to Multicall3.\n        uint256 length = addresses.length;\n        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            // 0x70a08231 = bytes4(\"balanceOf(address)\"))\n            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});\n        }\n\n        // Make the aggregate call.\n        (, bytes[] memory returnData) = multicall.aggregate(calls);\n\n        // ABI decode the return data and return the balances.\n        balances = new uint256[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            balances[i] = abi.decode(returnData[i], (uint256));\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.\n\n    function console2_log(string memory p0, uint256 p1) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n        status;\n    }\n\n    function console2_log(string memory p0, string memory p1) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n        status;\n    }\n}\n"
    },
    "node_modules/forge-std/src/Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n// 💬 ABOUT\n// Standard Library's default Test\n\n// 🧩 MODULES\nimport {console} from \"./console.sol\";\nimport {console2} from \"./console2.sol\";\nimport {StdAssertions} from \"./StdAssertions.sol\";\nimport {StdChains} from \"./StdChains.sol\";\nimport {StdCheats} from \"./StdCheats.sol\";\nimport {stdError} from \"./StdError.sol\";\nimport {StdInvariant} from \"./StdInvariant.sol\";\nimport {stdJson} from \"./StdJson.sol\";\nimport {stdMath} from \"./StdMath.sol\";\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {StdUtils} from \"./StdUtils.sol\";\nimport {Vm} from \"./Vm.sol\";\nimport {StdStyle} from \"./StdStyle.sol\";\n\n// 📦 BOILERPLATE\nimport {TestBase} from \"./Base.sol\";\nimport {DSTest} from \"ds-test/test.sol\";\n\n// ⭐️ TEST\nabstract contract Test is DSTest, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils, TestBase {\n// Note: IS_TEST() must return true.\n// Note: Must have failure system, https://github.com/dapphub/ds-test/blob/cd98eff28324bfac652e63a239a60632a761790b/src/test.sol#L39-L76.\n}\n"
    },
    "node_modules/forge-std/src/Vm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n// Cheatcodes are marked as view/pure/none using the following rules:\n// 0. A call's observable behaviour includes its return value, logs, reverts and state writes,\n// 1. If you can influence a later call's observable behaviour, you're neither `view` nor `pure (you are modifying some state be it the EVM, interpreter, filesystem, etc),\n// 2. Otherwise if you can be influenced by an earlier call, or if reading some state, you're `view`,\n// 3. Otherwise you're `pure`.\n\ninterface VmSafe {\n    struct Log {\n        bytes32[] topics;\n        bytes data;\n        address emitter;\n    }\n\n    struct Rpc {\n        string key;\n        string url;\n    }\n\n    struct FsMetadata {\n        bool isDir;\n        bool isSymlink;\n        uint256 length;\n        bool readOnly;\n        uint256 modified;\n        uint256 accessed;\n        uint256 created;\n    }\n\n    // Loads a storage slot from an address\n    function load(address target, bytes32 slot) external view returns (bytes32 data);\n    // Signs data\n    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n    // Gets the address for a given private key\n    function addr(uint256 privateKey) external pure returns (address keyAddr);\n    // Gets the nonce of an account\n    function getNonce(address account) external view returns (uint64 nonce);\n    // Performs a foreign function call via the terminal\n    function ffi(string[] calldata commandInput) external returns (bytes memory result);\n    // Sets environment variables\n    function setEnv(string calldata name, string calldata value) external;\n    // Reads environment variables, (name) => (value)\n    function envBool(string calldata name) external view returns (bool value);\n    function envUint(string calldata name) external view returns (uint256 value);\n    function envInt(string calldata name) external view returns (int256 value);\n    function envAddress(string calldata name) external view returns (address value);\n    function envBytes32(string calldata name) external view returns (bytes32 value);\n    function envString(string calldata name) external view returns (string memory value);\n    function envBytes(string calldata name) external view returns (bytes memory value);\n    // Reads environment variables as arrays\n    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);\n    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);\n    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);\n    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);\n    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);\n    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);\n    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);\n    // Read environment variables with default value\n    function envOr(string calldata name, bool defaultValue) external returns (bool value);\n    function envOr(string calldata name, uint256 defaultValue) external returns (uint256 value);\n    function envOr(string calldata name, int256 defaultValue) external returns (int256 value);\n    function envOr(string calldata name, address defaultValue) external returns (address value);\n    function envOr(string calldata name, bytes32 defaultValue) external returns (bytes32 value);\n    function envOr(string calldata name, string calldata defaultValue) external returns (string memory value);\n    function envOr(string calldata name, bytes calldata defaultValue) external returns (bytes memory value);\n    // Read environment variables as arrays with default value\n    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)\n        external\n        returns (bool[] memory value);\n    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)\n        external\n        returns (uint256[] memory value);\n    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)\n        external\n        returns (int256[] memory value);\n    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)\n        external\n        returns (address[] memory value);\n    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)\n        external\n        returns (bytes32[] memory value);\n    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)\n        external\n        returns (string[] memory value);\n    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)\n        external\n        returns (bytes[] memory value);\n    // Records all storage reads and writes\n    function record() external;\n    // Gets all accessed reads and write slot from a recording session, for a given address\n    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);\n    // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);\n    // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);\n    // Labels an address in call traces\n    function label(address account, string calldata newLabel) external;\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n    function broadcast() external;\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n    function broadcast(address signer) external;\n    // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain\n    function broadcast(uint256 privateKey) external;\n    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast() external;\n    // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain\n    function startBroadcast(address signer) external;\n    // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain\n    function startBroadcast(uint256 privateKey) external;\n    // Stops collecting onchain transactions\n    function stopBroadcast() external;\n    // Reads the entire content of file to string\n    function readFile(string calldata path) external view returns (string memory data);\n    // Reads the entire content of file as binary. Path is relative to the project root.\n    function readFileBinary(string calldata path) external view returns (bytes memory data);\n    // Get the path of the current project root\n    function projectRoot() external view returns (string memory path);\n    // Get the metadata for a file/directory\n    function fsMetadata(string calldata fileOrDir) external returns (FsMetadata memory metadata);\n    // Reads next line of file to string\n    function readLine(string calldata path) external view returns (string memory line);\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    function writeFile(string calldata path, string calldata data) external;\n    // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // Path is relative to the project root.\n    function writeFileBinary(string calldata path, bytes calldata data) external;\n    // Writes line to file, creating a file if it does not exist.\n    function writeLine(string calldata path, string calldata data) external;\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    function closeFile(string calldata path) external;\n    // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - Path points to a directory.\n    // - The file doesn't exist.\n    // - The user lacks permissions to remove the file.\n    function removeFile(string calldata path) external;\n    // Convert values to a string\n    function toString(address value) external pure returns (string memory stringifiedValue);\n    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);\n    function toString(bytes32 value) external pure returns (string memory stringifiedValue);\n    function toString(bool value) external pure returns (string memory stringifiedValue);\n    function toString(uint256 value) external pure returns (string memory stringifiedValue);\n    function toString(int256 value) external pure returns (string memory stringifiedValue);\n    // Convert values from a string\n    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);\n    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);\n    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);\n    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);\n    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);\n    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);\n    // Record all the transaction logs\n    function recordLogs() external;\n    // Gets all the recorded logs\n    function getRecordedLogs() external returns (Log[] memory logs);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at {derivationPath}{index}\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)\n        external\n        pure\n        returns (uint256 privateKey);\n    // Adds a private key to the local forge wallet and returns the address\n    function rememberKey(uint256 privateKey) external returns (address keyAddr);\n    //\n    // parseJson\n    //\n    // ----\n    // In case the returned value is a JSON object, it's encoded as a ABI-encoded tuple. As JSON objects\n    // don't have the notion of ordered, but tuples do, they JSON object is encoded with it's fields ordered in\n    // ALPHABETICAL order. That means that in order to successfully decode the tuple, we need to define a tuple that\n    // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded\n    // as tuples, with the attributes in the order in which they are defined.\n    // For example: json = { 'a': 1, 'b': 0xa4tb......3xs}\n    // a: uint256\n    // b: address\n    // To decode that json, we need to define a struct or a tuple as follows:\n    // struct json = { uint256 a; address b; }\n    // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to\n    // decode the tuple in that order, and thus fail.\n    // ----\n    // Given a string of JSON, return it as ABI-encoded\n    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);\n    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);\n\n    // The following parseJson cheatcodes will do type coercion, for the type that they indicate.\n    // For example, parseJsonUint will coerce all values to a uint256. That includes stringified numbers '12'\n    // and hex numbers '0xEF'.\n    // Type coercion works ONLY for discrete values or arrays. That means that the key must return a value or array, not\n    // a JSON object.\n    function parseJsonUint(string calldata, string calldata) external returns (uint256);\n    function parseJsonUintArray(string calldata, string calldata) external returns (uint256[] memory);\n    function parseJsonInt(string calldata, string calldata) external returns (int256);\n    function parseJsonIntArray(string calldata, string calldata) external returns (int256[] memory);\n    function parseJsonBool(string calldata, string calldata) external returns (bool);\n    function parseJsonBoolArray(string calldata, string calldata) external returns (bool[] memory);\n    function parseJsonAddress(string calldata, string calldata) external returns (address);\n    function parseJsonAddressArray(string calldata, string calldata) external returns (address[] memory);\n    function parseJsonString(string calldata, string calldata) external returns (string memory);\n    function parseJsonStringArray(string calldata, string calldata) external returns (string[] memory);\n    function parseJsonBytes(string calldata, string calldata) external returns (bytes memory);\n    function parseJsonBytesArray(string calldata, string calldata) external returns (bytes[] memory);\n    function parseJsonBytes32(string calldata, string calldata) external returns (bytes32);\n    function parseJsonBytes32Array(string calldata, string calldata) external returns (bytes32[] memory);\n\n    // Serialize a key and value to a JSON object stored in-memory that can be later written to a file\n    // It returns the stringified version of the specific JSON file up to that moment.\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)\n        external\n        returns (string memory json);\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)\n        external\n        returns (string memory json);\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)\n        external\n        returns (string memory json);\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)\n        external\n        returns (string memory json);\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)\n        external\n        returns (string memory json);\n    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)\n        external\n        returns (string memory json);\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)\n        external\n        returns (string memory json);\n\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)\n        external\n        returns (string memory json);\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)\n        external\n        returns (string memory json);\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)\n        external\n        returns (string memory json);\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)\n        external\n        returns (string memory json);\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)\n        external\n        returns (string memory json);\n    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)\n        external\n        returns (string memory json);\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)\n        external\n        returns (string memory json);\n\n    //\n    // writeJson\n    //\n    // ----\n    // Write a serialized JSON object to a file. If the file exists, it will be overwritten.\n    // Let's assume we want to write the following JSON to a file:\n    //\n    // { \"boolean\": true, \"number\": 342, \"object\": { \"title\": \"finally json serialization\" } }\n    //\n    // ```\n    //  string memory json1 = \"some key\";\n    //  vm.serializeBool(json1, \"boolean\", true);\n    //  vm.serializeBool(json1, \"number\", uint256(342));\n    //  json2 = \"some other key\";\n    //  string memory output = vm.serializeString(json2, \"title\", \"finally json serialization\");\n    //  string memory finalJson = vm.serialize(json1, \"object\", output);\n    //  vm.writeJson(finalJson, \"./output/example.json\");\n    // ```\n    // The critical insight is that every invocation of serialization will return the stringified version of the JSON\n    // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version\n    // to serialize them as values to another JSON object.\n    //\n    // json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)\n    // will find the object in-memory that is keyed by \"some key\".\n    function writeJson(string calldata json, string calldata path) external;\n    // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key>\n    // This is useful to replace a specific value of a JSON file, without having to parse the entire thing\n    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;\n    // Returns the RPC url for the given alias\n    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);\n    // Returns all rpc urls and their aliases `[alias, url][]`\n    function rpcUrls() external view returns (string[2][] memory urls);\n    // Returns all rpc urls and their aliases as structs.\n    function rpcUrlStructs() external view returns (Rpc[] memory urls);\n    // If the condition is false, discard this run's fuzz inputs and generate new ones.\n    function assume(bool condition) external pure;\n    // Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.\n    function pauseGasMetering() external;\n    // Resumes gas metering (i.e. gas usage is counted again). Noop if already on.\n    function resumeGasMetering() external;\n}\n\ninterface Vm is VmSafe {\n    // Sets block.timestamp\n    function warp(uint256 newTimestamp) external;\n    // Sets block.height\n    function roll(uint256 newHeight) external;\n    // Sets block.basefee\n    function fee(uint256 newBasefee) external;\n    // Sets block.difficulty\n    function difficulty(uint256 newDifficulty) external;\n    // Sets block.chainid\n    function chainId(uint256 newChainId) external;\n    // Stores a value to an address' storage slot.\n    function store(address target, bytes32 slot, bytes32 value) external;\n    // Sets the nonce of an account; must be higher than the current nonce of the account\n    function setNonce(address account, uint64 newNonce) external;\n    // Sets the *next* call's msg.sender to be the input address\n    function prank(address msgSender) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n    function startPrank(address msgSender) external;\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n    function prank(address msgSender, address txOrigin) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n    function startPrank(address msgSender, address txOrigin) external;\n    // Resets subsequent calls' msg.sender to be `address(this)`\n    function stopPrank() external;\n    // Sets an address' balance\n    function deal(address account, uint256 newBalance) external;\n    // Sets an address' code\n    function etch(address target, bytes calldata newRuntimeBytecode) external;\n    // Expects an error on next call\n    function expectRevert(bytes calldata revertData) external;\n    function expectRevert(bytes4 revertData) external;\n    function expectRevert() external;\n\n    // Prepare an expected log with all four checks enabled.\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data.\n    // Second form also checks supplied address against emitting contract.\n    function expectEmit() external;\n    function expectEmit(address emitter) external;\n\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n    // Second form also checks supplied address against emitting contract.\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)\n        external;\n\n    // Mocks a call to an address, returning specified data.\n    // Calldata can either be strict or a partial match, e.g. if you only\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\n    // function will be mocked.\n    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;\n    // Mocks a call to an address with a specific msg.value, returning specified data.\n    // Calldata match takes precedence over msg.value in case of ambiguity.\n    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;\n    // Clears all mocked calls\n    function clearMockedCalls() external;\n    // Expects a call to an address with the specified calldata.\n    // Calldata can either be a strict or a partial match\n    function expectCall(address callee, bytes calldata data) external;\n    // Expects a call to an address with the specified msg.value and calldata\n    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;\n    // Expect a call to an address with the specified msg.value, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;\n    // Expect a call to an address with the specified msg.value and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;\n    // Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the current subcontext. If any other\n    // memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.\n    function expectSafeMemory(uint64 min, uint64 max) external;\n    // Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the next created subcontext.\n    // If any other memory is written to, the test will fail. Can be called multiple times to add more ranges\n    // to the set.\n    function expectSafeMemoryCall(uint64 min, uint64 max) external;\n    // Sets block.coinbase\n    function coinbase(address newCoinbase) external;\n    // Snapshot the current state of the evm.\n    // Returns the id of the snapshot that was created.\n    // To revert a snapshot use `revertTo`\n    function snapshot() external returns (uint256 snapshotId);\n    // Revert the state of the EVM to a previous snapshot\n    // Takes the snapshot id to revert to.\n    // This deletes the snapshot and all snapshots taken after the given snapshot id.\n    function revertTo(uint256 snapshotId) external returns (bool success);\n    // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);\n    // Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction,\n    // and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n    // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before\n    // the transaction, returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);\n    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256 forkId) external;\n    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.\n    function activeFork() external view returns (uint256 forkId);\n    // Updates the currently active fork to given block number\n    // This is similar to `roll` but for the currently active fork\n    function rollFork(uint256 blockNumber) external;\n    // Updates the currently active fork to given transaction\n    // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block\n    function rollFork(bytes32 txHash) external;\n    // Updates the given fork to given block number\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n    // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block\n    function rollFork(uint256 forkId, bytes32 txHash) external;\n    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    // Meaning, changes made to the state of this account will be kept when switching forks\n    function makePersistent(address account) external;\n    function makePersistent(address account0, address account1) external;\n    function makePersistent(address account0, address account1, address account2) external;\n    function makePersistent(address[] calldata accounts) external;\n    // Revokes persistent status from the address, previously added via `makePersistent`\n    function revokePersistent(address account) external;\n    function revokePersistent(address[] calldata accounts) external;\n    // Returns true if the account is marked as persistent\n    function isPersistent(address account) external view returns (bool persistent);\n    // In forking mode, explicitly grant the given address cheatcode access\n    function allowCheatcodes(address account) external;\n    // Fetches the given transaction from the active fork and executes it on the current state\n    function transact(bytes32 txHash) external;\n    // Fetches the given transaction from the given fork and executes it on the current state\n    function transact(uint256 forkId, bytes32 txHash) external;\n}\n"
    },
    "node_modules/forge-std/src/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "node_modules/forge-std/src/console2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n/// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should\n/// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n/// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n/// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n/// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, int256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,int256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "node_modules/forge-std/src/interfaces/IMulticall3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\ninterface IMulticall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    function aggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes[] memory returnData);\n\n    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function blockAndAggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n\n    function getBasefee() external view returns (uint256 basefee);\n\n    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);\n\n    function getBlockNumber() external view returns (uint256 blockNumber);\n\n    function getChainId() external view returns (uint256 chainid);\n\n    function getCurrentBlockCoinbase() external view returns (address coinbase);\n\n    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);\n\n    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);\n\n    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);\n\n    function getEthBalance(address addr) external view returns (uint256 balance);\n\n    function getLastBlockHash() external view returns (bytes32 blockHash);\n\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (Result[] memory returnData);\n\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@openzeppelin/=node_modules/@openzeppelin/",
      "@openzeppelin/contracts-upgradeable/=node_modules/@openzeppelin/contracts-upgradeable/",
      "@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/",
      "@rari-capital/=node_modules/@rari-capital/",
      "@rari-capital/solmate/=node_modules/@rari-capital/solmate/",
      "ds-test/=node_modules/ds-test/src/",
      "forge-std/=node_modules/forge-std/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "metadata": {
      "bytecodeHash": "none"
    },
    "outputSelection": {
      "*": {
        "": [
          "ast"
        ],
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}
