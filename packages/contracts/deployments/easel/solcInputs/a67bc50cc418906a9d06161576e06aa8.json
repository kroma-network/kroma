{
  "language": "Solidity",
  "sources": {
    "contracts/L1/Colosseum.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { Types } from \"../libraries/Types.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { L2OutputOracle } from \"./L2OutputOracle.sol\";\nimport { ZKVerifier } from \"./ZKVerifier.sol\";\n\ncontract Colosseum is Initializable, Semver {\n    /**\n     * @notice enum of challenge status.\n     *\n     * See the https://github.com/kroma-network/kroma/blob/dev/specs/challenge.md#state-diagram for more details.\n     *\n     * Belows are possible state transitions at current implementation.\n     * TODO: add PROOF_VERIFIED state.\n     *\n     *  1) NONE               → createChallenge()                   → ASSERTER_TURN\n     *  2) ASSERTER_TURN      → bisect()                            → ASSERTER_TURN\n     *  3) ASSERTER_TURN      → on asserter timeout                 → ASSERTER_TIMEOUT\n     *  4) CHALLENGER_TURN    → when isAbleToBisect() returns false → READY_TO_PROVE\n     *  5) CHALLENGER_TURN    → on challenger timeout               → CHALLENGER_TIMEOUT\n     *  6) ASSERTER_TIMEOUT   → asserterTimeout()                   → CLOSED\n     *  7) ASSERTER_TIMEOUT   → on challenger timeout               → CHALLENGER_TIMEOUT\n     *  8) READY_TO_PROVE     → when proveFault() succeeds          → CLOSED\n     *  9) READY_TO_PROVE     → on challenger timeout               → CHALLENGER_TIMEOUT\n     * 10) CHALLENGER_TIMEOUT → challengerTimeout()                 → CLOSED\n     */\n    enum ChallengeStatus {\n        NONE,\n        CHALLENGER_TURN,\n        ASSERTER_TURN,\n        CHALLENGER_TIMEOUT,\n        ASSERTER_TIMEOUT,\n        READY_TO_PROVE\n    }\n\n    enum ValidateTurnMode {\n        NORMAL,\n        PROOF\n    }\n\n    /**\n     * @notice Address of the L2OutputOracle.\n     */\n    L2OutputOracle public immutable L2_ORACLE;\n\n    /**\n     * @notice Address of the ZKVerifier.\n     */\n    ZKVerifier public immutable ZK_VERIFIER;\n\n    /**\n     * @notice Timeout seconds for the challenge.\n     */\n    uint256 public immutable CHALLENGE_TIMEOUT;\n\n    /**\n     * @notice The interval in L2 blocks at which checkpoints must be\n     *         submitted on L2OutputOracle contract.\n     */\n    uint256 public immutable L2_ORACLE_SUBMISSION_INTERVAL;\n\n    /**\n     * @notice Length of segment array for each turn.\n     */\n    mapping(uint256 => uint256) internal segmentsLengths;\n\n    /**\n     * @notice A mapping of challenge.\n     */\n    mapping(uint256 => Types.Challenge) public challenges;\n\n    /**\n     * @notice The number of the most recent challenge created by this contract.\n     */\n    uint256 public latestChallengeId;\n\n    event ChallengeCreated(\n        uint256 indexed challengeId,\n        address indexed challenger,\n        uint256 indexed outputIndex,\n        uint256 timestamp\n    );\n\n    event Bisected(uint256 indexed challengeId, uint256 turn, uint256 timestamp);\n    event ProofCompleted(uint256 indexed challengeId, uint256 outputIndex);\n    event Closed(uint256 indexed challengeId, uint256 turn, uint256 timestamp);\n\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _l2Oracle                  Address of the L2OutputOracle contract.\n     * @param _zkVerifier                Address of the ZKVerifier contract.\n     * @param _challengeTimeout          Timeout seconds for the challenge.\n     * @param _segmentsLengths           Lengths of segments.\n     */\n    constructor(\n        L2OutputOracle _l2Oracle,\n        ZKVerifier _zkVerifier,\n        uint256 _submissionInterval,\n        uint256 _challengeTimeout,\n        uint256[] memory _segmentsLengths\n    ) Semver(0, 1, 0) {\n        L2_ORACLE = _l2Oracle;\n        ZK_VERIFIER = _zkVerifier;\n        CHALLENGE_TIMEOUT = _challengeTimeout;\n        L2_ORACLE_SUBMISSION_INTERVAL = _submissionInterval;\n        initialize(_segmentsLengths);\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize(uint256[] memory _segmentsLengths) public initializer {\n        _setSegmentsLengths(_segmentsLengths);\n    }\n\n    function createChallenge(uint256 _outputIndex, bytes32[] calldata _segments) external payable {\n        // TODO(pangssu): Currently, only one task can be opened. It is necessary to\n        //                consider holding multiple challenges at the same time.\n        require(!isInProgress(), \"Colosseum: previous challenge is in progress\");\n\n        Types.CheckpointOutput memory targetOutput = L2_ORACLE.getL2Output(_outputIndex);\n        require(targetOutput.l2BlockNumber != 0, \"Colosseum: output not found\");\n        Types.CheckpointOutput memory prevOutput;\n        if (_outputIndex > 0) {\n            prevOutput = L2_ORACLE.getL2Output(_outputIndex - 1);\n        }\n\n        _validateSegments(1, prevOutput.outputRoot, targetOutput.outputRoot, _segments);\n\n        uint256 challengeId = latestChallengeId + 1;\n        Types.Challenge storage challenge = challenges[challengeId];\n\n        _updateSegments(\n            challenge,\n            _segments,\n            prevOutput.l2BlockNumber,\n            targetOutput.l2BlockNumber - prevOutput.l2BlockNumber\n        );\n\n        challenge.outputIndex = _outputIndex;\n        challenge.turn = 1;\n        challenge.current = msg.sender;\n        challenge.next = L2_ORACLE.VALIDATOR();\n        challenge.timeoutAt = block.timestamp + CHALLENGE_TIMEOUT;\n\n        latestChallengeId = challengeId;\n\n        emit ChallengeCreated(challengeId, msg.sender, _outputIndex, block.timestamp);\n    }\n\n    function bisect(uint256 _pos, bytes32[] calldata _segments) external payable {\n        uint256 challengeId = latestChallengeId;\n        Types.Challenge storage challenge = challenges[challengeId];\n\n        _validateTurn(challenge, ValidateTurnMode.NORMAL);\n\n        uint256 newTurn = challenge.turn + 1;\n\n        _validateSegments(\n            newTurn,\n            challenge.segments[_pos],\n            challenge.segments[_pos + 1],\n            _segments\n        );\n\n        uint256 segSize = _calcSegSize(challenge.segSize, newTurn - 1);\n        uint256 segStart = challenge.segStart + _pos * segSize;\n\n        _updateSegments(challenge, _segments, segStart, segSize);\n\n        challenge.turn = newTurn;\n        challenge.next = challenge.current;\n        challenge.current = msg.sender;\n        challenge.timeoutAt = block.timestamp + CHALLENGE_TIMEOUT;\n\n        emit Bisected(challengeId, newTurn, block.timestamp);\n    }\n\n    function proveFault(\n        uint256 _pos,\n        bytes32 _outputRoot,\n        uint256[] calldata _proof,\n        uint256[] calldata _pair\n    ) external payable {\n        uint256 challengeId = latestChallengeId;\n        Types.Challenge storage challenge = challenges[challengeId];\n        _validateTurn(challenge, ValidateTurnMode.PROOF);\n\n        require(\n            challenge.segments[_pos + 1] != _outputRoot,\n            \"Colosseum: the last segment must not be matched\"\n        );\n        require(ZK_VERIFIER.verify(_proof, _pair), \"Colosseum: invalid proof\");\n\n        L2_ORACLE.deleteL2Outputs(challenge.outputIndex);\n        emit ProofCompleted(challengeId, challenge.outputIndex);\n        _closeChallenge(challengeId, challenge);\n    }\n\n    function asserterTimeout() external {\n        uint256 challengeId = latestChallengeId;\n        Types.Challenge storage challenge = challenges[challengeId];\n        _validateTurn(challenge, ValidateTurnMode.NORMAL);\n        L2_ORACLE.deleteL2Outputs(challenge.outputIndex);\n        _closeChallenge(challengeId, challenge);\n    }\n\n    function challengerTimeout(uint256 _challengeId) external {\n        Types.Challenge storage challenge = challenges[_challengeId];\n        _validateTurn(challenge, ValidateTurnMode.NORMAL);\n        _closeChallenge(_challengeId, challenge);\n    }\n\n    function _validateTurn(Types.Challenge storage _challenge, ValidateTurnMode _mode)\n        private\n        view\n    {\n        ChallengeStatus status = _challengeStatus(_challenge);\n        require(status != ChallengeStatus.NONE, \"Colosseum: challenge not found\");\n\n        address expectedSender = _isTimedOut(status) ? _challenge.current : _challenge.next;\n        require(expectedSender == msg.sender, \"Colosseum: not your turn\");\n\n        if (_mode == ValidateTurnMode.PROOF) {\n            require(status == ChallengeStatus.READY_TO_PROVE, \"Colosseum: not ready to prove\");\n        }\n    }\n\n    function _validateSegments(\n        uint256 _turn,\n        bytes32 _prevFirst,\n        bytes32 _prevLast,\n        bytes32[] memory _segments\n    ) private view {\n        uint256 segLen = _segments.length;\n\n        require(getSegmentsLength(_turn) == segLen, \"Colosseum: invalid segments length\");\n        require(_prevFirst == _segments[0], \"Colosseum: the first segment must be matched\");\n        require(\n            _prevLast != _segments[segLen - 1],\n            \"Colosseum: the last segment must not be matched\"\n        );\n    }\n\n    function _updateSegments(\n        Types.Challenge storage _challenge,\n        bytes32[] memory _segments,\n        uint256 _segStart,\n        uint256 _segSize\n    ) private {\n        _challenge.segments = _segments;\n        _challenge.segStart = _segStart;\n        _challenge.segSize = _segSize;\n    }\n\n    function _setSegmentsLengths(uint256[] memory _segmentsLengths) private {\n        // _segmentsLengths length should be an even number in order to let challenger submit\n        // invalidity proof at the last turn.\n        require(\n            _segmentsLengths.length % 2 == 0,\n            \"Colosseum: length of segments lengths cannot be odd number.\"\n        );\n\n        uint256 sum = 1;\n        for (uint256 i = 0; i < _segmentsLengths.length; i++) {\n            segmentsLengths[i] = _segmentsLengths[i];\n            sum = sum * (_segmentsLengths[i] - 1);\n        }\n\n        require(sum == L2_ORACLE_SUBMISSION_INTERVAL, \"Colosseum: invalid segments lengths\");\n    }\n\n    function _closeChallenge(uint256 _challengeId, Types.Challenge storage _challenge) private {\n        delete challenges[_challengeId];\n\n        emit Closed(_challengeId, _challenge.turn, block.timestamp);\n    }\n\n    function _calcSegSize(uint256 _prevSegSize, uint256 _turn) private view returns (uint256) {\n        return _prevSegSize / (getSegmentsLength(_turn) - 1);\n    }\n\n    function _isPast(uint256 _sec) private view returns (bool) {\n        return block.timestamp > _sec;\n    }\n\n    function _isTimedOut(ChallengeStatus status) private pure returns (bool) {\n        return\n            status == ChallengeStatus.CHALLENGER_TIMEOUT ||\n            status == ChallengeStatus.ASSERTER_TIMEOUT;\n    }\n\n    function _isAbleToBisect(uint256 _segSize, uint256 _turn) private view returns (bool) {\n        return _calcSegSize(_segSize, _turn) > 1;\n    }\n\n    function _challengeStatus(Types.Challenge storage _challenge)\n        private\n        view\n        returns (ChallengeStatus)\n    {\n        // If challenge does not exist or is closed, the turn is 0.\n        if (_challenge.turn == 0) {\n            return ChallengeStatus.NONE;\n        }\n\n        // Challenger turns are odd numbers and asserter turns are even numbers.\n        bool isChallengerTurn = (_challenge.turn + 1) % 2 == 1;\n\n        // Check if it is a timed out challenge.\n        if (_isPast(_challenge.timeoutAt)) {\n            // timeout on challenger turn\n            if (isChallengerTurn) {\n                return ChallengeStatus.CHALLENGER_TIMEOUT;\n            }\n\n            // If the challenger doesn't close a challenge even though the asserter has timed out,\n            // the challenger is considered to have timed out.\n            if (_isPast(_challenge.timeoutAt + CHALLENGE_TIMEOUT)) {\n                return ChallengeStatus.CHALLENGER_TIMEOUT;\n            }\n\n            // timeout on asserter turn\n            return ChallengeStatus.ASSERTER_TIMEOUT;\n        }\n\n        // If bisection is not possible, the Challenger must execute the fault proof.\n        if (!_isAbleToBisect(_challenge.segSize, _challenge.turn)) {\n            return ChallengeStatus.READY_TO_PROVE;\n        }\n\n        return isChallengerTurn ? ChallengeStatus.CHALLENGER_TURN : ChallengeStatus.ASSERTER_TURN;\n    }\n\n    function getSegmentsLength(uint256 _turn) public view returns (uint256) {\n        require(_turn > 0, \"Colosseum: invalid turn\");\n        return segmentsLengths[_turn - 1];\n    }\n\n    function getStatusInProgress() public view returns (ChallengeStatus) {\n        return _challengeStatus(challenges[latestChallengeId]);\n    }\n\n    function getChallengeInProgress() public view returns (Types.Challenge memory) {\n        Types.Challenge memory challenge = challenges[latestChallengeId];\n\n        require(challenge.turn > 0, \"Colosseum: challenge not found\");\n\n        return challenge;\n    }\n\n    function isAbleToBisect() public view returns (bool) {\n        Types.Challenge memory challenge = getChallengeInProgress();\n        return _isAbleToBisect(challenge.segSize, challenge.turn);\n    }\n\n    function isInProgress() public view returns (bool) {\n        ChallengeStatus status = getStatusInProgress();\n\n        // If the challenger turn times out, there is no motivation for the asserter\n        // to progress the challenge. The asserter only pay gas. So the challenger\n        // timeout status is considered to be closed, too.\n        return status != ChallengeStatus.NONE && status != ChallengeStatus.CHALLENGER_TIMEOUT;\n    }\n\n    function isChallengeRelated(address _account) public view returns (bool) {\n        Types.Challenge memory challenge = challenges[latestChallengeId];\n        return challenge.current == _account || challenge.next == _account;\n    }\n}\n"
    },
    "contracts/L1/KromaPortal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { ResourceMetering } from \"./ResourceMetering.sol\";\nimport { L2OutputOracle } from \"./L2OutputOracle.sol\";\nimport { ZKMerkleTrie } from \"./ZKMerkleTrie.sol\";\n\n/**\n * @custom:proxied\n * @title KromaPortal\n * @notice The KromaPortal is a low-level contract responsible for passing messages between L1\n *         and L2. Messages sent directly to the KromaPortal have no form of replayability.\n *         Users are encouraged to use the L1CrossDomainMessenger for a higher-level interface.\n */\ncontract KromaPortal is Initializable, ResourceMetering, Semver {\n    /**\n     * @notice Represents a proven withdrawal.\n     *\n     * @custom:field outputRoot    Root of the L2 output this was proven against.\n     * @custom:field timestamp     Timestamp at whcih the withdrawal was proven.\n     * @custom:field l2OutputIndex Index of the output this was proven against.\n     */\n    struct ProvenWithdrawal {\n        bytes32 outputRoot;\n        uint128 timestamp;\n        uint128 l2OutputIndex;\n    }\n\n    /**\n     * @notice Version of the deposit event.\n     */\n    uint256 internal constant DEPOSIT_VERSION = 0;\n\n    /**\n     * @notice The L2 gas limit set when eth is deposited using the receive() function.\n     */\n    uint64 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;\n\n    /**\n     * @notice Address of the L2OutputOracle.\n     */\n    L2OutputOracle public immutable L2_ORACLE;\n\n    /**\n     * @notice Address that has the ability to pause and unpause withdrawals.\n     */\n    address public immutable GUARDIAN;\n\n    /**\n     * @notice Address of the ZKMerkleTrie.\n     */\n    ZKMerkleTrie public immutable ZK_MERKLE_TRIE;\n\n    /**\n     * @notice Address of the L2 account which initiated a withdrawal in this transaction. If the\n     *         of this variable is the default L2 sender address, then we are NOT inside of a call\n     *         to finalizeWithdrawalTransaction.\n     */\n    address public l2Sender;\n\n    /**\n     * @notice A list of withdrawal hashes which have been successfully finalized.\n     */\n    mapping(bytes32 => bool) public finalizedWithdrawals;\n\n    /**\n     * @notice A mapping of withdrawal hashes to `ProvenWithdrawal` data.\n     */\n    mapping(bytes32 => ProvenWithdrawal) public provenWithdrawals;\n\n    /**\n     * @notice Determines if cross domain messaging is paused. When set to true,\n     *         deposits and withdrawals are paused. This may be removed in the\n     *         future.\n     */\n    bool public paused;\n\n    /**\n     * @notice Emitted when a transaction is deposited from L1 to L2. The parameters of this event\n     *         are read by the rollup node and used to derive deposit transactions on L2.\n     *\n     * @param from       Address that triggered the deposit transaction.\n     * @param to         Address that the deposit transaction is directed to.\n     * @param version    Version of this deposit transaction event.\n     * @param opaqueData ABI encoded deposit data to be parsed off-chain.\n     */\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 indexed version,\n        bytes opaqueData\n    );\n\n    /**\n     * @notice Emitted when a withdrawal transaction is proven.\n     *\n     * @param withdrawalHash Hash of the withdrawal transaction.\n     */\n    event WithdrawalProven(\n        bytes32 indexed withdrawalHash,\n        address indexed from,\n        address indexed to\n    );\n\n    /**\n     * @notice Emitted when a withdrawal transaction is finalized.\n     *\n     * @param withdrawalHash Hash of the withdrawal transaction.\n     * @param success        Whether the withdrawal transaction was successful.\n     */\n    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);\n\n    /**\n     * @notice Emitted when the pause is triggered.\n     *\n     * @param account Address of the account triggering the pause.\n     */\n    event Paused(address account);\n\n    /**\n     * @notice Emitted when the pause is lifted.\n     *\n     * @param account Address of the account triggering the unpause.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @notice Reverts when paused.\n     */\n    modifier whenNotPaused() {\n        require(paused == false, \"KromaPortal: paused\");\n        _;\n    }\n\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _l2Oracle                  Address of the L2OutputOracle contract.\n     * @param _guardian                  Address that can pause deposits and withdrawals.\n     * @param _paused                    Sets the contract's pausability state.\n     * @param _zkMerkleTrie              Address of the ZKMerkleTrie contract.\n     */\n    constructor(\n        L2OutputOracle _l2Oracle,\n        address _guardian,\n        bool _paused,\n        ZKMerkleTrie _zkMerkleTrie\n    ) Semver(0, 1, 0) {\n        L2_ORACLE = _l2Oracle;\n        GUARDIAN = _guardian;\n        ZK_MERKLE_TRIE = _zkMerkleTrie;\n        initialize(_paused);\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize(bool _paused) public initializer {\n        l2Sender = Constants.DEFAULT_L2_SENDER;\n        paused = _paused;\n        __ResourceMetering_init();\n    }\n\n     /**\n     * @notice Pause deposits and withdrawals.\n     */\n    function pause() external {\n        require(msg.sender == GUARDIAN, \"KromaPortal: only guardian can pause\");\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @notice Unpause deposits and withdrawals.\n     */\n    function unpause() external {\n        require(msg.sender == GUARDIAN, \"KromaPortal: only guardian can unpause\");\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    /**\n     * @notice Accepts value so that users can send ETH directly to this contract and have the\n     *         funds be deposited to their address on L2. This is intended as a convenience\n     *         function for EOAs. Contracts should call the depositTransaction() function directly\n     *         otherwise any deposited funds will be lost due to address aliasing.\n     */\n    // solhint-disable-next-line ordering\n    receive() external payable {\n        depositTransaction(msg.sender, msg.value, RECEIVE_DEFAULT_GAS_LIMIT, false, bytes(\"\"));\n    }\n\n    /**\n     * @notice Proves a withdrawal transaction.\n     *\n     * @param _tx              Withdrawal transaction to finalize.\n     * @param _l2OutputIndex   L2 output index to prove against.\n     * @param _outputRootProof Inclusion proof of the L2ToL1MessagePasser contract's storage root.\n     * @param _withdrawalProof Inclusion proof of the withdrawal in L2ToL1MessagePasser contract.\n     */\n    function proveWithdrawalTransaction(\n        Types.WithdrawalTransaction memory _tx,\n        uint256 _l2OutputIndex,\n        Types.OutputRootProof calldata _outputRootProof,\n        bytes[] calldata _withdrawalProof\n    ) external whenNotPaused {\n        // Prevent users from creating a deposit transaction where this address is the message\n        // sender on L2. Because this is checked here, we do not need to check again in\n        // `finalizeWithdrawalTransaction`.\n        require(\n            _tx.target != address(this),\n            \"KromaPortal: you cannot send messages to the portal contract\"\n        );\n\n        // Get the output root and load onto the stack to prevent multiple mloads. This will\n        // revert if there is no output root for the given block number.\n        bytes32 outputRoot = L2_ORACLE.getL2Output(_l2OutputIndex).outputRoot;\n\n        // Verify that the output root can be generated with the elements in the proof.\n        require(\n            outputRoot == Hashing.hashOutputRootProof(_outputRootProof),\n            \"KromaPortal: invalid output root proof\"\n        );\n\n        // Load the ProvenWithdrawal into memory, using the withdrawal hash as a unique identifier.\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];\n\n        // We generally want to prevent users from proving the same withdrawal multiple times\n        // because each successive proof will update the timestamp. A malicious user can take\n        // advantage of this to prevent other users from finalizing their withdrawal. However,\n        // since withdrawals are proven before an output root is finalized, we need to allow users\n        // to re-prove their withdrawal only in the case that the output root for their specified\n        // output index has been updated.\n        require(\n            provenWithdrawal.timestamp == 0 ||\n                L2_ORACLE.getL2Output(provenWithdrawal.l2OutputIndex).outputRoot !=\n                provenWithdrawal.outputRoot,\n            \"KromaPortal: withdrawal hash has already been proven\"\n        );\n\n        // Compute the storage slot of the withdrawal hash in the L2ToL1MessagePasser contract.\n        // Refer to the Solidity documentation for more information on how storage layouts are\n        // computed for mappings.\n        bytes32 storageKey = keccak256(\n            abi.encode(\n                withdrawalHash,\n                uint256(0) // The withdrawals mapping is at the first slot in the layout.\n            )\n        );\n\n        // Verify that the hash of this withdrawal was stored in the L2toL1MessagePasser contract\n        // on L2. If this is true, under the assumption that the ZKMerkleTrie contract does not have\n        // bugs, then we know that this withdrawal was actually triggered on L2 and can therefore\n        // be relayed on L1.\n        require(\n            ZK_MERKLE_TRIE.verifyInclusionProof(\n                storageKey,\n                hex\"0000000000000000000000000000000000000000000000000000000000000001\",\n                _withdrawalProof,\n                _outputRootProof.messagePasserStorageRoot\n            ),\n            \"KromaPortal: invalid withdrawal inclusion proof\"\n        );\n\n        // Designate the withdrawalHash as proven by storing the `outputRoot`, `timestamp`, and\n        // `l2BlockNumber` in the `provenWithdrawals` mapping. A `withdrawalHash` can only be\n        // proven once unless it is submitted again with a different outputRoot.\n        provenWithdrawals[withdrawalHash] = ProvenWithdrawal({\n            outputRoot: outputRoot,\n            timestamp: uint128(block.timestamp),\n            l2OutputIndex: uint128(_l2OutputIndex)\n        });\n\n        // Emit a `WithdrawalProven` event.\n        emit WithdrawalProven(withdrawalHash, _tx.sender, _tx.target);\n    }\n\n    /**\n     * @notice Finalizes a withdrawal transaction.\n     *\n     * @param _tx Withdrawal transaction to finalize.\n     */\n    function finalizeWithdrawalTransaction(Types.WithdrawalTransaction memory _tx)\n        external\n        whenNotPaused\n    {\n        // Make sure that the l2Sender has not yet been set. The l2Sender is set to a value other\n        // than the default value when a withdrawal transaction is being finalized. This check is\n        // a defacto reentrancy guard.\n        require(\n            l2Sender == Constants.DEFAULT_L2_SENDER,\n            \"KromaPortal: can only trigger one withdrawal per transaction\"\n        );\n\n        // Grab the proven withdrawal from the `provenWithdrawals` map.\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];\n\n        // A withdrawal can only be finalized if it has been proven. We know that a withdrawal has\n        // been proven at least once when its timestamp is non-zero. Unproven withdrawals will have\n        // a timestamp of zero.\n        require(\n            provenWithdrawal.timestamp != 0,\n            \"KromaPortal: withdrawal has not been proven yet\"\n        );\n\n        // As a sanity check, we make sure that the proven withdrawal's timestamp is greater than\n        // starting timestamp inside the L2OutputOracle. Not strictly necessary but extra layer of\n        // safety against weird bugs in the proving step.\n        require(\n            provenWithdrawal.timestamp >= L2_ORACLE.startingTimestamp(),\n            \"KromaPortal: withdrawal timestamp less than L2 Oracle starting timestamp\"\n        );\n\n        // A proven withdrawal must wait at least the finalization period before it can be\n        // finalized. This waiting period can elapse in parallel with the waiting period for the\n        // output the withdrawal was proven against. In effect, this means that the minimum\n        // withdrawal time is l2 output submission time + finalization period.\n        require(\n            _isFinalizationPeriodElapsed(provenWithdrawal.timestamp),\n            \"KromaPortal: proven withdrawal finalization period has not elapsed\"\n        );\n\n        // Grab the CheckpointOutput from the L2OutputOracle, will revert if the output that\n        // corresponds to the given index has not been submitted yet.\n        Types.CheckpointOutput memory checkpointOutput = L2_ORACLE.getL2Output(\n            provenWithdrawal.l2OutputIndex\n        );\n\n        // Check that the output root that was used to prove the withdrawal is the same as the\n        // current output root for the given output index. An output root may change if it is\n        // deleted by the challenger address and then re-submitted.\n        require(\n            checkpointOutput.outputRoot == provenWithdrawal.outputRoot,\n            \"KromaPortal: output root proven is not the same as current output root\"\n        );\n\n        // Check that the checkpoint output has also been finalized.\n        require(\n            _isFinalizationPeriodElapsed(checkpointOutput.timestamp),\n            \"KromaPortal: checkpoint output finalization period has not elapsed\"\n        );\n\n        // Check that this withdrawal has not already been finalized, this is replay protection.\n        require(\n            finalizedWithdrawals[withdrawalHash] == false,\n            \"KromaPortal: withdrawal has already been finalized\"\n        );\n\n        // Mark the withdrawal as finalized so it can't be replayed.\n        finalizedWithdrawals[withdrawalHash] = true;\n\n        // Set the l2Sender so contracts know who triggered this withdrawal on L2.\n        l2Sender = _tx.sender;\n\n        // Trigger the call to the target contract. We use a custom low level method\n        // SafeCall.callWithMinGas to ensure two key properties\n        //   1. Target contracts cannot force this call to run out of gas by returning a very large\n        //      amount of data (and this is OK because we don't care about the returndata here).\n        //   2. The amount of gas provided to the call to the target contract is at least the gas\n        //      limit specified by the user. If there is not enough gas in the callframe to\n        //      accomplish this, `callWithMinGas` will revert.\n        // Additionally, if there is not enough gas remaining to complete the execution after the\n        // call returns, this function will revert.\n        bool success = SafeCall.callWithMinGas(_tx.target, _tx.gasLimit, _tx.value, _tx.data);\n\n        // Reset the l2Sender back to the default value.\n        l2Sender = Constants.DEFAULT_L2_SENDER;\n\n        // All withdrawals are immediately finalized. Replayability can\n        // be achieved through contracts built on top of this contract\n        emit WithdrawalFinalized(withdrawalHash, success);\n\n        // Reverting here is useful for determining the exact gas cost to successfully execute the\n        // sub call to the target contract if the minimum gas limit specified by the user would not\n        // be sufficient to execute the sub call.\n        if (success == false && tx.origin == Constants.ESTIMATION_ADDRESS) {\n            revert(\"KromaPortal: withdrawal failed\");\n        }\n    }\n\n    /**\n     * @notice Accepts deposits of ETH and data, and emits a TransactionDeposited event for use in\n     *         deriving deposit transactions. Note that if a deposit is made by a contract, its\n     *         address will be aliased when retrieved using `tx.origin` or `msg.sender`. Consider\n     *         using the CrossDomainMessenger contracts for a simpler developer experience.\n     *\n     * @param _to         Target address on L2.\n     * @param _value      ETH value to send to the recipient.\n     * @param _gasLimit   Minimum L2 gas limit (can be greater than or equal to this value).\n     * @param _isCreation Whether or not the transaction is a contract creation.\n     * @param _data       Data to trigger the recipient with.\n     */\n    function depositTransaction(\n        address _to,\n        uint256 _value,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    ) public payable metered(_gasLimit) {\n        // Just to be safe, make sure that people specify address(0) as the target when doing\n        // contract creations.\n        if (_isCreation) {\n            require(\n                _to == address(0),\n                \"KromaPortal: must send to address(0) when creating a contract\"\n            );\n        }\n\n        // Prevent depositing transactions that have too small of a gas limit.\n        require(_gasLimit >= 21_000, \"KromaPortal: gas limit must cover instrinsic gas cost\");\n\n        // Transform the from-address to its alias if the caller is a contract.\n        address from = msg.sender;\n        if (msg.sender != tx.origin) {\n            from = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        // Compute the opaque data that will be emitted as part of the TransactionDeposited event.\n        // We use opaque data so that we can update the TransactionDeposited event in the future\n        // without breaking the current interface.\n        bytes memory opaqueData = abi.encodePacked(\n            msg.value,\n            _value,\n            _gasLimit,\n            _isCreation,\n            _data\n        );\n\n        // Emit a TransactionDeposited event so that the rollup node can derive a deposit\n        // transaction for this deposit.\n        emit TransactionDeposited(from, _to, DEPOSIT_VERSION, opaqueData);\n    }\n\n    /**\n     * @notice Determine if a given output is finalized. Reverts if the call to\n     *         L2_ORACLE.getL2Output reverts. Returns a boolean otherwise.\n     *\n     * @param _l2OutputIndex Index of the L2 output to check.\n     *\n     * @return Whether or not the output is finalized.\n     */\n    function isOutputFinalized(uint256 _l2OutputIndex) external view returns (bool) {\n        return _isFinalizationPeriodElapsed(L2_ORACLE.getL2Output(_l2OutputIndex).timestamp);\n    }\n\n    /**\n     * @notice Determines whether the finalization period has elapsed w/r/t a given timestamp.\n     *\n     * @param _timestamp Timestamp to check.\n     *\n     * @return Whether or not the finalization period has elapsed.\n     */\n    function _isFinalizationPeriodElapsed(uint256 _timestamp) internal view returns (bool) {\n        return block.timestamp > _timestamp + L2_ORACLE.FINALIZATION_PERIOD_SECONDS();\n    }\n}\n"
    },
    "contracts/L1/L1CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { KromaPortal } from \"./KromaPortal.sol\";\n\n/**\n * @custom:proxied\n * @title L1CrossDomainMessenger\n * @notice The L1CrossDomainMessenger is a message passing interface between L1 and L2 responsible\n *         for sending and receiving data on the L1 side. Users are encouraged to use this\n *         interface instead of interacting with lower-level contracts directly.\n */\ncontract L1CrossDomainMessenger is CrossDomainMessenger, Semver {\n    /**\n     * @notice Address of the KromaPortal.\n     */\n    KromaPortal public immutable PORTAL;\n\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _portal Address of the KromaPortal contract on this network.\n     */\n    constructor(KromaPortal _portal)\n        Semver(0, 1, 0)\n        CrossDomainMessenger(Predeploys.L2_CROSS_DOMAIN_MESSENGER)\n    {\n        PORTAL = _portal;\n        initialize();\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize() public initializer {\n        __CrossDomainMessenger_init();\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal override {\n        PORTAL.depositTransaction{ value: _value }(_to, _value, _gasLimit, false, _data);\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _isOtherMessenger() internal view override returns (bool) {\n        return msg.sender == address(PORTAL) && PORTAL.l2Sender() == OTHER_MESSENGER;\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _isUnsafeTarget(address _target) internal view override returns (bool) {\n        return _target == address(this) || _target == address(PORTAL);\n    }\n}\n"
    },
    "contracts/L1/L1ERC721Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport { L2ERC721Bridge } from \"../L2/L2ERC721Bridge.sol\";\nimport { ERC721Bridge } from \"../universal/ERC721Bridge.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @title L1ERC721Bridge\n * @notice The L1 ERC721 bridge is a contract which works together with the L2 ERC721 bridge to\n *         make it possible to transfer ERC721 tokens from Ethereum to Kroma. This contract\n *         acts as an escrow for ERC721 tokens deposited into L2.\n */\ncontract L1ERC721Bridge is ERC721Bridge, Semver {\n    /**\n     * @notice Mapping of L1 token to L2 token to ID to boolean, indicating if the given L1 token\n     *         by ID was deposited for a given L2 token.\n     */\n    mapping(address => mapping(address => mapping(uint256 => bool))) public deposits;\n\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _messenger   Address of the CrossDomainMessenger on this network.\n     * @param _otherBridge Address of the ERC721 bridge on the other network.\n     */\n    constructor(address _messenger, address _otherBridge)\n        Semver(0, 1, 0)\n        ERC721Bridge(_messenger, _otherBridge)\n    {}\n\n    /**\n     * @notice Completes an ERC721 bridge from the other domain and sends the ERC721 token to the\n     *         recipient on this domain.\n     *\n     * @param _localToken  Address of the ERC721 token on this domain.\n     * @param _remoteToken Address of the ERC721 token on the other domain.\n     * @param _from        Address that triggered the bridge on the other domain.\n     * @param _to          Address to receive the token on this domain.\n     * @param _tokenId     ID of the token being deposited.\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\n     *                     execute any code on L2 and is only emitted as extra data for the\n     *                     convenience of off-chain tooling.\n     */\n    function finalizeBridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes calldata _extraData\n    ) external onlyOtherBridge {\n        require(_localToken != address(this), \"L1ERC721Bridge: local token cannot be self\");\n\n        // Checks that the L1/L2 NFT pair has a token ID that is escrowed in the L1 Bridge.\n        require(\n            deposits[_localToken][_remoteToken][_tokenId] == true,\n            \"L1ERC721Bridge: Token ID is not escrowed in the L1 Bridge\"\n        );\n\n        // Mark that the token ID for this L1/L2 token pair is no longer escrowed in the L1\n        // Bridge.\n        deposits[_localToken][_remoteToken][_tokenId] = false;\n\n        // When a withdrawal is finalized on L1, the L1 Bridge transfers the NFT to the\n        // withdrawer.\n        IERC721(_localToken).safeTransferFrom(address(this), _to, _tokenId);\n\n        // slither-disable-next-line reentrancy-events\n        emit ERC721BridgeFinalized(_localToken, _remoteToken, _from, _to, _tokenId, _extraData);\n    }\n\n    /**\n     * @inheritdoc ERC721Bridge\n     */\n    function _initiateBridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) internal override {\n        require(_remoteToken != address(0), \"L1ERC721Bridge: remote token cannot be address(0)\");\n\n        // Construct calldata for _l2Token.finalizeBridgeERC721(_to, _tokenId)\n        bytes memory message = abi.encodeWithSelector(\n            L2ERC721Bridge.finalizeBridgeERC721.selector,\n            _remoteToken,\n            _localToken,\n            _from,\n            _to,\n            _tokenId,\n            _extraData\n        );\n\n        // Lock token into bridge\n        deposits[_localToken][_remoteToken][_tokenId] = true;\n        IERC721(_localToken).transferFrom(_from, address(this), _tokenId);\n\n        // Send calldata into L2\n        MESSENGER.sendMessage(OTHER_BRIDGE, message, _minGasLimit);\n        emit ERC721BridgeInitiated(_localToken, _remoteToken, _from, _to, _tokenId, _extraData);\n    }\n}\n"
    },
    "contracts/L1/L1StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\n\n/**\n * @custom:proxied\n * @title L1StandardBridge\n * @notice The L1StandardBridge is responsible for transfering ETH and ERC20 tokens between L1 and\n *         L2. In the case that an ERC20 token is native to L1, it will be escrowed within this\n *         contract. If the ERC20 token is native to L2, it will be burnt. ETH is instead stored\n *         inside the KromaPortal contract.\n *         NOTE: this contract is not intended to support all variations of ERC20 tokens. Examples\n *         of some token types that may not be properly supported by this contract include, but are\n *         not limited to: tokens with transfer fees, rebasing tokens, and tokens with blocklists.\n */\ncontract L1StandardBridge is StandardBridge, Semver {\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _messenger Address of the L1CrossDomainMessenger.\n     */\n    constructor(address payable _messenger)\n        Semver(0, 1, 0)\n        StandardBridge(_messenger, payable(Predeploys.L2_STANDARD_BRIDGE))\n    {}\n\n    /**\n     * @notice Allows EOAs to bridge ETH by sending directly to the bridge.\n     */\n    receive() external payable override onlyEOA {\n        _initiateBridgeETH(msg.sender, msg.sender, msg.value, RECEIVE_DEFAULT_GAS_LIMIT, bytes(\"\"));\n    }\n}\n"
    },
    "contracts/L1/L2OutputOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport { Types } from \"../libraries/Types.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @title L2OutputOracle\n * @notice The L2OutputOracle contains an array of L2 state outputs, where each output is a\n *         commitment to the state of the L2 chain. Other contracts like the KromaPortal use\n *         these outputs to verify information about the state of L2.\n */\ncontract L2OutputOracle is Initializable, Semver {\n    /**\n     * @notice The interval in L2 blocks at which checkpoints must be submitted. Although this is\n     *         immutable, it can safely be modified by upgrading the implementation contract.\n     */\n    uint256 public immutable SUBMISSION_INTERVAL;\n\n    /**\n     * @notice The time between L2 blocks in seconds. Once set, this value MUST NOT be modified.\n     */\n    uint256 public immutable L2_BLOCK_TIME;\n\n    /**\n     * @notice The address of the challenger. Can be updated via upgrade.\n     */\n    address public immutable CHALLENGER;\n\n    /**\n     * @notice The address of the validator. Can be updated via upgrade.\n     */\n    address public immutable VALIDATOR;\n\n    /**\n     * @notice Minimum time (in seconds) that must elapse before a withdrawal can be finalized.\n     */\n    uint256 public immutable FINALIZATION_PERIOD_SECONDS;\n\n    /**\n     * @notice The number of the first L2 block recorded in this contract.\n     */\n    uint256 public startingBlockNumber;\n\n    /**\n     * @notice The timestamp of the first L2 block recorded in this contract.\n     */\n    uint256 public startingTimestamp;\n\n    /**\n     * @notice Array of L2 checkpoint outputs.\n     */\n    Types.CheckpointOutput[] internal l2Outputs;\n\n    /**\n     * @notice Emitted when an output is submitted.\n     *\n     * @param outputRoot    The output root.\n     * @param l2OutputIndex The index of the output in the l2Outputs array.\n     * @param l2BlockNumber The L2 block number of the output root.\n     * @param l1Timestamp   The L1 timestamp when submitted.\n     */\n    event OutputSubmitted(\n        bytes32 indexed outputRoot,\n        uint256 indexed l2OutputIndex,\n        uint256 indexed l2BlockNumber,\n        uint256 l1Timestamp\n    );\n\n    /**\n     * @notice Emitted when outputs are deleted.\n     *\n     * @param prevNextOutputIndex Next L2 output index before the deletion.\n     * @param newNextOutputIndex  Next L2 output index after the deletion.\n     */\n    event OutputsDeleted(uint256 indexed prevNextOutputIndex, uint256 indexed newNextOutputIndex);\n\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _submissionInterval        Interval in blocks at which checkpoints must be submitted.\n     * @param _l2BlockTime               The time per L2 block, in seconds.\n     * @param _startingBlockNumber       The number of the first L2 block.\n     * @param _startingTimestamp         The timestamp of the first L2 block.\n     * @param _validator                 The address of the validator.\n     * @param _challenger                The address of the challenger.\n     * @param _finalizationPeriodSeconds Output finalization time in seconds.\n     */\n    constructor(\n        uint256 _submissionInterval,\n        uint256 _l2BlockTime,\n        uint256 _startingBlockNumber,\n        uint256 _startingTimestamp,\n        address _validator,\n        address _challenger,\n        uint256 _finalizationPeriodSeconds\n    ) Semver(0, 1, 0) {\n        require(_l2BlockTime > 0, \"L2OutputOracle: L2 block time must be greater than 0\");\n        require(\n            _submissionInterval > _l2BlockTime,\n            \"L2OutputOracle: submission interval must be greater than L2 block time\"\n        );\n\n        SUBMISSION_INTERVAL = _submissionInterval;\n        L2_BLOCK_TIME = _l2BlockTime;\n        VALIDATOR = _validator;\n        CHALLENGER = _challenger;\n        FINALIZATION_PERIOD_SECONDS = _finalizationPeriodSeconds;\n\n        initialize(_startingBlockNumber, _startingTimestamp);\n    }\n\n    /**\n     * @notice Initializer.\n     *\n     * @param _startingBlockNumber Block number for the first recorded L2 block.\n     * @param _startingTimestamp   Timestamp for the first recorded L2 block.\n     */\n    function initialize(uint256 _startingBlockNumber, uint256 _startingTimestamp)\n        public\n        initializer\n    {\n        require(\n            _startingTimestamp <= block.timestamp,\n            \"L2OutputOracle: starting L2 timestamp must be less than current time\"\n        );\n\n        startingTimestamp = _startingTimestamp;\n        startingBlockNumber = _startingBlockNumber;\n    }\n\n    /**\n     * @notice Deletes all checkpoint outputs after and including the output that corresponds to\n     *         the given output index. Only the challenger address can delete outputs.\n     *\n     * @param _l2OutputIndex Index of the first L2 output to be deleted. All outputs after this\n     *                       output will also be deleted.\n     */\n    // solhint-disable-next-line ordering\n    function deleteL2Outputs(uint256 _l2OutputIndex) external {\n        require(\n            msg.sender == CHALLENGER,\n            \"L2OutputOracle: only the challenger address can delete outputs\"\n        );\n\n        // Make sure we're not *increasing* the length of the array.\n        require(\n            _l2OutputIndex < l2Outputs.length,\n            \"L2OutputOracle: cannot delete outputs after the latest output index\"\n        );\n\n        // Do not allow deleting any outputs that have already been finalized.\n        require(\n            block.timestamp - l2Outputs[_l2OutputIndex].timestamp < FINALIZATION_PERIOD_SECONDS,\n            \"L2OutputOracle: cannot delete outputs that have already been finalized\"\n        );\n\n        uint256 prevNextL2OutputIndex = nextOutputIndex();\n\n        // Use assembly to delete the array elements because Solidity doesn't allow it.\n        assembly {\n            sstore(l2Outputs.slot, _l2OutputIndex)\n        }\n\n        emit OutputsDeleted(prevNextL2OutputIndex, _l2OutputIndex);\n    }\n\n    /**\n     * @notice Accepts an outputRoot and the timestamp of the corresponding L2 block. The timestamp\n     *         must be equal to the current value returned by `nextTimestamp()` in order to be\n     *         accepted. This function may only be called by the Validator.\n     *\n     * @param _outputRoot    The L2 output of the checkpoint block.\n     * @param _l2BlockNumber The L2 block number that resulted in _outputRoot.\n     * @param _l1BlockHash   A block hash which must be included in the current chain.\n     * @param _l1BlockNumber The block number with the specified block hash.\n     */\n    function submitL2Output(\n        bytes32 _outputRoot,\n        uint256 _l2BlockNumber,\n        bytes32 _l1BlockHash,\n        uint256 _l1BlockNumber\n    ) external payable {\n        require(\n            msg.sender == VALIDATOR,\n            \"L2OutputOracle: only the validator address can submit new outputs\"\n        );\n\n        require(\n            _l2BlockNumber == nextBlockNumber(),\n            \"L2OutputOracle: block number must be equal to next expected block number\"\n        );\n\n        require(\n            computeL2Timestamp(_l2BlockNumber) < block.timestamp,\n            \"L2OutputOracle: cannot submit L2 output in the future\"\n        );\n\n        require(\n            _outputRoot != bytes32(0),\n            \"L2OutputOracle: L2 checkpoint output cannot be the zero hash\"\n        );\n\n        if (_l1BlockHash != bytes32(0)) {\n            // This check allows the validator to submit an output based on a given L1 block,\n            // without fear that it will be reorged out.\n            // It will also revert if the blockheight provided is more than 256 blocks behind the\n            // chain tip (as the hash will return as zero). This does open the door to a griefing\n            // attack in which the validator's submission is censored until the block is no longer\n            // retrievable, if the validator is experiencing this attack it can simply leave out the\n            // blockhash value, and delay submission until it is confident that the L1 block is\n            // finalized.\n            require(\n                blockhash(_l1BlockNumber) == _l1BlockHash,\n                \"L2OutputOracle: block hash does not match the hash at the expected height\"\n            );\n        }\n\n        emit OutputSubmitted(_outputRoot, nextOutputIndex(), _l2BlockNumber, block.timestamp);\n\n        l2Outputs.push(\n            Types.CheckpointOutput({\n                outputRoot: _outputRoot,\n                timestamp: uint128(block.timestamp),\n                l2BlockNumber: uint128(_l2BlockNumber)\n            })\n        );\n    }\n\n    /**\n     * @notice Returns an output by index. Exists because Solidity's array access will return a\n     *         tuple instead of a struct.\n     *\n     * @param _l2OutputIndex Index of the output to return.\n     *\n     * @return The output at the given index.\n     */\n    function getL2Output(uint256 _l2OutputIndex)\n        external\n        view\n        returns (Types.CheckpointOutput memory)\n    {\n        return l2Outputs[_l2OutputIndex];\n    }\n\n    /**\n     * @notice Returns the index of the L2 output that checkpoints a given L2 block number. Uses a\n     *         binary search to find the first output greater than or equal to the given block.\n     *\n     * @param _l2BlockNumber L2 block number to find a checkpoint for.\n     *\n     * @return Index of the first checkpoint that commits to the given L2 block number.\n     */\n    function getL2OutputIndexAfter(uint256 _l2BlockNumber) public view returns (uint256) {\n        // Make sure an output for this block number has actually been submitted.\n        require(\n            _l2BlockNumber <= latestBlockNumber(),\n            \"L2OutputOracle: cannot get output for a block that has not been submitted\"\n        );\n\n        // Make sure there's at least one output submitted.\n        require(\n            l2Outputs.length > 0,\n            \"L2OutputOracle: cannot get output as no outputs have been submitted yet\"\n        );\n\n        // Find the output via binary search, guaranteed to exist.\n        uint256 lo = 0;\n        uint256 hi = l2Outputs.length;\n        while (lo < hi) {\n            uint256 mid = (lo + hi) / 2;\n            if (l2Outputs[mid].l2BlockNumber < _l2BlockNumber) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n\n        return lo;\n    }\n\n    /**\n     * @notice Returns the L2 checkpoint output that checkpoints a given L2 block number. Uses a\n     *         binary search to find the first output greater than or equal to the given block.\n     *\n     * @param _l2BlockNumber L2 block number to find a checkpoint for.\n     *\n     * @return First checkpoint that commits to the given L2 block number.\n     */\n    function getL2OutputAfter(uint256 _l2BlockNumber)\n        external\n        view\n        returns (Types.CheckpointOutput memory)\n    {\n        return l2Outputs[getL2OutputIndexAfter(_l2BlockNumber)];\n    }\n\n    /**\n     * @notice Returns the number of outputs that have been submitted. Will revert if no outputs\n     *         have been submitted yet.\n     *\n     * @return The number of outputs that have been submitted.\n     */\n    function latestOutputIndex() external view returns (uint256) {\n        return l2Outputs.length - 1;\n    }\n\n    /**\n     * @notice Returns the index of the next output to be submitted.\n     *\n     * @return The index of the next output to be submitted.\n     */\n    function nextOutputIndex() public view returns (uint256) {\n        return l2Outputs.length;\n    }\n\n    /**\n     * @notice Returns the block number of the latest submitted L2 checkpoint output. If no outputs\n     *         have been submitted yet then this function will return the starting block number.\n     *\n     * @return Latest submitted L2 block number.\n     */\n    function latestBlockNumber() public view returns (uint256) {\n        return\n            l2Outputs.length == 0\n                ? startingBlockNumber\n                : l2Outputs[l2Outputs.length - 1].l2BlockNumber;\n    }\n\n    /**\n     * @notice Computes the block number of the next L2 block that needs to be checkpointed.\n     *\n     * @return Next L2 block number.\n     */\n    function nextBlockNumber() public view returns (uint256) {\n        return latestBlockNumber() + SUBMISSION_INTERVAL;\n    }\n\n    /**\n     * @notice Returns the L2 timestamp corresponding to a given L2 block number.\n     *\n     * @param _l2BlockNumber The L2 block number of the target block.\n     *\n     * @return L2 timestamp of the given block.\n     */\n    function computeL2Timestamp(uint256 _l2BlockNumber) public view returns (uint256) {\n        return startingTimestamp + ((_l2BlockNumber - startingBlockNumber) * L2_BLOCK_TIME);\n    }\n}\n"
    },
    "contracts/L1/ResourceMetering.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { Arithmetic } from \"../libraries/Arithmetic.sol\";\nimport { Burn } from \"../libraries/Burn.sol\";\n\n/**\n * @custom:upgradeable\n * @title ResourceMetering\n * @notice ResourceMetering implements an EIP-1559 style resource metering system where pricing\n *         updates automatically based on current demand.\n */\nabstract contract ResourceMetering is Initializable {\n    /**\n     * @notice Represents the various parameters that control the way in which resources are\n     *         metered. Corresponds to the EIP-1559 resource metering system.\n     *\n     * @custom:field prevBaseFee   Base fee from the previous block(s).\n     * @custom:field prevBoughtGas Amount of gas bought so far in the current block.\n     * @custom:field prevBlockNum  Last block number that the base fee was updated.\n     */\n    struct ResourceParams {\n        uint128 prevBaseFee;\n        uint64 prevBoughtGas;\n        uint64 prevBlockNum;\n    }\n\n    /**\n     * @notice Maximum amount of the resource that can be used within this block.\n     *         This value cannot be larger than the L2 block gas limit.\n     */\n    int256 public constant MAX_RESOURCE_LIMIT = 20_000_000;\n\n    /**\n     * @notice Along with the resource limit, determines the target resource limit.\n     */\n    int256 public constant ELASTICITY_MULTIPLIER = 10;\n\n    /**\n     * @notice Target amount of the resource that should be used within this block.\n     */\n    int256 public constant TARGET_RESOURCE_LIMIT = MAX_RESOURCE_LIMIT / ELASTICITY_MULTIPLIER;\n\n    /**\n     * @notice Denominator that determines max change on fee per block.\n     */\n    int256 public constant BASE_FEE_MAX_CHANGE_DENOMINATOR = 8;\n\n    /**\n     * @notice Minimum base fee value, cannot go lower than this.\n     */\n    int256 public constant MINIMUM_BASE_FEE = 1 gwei;\n\n    /**\n     * @notice Maximum base fee value, cannot go higher than this.\n     *         It is possible for the MAXIMUM_BASE_FEE to raise to a value\n     *         that is so large it will consume the entire gas limit of\n     *         an L1 block.\n     */\n    int256 public constant MAXIMUM_BASE_FEE = int256(uint256(type(uint128).max));\n\n    /**\n     * @notice Initial base fee value. This value must be smaller than the\n     *         MAXIMUM_BASE_FEE.\n     */\n    uint128 public constant INITIAL_BASE_FEE = 1 gwei;\n\n    /**\n     * @notice EIP-1559 style gas parameters.\n     */\n    ResourceParams public params;\n\n    /**\n     * @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\n     */\n    uint256[48] private __gap;\n\n    /**\n     * @notice Meters access to a function based an amount of a requested resource.\n     *\n     * @param _amount Amount of the resource requested.\n     */\n    modifier metered(uint64 _amount) {\n        // Record initial gas amount so we can refund for it later.\n        uint256 initialGas = gasleft();\n\n        // Run the underlying function.\n        _;\n\n        // Run the metering function.\n        _metered(_amount, initialGas);\n    }\n\n    /**\n     * @notice An internal function that holds all of the logic for metering a resource.\n     *\n     * @param _amount     Amount of the resource requested.\n     * @param _initialGas The amount of gas before any modifier execution.\n     */\n    function _metered(uint64 _amount, uint256 _initialGas) internal {\n        // Update block number and base fee if necessary.\n        uint256 blockDiff = block.number - params.prevBlockNum;\n        if (blockDiff > 0) {\n            // Handle updating EIP-1559 style gas parameters. We use EIP-1559 to restrict the rate\n            // at which deposits can be created and therefore limit the potential for deposits to\n            // spam the L2 system. Fee scheme is very similar to EIP-1559 with minor changes.\n            int256 gasUsedDelta = int256(uint256(params.prevBoughtGas)) - TARGET_RESOURCE_LIMIT;\n            int256 baseFeeDelta = (int256(uint256(params.prevBaseFee)) * gasUsedDelta) /\n                (TARGET_RESOURCE_LIMIT * BASE_FEE_MAX_CHANGE_DENOMINATOR);\n\n            // Update base fee by adding the base fee delta and clamp the resulting value between\n            // min and max.\n            int256 newBaseFee = Arithmetic.clamp({\n                _value: int256(uint256(params.prevBaseFee)) + baseFeeDelta,\n                _min: MINIMUM_BASE_FEE,\n                _max: MAXIMUM_BASE_FEE\n            });\n\n            // If we skipped more than one block, we also need to account for every empty block.\n            // Empty block means there was no demand for deposits in that block, so we should\n            // reflect this lack of demand in the fee.\n            if (blockDiff > 1) {\n                // Update the base fee by repeatedly applying the exponent 1-(1/change_denominator)\n                // blockDiff - 1 times. Simulates multiple empty blocks. Clamp the resulting value\n                // between min and max.\n                newBaseFee = Arithmetic.clamp({\n                    _value: Arithmetic.cdexp({\n                        _coefficient: newBaseFee,\n                        _denominator: BASE_FEE_MAX_CHANGE_DENOMINATOR,\n                        _exponent: int256(blockDiff - 1)\n                    }),\n                    _min: MINIMUM_BASE_FEE,\n                    _max: MAXIMUM_BASE_FEE\n                });\n            }\n\n            // Update new base fee, reset bought gas, and update block number.\n            params.prevBaseFee = uint128(uint256(newBaseFee));\n            params.prevBoughtGas = 0;\n            params.prevBlockNum = uint64(block.number);\n        }\n\n        // Make sure we can actually buy the resource amount requested by the user.\n        params.prevBoughtGas += _amount;\n        require(\n            int256(uint256(params.prevBoughtGas)) <= MAX_RESOURCE_LIMIT,\n            \"ResourceMetering: cannot buy more gas than available gas limit\"\n        );\n\n        // Determine the amount of ETH to be paid.\n        uint256 resourceCost = uint256(_amount) * uint256(params.prevBaseFee);\n\n        // We currently charge for this ETH amount as an L1 gas burn, so we convert the ETH amount\n        // into gas by dividing by the L1 base fee. We assume a minimum base fee of 1 gwei to avoid\n        // division by zero for L1s that don't support 1559 or to avoid excessive gas burns during\n        // periods of extremely low L1 demand. One-day average gas fee hasn't dipped below 1 gwei\n        // during any 1 day period in the last 5 years, so should be fine.\n        uint256 gasCost = resourceCost / Math.max(block.basefee, 1 gwei);\n\n        // Give the user a refund based on the amount of gas they used to do all of the work up to\n        // this point. Since we're at the end of the modifier, this should be pretty accurate. Acts\n        // effectively like a dynamic stipend (with a minimum value).\n        uint256 usedGas = _initialGas - gasleft();\n        if (gasCost > usedGas) {\n            Burn.gas(gasCost - usedGas);\n        }\n    }\n\n    /**\n     * @notice Sets initial resource parameter values. This function must either be called by the\n     *         initializer function of an upgradeable child contract.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __ResourceMetering_init() internal onlyInitializing {\n        params = ResourceParams({\n            prevBaseFee: INITIAL_BASE_FEE,\n            prevBoughtGas: 0,\n            prevBlockNum: uint64(block.number)\n        });\n    }\n}\n"
    },
    "contracts/L1/SystemConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @title SystemConfig\n * @notice The SystemConfig contract is used to manage configuration of a Kroma network. All\n *         configuration is stored on L1 and picked up by L2 as part of the derviation of the L2\n *         chain.\n */\ncontract SystemConfig is OwnableUpgradeable, Semver {\n    /**\n     * @notice Enum representing different types of updates.\n     *\n     * @custom:value BATCHER              Represents an update to the batcher hash.\n     * @custom:value GAS_CONFIG           Represents an update to txn fee config on L2.\n     * @custom:value GAS_LIMIT            Represents an update to gas limit on L2.\n     * @custom:value UNSAFE_BLOCK_SIGNER  Represents an update to the signer key for unsafe\n     *                                    block distrubution.\n     */\n    enum UpdateType {\n        BATCHER,\n        GAS_CONFIG,\n        GAS_LIMIT,\n        UNSAFE_BLOCK_SIGNER\n    }\n\n    /**\n     * @notice Version identifier, used for upgrades.\n     */\n    uint256 public constant VERSION = 0;\n\n    /**\n     * @notice Storage slot that the unsafe block signer is stored at. Storing it at this\n     *         deterministic storage slot allows for decoupling the storage layout from the way\n     *         that `solc` lays out storage. The `kroma-node` uses a storage proof to fetch this value.\n     */\n    bytes32 public constant UNSAFE_BLOCK_SIGNER_SLOT = keccak256(\"systemconfig.unsafeblocksigner\");\n\n    /**\n     * @notice Minimum gas limit. This should not be lower than the maximum deposit gas resource\n     *         limit in the ResourceMetering contract used by KromaPortal, to ensure the L2\n     *         block always has sufficient gas to process deposits.\n     */\n    uint64 public constant MINIMUM_GAS_LIMIT = 8_000_000;\n\n    /**\n     * @notice Fixed L2 gas overhead.\n     */\n    uint256 public overhead;\n\n    /**\n     * @notice Dynamic L2 gas overhead.\n     */\n    uint256 public scalar;\n\n    /**\n     * @notice Identifier for the batcher. For version 1 of this configuration, this is represented\n     *         as an address left-padded with zeros to 32 bytes.\n     */\n    bytes32 public batcherHash;\n\n    /**\n     * @notice L2 gas limit.\n     */\n    uint64 public gasLimit;\n\n    /**\n     * @notice Emitted when configuration is updated\n     *\n     * @param version    SystemConfig version.\n     * @param updateType Type of update.\n     * @param data       Encoded update data.\n     */\n    event ConfigUpdate(uint256 indexed version, UpdateType indexed updateType, bytes data);\n\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _owner             Initial owner of the contract.\n     * @param _overhead          Initial overhead value.\n     * @param _scalar            Initial scalar value.\n     * @param _batcherHash       Initial batcher hash.\n     * @param _gasLimit          Initial gas limit.\n     * @param _unsafeBlockSigner Initial unsafe block signer address.\n     */\n    constructor(\n        address _owner,\n        uint256 _overhead,\n        uint256 _scalar,\n        bytes32 _batcherHash,\n        uint64 _gasLimit,\n        address _unsafeBlockSigner\n    ) Semver(0, 1, 0) {\n        initialize(_owner, _overhead, _scalar, _batcherHash, _gasLimit, _unsafeBlockSigner);\n    }\n\n    /**\n     * @notice Initializer.\n     *\n     * @param _owner             Initial owner of the contract.\n     * @param _overhead          Initial overhead value.\n     * @param _scalar            Initial scalar value.\n     * @param _batcherHash       Initial batcher hash.\n     * @param _gasLimit          Initial gas limit.\n     * @param _unsafeBlockSigner Initial unsafe block signer address.\n     */\n    function initialize(\n        address _owner,\n        uint256 _overhead,\n        uint256 _scalar,\n        bytes32 _batcherHash,\n        uint64 _gasLimit,\n        address _unsafeBlockSigner\n    ) public initializer {\n        require(_gasLimit >= MINIMUM_GAS_LIMIT, \"SystemConfig: gas limit too low\");\n        __Ownable_init();\n        transferOwnership(_owner);\n        overhead = _overhead;\n        scalar = _scalar;\n        batcherHash = _batcherHash;\n        gasLimit = _gasLimit;\n        _setUnsafeBlockSigner(_unsafeBlockSigner);\n    }\n\n    /**\n     * @notice High level getter for the unsafe block signer address. Unsafe blocks can be\n     *         propagated across the p2p network if they are signed by the key corresponding to\n     *         this address.\n     *\n     * @return Address of the unsafe block signer.\n     */\n    // solhint-disable-next-line ordering\n    function unsafeBlockSigner() external view returns (address) {\n        address addr;\n        bytes32 slot = UNSAFE_BLOCK_SIGNER_SLOT;\n        assembly {\n            addr := sload(slot)\n        }\n        return addr;\n    }\n\n    /**\n     * @notice Updates the unsafe block signer address.\n     *\n     * @param _unsafeBlockSigner New unsafe block signer address.\n     */\n    function setUnsafeBlockSigner(address _unsafeBlockSigner) external onlyOwner {\n        _setUnsafeBlockSigner(_unsafeBlockSigner);\n\n        bytes memory data = abi.encode(_unsafeBlockSigner);\n        emit ConfigUpdate(VERSION, UpdateType.UNSAFE_BLOCK_SIGNER, data);\n    }\n\n    /**\n     * @notice Updates the batcher hash.\n     *\n     * @param _batcherHash New batcher hash.\n     */\n    function setBatcherHash(bytes32 _batcherHash) external onlyOwner {\n        batcherHash = _batcherHash;\n\n        bytes memory data = abi.encode(_batcherHash);\n        emit ConfigUpdate(VERSION, UpdateType.BATCHER, data);\n    }\n\n    /**\n     * @notice Updates gas config.\n     *\n     * @param _overhead New overhead value.\n     * @param _scalar   New scalar value.\n     */\n    function setGasConfig(uint256 _overhead, uint256 _scalar) external onlyOwner {\n        overhead = _overhead;\n        scalar = _scalar;\n\n        bytes memory data = abi.encode(_overhead, _scalar);\n        emit ConfigUpdate(VERSION, UpdateType.GAS_CONFIG, data);\n    }\n\n    /**\n     * @notice Updates the L2 gas limit.\n     *\n     * @param _gasLimit New gas limit.\n     */\n    function setGasLimit(uint64 _gasLimit) external onlyOwner {\n        require(_gasLimit >= MINIMUM_GAS_LIMIT, \"SystemConfig: gas limit too low\");\n        gasLimit = _gasLimit;\n\n        bytes memory data = abi.encode(_gasLimit);\n        emit ConfigUpdate(VERSION, UpdateType.GAS_LIMIT, data);\n    }\n\n    /**\n     * @notice Low level setter for the unsafe block signer address. This function exists to\n     *         deduplicate code around storing the unsafeBlockSigner address in storage.\n     *\n     * @param _unsafeBlockSigner New unsafeBlockSigner value.\n     */\n    function _setUnsafeBlockSigner(address _unsafeBlockSigner) internal {\n        bytes32 slot = UNSAFE_BLOCK_SIGNER_SLOT;\n        assembly {\n            sstore(slot, _unsafeBlockSigner)\n        }\n    }\n}\n"
    },
    "contracts/L1/ValidatorPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    ReentrancyGuardUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport { Types } from \"../libraries/Types.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @title ValidatorPool\n * @notice TBD\n */\ncontract ValidatorPool is ReentrancyGuardUpgradeable, Semver {\n    /**\n     * @notice The address of the colosseum. Can be updated via upgrade.\n     */\n    address public immutable COLOSSEUM_ADDRESS;\n\n    /**\n     * @notice The address of the trusted validator. Can be updated via upgrade.\n     */\n    address public immutable TRUSTED_VALIDATOR;\n\n    /**\n     * @notice The minimum deposit amount. Can be updated via upgrade.\n     */\n    uint256 public immutable MIN_DEPOSIT_AMOUNT;\n\n    /**\n     * @notice The slashing amount. Can be updated via upgrade.\n     */\n    uint256 public immutable SLASHING_AMOUNT;\n\n    /**\n     * @notice Mapping of registered validator addresses to boolean status.\n     */\n    mapping(address => bool) internal validators;\n\n    /**\n     * @notice Mapping of deposits of validators.\n     */\n    mapping(address => uint256) internal depositsOf;\n\n    /**\n     * @notice Emitted when a new validator is registered.\n     *\n     * @param validator The address of new validator.\n     */\n    event NewValidator(address validator);\n\n    /**\n     * @notice Emitted when the validator deposits.\n     *\n     * @param validator The address of new validator.\n     * @param amount    The deposit amount.\n     * @param balance   The deposit balance of validator.\n     */\n    event Deposit(address validator, uint256 amount, uint256 balance);\n\n    /**\n     * @notice Emitted when the validator withdraws.\n     *\n     * @param validator The address of new validator.\n     * @param amount    The withdrawal amount.\n     * @param balance   The deposit balance of validator.\n     */\n    event Withdraw(address validator, uint256 amount, uint256 balance);\n\n    /**\n     * @notice Emitted when the validator deposits is slashed.\n     *\n     * @param validator  The address of new validator.\n     * @param challenger The address of challenger.\n     * @param balance    The deposit balance of validator.\n     */\n    event Slashing(address validator, address challenger, uint256 balance);\n\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _colosseumAddress The address of colosseum contract.\n     * @param _trustedValidator The address of trusted validator.\n     * @param _minDepositAmount The minimum deposit amount.\n     * @param _slashingAmount   The slashing amount.\n     */\n    constructor(\n        address _colosseumAddress,\n        address _trustedValidator,\n        uint256 _minDepositAmount,\n        uint256 _slashingAmount\n    ) Semver(0, 1, 0) {\n        COLOSSEUM_ADDRESS = _colosseumAddress;\n        TRUSTED_VALIDATOR = _trustedValidator;\n        MIN_DEPOSIT_AMOUNT = _minDepositAmount;\n        SLASHING_AMOUNT = _slashingAmount;\n        initialize();\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize() public initializer {}\n\n    function deposit() external payable nonReentrant {\n        uint256 newDeposits = depositsOf[msg.sender] + msg.value;\n        require(msg.sender != TRUSTED_VALIDATOR, \"ValidatorPool: trusted validator cannot deposit\");\n        require(\n            newDeposits >= MIN_DEPOSIT_AMOUNT,\n            \"ValidatorPool: the total deposit is less than minimum amount\"\n        );\n\n        depositsOf[msg.sender] = newDeposits;\n\n        if (!validators[msg.sender]) {\n            validators[msg.sender] = true;\n            emit NewValidator(msg.sender);\n        }\n\n        emit Deposit(msg.sender, msg.value, newDeposits);\n    }\n\n    function withdraw(uint256 amount) external nonReentrant {\n        uint256 deposits = depositsOf[msg.sender];\n        require(deposits >= amount, \"ValidatorPool: insufficient deposits\");\n\n        (bool success, ) = address(this).call{ value: amount }(\"\");\n        require(success, \"ValidatorPool: failed to withdraw\");\n\n        emit Withdraw(msg.sender, amount, deposits - amount);\n    }\n\n    function slash(address validator, address challenger) external nonReentrant {\n        require(\n            msg.sender == COLOSSEUM_ADDRESS,\n            \"ValidatorPool: sender is not a colosseum contract\"\n        );\n        require(\n            validator != TRUSTED_VALIDATOR,\n            \"ValidatorPool: cannot slash deposits of trusted validator\"\n        );\n\n        uint256 validatorDeposits = depositsOf[validator];\n        uint256 slashing = SLASHING_AMOUNT;\n\n        if (validatorDeposits < SLASHING_AMOUNT) {\n            slashing = validatorDeposits - SLASHING_AMOUNT;\n        }\n\n        depositsOf[validator] -= slashing;\n        depositsOf[challenger] += slashing;\n\n        emit Slashing(validator, challenger, validatorDeposits);\n    }\n\n    /**\n     * @notice Returns the deposit balance of validator.\n     *\n     * @param _validator The address of validator\n     *\n     * @return Deposit balance of validator.\n     */\n    function balanceOf(address _validator) public view returns (uint256) {\n        return depositsOf[_validator];\n    }\n\n    function isValidator(address _validator) public view returns (bool) {\n        return validators[_validator] || _validator == TRUSTED_VALIDATOR;\n    }\n\n    function isValidatorAlive(address _validator) public view returns (bool) {\n        return depositsOf[_validator] > 0 || _validator == TRUSTED_VALIDATOR;\n    }\n}\n"
    },
    "contracts/L1/ZKMerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bytes } from \"../libraries/Bytes.sol\";\nimport { NodeReader } from \"../libraries/NodeReader.sol\";\nimport { ZKTrieHasher } from \"./ZKTrieHasher.sol\";\n\n/**\n * @custom:proxied\n * @title ZKMerkleTrie\n * @notice The ZKMerkleTrie is contract which can produce a hash according to ZKTrie.\n *         This owns an interface of Poseidon2 that is required to compute hash used by ZKTrie.\n */\ncontract ZKMerkleTrie is ZKTrieHasher {\n    /**\n     * @notice Struct representing a node in the trie.\n     */\n    struct TrieNode {\n        bytes encoded;\n        NodeReader.Node decoded;\n    }\n\n    /**\n     * @notice Magic hash which indicates\n     *         See https://github.com/kroma-network/zktrie/blob/main/trie/zk_trie_proof.go.\n     */\n    bytes32 private constant MAGIC_SMT_BYTES_HASH =\n        keccak256(\n            hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\"\n        );\n\n    /**\n     * @param _poseidon2 The address of poseidon2 contract.\n     */\n    constructor(address _poseidon2) ZKTrieHasher(_poseidon2) {}\n\n    /**\n     * @notice Checks if a given bytes is MAGIC_SMT_BYTES_HASH.\n     *\n     * @param _value Bytes to be compared.\n     */\n    function isMagicSmtBytesHash(bytes memory _value) private pure returns (bool) {\n        return keccak256(_value) == MAGIC_SMT_BYTES_HASH;\n    }\n\n    /**\n     * @notice Verifies a proof that a given key/value pair is present in the trie.\n     *\n     * @param _key    Key of the node to search for, as a hex string.\n     * @param _value  Value of the node to search for, as a hex string.\n     * @param _proofs Merkle trie inclusion proof for the desired node.\n     * @param _root   Known root of the Merkle trie. Used to verify that the included proof is\n     *                correctly constructed.\n     *\n     * @return Whether or not the proof is valid.\n     */\n    function verifyInclusionProof(\n        bytes32 _key,\n        bytes memory _value,\n        bytes[] memory _proofs,\n        bytes32 _root\n    ) external view returns (bool) {\n        (bool exists, bytes memory value) = this.get(_key, _proofs, _root);\n        return (exists && Bytes.equal(_value, value));\n    }\n\n    /**\n     * @notice Retrieves the value associated with a given key.\n     *\n     * @param _key    Key to search for, as hex bytes.\n     * @param _proofs Merkle trie inclusion proof for the key.\n     * @param _root   Known root of the Merkle trie.\n     *\n     * @return Whether or not the key exists.\n     * @return Value of the key if it exists.\n     */\n    function get(\n        bytes32 _key,\n        bytes[] memory _proofs,\n        bytes32 _root\n    ) external view returns (bool, bytes memory) {\n        require(_proofs.length >= 2, \"ZKMerkleTrie: provided proof is too short\");\n        require(\n            isMagicSmtBytesHash(_proofs[_proofs.length - 1]),\n            \"ZKMerkleTrie: the last item is not magic hash\"\n        );\n        bytes32 key = _hashElem(_key);\n        TrieNode[] memory nodes = _parseProofs(_proofs);\n        NodeReader.Node memory currentNode;\n        bytes32 computedKey = bytes32(0);\n        bool exists = false;\n        bool empty = false;\n        bytes memory value = bytes(\"\");\n        for (uint256 i = nodes.length - 2; i >= 0; ) {\n            currentNode = nodes[i].decoded;\n            if (currentNode.nodeType == NodeReader.NodeType.MIDDLE) {\n                bool isLeft = _isLeft(key, i);\n                if (isLeft) {\n                    require(computedKey == currentNode.childL, \"ZKMerkleTrie: invalid key L\");\n                } else {\n                    require(computedKey == currentNode.childR, \"ZKMerkleTrie: invalid key R\");\n                }\n                bytes32[] memory inputs = new bytes32[](2);\n                inputs[0] = currentNode.childL;\n                inputs[1] = currentNode.childR;\n                computedKey = _hashElems(inputs);\n            } else if (currentNode.nodeType == NodeReader.NodeType.LEAF) {\n                require(!exists, \"ZKMerkleTrie: duplicated leaf node\");\n                exists = true;\n                bytes32[] memory inputs = new bytes32[](3);\n                inputs[0] = bytes32(uint256(1));\n                inputs[1] = currentNode.nodeKey;\n                inputs[2] = _valueHash(currentNode.compressedFlags, currentNode.valuePreimage);\n                computedKey = _hashElems(inputs);\n                // TODO(chokobole): How about fixing length of valuePreimage to be 1?\n                value = new bytes(currentNode.valuePreimage.length * 32);\n                uint256 offset = 32;\n                for (uint256 j = 0; j < currentNode.valuePreimage.length; ) {\n                    bytes32 valuePreimage = currentNode.valuePreimage[j];\n                    assembly {\n                        mstore(add(value, offset), valuePreimage)\n                    }\n                    unchecked {\n                        ++j;\n                        offset += 32;\n                    }\n                }\n                if (currentNode.keyPreimage != bytes32(0)) {\n                    // NOTE(chokobole): The comparison order is important, because in this setting,\n                    // first condition is mostly evaluted to be true. When we're sure about\n                    // database preimage, then we need to enable just one of check below!\n                    require(\n                        currentNode.keyPreimage == _key || currentNode.keyPreimage == key,\n                        \"ZKMerkleTrie: invalid key preimage\"\n                    );\n                }\n            } else if (currentNode.nodeType == NodeReader.NodeType.EMPTY) {\n                require(!empty, \"ZKMerkleTrie: duplicated empty node\");\n                empty = true;\n            }\n            if (i == 0) {\n                require(computedKey == _root, \"ZKMerkeTrie: invalid root\");\n                break;\n            }\n            unchecked {\n                --i;\n            }\n        }\n        return (exists, value);\n    }\n\n    /**\n     * @notice Parses an array of proof elements into a new array that contains both the original\n     *         encoded element and the decoded element.\n     *\n     * @param _proofs Array of proof elements to parse.\n     *\n     * @return TrieNode parsed into easily accessible structs.\n     */\n    function _parseProofs(bytes[] memory _proofs) private pure returns (TrieNode[] memory) {\n        uint256 length = _proofs.length;\n        TrieNode[] memory nodes = new TrieNode[](length);\n        // NOTE(chokobole): Last proof is MAGIC_SMT_BYTES_HASH!\n        for (uint256 i = 0; i < length - 1; ) {\n            NodeReader.Node memory node = NodeReader.readNode(_proofs[i]);\n            nodes[i] = TrieNode({ encoded: _proofs[i], decoded: node });\n            unchecked {\n                ++i;\n            }\n        }\n        return nodes;\n    }\n\n    /**\n     * @notice Computes merkle path at index n based on a given keyPreimage.\n     *\n     * @param _keyPreimage Keypreimage.\n     * @param _n           Bit to mask.\n     *\n     * @return Whether merkle path is left or not.\n     */\n    function _isLeft(bytes32 _keyPreimage, uint256 _n) private pure returns (bool) {\n        require(_n < 256, \"ZKMerkleTrie: too long depth\");\n        return _keyPreimage & bytes32(1 << _n) == 0;\n    }\n}\n"
    },
    "contracts/L1/ZKTrieHasher.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { Bytes32 } from \"../libraries/Bytes32.sol\";\n\n/**\n * @title IPoseidon2\n */\ninterface IPoseidon2 {\n    function poseidon(bytes32[2] memory inputs) external pure returns (bytes32);\n}\n\n/**\n * @custom:proxied\n * @title ZKTrieHasher\n * @notice The ZKTrieHasher is contract which can produce a hash according to ZKTrie.\n *         This owns an interface of Poseidon2 that is required to compute hash used by ZKTrie.\n */\ncontract ZKTrieHasher {\n    /**\n     * @notice Poseidon2 contract generated by circomlibjs.\n     */\n    IPoseidon2 public immutable POSEIDON2;\n\n    /**\n     * @param _poseidon2 The address of poseidon2 contract.\n     */\n    constructor(address _poseidon2) {\n        POSEIDON2 = IPoseidon2(_poseidon2);\n    }\n\n    /**\n     * @notice Computes a hash of values.\n     *\n     * @param _compressedFlags Compressed flags.\n     * @param _values          Values.\n     *\n     * @return A hash of values.\n     */\n    function _valueHash(uint32 _compressedFlags, bytes32[] memory _values)\n        internal\n        view\n        returns (bytes32)\n    {\n        require(_values.length >= 1, \"ZKTrieHasher: too few values for _valueHash\");\n        bytes32[] memory ret = new bytes32[](_values.length);\n        for (uint256 i = 0; i < _values.length; ) {\n            if ((_compressedFlags & (1 << i)) != 0) {\n                ret[i] = _hashElem(_values[i]);\n            } else {\n                ret[i] = _values[i];\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        if (_values.length < 2) {\n            return ret[0];\n        }\n        return _hashElems(ret);\n    }\n\n    /**\n     * @notice Computes a hash of an element.\n     *\n     * @param _elem Bytes32 to be hashed.\n     *\n     * @return A hash of an element.\n     */\n    function _hashElem(bytes32 _elem) internal view returns (bytes32) {\n        (bytes32 high, bytes32 low) = Bytes32.split(_elem);\n        return POSEIDON2.poseidon([high, low]);\n    }\n\n    /**\n     * @notice Computes a hash of elements.\n     *\n     * @param _elems Bytes32 array to be hashed.\n     *\n     * @return A hash of element.\n     */\n    function _hashElems(bytes32[] memory _elems) internal view returns (bytes32) {\n        require(_elems.length >= 2, \"ZKTrieHasher: too few values for _hashElems\");\n        bytes32 baseH = POSEIDON2.poseidon([_elems[0], _elems[1]]);\n        if (_elems.length == 2) return baseH;\n        else if (_elems.length == 3) {\n            return POSEIDON2.poseidon([baseH, _elems[2]]);\n        }\n        bytes32[] memory newValues = new bytes32[](_elems.length / 2 + 1);\n        newValues[0] = baseH;\n        for (uint256 i = 0; i < newValues.length; ) {\n            if ((i + 1) * 2 > _elems.length) {\n                newValues[i] = _elems[i * 2 + 1];\n            } else {\n                newValues[i] = POSEIDON2.poseidon([_elems[i * 2], _elems[i * 2 + 1]]);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return _hashElems(newValues);\n    }\n}\n"
    },
    "contracts/L1/ZKVerifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\n// degree 22\ncontract ZKVerifier {\n    function pairing(G1Point[] memory p1, G2Point[] memory p2) internal view returns (bool) {\n        uint256 length = p1.length * 6;\n        uint256[] memory input = new uint256[](length);\n        uint256[1] memory result;\n        bool ret;\n\n        require(p1.length == p2.length);\n\n        for (uint256 i = 0; i < p1.length; i++) {\n            input[0 + i * 6] = p1[i].x;\n            input[1 + i * 6] = p1[i].y;\n            input[2 + i * 6] = p2[i].x[0];\n            input[3 + i * 6] = p2[i].x[1];\n            input[4 + i * 6] = p2[i].y[0];\n            input[5 + i * 6] = p2[i].y[1];\n        }\n\n        assembly {\n            ret := staticcall(\n            gas(),\n            8,\n            add(input, 0x20),\n            mul(length, 0x20),\n            result,\n            0x20\n            )\n        }\n        require(ret);\n        return result[0] != 0;\n    }\n\n    uint256 constant q_mod =\n    21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    function fr_invert(uint256 a) internal view returns (uint256) {\n        return fr_pow(a, q_mod - 2);\n    }\n\n    function fr_pow(uint256 a, uint256 power) internal view returns (uint256) {\n        uint256[6] memory input;\n        uint256[1] memory result;\n        bool ret;\n\n        input[0] = 32;\n        input[1] = 32;\n        input[2] = 32;\n        input[3] = a;\n        input[4] = power;\n        input[5] = q_mod;\n\n        assembly {\n            ret := staticcall(gas(), 0x05, input, 0xc0, result, 0x20)\n        }\n        require(ret);\n\n        return result[0];\n    }\n\n    function fr_div(uint256 a, uint256 b) internal view returns (uint256) {\n        require(b != 0);\n        return mulmod(a, fr_invert(b), q_mod);\n    }\n\n    function fr_mul_add(\n        uint256 a,\n        uint256 b,\n        uint256 c\n    ) internal pure returns (uint256) {\n        return addmod(mulmod(a, b, q_mod), c, q_mod);\n    }\n\n    function fr_mul_add_pm(\n        uint256[84] memory m,\n        uint256[] calldata proof,\n        uint256 opcode,\n        uint256 t\n    ) internal pure returns (uint256) {\n        for (uint256 i = 0; i < 32; i += 2) {\n            uint256 a = opcode & 0xff;\n            if (a != 0xff) {\n                opcode >>= 8;\n                uint256 b = opcode & 0xff;\n                opcode >>= 8;\n                t = addmod(mulmod(proof[a], m[b], q_mod), t, q_mod);\n            } else {\n                break;\n            }\n        }\n\n        return t;\n    }\n\n    function fr_mul_add_mt(\n        uint256[84] memory m,\n        uint256 base,\n        uint256 opcode,\n        uint256 t\n    ) internal pure returns (uint256) {\n        for (uint256 i = 0; i < 32; i += 1) {\n            uint256 a = opcode & 0xff;\n            if (a != 0xff) {\n                opcode >>= 8;\n                t = addmod(mulmod(base, t, q_mod), m[a], q_mod);\n            } else {\n                break;\n            }\n        }\n\n        return t;\n    }\n\n    function fr_reverse(uint256 input) internal pure returns (uint256 v) {\n        v = input;\n\n        // swap bytes\n        v = ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8) |\n        ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n\n        // swap 2-byte long pairs\n        v = ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16) |\n        ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n\n        // swap 4-byte long pairs\n        v = ((v & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32) |\n        ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n\n        // swap 8-byte long pairs\n        v = ((v & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64) |\n        ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n\n        // swap 16-byte long pairs\n        v = (v >> 128) | (v << 128);\n    }\n\n    uint256 constant p_mod =\n    21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    struct G1Point {\n        uint256 x;\n        uint256 y;\n    }\n\n    struct G2Point {\n        uint256[2] x;\n        uint256[2] y;\n    }\n\n    function ecc_from(uint256 x, uint256 y)\n    internal\n    pure\n    returns (G1Point memory r)\n    {\n        r.x = x;\n        r.y = y;\n    }\n\n    function ecc_add(uint256 ax, uint256 ay, uint256 bx, uint256 by)\n    internal\n    view\n    returns (uint256, uint256)\n    {\n        bool ret = false;\n        G1Point memory r;\n        uint256[4] memory input_points;\n\n        input_points[0] = ax;\n        input_points[1] = ay;\n        input_points[2] = bx;\n        input_points[3] = by;\n\n        assembly {\n            ret := staticcall(gas(), 6, input_points, 0x80, r, 0x40)\n        }\n        require(ret);\n\n        return (r.x, r.y);\n    }\n\n    function ecc_sub(uint256 ax, uint256 ay, uint256 bx, uint256 by)\n    internal\n    view\n    returns (uint256, uint256)\n    {\n        return ecc_add(ax, ay, bx, p_mod - by);\n    }\n\n    function ecc_mul(uint256 px, uint256 py, uint256 s)\n    internal\n    view\n    returns (uint256, uint256)\n    {\n        uint256[3] memory input;\n        bool ret = false;\n        G1Point memory r;\n\n        input[0] = px;\n        input[1] = py;\n        input[2] = s;\n\n        assembly {\n            ret := staticcall(gas(), 7, input, 0x60, r, 0x40)\n        }\n        require(ret);\n\n        return (r.x, r.y);\n    }\n\n    function _ecc_mul_add(uint256[5] memory input)\n    internal\n    view\n    {\n        bool ret = false;\n\n        assembly {\n            ret := staticcall(gas(), 7, input, 0x60, add(input, 0x20), 0x40)\n        }\n        require(ret);\n\n        assembly {\n            ret := staticcall(gas(), 6, add(input, 0x20), 0x80, add(input, 0x60), 0x40)\n        }\n        require(ret);\n    }\n\n    function ecc_mul_add(uint256 px, uint256 py, uint256 s, uint256 qx, uint256 qy)\n    internal\n    view\n    returns (uint256, uint256)\n    {\n        uint256[5] memory input;\n        input[0] = px;\n        input[1] = py;\n        input[2] = s;\n        input[3] = qx;\n        input[4] = qy;\n\n        _ecc_mul_add(input);\n\n        return (input[3], input[4]);\n    }\n\n    function ecc_mul_add_pm(\n        uint256[84] memory m,\n        uint256[] calldata proof,\n        uint256 opcode,\n        uint256 t0,\n        uint256 t1\n    ) internal view returns (uint256, uint256) {\n        uint256[5] memory input;\n        input[3] = t0;\n        input[4] = t1;\n        for (uint256 i = 0; i < 32; i += 2) {\n            uint256 a = opcode & 0xff;\n            if (a != 0xff) {\n                opcode >>= 8;\n                uint256 b = opcode & 0xff;\n                opcode >>= 8;\n                input[0] = proof[a];\n                input[1] = proof[a + 1];\n                input[2] = m[b];\n                _ecc_mul_add(input);\n            } else {\n                break;\n            }\n        }\n\n        return (input[3], input[4]);\n    }\n\n    function update_hash_scalar(uint256 v, uint256[144] memory absorbing, uint256 pos) internal pure {\n        absorbing[pos++] = 0x02;\n        absorbing[pos++] = v;\n    }\n\n    function update_hash_point(uint256 x, uint256 y, uint256[144] memory absorbing, uint256 pos) internal pure {\n        absorbing[pos++] = 0x01;\n        absorbing[pos++] = x;\n        absorbing[pos++] = y;\n    }\n\n    function to_scalar(bytes32 r) private pure returns (uint256 v) {\n        uint256 tmp = uint256(r);\n        tmp = fr_reverse(tmp);\n        v = tmp % 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;\n    }\n\n    function hash(uint256[144] memory absorbing, uint256 length) private view returns (bytes32[1] memory v) {\n        bool success;\n        assembly {\n            success := staticcall(sub(gas(), 2000), 2, absorbing, length, v, 32)\n            switch success case 0 { invalid() }\n        }\n        assert(success);\n    }\n\n    function squeeze_challenge(uint256[144] memory absorbing, uint32 length) internal view returns (uint256 v) {\n        absorbing[length] = 0;\n        bytes32 res = hash(absorbing, length * 32 + 1)[0];\n        v = to_scalar(res);\n        absorbing[0] = uint256(res);\n        length = 1;\n    }\n\n    function get_verify_circuit_g2_s() internal pure returns (G2Point memory s) {\n        s.x[0] = uint256(19996377281670978687180986182441301914718493784645870391946826878753710639456);\n        s.x[1] = uint256(4287478848095488335912479212753150961411468232106701703291869721868407715111);\n        s.y[0] = uint256(6995741485533723263267942814565501722132921805029874890336635619836737653877);\n        s.y[1] = uint256(11126659726611658836425410744462014686753643655648740844565393330984713428953);\n    }\n\n    function get_verify_circuit_g2_n() internal pure returns (G2Point memory n) {\n        n.x[0] = uint256(11559732032986387107991004021392285783925812861821192530917403151452391805634);\n        n.x[1] = uint256(10857046999023057135944570762232829481370756359578518086990519993285655852781);\n        n.y[0] = uint256(17805874995975841540914202342111839520379459829704422454583296818431106115052);\n        n.y[1] = uint256(13392588948715843804641432497768002650278120570034223513918757245338268106653);\n    }\n\n    function get_target_circuit_g2_s() internal pure returns (G2Point memory s) {\n        s.x[0] = uint256(13248582054897787373601989472583235208773272229661392322468236885784363196202);\n        s.x[1] = uint256(17724970336479649347122385879443248160462181404534435801587075993317378807815);\n        s.y[0] = uint256(9240867665184644458388355907871488947121426952899966964435462618131589174075);\n        s.y[1] = uint256(2290661379703939619525520604437966697427254096465577359551078618013852209381);\n    }\n\n    function get_target_circuit_g2_n() internal pure returns (G2Point memory n) {\n        n.x[0] = uint256(11559732032986387107991004021392285783925812861821192530917403151452391805634);\n        n.x[1] = uint256(10857046999023057135944570762232829481370756359578518086990519993285655852781);\n        n.y[0] = uint256(17805874995975841540914202342111839520379459829704422454583296818431106115052);\n        n.y[1] = uint256(13392588948715843804641432497768002650278120570034223513918757245338268106653);\n    }\n\n    function get_wx_wg(uint256[] calldata proof, uint256[4] memory instances)\n    internal\n    view\n    returns (uint256, uint256, uint256, uint256)\n    {\n        uint256[84] memory m;\n        uint256[144] memory absorbing;\n        uint256 t0 = 0;\n        uint256 t1 = 0;\n\n\n        (t0, t1) = (ecc_mul(13911018583007884881416842514661274050567796652031922980888952067142200734890, 6304656948134906299141761906515211516376236447819044970320185642735642777036, instances[0]));\n        (t0, t1) = (ecc_mul_add(10634526547038245645834822324032425487434811507756950001533785848774317018670, 11025818855933089539342999945076144168100709119485154428833847826982360951459, instances[1], t0, t1));\n        (t0, t1) = (ecc_mul_add(13485936455723319058155687139769502499697405985650416391707184524158646623799, 16234009237501684544798205490615498675425737095147152991328466405207467143566, instances[2], t0, t1));\n        (m[0], m[1]) = (ecc_mul_add(21550585789286941025166870525096478397065943995678337623823808437877187678077, 4447338868884713453743453617617291019986465683944733951178865127876671635659, instances[3], t0, t1));\n        update_hash_scalar(11128271094435464813502659979402794361360928921426997987191214123850851013226, absorbing, 0);\n        update_hash_point(m[0], m[1], absorbing, 2);\n        for (t0 = 0; t0 <= 4; t0++) {\n            update_hash_point(proof[0 + t0 * 2], proof[1 + t0 * 2], absorbing, 5 + t0 * 3);\n        }\n        m[2] = (squeeze_challenge(absorbing, 20));\n        for (t0 = 0; t0 <= 13; t0++) {\n            update_hash_point(proof[10 + t0 * 2], proof[11 + t0 * 2], absorbing, 1 + t0 * 3);\n        }\n        m[3] = (squeeze_challenge(absorbing, 43));\n        m[4] = (squeeze_challenge(absorbing, 1));\n        for (t0 = 0; t0 <= 9; t0++) {\n            update_hash_point(proof[38 + t0 * 2], proof[39 + t0 * 2], absorbing, 1 + t0 * 3);\n        }\n        m[5] = (squeeze_challenge(absorbing, 31));\n        for (t0 = 0; t0 <= 3; t0++) {\n            update_hash_point(proof[58 + t0 * 2], proof[59 + t0 * 2], absorbing, 1 + t0 * 3);\n        }\n        m[6] = (squeeze_challenge(absorbing, 13));\n        for (t0 = 0; t0 <= 70; t0++) {\n            update_hash_scalar(proof[66 + t0 * 1], absorbing, 1 + t0 * 2);\n        }\n        m[7] = (squeeze_challenge(absorbing, 143));\n        for (t0 = 0; t0 <= 3; t0++) {\n            update_hash_point(proof[137 + t0 * 2], proof[138 + t0 * 2], absorbing, 1 + t0 * 3);\n        }\n        m[8] = (squeeze_challenge(absorbing, 13));\n        m[9] = (mulmod(m[6], 6143038923529407703646399695489445107254060255791852207908457597807435305312, q_mod));\n        m[10] = (mulmod(m[6], 7358966525675286471217089135633860168646304224547606326237275077574224349359, q_mod));\n        m[11] = (mulmod(m[6], 11377606117859914088982205826922132024839443553408109299929510653283289974216, q_mod));\n        m[12] = (fr_pow(m[6], 33554432));\n        m[13] = (addmod(m[12], q_mod - 1, q_mod));\n        m[14] = (mulmod(21888242219518804655518433051623070663413851959604507555939307129453691614729, m[13], q_mod));\n        t0 = (addmod(m[6], q_mod - 1, q_mod));\n        m[14] = (fr_div(m[14], t0));\n        m[15] = (mulmod(3814514741328848551622746860665626251343731549210296844380905280010844577811, m[13], q_mod));\n        t0 = (addmod(m[6], q_mod - 11377606117859914088982205826922132024839443553408109299929510653283289974216, q_mod));\n        m[15] = (fr_div(m[15], t0));\n        m[16] = (mulmod(14167635312934689395373925807699824183296350635557349457928542208657273886961, m[13], q_mod));\n        t0 = (addmod(m[6], q_mod - 17329448237240114492580865744088056414251735686965494637158808787419781175510, q_mod));\n        m[16] = (fr_div(m[16], t0));\n        m[17] = (mulmod(12609034248192017902501772617940356704925468750503023243291639149763830461639, m[13], q_mod));\n        t0 = (addmod(m[6], q_mod - 16569469942529664681363945218228869388192121720036659574609237682362097667612, q_mod));\n        m[17] = (fr_div(m[17], t0));\n        m[18] = (mulmod(12805242257443675784492534138904933930037912868081131057088370227525924812579, m[13], q_mod));\n        t0 = (addmod(m[6], q_mod - 9741553891420464328295280489650144566903017206473301385034033384879943874347, q_mod));\n        m[18] = (fr_div(m[18], t0));\n        m[19] = (mulmod(6559137297042406441428413756926584610543422337862324541665337888392460442551, m[13], q_mod));\n        t0 = (addmod(m[6], q_mod - 5723528081196465413808013109680264505774289533922470433187916976440924869204, q_mod));\n        m[19] = (fr_div(m[19], t0));\n        m[20] = (mulmod(14811589476322888753142612645486192973009181596950146578897598212834285850868, m[13], q_mod));\n        t0 = (addmod(m[6], q_mod - 7358966525675286471217089135633860168646304224547606326237275077574224349359, q_mod));\n        m[20] = (fr_div(m[20], t0));\n        t0 = (addmod(m[15], m[16], q_mod));\n        t0 = (addmod(t0, m[17], q_mod));\n        t0 = (addmod(t0, m[18], q_mod));\n        m[15] = (addmod(t0, m[19], q_mod));\n        t0 = (fr_mul_add(proof[74], proof[72], proof[73]));\n        t0 = (fr_mul_add(proof[75], proof[67], t0));\n        t0 = (fr_mul_add(proof[76], proof[68], t0));\n        t0 = (fr_mul_add(proof[77], proof[69], t0));\n        t0 = (fr_mul_add(proof[78], proof[70], t0));\n        m[16] = (fr_mul_add(proof[79], proof[71], t0));\n        t0 = (mulmod(proof[67], proof[68], q_mod));\n        m[16] = (fr_mul_add(proof[80], t0, m[16]));\n        t0 = (mulmod(proof[69], proof[70], q_mod));\n        m[16] = (fr_mul_add(proof[81], t0, m[16]));\n        t0 = (addmod(1, q_mod - proof[97], q_mod));\n        m[17] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[100], proof[100], q_mod));\n        t0 = (addmod(t0, q_mod - proof[100], q_mod));\n        m[18] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(proof[100], q_mod - proof[99], q_mod));\n        m[19] = (mulmod(t0, m[14], q_mod));\n        m[21] = (mulmod(m[3], m[6], q_mod));\n        t0 = (addmod(m[20], m[15], q_mod));\n        m[15] = (addmod(1, q_mod - t0, q_mod));\n        m[22] = (addmod(proof[67], m[4], q_mod));\n        t0 = (fr_mul_add(proof[91], m[3], m[22]));\n        m[23] = (mulmod(t0, proof[98], q_mod));\n        t0 = (addmod(m[22], m[21], q_mod));\n        m[22] = (mulmod(t0, proof[97], q_mod));\n        m[24] = (mulmod(4131629893567559867359510883348571134090853742863529169391034518566172092834, m[21], q_mod));\n        m[25] = (addmod(proof[68], m[4], q_mod));\n        t0 = (fr_mul_add(proof[92], m[3], m[25]));\n        m[23] = (mulmod(t0, m[23], q_mod));\n        t0 = (addmod(m[25], m[24], q_mod));\n        m[22] = (mulmod(t0, m[22], q_mod));\n        m[24] = (mulmod(4131629893567559867359510883348571134090853742863529169391034518566172092834, m[24], q_mod));\n        m[25] = (addmod(proof[69], m[4], q_mod));\n        t0 = (fr_mul_add(proof[93], m[3], m[25]));\n        m[23] = (mulmod(t0, m[23], q_mod));\n        t0 = (addmod(m[25], m[24], q_mod));\n        m[22] = (mulmod(t0, m[22], q_mod));\n        m[24] = (mulmod(4131629893567559867359510883348571134090853742863529169391034518566172092834, m[24], q_mod));\n        t0 = (addmod(m[23], q_mod - m[22], q_mod));\n        m[22] = (mulmod(t0, m[15], q_mod));\n        m[21] = (mulmod(m[21], 11166246659983828508719468090013646171463329086121580628794302409516816350802, q_mod));\n        m[23] = (addmod(proof[70], m[4], q_mod));\n        t0 = (fr_mul_add(proof[94], m[3], m[23]));\n        m[24] = (mulmod(t0, proof[101], q_mod));\n        t0 = (addmod(m[23], m[21], q_mod));\n        m[23] = (mulmod(t0, proof[100], q_mod));\n        m[21] = (mulmod(4131629893567559867359510883348571134090853742863529169391034518566172092834, m[21], q_mod));\n        m[25] = (addmod(proof[71], m[4], q_mod));\n        t0 = (fr_mul_add(proof[95], m[3], m[25]));\n        m[24] = (mulmod(t0, m[24], q_mod));\n        t0 = (addmod(m[25], m[21], q_mod));\n        m[23] = (mulmod(t0, m[23], q_mod));\n        m[21] = (mulmod(4131629893567559867359510883348571134090853742863529169391034518566172092834, m[21], q_mod));\n        m[25] = (addmod(proof[66], m[4], q_mod));\n        t0 = (fr_mul_add(proof[96], m[3], m[25]));\n        m[24] = (mulmod(t0, m[24], q_mod));\n        t0 = (addmod(m[25], m[21], q_mod));\n        m[23] = (mulmod(t0, m[23], q_mod));\n        m[21] = (mulmod(4131629893567559867359510883348571134090853742863529169391034518566172092834, m[21], q_mod));\n        t0 = (addmod(m[24], q_mod - m[23], q_mod));\n        m[21] = (mulmod(t0, m[15], q_mod));\n        t0 = (addmod(proof[104], m[3], q_mod));\n        m[23] = (mulmod(proof[103], t0, q_mod));\n        t0 = (addmod(proof[106], m[4], q_mod));\n        m[23] = (mulmod(m[23], t0, q_mod));\n        m[24] = (mulmod(proof[67], proof[82], q_mod));\n        m[2] = (mulmod(0, m[2], q_mod));\n        m[24] = (addmod(m[2], m[24], q_mod));\n        m[25] = (addmod(m[2], proof[83], q_mod));\n        m[26] = (addmod(proof[104], q_mod - proof[106], q_mod));\n        t0 = (addmod(1, q_mod - proof[102], q_mod));\n        m[27] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[102], proof[102], q_mod));\n        t0 = (addmod(t0, q_mod - proof[102], q_mod));\n        m[28] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(m[24], m[3], q_mod));\n        m[24] = (mulmod(proof[102], t0, q_mod));\n        m[25] = (addmod(m[25], m[4], q_mod));\n        t0 = (mulmod(m[24], m[25], q_mod));\n        t0 = (addmod(m[23], q_mod - t0, q_mod));\n        m[23] = (mulmod(t0, m[15], q_mod));\n        m[24] = (mulmod(m[14], m[26], q_mod));\n        t0 = (addmod(proof[104], q_mod - proof[105], q_mod));\n        t0 = (mulmod(m[26], t0, q_mod));\n        m[26] = (mulmod(t0, m[15], q_mod));\n        t0 = (addmod(proof[109], m[3], q_mod));\n        m[29] = (mulmod(proof[108], t0, q_mod));\n        t0 = (addmod(proof[111], m[4], q_mod));\n        m[29] = (mulmod(m[29], t0, q_mod));\n        m[30] = (fr_mul_add(proof[82], proof[68], m[2]));\n        m[31] = (addmod(proof[109], q_mod - proof[111], q_mod));\n        t0 = (addmod(1, q_mod - proof[107], q_mod));\n        m[32] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[107], proof[107], q_mod));\n        t0 = (addmod(t0, q_mod - proof[107], q_mod));\n        m[33] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(m[30], m[3], q_mod));\n        t0 = (mulmod(proof[107], t0, q_mod));\n        t0 = (mulmod(t0, m[25], q_mod));\n        t0 = (addmod(m[29], q_mod - t0, q_mod));\n        m[29] = (mulmod(t0, m[15], q_mod));\n        m[30] = (mulmod(m[14], m[31], q_mod));\n        t0 = (addmod(proof[109], q_mod - proof[110], q_mod));\n        t0 = (mulmod(m[31], t0, q_mod));\n        m[31] = (mulmod(t0, m[15], q_mod));\n        t0 = (addmod(proof[114], m[3], q_mod));\n        m[34] = (mulmod(proof[113], t0, q_mod));\n        t0 = (addmod(proof[116], m[4], q_mod));\n        m[34] = (mulmod(m[34], t0, q_mod));\n        m[35] = (fr_mul_add(proof[82], proof[69], m[2]));\n        m[36] = (addmod(proof[114], q_mod - proof[116], q_mod));\n        t0 = (addmod(1, q_mod - proof[112], q_mod));\n        m[37] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[112], proof[112], q_mod));\n        t0 = (addmod(t0, q_mod - proof[112], q_mod));\n        m[38] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(m[35], m[3], q_mod));\n        t0 = (mulmod(proof[112], t0, q_mod));\n        t0 = (mulmod(t0, m[25], q_mod));\n        t0 = (addmod(m[34], q_mod - t0, q_mod));\n        m[34] = (mulmod(t0, m[15], q_mod));\n        m[35] = (mulmod(m[14], m[36], q_mod));\n        t0 = (addmod(proof[114], q_mod - proof[115], q_mod));\n        t0 = (mulmod(m[36], t0, q_mod));\n        m[36] = (mulmod(t0, m[15], q_mod));\n        t0 = (addmod(proof[119], m[3], q_mod));\n        m[39] = (mulmod(proof[118], t0, q_mod));\n        t0 = (addmod(proof[121], m[4], q_mod));\n        m[39] = (mulmod(m[39], t0, q_mod));\n        m[40] = (fr_mul_add(proof[82], proof[70], m[2]));\n        m[41] = (addmod(proof[119], q_mod - proof[121], q_mod));\n        t0 = (addmod(1, q_mod - proof[117], q_mod));\n        m[42] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[117], proof[117], q_mod));\n        t0 = (addmod(t0, q_mod - proof[117], q_mod));\n        m[43] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(m[40], m[3], q_mod));\n        t0 = (mulmod(proof[117], t0, q_mod));\n        t0 = (mulmod(t0, m[25], q_mod));\n        t0 = (addmod(m[39], q_mod - t0, q_mod));\n        m[25] = (mulmod(t0, m[15], q_mod));\n        m[39] = (mulmod(m[14], m[41], q_mod));\n        t0 = (addmod(proof[119], q_mod - proof[120], q_mod));\n        t0 = (mulmod(m[41], t0, q_mod));\n        m[40] = (mulmod(t0, m[15], q_mod));\n        t0 = (addmod(proof[124], m[3], q_mod));\n        m[41] = (mulmod(proof[123], t0, q_mod));\n        t0 = (addmod(proof[126], m[4], q_mod));\n        m[41] = (mulmod(m[41], t0, q_mod));\n        m[44] = (fr_mul_add(proof[84], proof[67], m[2]));\n        m[45] = (addmod(m[2], proof[85], q_mod));\n        m[46] = (addmod(proof[124], q_mod - proof[126], q_mod));\n        t0 = (addmod(1, q_mod - proof[122], q_mod));\n        m[47] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[122], proof[122], q_mod));\n        t0 = (addmod(t0, q_mod - proof[122], q_mod));\n        m[48] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(m[44], m[3], q_mod));\n        m[44] = (mulmod(proof[122], t0, q_mod));\n        t0 = (addmod(m[45], m[4], q_mod));\n        t0 = (mulmod(m[44], t0, q_mod));\n        t0 = (addmod(m[41], q_mod - t0, q_mod));\n        m[41] = (mulmod(t0, m[15], q_mod));\n        m[44] = (mulmod(m[14], m[46], q_mod));\n        t0 = (addmod(proof[124], q_mod - proof[125], q_mod));\n        t0 = (mulmod(m[46], t0, q_mod));\n        m[45] = (mulmod(t0, m[15], q_mod));\n        t0 = (addmod(proof[129], m[3], q_mod));\n        m[46] = (mulmod(proof[128], t0, q_mod));\n        t0 = (addmod(proof[131], m[4], q_mod));\n        m[46] = (mulmod(m[46], t0, q_mod));\n        m[49] = (fr_mul_add(proof[86], proof[67], m[2]));\n        m[50] = (addmod(m[2], proof[87], q_mod));\n        m[51] = (addmod(proof[129], q_mod - proof[131], q_mod));\n        t0 = (addmod(1, q_mod - proof[127], q_mod));\n        m[52] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[127], proof[127], q_mod));\n        t0 = (addmod(t0, q_mod - proof[127], q_mod));\n        m[53] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(m[49], m[3], q_mod));\n        m[49] = (mulmod(proof[127], t0, q_mod));\n        t0 = (addmod(m[50], m[4], q_mod));\n        t0 = (mulmod(m[49], t0, q_mod));\n        t0 = (addmod(m[46], q_mod - t0, q_mod));\n        m[46] = (mulmod(t0, m[15], q_mod));\n        m[49] = (mulmod(m[14], m[51], q_mod));\n        t0 = (addmod(proof[129], q_mod - proof[130], q_mod));\n        t0 = (mulmod(m[51], t0, q_mod));\n        m[50] = (mulmod(t0, m[15], q_mod));\n        t0 = (addmod(proof[134], m[3], q_mod));\n        m[51] = (mulmod(proof[133], t0, q_mod));\n        t0 = (addmod(proof[136], m[4], q_mod));\n        m[51] = (mulmod(m[51], t0, q_mod));\n        m[54] = (fr_mul_add(proof[88], proof[67], m[2]));\n        m[2] = (addmod(m[2], proof[89], q_mod));\n        m[55] = (addmod(proof[134], q_mod - proof[136], q_mod));\n        t0 = (addmod(1, q_mod - proof[132], q_mod));\n        m[56] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[132], proof[132], q_mod));\n        t0 = (addmod(t0, q_mod - proof[132], q_mod));\n        m[20] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(m[54], m[3], q_mod));\n        m[3] = (mulmod(proof[132], t0, q_mod));\n        t0 = (addmod(m[2], m[4], q_mod));\n        t0 = (mulmod(m[3], t0, q_mod));\n        t0 = (addmod(m[51], q_mod - t0, q_mod));\n        m[2] = (mulmod(t0, m[15], q_mod));\n        m[3] = (mulmod(m[14], m[55], q_mod));\n        t0 = (addmod(proof[134], q_mod - proof[135], q_mod));\n        t0 = (mulmod(m[55], t0, q_mod));\n        m[4] = (mulmod(t0, m[15], q_mod));\n        t0 = (fr_mul_add(m[5], 0, m[16]));\n        t0 = (fr_mul_add_mt(m, m[5], 24064768791442479290152634096194013545513974547709823832001394403118888981009, t0));\n        t0 = (fr_mul_add_mt(m, m[5], 4704208815882882920750, t0));\n        m[2] = (fr_div(t0, m[13]));\n        m[3] = (mulmod(m[8], m[8], q_mod));\n        m[4] = (mulmod(m[3], m[8], q_mod));\n        (t0, t1) = (ecc_mul(proof[143], proof[144], m[4]));\n        (t0, t1) = (ecc_mul_add_pm(m, proof, 281470825071501, t0, t1));\n        (m[14], m[15]) = (ecc_add(t0, t1, proof[137], proof[138]));\n        m[5] = (mulmod(m[4], m[11], q_mod));\n        m[11] = (mulmod(m[4], m[7], q_mod));\n        m[13] = (mulmod(m[11], m[7], q_mod));\n        m[16] = (mulmod(m[13], m[7], q_mod));\n        m[17] = (mulmod(m[16], m[7], q_mod));\n        m[18] = (mulmod(m[17], m[7], q_mod));\n        m[19] = (mulmod(m[18], m[7], q_mod));\n        t0 = (mulmod(m[19], proof[135], q_mod));\n        t0 = (fr_mul_add_pm(m, proof, 79227007564587019091207590530, t0));\n        m[20] = (fr_mul_add(proof[105], m[4], t0));\n        m[10] = (mulmod(m[3], m[10], q_mod));\n        m[20] = (fr_mul_add(proof[99], m[3], m[20]));\n        m[9] = (mulmod(m[8], m[9], q_mod));\n        m[21] = (mulmod(m[8], m[7], q_mod));\n        for (t0 = 0; t0 < 8; t0++) {\n            m[22 + t0 * 1] = (mulmod(m[21 + t0 * 1], m[7 + t0 * 0], q_mod));\n        }\n        t0 = (mulmod(m[29], proof[133], q_mod));\n        t0 = (fr_mul_add_pm(m, proof, 1461480058012745347196003969984389955172320353408, t0));\n        m[20] = (addmod(m[20], t0, q_mod));\n        m[3] = (addmod(m[3], m[21], q_mod));\n        m[21] = (mulmod(m[7], m[7], q_mod));\n        m[30] = (mulmod(m[21], m[7], q_mod));\n        for (t0 = 0; t0 < 50; t0++) {\n            m[31 + t0 * 1] = (mulmod(m[30 + t0 * 1], m[7 + t0 * 0], q_mod));\n        }\n        m[81] = (mulmod(m[80], proof[90], q_mod));\n        m[82] = (mulmod(m[79], m[12], q_mod));\n        m[83] = (mulmod(m[82], m[12], q_mod));\n        m[12] = (mulmod(m[83], m[12], q_mod));\n        t0 = (fr_mul_add(m[79], m[2], m[81]));\n        t0 = (fr_mul_add_pm(m, proof, 28637501128329066231612878461967933875285131620580756137874852300330784214624, t0));\n        t0 = (fr_mul_add_pm(m, proof, 21474593857386732646168474467085622855647258609351047587832868301163767676495, t0));\n        t0 = (fr_mul_add_pm(m, proof, 14145600374170319983429588659751245017860232382696106927048396310641433325177, t0));\n        t0 = (fr_mul_add_pm(m, proof, 18446470583433829957, t0));\n        t0 = (addmod(t0, proof[66], q_mod));\n        m[2] = (addmod(m[20], t0, q_mod));\n        m[19] = (addmod(m[19], m[54], q_mod));\n        m[20] = (addmod(m[29], m[53], q_mod));\n        m[18] = (addmod(m[18], m[51], q_mod));\n        m[28] = (addmod(m[28], m[50], q_mod));\n        m[17] = (addmod(m[17], m[48], q_mod));\n        m[27] = (addmod(m[27], m[47], q_mod));\n        m[16] = (addmod(m[16], m[45], q_mod));\n        m[26] = (addmod(m[26], m[44], q_mod));\n        m[13] = (addmod(m[13], m[42], q_mod));\n        m[25] = (addmod(m[25], m[41], q_mod));\n        m[11] = (addmod(m[11], m[39], q_mod));\n        m[24] = (addmod(m[24], m[38], q_mod));\n        m[4] = (addmod(m[4], m[36], q_mod));\n        m[23] = (addmod(m[23], m[35], q_mod));\n        m[22] = (addmod(m[22], m[34], q_mod));\n        m[3] = (addmod(m[3], m[33], q_mod));\n        m[8] = (addmod(m[8], m[32], q_mod));\n        (t0, t1) = (ecc_mul(proof[143], proof[144], m[5]));\n        (t0, t1) = (ecc_mul_add_pm(m, proof, 10933423423422768024429730621579321771439401845242250760130969989159573132066, t0, t1));\n        (t0, t1) = (ecc_mul_add_pm(m, proof, 1461486238301980199876269201563775120819706402602, t0, t1));\n        (t0, t1) = (ecc_mul_add(9575624289502861614115950708340858458691668435663155708234349366227359442100, 17278215579851010224193489673699911295488764750975985770869826330981886215470, m[78], t0, t1));\n        (t0, t1) = (ecc_mul_add(10623774664464928147605621513502581446370058620860753485385030414176707173453, 20461442932589997306458655300576037944484531715758384232708126447133735441979, m[77], t0, t1));\n        (t0, t1) = (ecc_mul_add(15862858586011250377472115458965152043453745530099609329969933505916007240880, 2341604243233281367408253773029175391229780664726713243196695873108858281797, m[76], t0, t1));\n        (t0, t1) = (ecc_mul_add(18355706619561083855174573820172936175069897980616378932070421436382797252118, 17519603384519219981904516298932764078366636685063406996510984696566157270836, m[75], t0, t1));\n        (t0, t1) = (ecc_mul_add(723685183791911465572906772425672599323764161204388375494838171004436678461, 15180946673280092172842751639335069496366843968386363199482988738439227645602, m[74], t0, t1));\n        (t0, t1) = (ecc_mul_add(13475110182916639216688045805872759286792222127687710168246447450984281609542, 4808586554185164069661363841331411442754718354994777703217101027289277006074, m[73], t0, t1));\n        (t0, t1) = (ecc_mul_add(8808629196631084710334110767449499515582902470045288549019060600095073238105, 13294364470509711632739201553507258372326885785844949555702886281377427438475, m[72], t0, t1));\n        (t0, t1) = (ecc_mul_add(7694806995350279076430985554758961971570090415792012046894145647618980258711, 9586381906503862952263008277154214261561305237981957027298978522358599560826, m[71], t0, t1));\n        (t0, t1) = (ecc_mul_add(20143075587083355112417414887372164250381042430441089145485481665404780784123, 9674175910548207533970570126063643897609459066877075659644076646142886425503, m[70], t0, t1));\n        (t0, t1) = (ecc_mul_add(4160161843826725835319086896015967648968270916919657147192147777662945441776, 6750927504559163550211186750577687650739030152531905528973818483362173636065, m[69], t0, t1));\n        (t0, t1) = (ecc_mul_add(8808629196631084710334110767449499515582902470045288549019060600095073238105, 13294364470509711632739201553507258372326885785844949555702886281377427438475, m[68], t0, t1));\n        (t0, t1) = (ecc_mul_add(10128172985538710571442504471613584632281201161977967643082566262255157983327, 14800575683188215952883821909984695943582911308773852264768393503546661535017, m[67], t0, t1));\n        (t0, t1) = (ecc_mul_add(11667150339256836494926506499230187360957884531183800528342644917396989453992, 15540782144062394272475578831064080588044323224200171932910650185556553066875, m[66], t0, t1));\n        (t0, t1) = (ecc_mul_add(19707944436737019530187133977767817328535409820727690101284055146691544397369, 21234814375132264535075361646873693573370296556679356464856569870133791848992, m[65], t0, t1));\n        (t0, t1) = (ecc_mul_add(19998754376473674929116908609817336497632228100083676145278794069548307901773, 911763492369880436982165546147211783731077957331079292522164399794296474094, m[64], t0, t1));\n        (t0, t1) = (ecc_mul_add(1297932787410594906027297704264348510708180635298256438199019959535294449208, 17553638015755794285839969846813156763509561908706944579078124452344529358187, m[63], t0, t1));\n        (t0, t1) = (ecc_mul_add(19293297112406709329111802197195643682437751302947990642643242083307098226901, 1379236830317662364367416024656483115981718691089785554839934080885281890431, m[62], t0, t1));\n        (t0, t1) = (ecc_mul_add(6023106419257509858968091751099362933657439778880516504600664082747009919365, 21692024809398622015690991721724381601766890220278151315463242315376543889368, m[61], t0, t1));\n        (t0, t1) = (ecc_mul_add(19660421769860625959597916118496463616121263474365577796693423791603335287005, 4558133964660344843014928437189147593941721219549965048591412380260312341135, m[60], t0, t1));\n        (t0, t1) = (ecc_mul_add(14038651586240453659121693215035955338046998278102012190089021534310306139106, 2518381069429324773995018372557334481877942157553364304801697680743658820188, m[59], t0, t1));\n        (t0, t1) = (ecc_mul_add(18992033805332463193525936922729035835806608874837365918758109388288743115558, 17158269789552322041175053649847936942418551241689337543097704823778298714444, m[58], t0, t1));\n        (t0, t1) = (ecc_mul_add(16967097887204379968227175130948731724187916693700667561409096814514653992686, 8504130591576631301452714636943879547518954992620475718170488538077891319921, m[57], t0, t1));\n        (t0, t1) = (ecc_mul_add(3411280748863397302354730804555543800472444522107022058245299864148468843213, 8906724762016631687770656175775779598568330238982655555344629518727360254257, m[56], t0, t1));\n        (t0, t1) = (ecc_mul_add_pm(m, proof, 6277008573546246765208814532330797927747086570010716419876, t0, t1));\n        (m[0], m[1]) = (ecc_add(t0, t1, m[0], m[1]));\n        (t0, t1) = (ecc_mul(1, 2, m[2]));\n        (m[0], m[1]) = (ecc_sub(m[0], m[1], t0, t1));\n        return (m[14], m[15], m[0], m[1]);\n    }\n\n    function verify(\n        uint256[] calldata proof,\n        uint256[] calldata target_circuit_final_pair\n    ) public view returns (bool) {\n        uint256[4] memory instances;\n        instances[0] = target_circuit_final_pair[0] & ((1 << 136) - 1);\n        instances[1] = (target_circuit_final_pair[0] >> 136) + ((target_circuit_final_pair[1] & 1) << 136);\n        instances[2] = target_circuit_final_pair[2] & ((1 << 136) - 1);\n        instances[3] = (target_circuit_final_pair[2] >> 136) + ((target_circuit_final_pair[3] & 1) << 136);\n\n\n        uint256 x0 = 0;\n        uint256 x1 = 0;\n        uint256 y0 = 0;\n        uint256 y1 = 0;\n\n        G1Point[] memory g1_points = new G1Point[](2);\n        G2Point[] memory g2_points = new G2Point[](2);\n\n        (x0, y0, x1, y1) = get_wx_wg(proof, instances);\n        g1_points[0].x = x0;\n        g1_points[0].y = y0;\n        g1_points[1].x = x1;\n        g1_points[1].y = y1;\n        g2_points[0] = get_verify_circuit_g2_s();\n        g2_points[1] = get_verify_circuit_g2_n();\n\n        if (!pairing(g1_points, g2_points)) {\n            return false;\n        }\n\n        g1_points[0].x = target_circuit_final_pair[0];\n        g1_points[0].y = target_circuit_final_pair[1];\n        g1_points[1].x = target_circuit_final_pair[2];\n        g1_points[1].y = target_circuit_final_pair[3];\n        g2_points[0] = get_target_circuit_g2_s();\n        g2_points[1] = get_target_circuit_g2_n();\n\n        if (!pairing(g1_points, g2_points)) {\n            return false;\n        }\n\n        return true;\n    }\n}\n"
    },
    "contracts/L2/BaseFeeVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { FeeVault } from \"../universal/FeeVault.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000006\n * @title BaseFeeVault\n * @notice The BaseFeeVault accumulates the base fee that is paid by transactions.\n */\ncontract BaseFeeVault is FeeVault, Semver {\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _recipient Address that will receive the accumulated fees.\n     */\n    constructor(address _recipient) FeeVault(_recipient, 10 ether) Semver(0, 1, 0) {}\n}\n"
    },
    "contracts/L2/CrossDomainOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\n\n/**\n * @title CrossDomainOwnable\n * @notice This contract extends the OpenZeppelin `Ownable` contract for L2 contracts to be owned\n *         by contracts on L1. Note that this contract is only safe to be used if the\n *         CrossDomainMessenger system is bypassed and the caller on L1 is calling the\n *         KromaPortal directly.\n */\nabstract contract CrossDomainOwnable is Ownable {\n    /**\n     * @notice Overrides the implementation of the `onlyOwner` modifier to check that the unaliased\n     *         `msg.sender` is the owner of the contract.\n     */\n    function _checkOwner() internal view override {\n        require(\n            owner() == AddressAliasHelper.undoL1ToL2Alias(msg.sender),\n            \"CrossDomainOwnable: caller is not the owner\"\n        );\n    }\n}\n"
    },
    "contracts/L2/CrossDomainOwnable2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { L2CrossDomainMessenger } from \"./L2CrossDomainMessenger.sol\";\n\n/**\n * @title CrossDomainOwnable2\n * @notice This contract extends the OpenZeppelin `Ownable` contract for L2 contracts to be owned\n *         by contracts on L1. Note that this contract is meant to be used with systems that use\n *         the CrossDomainMessenger system. It will not work if the KromaPortal is used\n *         directly.\n */\nabstract contract CrossDomainOwnable2 is Ownable {\n    /**\n     * @notice Overrides the implementation of the `onlyOwner` modifier to check that the unaliased\n     *         `xDomainMessageSender` is the owner of the contract. This value is set to the caller\n     *         of the L1CrossDomainMessenger.\n     */\n    function _checkOwner() internal view override {\n        L2CrossDomainMessenger messenger = L2CrossDomainMessenger(\n            Predeploys.L2_CROSS_DOMAIN_MESSENGER\n        );\n\n        require(\n            msg.sender == address(messenger),\n            \"CrossDomainOwnable2: caller is not the messenger\"\n        );\n\n        require(\n            owner() == messenger.xDomainMessageSender(),\n            \"CrossDomainOwnable2: caller is not the owner\"\n        );\n    }\n}\n"
    },
    "contracts/L2/CrossDomainOwnable3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { L2CrossDomainMessenger } from \"./L2CrossDomainMessenger.sol\";\n\n/**\n * @title CrossDomainOwnable3\n * @notice This contract extends the OpenZeppelin `Ownable` contract for L2 contracts to be owned\n *         by contracts on either L1 or L2. Note that this contract is meant to be used with systems\n *         that use the CrossDomainMessenger system. It will not work if the KromaPortal is\n *         used directly.\n */\nabstract contract CrossDomainOwnable3 is Ownable {\n    /**\n     * @notice If true, the contract uses the cross domain _checkOwner function override. If false\n     *         it uses the standard Ownable _checkOwner function.\n     */\n    bool public isLocal = true;\n\n    /**\n     * @notice Emits when ownership of the contract is transferred. Includes the\n     *         isLocal field in addition to the standard `Ownable` OwnershipTransferred event.\n     */\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner,\n        bool isLocal\n    );\n\n    /**\n     * @notice Allows for ownership to be transferred with specifying the locality.\n     * @param _owner   The new owner of the contract.\n     * @param _isLocal Configures the locality of the ownership.\n     */\n    function transferOwnership(address _owner, bool _isLocal) external onlyOwner {\n        require(_owner != address(0), \"CrossDomainOwnable3: new owner is the zero address\");\n\n        address oldOwner = owner();\n        _transferOwnership(_owner);\n        isLocal = _isLocal;\n\n        emit OwnershipTransferred(oldOwner, _owner, _isLocal);\n    }\n\n    /**\n     * @notice Overrides the implementation of the `onlyOwner` modifier to check that the unaliased\n     *         `xDomainMessageSender` is the owner of the contract. This value is set to the caller\n     *         of the L1CrossDomainMessenger.\n     */\n    function _checkOwner() internal view override {\n        if (isLocal) {\n            require(owner() == msg.sender, \"CrossDomainOwnable3: caller is not the owner\");\n        } else {\n            L2CrossDomainMessenger messenger = L2CrossDomainMessenger(\n                Predeploys.L2_CROSS_DOMAIN_MESSENGER\n            );\n\n            require(\n                msg.sender == address(messenger),\n                \"CrossDomainOwnable3: caller is not the messenger\"\n            );\n\n            require(\n                owner() == messenger.xDomainMessageSender(),\n                \"CrossDomainOwnable3: caller is not the owner\"\n            );\n        }\n    }\n}\n"
    },
    "contracts/L2/GasPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { L1Block } from \"../L2/L1Block.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000005\n * @title GasPriceOracle\n * @notice This contract maintains the variables responsible for computing the L1 portion of the\n *         total fee charged on L2. It also exposes an API that is useful for knowing how large\n *         the L1 portion of the transaction fee will be.\n */\ncontract GasPriceOracle is Semver {\n    /**\n     * @notice Number of decimals used in the scalar.\n     */\n    uint256 public constant DECIMALS = 6;\n\n    /**\n     * @custom:semver 0.1.0\n     */\n    constructor() Semver(0, 1, 0) {}\n\n    /**\n     * @notice Computes the L1 portion of the fee based on the size of the rlp encoded input\n     *         transaction, the current L1 base fee, and the various dynamic parameters.\n     *\n     * @param _data Unsigned fully RLP-encoded transaction to get the L1 fee for.\n     *\n     * @return L1 fee that should be paid for the tx\n     */\n    function getL1Fee(bytes memory _data) external view returns (uint256) {\n        uint256 l1GasUsed = getL1GasUsed(_data);\n        uint256 l1Fee = l1GasUsed * l1BaseFee();\n        uint256 divisor = 10**DECIMALS;\n        uint256 unscaled = l1Fee * scalar();\n        uint256 scaled = unscaled / divisor;\n        return scaled;\n    }\n\n    /**\n     * @notice Retrieves the current gas price (base fee).\n     *\n     * @return Current L2 gas price (base fee).\n     */\n    function gasPrice() public view returns (uint256) {\n        return block.basefee;\n    }\n\n    /**\n     * @notice Retrieves the current base fee.\n     *\n     * @return Current L2 base fee.\n     */\n    function baseFee() public view returns (uint256) {\n        return block.basefee;\n    }\n\n    /**\n     * @notice Retrieves the current fee overhead.\n     *\n     * @return Current fee overhead.\n     */\n    function overhead() public view returns (uint256) {\n        return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).l1FeeOverhead();\n    }\n\n    /**\n     * @notice Retrieves the current fee scalar.\n     *\n     * @return Current fee scalar.\n     */\n    function scalar() public view returns (uint256) {\n        return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).l1FeeScalar();\n    }\n\n    /**\n     * @notice Retrieves the latest known L1 base fee.\n     *\n     * @return Latest known L1 base fee.\n     */\n    function l1BaseFee() public view returns (uint256) {\n        return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).basefee();\n    }\n\n    /**\n     * @notice Computes the amount of L1 gas used for a transaction. Adds the overhead which\n     *         represents the per-transaction gas overhead of posting the transaction and state\n     *         roots to L1. Adds 68 bytes of padding to account for the fact that the input does\n     *         not have a signature.\n     *\n     * @param _data Unsigned fully RLP-encoded transaction to get the L1 gas for.\n     *\n     * @return Amount of L1 gas used to publish the transaction.\n     */\n    function getL1GasUsed(bytes memory _data) public view returns (uint256) {\n        uint256 total = 0;\n        uint256 length = _data.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (_data[i] == 0) {\n                total += 4;\n            } else {\n                total += 16;\n            }\n        }\n        return total + overhead();\n    }\n}\n"
    },
    "contracts/L2/L1Block.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000002\n * @title L1Block\n * @notice The L1Block predeploy gives users access to information about the last known L1 block.\n *         Values within this contract are updated once per epoch (every L1 block) and can only be\n *         set by the \"depositor\" account, a special system address. Depositor account transactions\n *         are created by the protocol whenever we move to a new epoch.\n */\ncontract L1Block is Semver {\n    /**\n     * @notice Address of the special depositor account.\n     */\n    address public constant DEPOSITOR_ACCOUNT = 0xDeaDDEaDDeAdDeAdDEAdDEaddeAddEAdDEAd0001;\n\n    /**\n     * @notice The latest L1 block number known by the L2 system.\n     */\n    uint64 public number;\n\n    /**\n     * @notice The latest L1 timestamp known by the L2 system.\n     */\n    uint64 public timestamp;\n\n    /**\n     * @notice The latest L1 basefee.\n     */\n    uint256 public basefee;\n\n    /**\n     * @notice The latest L1 blockhash.\n     */\n    bytes32 public hash;\n\n    /**\n     * @notice The number of L2 blocks in the same epoch.\n     */\n    uint64 public sequenceNumber;\n\n    /**\n     * @notice The versioned hash to authenticate the batcher by.\n     */\n    bytes32 public batcherHash;\n\n    /**\n     * @notice The overhead value applied to the L1 portion of the transaction\n     *         fee.\n     */\n    uint256 public l1FeeOverhead;\n\n    /**\n     * @notice The scalar value applied to the L1 portion of the transaction fee.\n     */\n    uint256 public l1FeeScalar;\n\n    /**\n     * @custom:semver 0.1.0\n     */\n    constructor() Semver(0, 1, 0) {}\n\n    /**\n     * @notice Updates the L1 block values.\n     *\n     * @param _number         L1 blocknumber.\n     * @param _timestamp      L1 timestamp.\n     * @param _basefee        L1 basefee.\n     * @param _hash           L1 blockhash.\n     * @param _sequenceNumber Number of L2 blocks since epoch start.\n     * @param _batcherHash    Versioned hash to authenticate batcher by.\n     * @param _l1FeeOverhead  L1 fee overhead.\n     * @param _l1FeeScalar    L1 fee scalar.\n     */\n    function setL1BlockValues(\n        uint64 _number,\n        uint64 _timestamp,\n        uint256 _basefee,\n        bytes32 _hash,\n        uint64 _sequenceNumber,\n        bytes32 _batcherHash,\n        uint256 _l1FeeOverhead,\n        uint256 _l1FeeScalar\n    ) external {\n        require(\n            msg.sender == DEPOSITOR_ACCOUNT,\n            \"L1Block: only the depositor account can set L1 block values\"\n        );\n\n        number = _number;\n        timestamp = _timestamp;\n        basefee = _basefee;\n        hash = _hash;\n        sequenceNumber = _sequenceNumber;\n        batcherHash = _batcherHash;\n        l1FeeOverhead = _l1FeeOverhead;\n        l1FeeScalar = _l1FeeScalar;\n    }\n}\n"
    },
    "contracts/L2/L1FeeVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { FeeVault } from \"../universal/FeeVault.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000007\n * @title L1FeeVault\n * @notice The L1FeeVault accumulates the L1 portion of the transaction fees.\n */\ncontract L1FeeVault is FeeVault, Semver {\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _recipient Address that will receive the accumulated fees.\n     */\n    constructor(address _recipient) FeeVault(_recipient, 10 ether) Semver(0, 1, 0) {}\n}\n"
    },
    "contracts/L2/L2CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { L2ToL1MessagePasser } from \"./L2ToL1MessagePasser.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000004\n * @title L2CrossDomainMessenger\n * @notice The L2CrossDomainMessenger is a high-level interface for message passing between L1 and\n *         L2 on the L2 side. Users are generally encouraged to use this contract instead of lower\n *         level message passing contracts.\n */\ncontract L2CrossDomainMessenger is CrossDomainMessenger, Semver {\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _l1CrossDomainMessenger Address of the L1CrossDomainMessenger contract.\n     */\n    constructor(address _l1CrossDomainMessenger)\n        Semver(0, 1, 0)\n        CrossDomainMessenger(_l1CrossDomainMessenger)\n    {\n        initialize();\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize() public initializer {\n        __CrossDomainMessenger_init();\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal override {\n        L2ToL1MessagePasser(payable(Predeploys.L2_TO_L1_MESSAGE_PASSER)).initiateWithdrawal{\n            value: _value\n        }(_to, _gasLimit, _data);\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _isOtherMessenger() internal view override returns (bool) {\n        return AddressAliasHelper.undoL1ToL2Alias(msg.sender) == OTHER_MESSENGER;\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _isUnsafeTarget(address _target) internal view override returns (bool) {\n        return _target == address(this) || _target == address(Predeploys.L2_TO_L1_MESSAGE_PASSER);\n    }\n}\n"
    },
    "contracts/L2/L2ERC721Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport { L1ERC721Bridge } from \"../L1/L1ERC721Bridge.sol\";\nimport { ERC721Bridge } from \"../universal/ERC721Bridge.sol\";\nimport { IKromaMintableERC721 } from \"../universal/IKromaMintableERC721.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @title L2ERC721Bridge\n * @notice The L2 ERC721 bridge is a contract which works together with the L1 ERC721 bridge to\n *         make it possible to transfer ERC721 tokens from Ethereum to Kroma. This contract\n *         acts as a minter for new tokens when it hears about deposits into the L1 ERC721 bridge.\n *         This contract also acts as a burner for tokens being withdrawn.\n *         **WARNING**: Do not bridge an ERC721 that was originally deployed on Kroma. This\n *         bridge ONLY supports ERC721s originally deployed on Ethereum. Users will need to\n *         wait for the one-week challenge period to elapse before their Kroma-native NFT\n *         can be refunded on L2.\n */\ncontract L2ERC721Bridge is ERC721Bridge, Semver {\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _messenger   Address of the CrossDomainMessenger on this network.\n     * @param _otherBridge Address of the ERC721 bridge on the other network.\n     */\n    constructor(address _messenger, address _otherBridge)\n        Semver(0, 1, 0)\n        ERC721Bridge(_messenger, _otherBridge)\n    {}\n\n    /**\n     * @notice Completes an ERC721 bridge from the other domain and sends the ERC721 token to the\n     *         recipient on this domain.\n     *\n     * @param _localToken  Address of the ERC721 token on this domain.\n     * @param _remoteToken Address of the ERC721 token on the other domain.\n     * @param _from        Address that triggered the bridge on the other domain.\n     * @param _to          Address to receive the token on this domain.\n     * @param _tokenId     ID of the token being deposited.\n     * @param _extraData   Optional data to forward to L1. Data supplied here will not be used to\n     *                     execute any code on L1 and is only emitted as extra data for the\n     *                     convenience of off-chain tooling.\n     */\n    function finalizeBridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes calldata _extraData\n    ) external onlyOtherBridge {\n        require(_localToken != address(this), \"L2ERC721Bridge: local token cannot be self\");\n\n        // Note that supportsInterface makes a callback to the _localToken address which is user\n        // provided.\n        require(\n            ERC165Checker.supportsInterface(_localToken, type(IKromaMintableERC721).interfaceId),\n            \"L2ERC721Bridge: local token interface is not compliant\"\n        );\n\n        require(\n            _remoteToken == IKromaMintableERC721(_localToken).REMOTE_TOKEN(),\n            \"L2ERC721Bridge: wrong remote token for Kroma Mintable ERC721 local token\"\n        );\n\n        // When a deposit is finalized, we give the NFT with the same tokenId to the account\n        // on L2. Note that safeMint makes a callback to the _to address which is user provided.\n        IKromaMintableERC721(_localToken).safeMint(_to, _tokenId);\n\n        // slither-disable-next-line reentrancy-events\n        emit ERC721BridgeFinalized(_localToken, _remoteToken, _from, _to, _tokenId, _extraData);\n    }\n\n    /**\n     * @inheritdoc ERC721Bridge\n     */\n    function _initiateBridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) internal override {\n        require(_remoteToken != address(0), \"L2ERC721Bridge: remote token cannot be address(0)\");\n\n        // Check that the withdrawal is being initiated by the NFT owner\n        require(\n            _from == IKromaMintableERC721(_localToken).ownerOf(_tokenId),\n            \"L2ERC721Bridge: Withdrawal is not being initiated by NFT owner\"\n        );\n\n        // Construct calldata for l1ERC721Bridge.finalizeBridgeERC721(_to, _tokenId)\n        // slither-disable-next-line reentrancy-events\n        address remoteToken = IKromaMintableERC721(_localToken).REMOTE_TOKEN();\n        require(\n            remoteToken == _remoteToken,\n            \"L2ERC721Bridge: remote token does not match given value\"\n        );\n\n        // When a withdrawal is initiated, we burn the withdrawer's NFT to prevent subsequent L2\n        // usage\n        // slither-disable-next-line reentrancy-events\n        IKromaMintableERC721(_localToken).burn(_from, _tokenId);\n\n        bytes memory message = abi.encodeWithSelector(\n            L1ERC721Bridge.finalizeBridgeERC721.selector,\n            remoteToken,\n            _localToken,\n            _from,\n            _to,\n            _tokenId,\n            _extraData\n        );\n\n        // Send message to L1 bridge\n        // slither-disable-next-line reentrancy-events\n        MESSENGER.sendMessage(OTHER_BRIDGE, message, _minGasLimit);\n\n        // slither-disable-next-line reentrancy-events\n        emit ERC721BridgeInitiated(_localToken, remoteToken, _from, _to, _tokenId, _extraData);\n    }\n}\n"
    },
    "contracts/L2/L2StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000009\n * @title L2StandardBridge\n * @notice The L2StandardBridge is responsible for transfering ETH and ERC20 tokens between L1 and\n *         L2. In the case that an ERC20 token is native to L2, it will be escrowed within this\n *         contract. If the ERC20 token is native to L1, it will be burnt.\n *         NOTE: this contract is not intended to support all variations of ERC20 tokens. Examples\n *         of some token types that may not be properly supported by this contract include, but are\n *         not limited to: tokens with transfer fees, rebasing tokens, and tokens with blocklists.\n */\ncontract L2StandardBridge is StandardBridge, Semver {\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _otherBridge Address of the L1StandardBridge.\n     */\n    constructor(address payable _otherBridge)\n        Semver(0, 1, 0)\n        StandardBridge(payable(Predeploys.L2_CROSS_DOMAIN_MESSENGER), _otherBridge)\n    {}\n\n    /**\n     * @notice Allows EOAs to bridge ETH by sending directly to the bridge.\n     */\n    receive() external payable override onlyEOA {\n        _initiateBridgeETH(\n            msg.sender,\n            msg.sender,\n            msg.value,\n            RECEIVE_DEFAULT_GAS_LIMIT,\n            bytes(\"\")\n        );\n    }\n}\n"
    },
    "contracts/L2/L2ToL1MessagePasser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Burn } from \"../libraries/Burn.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000003\n * @title L2ToL1MessagePasser\n * @notice The L2ToL1MessagePasser is a dedicated contract where messages that are being sent from\n *         L2 to L1 can be stored. The storage root of this contract is pulled up to the top level\n *         of the L2 output to reduce the cost of proving the existence of sent messages.\n */\ncontract L2ToL1MessagePasser is Semver {\n    /**\n     * @notice The L1 gas limit set when eth is withdrawn using the receive() function.\n     */\n    uint256 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;\n\n    /**\n     * @notice Current message version identifier.\n     */\n    uint16 public constant MESSAGE_VERSION = 0;\n\n    /**\n     * @notice Includes the message hashes for all withdrawals\n     */\n    mapping(bytes32 => bool) public sentMessages;\n\n    /**\n     * @notice A unique value hashed with each withdrawal.\n     */\n    uint240 internal msgNonce;\n\n    /**\n     * @notice Emitted any time a withdrawal is initiated.\n     *\n     * @param nonce          Unique value corresponding to each withdrawal.\n     * @param sender         The L2 account address which initiated the withdrawal.\n     * @param target         The L1 account address the call will be send to.\n     * @param value          The ETH value submitted for withdrawal, to be forwarded to the target.\n     * @param gasLimit       The minimum amount of gas that must be provided when withdrawing.\n     * @param data           The data to be forwarded to the target on L1.\n     * @param withdrawalHash The hash of the withdrawal.\n     */\n    event MessagePassed(\n        uint256 indexed nonce,\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes data,\n        bytes32 withdrawalHash\n    );\n\n    /**\n     * @notice Emitted when the balance of this contract is burned.\n     *\n     * @param amount Amount of ETh that was burned.\n     */\n    event WithdrawerBalanceBurnt(uint256 indexed amount);\n\n    /**\n     * @custom:semver 0.1.0\n     */\n    constructor() Semver(0, 1, 0) {}\n\n    /**\n     * @notice Allows users to withdraw ETH by sending directly to this contract.\n     */\n    receive() external payable {\n        initiateWithdrawal(msg.sender, RECEIVE_DEFAULT_GAS_LIMIT, bytes(\"\"));\n    }\n\n    /**\n     * @notice Removes all ETH held by this contract from the state. Used to prevent the amount of\n     *         ETH on L2 inflating when ETH is withdrawn. Currently only way to do this is to\n     *         create a contract and self-destruct it to itself. Anyone can call this function. Not\n     *         incentivized since this function is very cheap.\n     */\n    function burn() external {\n        uint256 balance = address(this).balance;\n        Burn.eth(balance);\n        emit WithdrawerBalanceBurnt(balance);\n    }\n\n    /**\n     * @notice Sends a message from L2 to L1.\n     *\n     * @param _target   Address to call on L1 execution.\n     * @param _gasLimit Minimum gas limit for executing the message on L1.\n     * @param _data     Data to forward to L1 target.\n     */\n    function initiateWithdrawal(\n        address _target,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) public payable {\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction({\n                nonce: messageNonce(),\n                sender: msg.sender,\n                target: _target,\n                value: msg.value,\n                gasLimit: _gasLimit,\n                data: _data\n            })\n        );\n\n        sentMessages[withdrawalHash] = true;\n\n        emit MessagePassed(\n            messageNonce(),\n            msg.sender,\n            _target,\n            msg.value,\n            _gasLimit,\n            _data,\n            withdrawalHash\n        );\n\n        unchecked {\n            ++msgNonce;\n        }\n    }\n\n    /**\n     * @notice Retrieves the next message nonce. Message version will be added to the upper two\n     *         bytes of the message nonce. Message version allows us to treat messages as having\n     *         different structures.\n     *\n     * @return Nonce of the next message to be sent, with added message version.\n     */\n    function messageNonce() public view returns (uint256) {\n        return Encoding.encodeVersionedNonce(msgNonce, MESSAGE_VERSION);\n    }\n}\n"
    },
    "contracts/L2/ProposerFeeVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { FeeVault } from \"../universal/FeeVault.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000008\n * @title ProposerFeeVault\n * @notice The ProposerFeeVault is the contract that holds any fees paid to the Sequencer during\n *         transaction processing and block production.\n */\ncontract ProposerFeeVault is FeeVault, Semver {\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _recipient Address that will receive the accumulated fees.\n     */\n    constructor(address _recipient) FeeVault(_recipient, 10 ether) Semver(0, 1, 0) {}\n}\n"
    },
    "contracts/echidna/FuzzAddressAliasing.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\n\ncontract EchidnaFuzzAddressAliasing {\n    bool internal failedRoundtrip;\n\n    /**\n     * @notice Takes an address to be aliased with AddressAliasHelper and then unaliased\n     *         and updates the test contract's state indicating if the round trip encoding\n     *         failed.\n     */\n    function testRoundTrip(address addr) public {\n        // Alias our address\n        address aliasedAddr = AddressAliasHelper.applyL1ToL2Alias(addr);\n\n        // Unalias our address\n        address undoneAliasAddr = AddressAliasHelper.undoL1ToL2Alias(aliasedAddr);\n\n        // If our round trip aliasing did not return the original result, set our state.\n        if (addr != undoneAliasAddr) {\n            failedRoundtrip = true;\n        }\n    }\n\n    /**\n     * @custom:invariant Address aliases are always able to be undone.\n     *\n     * Asserts that an address that has been aliased with `applyL1ToL2Alias` can always\n     * be unaliased with `undoL1ToL2Alias`.\n     */\n    function echidna_round_trip_aliasing() public view returns (bool) {\n        // ASSERTION: The round trip aliasing done in testRoundTrip(...) should never fail.\n        return !failedRoundtrip;\n    }\n}\n"
    },
    "contracts/echidna/FuzzBurn.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { StdUtils } from \"forge-std/Test.sol\";\n\nimport { Burn } from \"../libraries/Burn.sol\";\n\ncontract EchidnaFuzzBurnEth is StdUtils {\n    bool internal failedEthBurn;\n\n    /**\n     * @notice Takes an integer amount of eth to burn through the Burn library and\n     * updates the contract state if an incorrect amount of eth moved from the contract\n     */\n    function testBurn(uint256 _value) public {\n        // cache the contract's eth balance\n        uint256 preBurnBalance = address(this).balance;\n        uint256 value = bound(_value, 0, preBurnBalance);\n\n        // execute a burn of _value eth\n        Burn.eth(value);\n\n        // check that exactly value eth was transfered from the contract\n        unchecked {\n            if (address(this).balance != preBurnBalance - value) {\n                failedEthBurn = true;\n            }\n        }\n    }\n\n    /**\n     * @custom:invariant `eth(uint256)` always burns the exact amount of eth passed.\n     *\n     * Asserts that when `Burn.eth(uint256)` is called, it always burns the exact amount\n     * of ETH passed to the function.\n     */\n    function echidna_burn_eth() public view returns (bool) {\n        // ASSERTION: The amount burned should always match the amount passed exactly\n        return !failedEthBurn;\n    }\n}\n\ncontract EchidnaFuzzBurnGas is StdUtils {\n    bool internal failedGasBurn;\n\n    /**\n     * @notice Takes an integer amount of gas to burn through the Burn library and\n     * updates the contract state if at least that amount of gas was not burned\n     * by the library\n     */\n    function testGas(uint256 _value) public {\n        // cap the value to the max resource limit\n        uint256 MAX_RESOURCE_LIMIT = 8_000_000;\n        uint256 value = bound(_value, 0, MAX_RESOURCE_LIMIT);\n\n        // cache the contract's current remaining gas\n        uint256 preBurnGas = gasleft();\n\n        // execute the gas burn\n        Burn.gas(value);\n\n        // cache the remaining gas post burn\n        uint256 postBurnGas = gasleft();\n\n        // check that at least value gas was burnt (and that there was no underflow)\n        unchecked {\n            if (postBurnGas - preBurnGas > value || preBurnGas - value > preBurnGas) {\n                failedGasBurn = true;\n            }\n        }\n    }\n\n    /**\n     * @custom:invariant `gas(uint256)` always burns at least the amount of gas passed.\n     *\n     * Asserts that when `Burn.gas(uint256)` is called, it always burns at least the amount\n     * of gas passed to the function.\n     */\n    function echidna_burn_gas() public view returns (bool) {\n        // ASSERTION: The amount of gas burned should be strictly greater than the\n        // the amount passed as _value (minimum _value + whatever minor overhead to\n        // the value after the call)\n        return !failedGasBurn;\n    }\n}\n"
    },
    "contracts/echidna/FuzzEncoding.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Encoding } from \"../libraries/Encoding.sol\";\n\ncontract EchidnaFuzzEncoding {\n    bool internal failedRoundtripAToB;\n    bool internal failedRoundtripBToA;\n\n    /**\n     * @notice Takes a pair of integers to be encoded into a versioned nonce with the\n     *         Encoding library and then decoded and updates the test contract's state\n     *         indicating if the round trip encoding failed.\n     */\n    function testRoundTripAToB(uint240 _nonce, uint16 _version) public {\n        // Encode the nonce and version\n        uint256 encodedVersionedNonce = Encoding.encodeVersionedNonce(_nonce, _version);\n\n        // Decode the nonce and version\n        uint240 decodedNonce;\n        uint16 decodedVersion;\n\n        (decodedNonce, decodedVersion) = Encoding.decodeVersionedNonce(encodedVersionedNonce);\n\n        // If our round trip encoding did not return the original result, set our state.\n        if ((decodedNonce != _nonce) || (decodedVersion != _version)) {\n            failedRoundtripAToB = true;\n        }\n    }\n\n    /**\n     * @notice Takes an integer representing a packed version and nonce and attempts\n     *         to decode them using the Encoding library before re-encoding and updates\n     *         the test contract's state indicating if the round trip encoding failed.\n     */\n    function testRoundTripBToA(uint256 _versionedNonce) public {\n        // Decode the nonce and version\n        uint240 decodedNonce;\n        uint16 decodedVersion;\n\n        (decodedNonce, decodedVersion) = Encoding.decodeVersionedNonce(_versionedNonce);\n\n        // Encode the nonce and version\n        uint256 encodedVersionedNonce = Encoding.encodeVersionedNonce(decodedNonce, decodedVersion);\n\n        // If our round trip encoding did not return the original result, set our state.\n        if (encodedVersionedNonce != _versionedNonce) {\n            failedRoundtripBToA = true;\n        }\n    }\n\n    /**\n     * @custom:invariant `testRoundTripAToB` never fails.\n     *\n     * Asserts that a raw versioned nonce can be encoded / decoded to reach the same raw value.\n     */\n    function echidna_round_trip_encoding_AToB() public view returns (bool) {\n        // ASSERTION: The round trip encoding done in testRoundTripAToB(...)\n        return !failedRoundtripAToB;\n    }\n\n    /**\n     * @custom:invariant `testRoundTripBToA` never fails.\n     *\n     * Asserts that an encoded versioned nonce can always be decoded / re-encoded to reach\n     * the same encoded value.\n     */\n    function echidna_round_trip_encoding_BToA() public view returns (bool) {\n        // ASSERTION: The round trip encoding done in testRoundTripBToA should never\n        // fail.\n        return !failedRoundtripBToA;\n    }\n}\n"
    },
    "contracts/echidna/FuzzHashing.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\n\ncontract EchidnaFuzzHashing {\n    bool internal failedCrossDomainHashHighVersion;\n    bool internal failedCrossDomainHashV0;\n\n    /**\n     * @notice Takes the necessary parameters to perform a cross domain hash with a randomly\n     * generated version. Only schema version 0 is supported and all others should revert.\n     */\n    function testHashCrossDomainMessageHighVersion(\n        uint16 _version,\n        uint240 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) public {\n        // generate the versioned nonce\n        uint256 encodedNonce = Encoding.encodeVersionedNonce(_nonce, _version);\n\n        // hash the cross domain message. we don't need to store the result since the function\n        // validates and should revert if an invalid version (>0) is encoded\n        Hashing.hashCrossDomainMessage(encodedNonce, _sender, _target, _value, _gasLimit, _data);\n\n        // check that execution never makes it this far for an invalid version\n        if (_version > 0) {\n            failedCrossDomainHashHighVersion = true;\n        }\n    }\n\n    /**\n     * @notice Takes the necessary parameters to perform a cross domain hash using the v0 schema\n     * and compares the output of a call to the unversioned function to the v0 function directly\n     */\n    function testHashCrossDomainMessageV0(\n        uint240 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) public {\n        // generate the versioned nonce with the version set to 0\n        uint256 encodedNonce = Encoding.encodeVersionedNonce(_nonce, 0);\n\n        // hash the cross domain message using the unversioned and versioned functions for\n        // comparison\n        bytes32 sampleHash1 = Hashing.hashCrossDomainMessage(\n            encodedNonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n        bytes32 sampleHash2 = Hashing.hashCrossDomainMessageV0(\n            encodedNonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n\n        // check that the output of both functions matches\n        if (sampleHash1 != sampleHash2) {\n            failedCrossDomainHashV0 = true;\n        }\n    }\n\n    /**\n     * @custom:invariant `hashCrossDomainMessage` reverts if `version` is > `0`.\n     *\n     * The `hashCrossDomainMessage` function should always revert if the `version` passed is > `0`.\n     */\n    function echidna_hash_xdomain_msg_high_version() public view returns (bool) {\n        // ASSERTION: A call to hashCrossDomainMessage will never succeed for a version > 1\n        return !failedCrossDomainHashHighVersion;\n    }\n\n    /**\n     * @custom:invariant `version` = `0`: `hashCrossDomainMessage` and `hashCrossDomainMessageV0`\n     * are equivalent.\n     *\n     * If the version passed is 0, `hashCrossDomainMessage` and `hashCrossDomainMessageV0` should be\n     * equivalent.\n     */\n    function echidna_hash_xdomain_msg_0() public view returns (bool) {\n        // ASSERTION: A call to hashCrossDomainMessage and hashCrossDomainMessageV0\n        // should always match when the version passed is 0\n        return !failedCrossDomainHashV0;\n    }\n}\n"
    },
    "contracts/echidna/FuzzKromaPortal.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { KromaPortal } from \"../L1/KromaPortal.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { ZKMerkleTrie } from \"../L1/ZKMerkleTrie.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\n\ncontract EchidnaFuzzKromaPortal {\n    KromaPortal internal portal;\n    bool internal failedToComplete;\n\n    constructor() {\n        portal = new KromaPortal({\n            _l2Oracle: L2OutputOracle(address(0)),\n            _guardian: address(0),\n            _paused: false,\n            _zkMerkleTrie: ZKMerkleTrie(address(0))\n        });\n    }\n\n    // A test intended to identify any unexpected halting conditions\n    function testDepositTransactionCompletes(\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    ) public payable {\n        failedToComplete = true;\n        require(!_isCreation || _to == address(0), \"EchidnaFuzzKromaPortal: invalid test case.\");\n        portal.depositTransaction{ value: _mint }(_to, _value, _gasLimit, _isCreation, _data);\n        failedToComplete = false;\n    }\n\n    /**\n     * @custom:invariant Deposits of any value should always succeed unless\n     * `_to` = `address(0)` or `_isCreation` = `true`.\n     *\n     * All deposits, barring creation transactions and transactions sent to `address(0)`,\n     * should always succeed.\n     */\n    function echidna_deposit_completes() public view returns (bool) {\n        return !failedToComplete;\n    }\n}\n"
    },
    "contracts/echidna/FuzzResourceMetering.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { StdUtils } from \"forge-std/Test.sol\";\n\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { Arithmetic } from \"../libraries/Arithmetic.sol\";\n\ncontract EchidnaFuzzResourceMetering is ResourceMetering, StdUtils {\n    bool internal failedMaxGasPerBlock;\n    bool internal failedRaiseBaseFee;\n    bool internal failedLowerBaseFee;\n    bool internal failedNeverBelowMinBaseFee;\n    bool internal failedMaxRaiseBaseFeePerBlock;\n    bool internal failedMaxLowerBaseFeePerBlock;\n\n    // Used as a special flag for the purpose of identifying unchecked math errors specifically\n    // in the test contracts, not the target contracts themselves.\n    bool internal underflow;\n\n    constructor() {\n        initialize();\n    }\n\n    function initialize() internal initializer {\n        __ResourceMetering_init();\n    }\n\n    /**\n     * @notice Takes the necessary parameters to allow us to burn arbitrary amounts of gas to test\n     *         the underlying resource metering/gas market logic\n     */\n    function testBurn(uint256 _gasToBurn, bool _raiseBaseFee) public {\n        // Part 1: we cache the current param values and do some basic checks on them.\n        uint256 cachedPrevBaseFee = uint256(params.prevBaseFee);\n        uint256 cachedPrevBoughtGas = uint256(params.prevBoughtGas);\n        uint256 cachedPrevBlockNum = uint256(params.prevBlockNum);\n\n        // check that the last block's base fee hasn't dropped below the minimum\n        if (cachedPrevBaseFee < uint256(MINIMUM_BASE_FEE)) {\n            failedNeverBelowMinBaseFee = true;\n        }\n        // check that the last block didn't consume more than the max amount of gas\n        if (cachedPrevBoughtGas > uint256(MAX_RESOURCE_LIMIT)) {\n            failedMaxGasPerBlock = true;\n        }\n\n        // Part2: we perform the gas burn\n\n        // force the gasToBurn into the correct range based on whether we intend to\n        // raise or lower the baseFee after this block, respectively\n        uint256 gasToBurn;\n        if (_raiseBaseFee) {\n            gasToBurn = bound(\n                _gasToBurn,\n                uint256(TARGET_RESOURCE_LIMIT),\n                uint256(MAX_RESOURCE_LIMIT)\n            );\n        } else {\n            gasToBurn = bound(_gasToBurn, 0, uint256(TARGET_RESOURCE_LIMIT));\n        }\n\n        _burnInternal(uint64(gasToBurn));\n\n        // Part 3: we run checks and modify our invariant flags based on the updated params values\n\n        // Calculate the maximum allowed baseFee change (per block)\n        uint256 maxBaseFeeChange = cachedPrevBaseFee / uint256(BASE_FEE_MAX_CHANGE_DENOMINATOR);\n\n        // If the last block used more than the target amount of gas (and there were no\n        // empty blocks in between), ensure this block's baseFee increased, but not by\n        // more than the max amount per block\n        if (\n            (cachedPrevBoughtGas > uint256(TARGET_RESOURCE_LIMIT)) &&\n            (uint256(params.prevBlockNum) - cachedPrevBlockNum == 1)\n        ) {\n            failedRaiseBaseFee = failedRaiseBaseFee || (params.prevBaseFee <= cachedPrevBaseFee);\n            failedMaxRaiseBaseFeePerBlock =\n                failedMaxRaiseBaseFeePerBlock ||\n                ((uint256(params.prevBaseFee) - cachedPrevBaseFee) < maxBaseFeeChange);\n        }\n\n        // If the last block used less than the target amount of gas, (or was empty),\n        // ensure that: this block's baseFee was decreased, but not by more than the max amount\n        if (\n            (cachedPrevBoughtGas < uint256(TARGET_RESOURCE_LIMIT)) ||\n            (uint256(params.prevBlockNum) - cachedPrevBlockNum > 1)\n        ) {\n            // Invariant: baseFee should decrease\n            failedLowerBaseFee =\n                failedLowerBaseFee ||\n                (uint256(params.prevBaseFee) > cachedPrevBaseFee);\n\n            if (params.prevBlockNum - cachedPrevBlockNum == 1) {\n                // No empty blocks\n                // Invariant: baseFee should not have decreased by more than the maximum amount\n                failedMaxLowerBaseFeePerBlock =\n                    failedMaxLowerBaseFeePerBlock ||\n                    ((cachedPrevBaseFee - uint256(params.prevBaseFee)) <= maxBaseFeeChange);\n            } else if (params.prevBlockNum - cachedPrevBlockNum > 1) {\n                // We have at least one empty block\n                // Update the maxBaseFeeChange to account for multiple blocks having passed\n                unchecked {\n                    maxBaseFeeChange = uint256(\n                        int256(cachedPrevBaseFee) -\n                            Arithmetic.clamp(\n                                Arithmetic.cdexp(\n                                    int256(cachedPrevBaseFee),\n                                    BASE_FEE_MAX_CHANGE_DENOMINATOR,\n                                    int256(uint256(params.prevBlockNum) - cachedPrevBlockNum)\n                                ),\n                                MINIMUM_BASE_FEE,\n                                MAXIMUM_BASE_FEE\n                            )\n                    );\n                }\n\n                // Detect an underflow in the previous calculation.\n                // Without using unchecked above, and detecting the underflow here, echidna would\n                // otherwise ignore the revert.\n                underflow = underflow || maxBaseFeeChange > cachedPrevBaseFee;\n\n                // Invariant: baseFee should not have decreased by more than the maximum amount\n                failedMaxLowerBaseFeePerBlock =\n                    failedMaxLowerBaseFeePerBlock ||\n                    ((cachedPrevBaseFee - uint256(params.prevBaseFee)) <= maxBaseFeeChange);\n            }\n        }\n    }\n\n    function _burnInternal(uint64 _gasToBurn) private metered(_gasToBurn) {}\n\n    /**\n     * @custom:invariant The base fee should increase if the last block used more\n     * than the target amount of gas\n     *\n     * If the last block used more than the target amount of gas (and there were no\n     * empty blocks in between), ensure this block's baseFee increased, but not by\n     * more than the max amount per block.\n     */\n    function echidna_high_usage_raise_baseFee() public view returns (bool) {\n        return !failedRaiseBaseFee;\n    }\n\n    /**\n     * @custom:invariant The base fee should decrease if the last block used less\n     * than the target amount of gas\n     *\n     * If the previous block used less than the target amount of gas, the base fee should decrease,\n     * but not more than the max amount.\n     */\n    function echidna_low_usage_lower_baseFee() public view returns (bool) {\n        return !failedLowerBaseFee;\n    }\n\n    /**\n     * @custom:invariant A block's base fee should never be below `MINIMUM_BASE_FEE`\n     *\n     * This test asserts that a block's base fee can never drop below the\n     * `MINIMUM_BASE_FEE` threshold.\n     */\n    function echidna_never_below_min_baseFee() public view returns (bool) {\n        return !failedNeverBelowMinBaseFee;\n    }\n\n    /**\n     * @custom:invariant A block can never consume more than `MAX_RESOURCE_LIMIT` gas.\n     *\n     * This test asserts that a block can never consume more than the `MAX_RESOURCE_LIMIT`\n     * gas threshold.\n     */\n    function echidna_never_above_max_gas_limit() public view returns (bool) {\n        return !failedMaxGasPerBlock;\n    }\n\n    /**\n     * @custom:invariant The base fee can never be raised more than the max base fee change.\n     *\n     * After a block consumes more gas than the target gas, the base fee cannot be raised\n     * more than the maximum amount allowed. The max base fee change (per-block) is derived\n     * as follows: `prevBaseFee / BASE_FEE_MAX_CHANGE_DENOMINATOR`\n     */\n    function echidna_never_exceed_max_increase() public view returns (bool) {\n        return !failedMaxRaiseBaseFeePerBlock;\n    }\n\n    /**\n     * @custom:invariant The base fee can never be lowered more than the max base fee change.\n     *\n     * After a block consumes less than the target gas, the base fee cannot be lowered more\n     * than the maximum amount allowed. The max base fee change (per-block) is derived as\n     *follows: `prevBaseFee / BASE_FEE_MAX_CHANGE_DENOMINATOR`\n     */\n    function echidna_never_exceed_max_decrease() public view returns (bool) {\n        return !failedMaxLowerBaseFeePerBlock;\n    }\n\n    /**\n     * @custom:invariant The `maxBaseFeeChange` calculation over multiple blocks can never\n     * underflow.\n     *\n     * When calculating the `maxBaseFeeChange` after multiple empty blocks, the calculation\n     * should never be allowed to underflow.\n     */\n    function echidna_underflow() public view returns (bool) {\n        return !underflow;\n    }\n}\n"
    },
    "contracts/libraries/Arithmetic.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { SignedMath } from \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport { FixedPointMathLib } from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\n\n/**\n * @title Arithmetic\n * @notice Even more math than before.\n */\nlibrary Arithmetic {\n    /**\n     * @notice Clamps a value between a minimum and maximum.\n     *\n     * @param _value The value to clamp.\n     * @param _min   The minimum value.\n     * @param _max   The maximum value.\n     *\n     * @return The clamped value.\n     */\n    function clamp(\n        int256 _value,\n        int256 _min,\n        int256 _max\n    ) internal pure returns (int256) {\n        return SignedMath.min(SignedMath.max(_value, _min), _max);\n    }\n\n    /**\n     * @notice (c)oefficient (d)enominator (exp)onentiation function.\n     *         Returns the result of: c * (1 - 1/d)^exp.\n     *\n     * @param _coefficient Coefficient of the function.\n     * @param _denominator Fractional denominator.\n     * @param _exponent    Power function exponent.\n     *\n     * @return Result of c * (1 - 1/d)^exp.\n     */\n    function cdexp(\n        int256 _coefficient,\n        int256 _denominator,\n        int256 _exponent\n    ) internal pure returns (int256) {\n        return\n            (_coefficient *\n                (FixedPointMathLib.powWad(1e18 - (1e18 / _denominator), _exponent * 1e18))) / 1e18;\n    }\n}\n"
    },
    "contracts/libraries/Burn.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title Burn\n * @notice Utilities for burning stuff.\n */\nlibrary Burn {\n    /**\n     * Burns a given amount of ETH.\n     *\n     * @param _amount Amount of ETH to burn.\n     */\n    function eth(uint256 _amount) internal {\n        new Burner{ value: _amount }();\n    }\n\n    /**\n     * Burns a given amount of gas.\n     *\n     * @param _amount Amount of gas to burn.\n     */\n    function gas(uint256 _amount) internal view {\n        uint256 i = 0;\n        uint256 initialGas = gasleft();\n        while (initialGas - gasleft() < _amount) {\n            ++i;\n        }\n    }\n}\n\n/**\n * @title Burner\n * @notice Burner self-destructs on creation and sends all ETH to itself, removing all ETH given to\n *         the contract from the circulating supply. Self-destructing is the only way to remove ETH\n *         from the circulating supply.\n */\ncontract Burner {\n    constructor() payable {\n        selfdestruct(payable(address(this)));\n    }\n}\n"
    },
    "contracts/libraries/Bytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Bytes\n * @notice Bytes is a library for manipulating byte arrays.\n */\nlibrary Bytes {\n    /**\n     * @notice Compares two byte arrays by comparing their keccak256 hashes.\n     *\n     * @param _bytes First byte array to compare.\n     * @param _other Second byte array to compare.\n     *\n     * @return True if the two byte arrays are equal, false otherwise.\n     */\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\n        return keccak256(_bytes) == keccak256(_other);\n    }\n}\n"
    },
    "contracts/libraries/Bytes32.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Bytes32\n * @notice Bytes32 is a library for manipulating byte32.\n */\nlibrary Bytes32 {\n    /**\n     * @notice Splits bytes32 to high and low parts.\n     *\n     * @param _bytes Bytes32 to split.\n     *\n     * @return High part of bytes32.\n     * @return Low part of bytes32.\n     */\n    function split(bytes32 _bytes) internal pure returns (bytes32, bytes32) {\n        bytes16 high = bytes16(_bytes);\n        bytes16 low = bytes16(uint128(uint256(_bytes)));\n        return (fromBytes16(high), fromBytes16(low));\n    }\n\n    /**\n     * @notice Converts bytes16 to bytes32.\n     *\n     * @param _bytes Bytes to constrcut to bytes32.\n     *\n     * @return Bytes32 constructed from bytes16.\n     */\n    function fromBytes16(bytes16 _bytes) internal pure returns (bytes32) {\n        return bytes32(uint256(uint128(_bytes)));\n    }\n}\n"
    },
    "contracts/libraries/CodeDeployer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title CodeDeployer\n * @notice CodeDeployer is a library to deploy bytecode.\n */\nlibrary CodeDeployer {\n    function deployCode(bytes memory _code) internal returns (address deployedAddress) {\n        assembly {\n            deployedAddress := create(0, add(_code, 0x20), mload(_code))\n        }\n    }\n}\n"
    },
    "contracts/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Constants\n * @notice Constants is a library for storing constants. Simple! Don't put everything in here, just\n *         the stuff used in multiple contracts. Constants that only apply to a single contract\n *         should be defined in that contract instead.\n */\nlibrary Constants {\n    /**\n     * @notice Special address to be used as the tx origin for gas estimation calls in the\n     *         KromaPortal and CrossDomainMessenger calls. You only need to use this address if\n     *         the minimum gas limit specified by the user is not actually enough to execute the\n     *         given message and you're attempting to estimate the actual necessary gas limit. We\n     *         use address(1) because it's the ecrecover precompile and therefore guaranteed to\n     *         never have any code on any EVM chain.\n     */\n    address internal constant ESTIMATION_ADDRESS = address(1);\n\n    /**\n     * @notice Value used for the L2 sender storage slot in both the KromaPortal and the\n     *         CrossDomainMessenger contracts before an actual sender is set. This value is\n     *         non-zero to reduce the gas cost of message passing transactions.\n     */\n    address internal constant DEFAULT_L2_SENDER = 0x000000000000000000000000000000000000dEaD;\n}\n"
    },
    "contracts/libraries/Encoding.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Hashing } from \"./Hashing.sol\";\nimport { Types } from \"./Types.sol\";\nimport { RLPWriter } from \"./rlp/RLPWriter.sol\";\n\n/**\n * @title Encoding\n * @notice Encoding handles Kroma's various different encoding schemes.\n */\nlibrary Encoding {\n    /**\n     * @notice RLP encodes the L2 transaction that would be generated when a given deposit is sent\n     *         to the L2 system. Useful for searching for a deposit in the L2 system. The\n     *         transaction is prefixed with 0x7e to identify its EIP-2718 type.\n     *\n     * @param _tx User deposit transaction to encode.\n     *\n     * @return RLP encoded L2 deposit transaction.\n     */\n    function encodeDepositTransaction(Types.UserDepositTransaction memory _tx)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes32 source = Hashing.hashDepositSource(_tx.l1BlockHash, _tx.logIndex);\n        bytes[] memory raw = new bytes[](7);\n        raw[0] = RLPWriter.writeBytes(abi.encodePacked(source));\n        raw[1] = RLPWriter.writeAddress(_tx.from);\n        raw[2] = _tx.isCreation ? RLPWriter.writeBytes(\"\") : RLPWriter.writeAddress(_tx.to);\n        raw[3] = RLPWriter.writeUint(_tx.mint);\n        raw[4] = RLPWriter.writeUint(_tx.value);\n        raw[5] = RLPWriter.writeUint(uint256(_tx.gasLimit));\n        raw[6] = RLPWriter.writeBytes(_tx.data);\n        return abi.encodePacked(uint8(0x7e), RLPWriter.writeList(raw));\n    }\n\n    /**\n     * @notice Encodes the cross domain message based on the version that is encoded into the\n     *         message nonce.\n     *\n     * @param _nonce    Message nonce with version encoded into the first two bytes.\n     * @param _sender   Address of the sender of the message.\n     * @param _target   Address of the target of the message.\n     * @param _value    ETH value to send to the target.\n     * @param _gasLimit Gas limit to use for the message.\n     * @param _data     Data to send with the message.\n     *\n     * @return Encoded cross domain message.\n     */\n    function encodeCrossDomainMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes memory) {\n        (, uint16 version) = decodeVersionedNonce(_nonce);\n        if (version == 0) {\n            return encodeCrossDomainMessageV0(_nonce, _sender, _target, _value, _gasLimit, _data);\n        } else {\n            revert(\"Encoding: unknown cross domain message version\");\n        }\n    }\n\n    /**\n     * @notice Encodes a cross domain message based on the V0 (current) encoding.\n     *\n     * @param _nonce    Message nonce.\n     * @param _sender   Address of the sender of the message.\n     * @param _target   Address of the target of the message.\n     * @param _value    ETH value to send to the target.\n     * @param _gasLimit Gas limit to use for the message.\n     * @param _data     Data to send with the message.\n     *\n     * @return Encoded cross domain message.\n     */\n    function encodeCrossDomainMessageV0(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                \"relayMessage(uint256,address,address,uint256,uint256,bytes)\",\n                _nonce,\n                _sender,\n                _target,\n                _value,\n                _gasLimit,\n                _data\n            );\n    }\n\n    /**\n     * @notice Adds a version number into the first two bytes of a message nonce.\n     *\n     * @param _nonce   Message nonce to encode into.\n     * @param _version Version number to encode into the message nonce.\n     *\n     * @return Message nonce with version encoded into the first two bytes.\n     */\n    function encodeVersionedNonce(uint240 _nonce, uint16 _version) internal pure returns (uint256) {\n        uint256 nonce;\n        assembly {\n            nonce := or(shl(240, _version), _nonce)\n        }\n        return nonce;\n    }\n\n    /**\n     * @notice Pulls the version out of a version-encoded nonce.\n     *\n     * @param _nonce Message nonce with version encoded into the first two bytes.\n     *\n     * @return Nonce without encoded version.\n     * @return Version of the message.\n     */\n    function decodeVersionedNonce(uint256 _nonce) internal pure returns (uint240, uint16) {\n        uint240 nonce;\n        uint16 version;\n        assembly {\n            nonce := and(_nonce, 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            version := shr(240, _nonce)\n        }\n        return (nonce, version);\n    }\n}\n"
    },
    "contracts/libraries/Hashing.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Encoding } from \"./Encoding.sol\";\nimport { Types } from \"./Types.sol\";\n\n/**\n * @title Hashing\n * @notice Hashing handles Kroma's various different hashing schemes.\n */\nlibrary Hashing {\n    /**\n     * @notice Computes the hash of the RLP encoded L2 transaction that would be generated when a\n     *         given deposit is sent to the L2 system. Useful for searching for a deposit in the L2\n     *         system.\n     *\n     * @param _tx User deposit transaction to hash.\n     *\n     * @return Hash of the RLP encoded L2 deposit transaction.\n     */\n    function hashDepositTransaction(Types.UserDepositTransaction memory _tx)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(Encoding.encodeDepositTransaction(_tx));\n    }\n\n    /**\n     * @notice Computes the deposit transaction's \"source hash\", a value that guarantees the hash\n     *         of the L2 transaction that corresponds to a deposit is unique and is\n     *         deterministically generated from L1 transaction data.\n     *\n     * @param _l1BlockHash Hash of the L1 block where the deposit was included.\n     * @param _logIndex    The index of the log that created the deposit transaction.\n     *\n     * @return Hash of the deposit transaction's \"source hash\".\n     */\n    function hashDepositSource(bytes32 _l1BlockHash, uint64 _logIndex)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 depositId = keccak256(abi.encode(_l1BlockHash, _logIndex));\n        return keccak256(abi.encode(bytes32(0), depositId));\n    }\n\n    /**\n     * @notice Hashes the cross domain message based on the version that is encoded into the\n     *         message nonce.\n     *\n     * @param _nonce    Message nonce with version encoded into the first two bytes.\n     * @param _sender   Address of the sender of the message.\n     * @param _target   Address of the target of the message.\n     * @param _value    ETH value to send to the target.\n     * @param _gasLimit Gas limit to use for the message.\n     * @param _data     Data to send with the message.\n     *\n     * @return Hashed cross domain message.\n     */\n    function hashCrossDomainMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes32) {\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\n        if (version == 0) {\n            return hashCrossDomainMessageV0(_nonce, _sender, _target, _value, _gasLimit, _data);\n        } else {\n            revert(\"Hashing: unknown cross domain message version\");\n        }\n    }\n\n    /**\n     * @notice Hashes a cross domain message based on the V0 (current) encoding.\n     *\n     * @param _nonce    Message nonce.\n     * @param _sender   Address of the sender of the message.\n     * @param _target   Address of the target of the message.\n     * @param _value    ETH value to send to the target.\n     * @param _gasLimit Gas limit to use for the message.\n     * @param _data     Data to send with the message.\n     *\n     * @return Hashed cross domain message.\n     */\n    function hashCrossDomainMessageV0(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                Encoding.encodeCrossDomainMessageV0(\n                    _nonce,\n                    _sender,\n                    _target,\n                    _value,\n                    _gasLimit,\n                    _data\n                )\n            );\n    }\n\n    /**\n     * @notice Derives the withdrawal hash according to the encoding in the L2 Withdrawer contract\n     *\n     * @param _tx Withdrawal transaction to hash.\n     *\n     * @return Hashed withdrawal transaction.\n     */\n    function hashWithdrawal(Types.WithdrawalTransaction memory _tx)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(_tx.nonce, _tx.sender, _tx.target, _tx.value, _tx.gasLimit, _tx.data)\n            );\n    }\n\n    /**\n     * @notice Hashes the various elements of an output root proof into an output root hash which\n     *         can be used to check if the proof is valid.\n     *\n     * @param _outputRootProof Output root proof which should hash to an output root.\n     *\n     * @return Hashed output root proof.\n     */\n    function hashOutputRootProof(Types.OutputRootProof memory _outputRootProof)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    _outputRootProof.version,\n                    _outputRootProof.stateRoot,\n                    _outputRootProof.messagePasserStorageRoot,\n                    _outputRootProof.latestBlockhash\n                )\n            );\n    }\n}\n"
    },
    "contracts/libraries/NodeReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title NodeReader\n * @notice NodeReader is a library for reading ZKTrie Node.\n */\nlibrary NodeReader {\n    /**\n     * @notice Node types.\n     *         See https://github.com/kroma-network/zktrie/blob/main/types/README.md.\n     *\n     * @custom:value MIDDLE Represents a middle node.\n     * @custom:value LEAF   Represents a leaf node.\n     * @custom:value EMPTY  Represents a empty node.\n     * @custom:value ROOT   Represents a middle node.\n     */\n    enum NodeType {\n        MIDDLE,\n        LEAF,\n        EMPTY,\n        ROOT\n    }\n\n    /**\n     * @notice Struct representing a Node.\n     *         See https://github.com/kroma-network/zktrie/blob/main/types/README.md.\n     */\n    struct Node {\n        NodeType nodeType;\n        bytes32 childL;\n        bytes32 childR;\n        bytes32 nodeKey;\n        bytes32[] valuePreimage;\n        uint32 compressedFlags;\n        bytes32 valueHash;\n        bytes32 keyPreimage;\n    }\n\n    /**\n     * @notice Struct representing an Item.\n     */\n    struct Item {\n        bytes ptr;\n        uint256 len;\n    }\n\n    /**\n     * @notice Converts bytes to Item.\n     *\n     * @param _bytes bytes to convert.\n     *\n     * @return Item referencing _bytes.\n     */\n    function toItem(bytes memory _bytes) internal pure returns (Item memory) {\n        bytes memory ptr;\n        assembly {\n            ptr := add(_bytes, 32)\n        }\n        return Item({ ptr: ptr, len: _bytes.length });\n    }\n\n    /**\n     * @notice Reads an Item into an uint8.\n     *         Internal ptr and length is updated automatically.\n     *\n     * @param _item Item to read.\n     *\n     * @return An uint8 value.\n     */\n    function readUint8(Item memory _item) internal pure returns (uint8) {\n        require(_item.len >= 1, \"NodeReader: too short for uint8\");\n        bytes memory newPtr;\n        bytes memory ptr = _item.ptr;\n        uint8 ret;\n        assembly {\n            ret := shr(248, mload(ptr))\n            newPtr := add(ptr, 1)\n        }\n        _item.ptr = newPtr;\n        _item.len -= 1;\n        return ret;\n    }\n\n    /**\n     * @notice Reads an Item into compressed flags and length of values.\n     *         Internal ptr and length is updated automatically.\n     *\n     * @param _item Item to read.\n     *\n     * @return Compressed flags.\n     * @return Length of values.\n     */\n    function readCompressedFlags(Item memory _item) internal pure returns (uint32, uint8) {\n        require(_item.len >= 4, \"NodeReader: too short for uint32\");\n        bytes memory newPtr;\n        bytes memory ptr = _item.ptr;\n        uint32 temp;\n        uint8 flag;\n        uint8 len;\n        assembly {\n            temp := mload(ptr)\n            len := shr(248, temp)\n            flag := shr(240, temp)\n            newPtr := add(ptr, 4)\n        }\n        _item.ptr = newPtr;\n        _item.len -= 4;\n        return (flag, len);\n    }\n\n    /**\n     * @notice Reads an Item into a bytes32.\n     *         Internal ptr and length is updated automatically.\n     *\n     * @param _item Item to read.\n     *\n     * @return A bytes32 value.\n     */\n    function readBytes32(Item memory _item) internal pure returns (bytes32) {\n        require(_item.len >= 32, \"NodeReader: too short for bytes32\");\n        bytes memory newPtr;\n        bytes memory ptr = _item.ptr;\n        bytes32 ret;\n        assembly {\n            ret := mload(ptr)\n            newPtr := add(ptr, 32)\n        }\n        _item.ptr = newPtr;\n        _item.len -= 32;\n        return ret;\n    }\n\n    /**\n     * @notice Reads an Item by n bytes into a bytes32.\n     *         Internal ptr and length is updated automatically.\n     *\n     * @param _item Item to read.\n     *\n     * @return A bytes32 value.\n     */\n    function readBytesN(Item memory _item, uint256 _length) internal pure returns (bytes32) {\n        require(_item.len >= _length, \"NodeReader: too short for n bytes\");\n        bytes memory newPtr;\n        bytes memory ptr = _item.ptr;\n        bytes32 ret;\n        uint256 to = 256 - _length * 8;\n        assembly {\n            newPtr := add(ptr, _length)\n            ret := shr(to, mload(ptr))\n        }\n        _item.ptr = newPtr;\n        _item.len -= _length;\n        return ret;\n    }\n\n    /**\n     * @notice Reads bytes into a Node.\n     *\n     * @param _proof Bytes to read.\n     *\n     * @return A decoded Node.\n     */\n    function readNode(bytes memory _proof) internal pure returns (Node memory) {\n        Node memory node;\n        Item memory item = toItem(_proof);\n        uint256 nodeType = readUint8(item);\n        if (nodeType == uint256(NodeType.MIDDLE)) {\n            // TODO(chokobole): Do the length check as much as possible at once and read the bytes.\n            node.childL = readBytes32(item);\n            node.childR = readBytes32(item);\n        } else if (nodeType == uint256(NodeType.LEAF)) {\n            // TODO(chokobole): Do the length check as much as possible at once and read the bytes.\n            node.nodeKey = readBytes32(item);\n            (uint32 compressedFlags, uint256 valuePreimageLen) = readCompressedFlags(item);\n            node.compressedFlags = compressedFlags;\n            node.valuePreimage = new bytes32[](valuePreimageLen);\n            for (uint256 i = 0; i < valuePreimageLen; ) {\n                node.valuePreimage[i] = readBytes32(item);\n                unchecked {\n                    ++i;\n                }\n            }\n            uint256 keyPreimageLen = readUint8(item);\n            if (keyPreimageLen > 0) {\n                node.keyPreimage = readBytesN(item, keyPreimageLen);\n            }\n        } else if (nodeType == uint256(NodeType.EMPTY)) {\n            // Do nothing.\n        } else if (nodeType == uint256(NodeType.ROOT)) {\n            revert(\"NodeReader: unexpected root node type\");\n        } else {\n            revert(\"NodeReader: invalid node type\");\n        }\n        node.nodeType = NodeType(nodeType);\n        return node;\n    }\n}\n"
    },
    "contracts/libraries/Predeploys.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Predeploys\n * @notice Contains constant addresses for contracts that are pre-deployed to the L2 system.\n */\nlibrary Predeploys {\n    /**\n     * @notice Address of the ProxyAdmin predeploy.\n     */\n    address internal constant PROXY_ADMIN = 0x4200000000000000000000000000000000000000;\n\n    /**\n     * @notice Address of the L1Block predeploy.\n     */\n    address internal constant L1_BLOCK_ATTRIBUTES = 0x4200000000000000000000000000000000000002;\n\n    /**\n     * @notice Address of the L2ToL1MessagePasser predeploy.\n     */\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000003;\n\n    /**\n     * @notice Address of the L2CrossDomainMessenger predeploy.\n     */\n    address internal constant L2_CROSS_DOMAIN_MESSENGER =\n        0x4200000000000000000000000000000000000004;\n\n    /**\n     * @notice Address of the GasPriceOracle predeploy. Includes fee information\n     *         and helpers for computing the L1 portion of the transaction fee.\n     */\n    address internal constant GAS_PRICE_ORACLE = 0x4200000000000000000000000000000000000005;\n\n    /**\n     * @notice Address of the BaseFeeVault predeploy.\n     */\n    address internal constant BASE_FEE_VAULT = 0x4200000000000000000000000000000000000006;\n\n    /**\n     * @notice Address of the L1FeeVault predeploy.\n     */\n    address internal constant L1_FEE_VAULT = 0x4200000000000000000000000000000000000007;\n\n    /**\n     * @notice Address of the ProposerFeeWallet predeploy.\n     */\n    address internal constant PROPOSER_FEE_WALLET = 0x4200000000000000000000000000000000000008;\n\n    /**\n     * @notice Address of the L2StandardBridge predeploy.\n     */\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000009;\n\n    /**\n     * @notice Address of the L2ERC721Bridge predeploy.\n     */\n    address internal constant L2_ERC721_BRIDGE = 0x420000000000000000000000000000000000000A;\n\n    /**\n     * @notice Address of the KromaMintableERC20Factory predeploy.\n     */\n    address internal constant KROMA_MINTABLE_ERC20_FACTORY =\n        0x420000000000000000000000000000000000000B;\n\n    /**\n     * @notice Address of the KromaMintableERC721Factory predeploy.\n     */\n    address internal constant KROMA_MINTABLE_ERC721_FACTORY =\n        0x420000000000000000000000000000000000000c;\n}\n"
    },
    "contracts/libraries/SafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title SafeCall\n * @notice Perform low level safe calls\n */\nlibrary SafeCall {\n    /**\n     * @notice Perform a low level call without copying any returndata\n     *\n     * @param _target   Address to call\n     * @param _gas      Amount of gas to pass to the call\n     * @param _value    Amount of value to pass to the call\n     * @param _calldata Calldata to pass to the call\n     */\n    function call(\n        address _target,\n        uint256 _gas,\n        uint256 _value,\n        bytes memory _calldata\n    ) internal returns (bool) {\n        bool _success;\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 32), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n        }\n        return _success;\n    }\n\n    /**\n     * @notice Perform a low level call without copying any returndata. This function\n     *         will revert if the call cannot be performed with the specified minimum\n     *         gas.\n     *\n     * @param _target   Address to call\n     * @param _minGas   The minimum amount of gas that may be passed to the call\n     * @param _value    Amount of value to pass to the call\n     * @param _calldata Calldata to pass to the call\n     */\n    function callWithMinGas(\n        address _target,\n        uint256 _minGas,\n        uint256 _value,\n        bytes memory _calldata\n    ) internal returns (bool) {\n        bool _success;\n        assembly {\n            // Assertion: gasleft() >= ((_minGas + 200) * 64) / 63\n            //\n            // Because EIP-150 ensures that, a maximum of 63/64ths of the remaining gas in the call\n            // frame may be passed to a subcontext, we need to ensure that the gas will not be\n            // truncated to hold this function's invariant: \"If a call is performed by\n            // `callWithMinGas`, it must receive at least the specified minimum gas limit.\" In\n            // addition, exactly 51 gas is consumed between the below `GAS` opcode and the `CALL`\n            // opcode, so it is factored in with some extra room for error.\n            if lt(gas(), div(mul(64, add(_minGas, 200)), 63)) {\n                // Store the \"Error(string)\" selector in scratch space.\n                mstore(0, 0x08c379a0)\n                // Store the pointer to the string length in scratch space.\n                mstore(32, 32)\n                // Store the string.\n                //\n                // SAFETY:\n                // - We pad the beginning of the string with two zero bytes as well as the\n                // length (24) to ensure that we override the free memory pointer at offset\n                // 0x40. This is necessary because the free memory pointer is likely to\n                // be greater than 1 byte when this function is called, but it is incredibly\n                // unlikely that it will be greater than 3 bytes. As for the data within\n                // 0x60, it is ensured that it is 0 due to 0x60 being the zero offset.\n                // - It's fine to clobber the free memory pointer, we're reverting.\n                mstore(88, 0x0000185361666543616c6c3a204e6f7420656e6f75676820676173)\n\n                // Revert with 'Error(\"SafeCall: Not enough gas\")'\n                revert(28, 100)\n            }\n\n            // The call will be supplied at least (((_minGas + 200) * 64) / 63) - 49 gas due to the\n            // above assertion. This ensures that, in all circumstances, the call will\n            // receive at least the minimum amount of gas specified.\n            // We can prove this property by solving the inequalities:\n            // ((((_minGas + 200) * 64) / 63) - 49) >= _minGas\n            // ((((_minGas + 200) * 64) / 63) - 51) * (63 / 64) >= _minGas\n            // Both inequalities hold true for all possible values of `_minGas`.\n            _success := call(\n                gas(), // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 32), // inloc\n                mload(_calldata), // inlen\n                0x00, // outloc\n                0x00 // outlen\n            )\n        }\n        return _success;\n    }\n}\n"
    },
    "contracts/libraries/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Types\n * @notice Contains various types used throughout the Kroma contract system.\n */\nlibrary Types {\n    /**\n     * @notice CheckpointOutput represents a commitment to the state of L2 checkpoint. The timestamp\n     *         is the L1 timestamp that the output root is posted. This timestamp is used to verify\n     *         that the finalization period has passed since the output root was submitted.\n     *\n     * @custom:field outputRoot    Hash of the L2 output.\n     * @custom:field timestamp     Timestamp of the L1 block that the output root was submitted in.\n     * @custom:field l2BlockNumber L2 block number that the output corresponds to.\n     */\n    struct CheckpointOutput {\n        bytes32 outputRoot;\n        uint128 timestamp;\n        uint128 l2BlockNumber;\n    }\n\n    /**\n     * @notice Struct representing the elements that are hashed together to generate an output root\n     *         which itself represents a snapshot of the L2 state.\n     *\n     * @custom:field version                  Version of the output root.\n     * @custom:field stateRoot                Root of the state trie at the block of this output.\n     * @custom:field messagePasserStorageRoot Root of the message passer storage trie.\n     * @custom:field latestBlockhash          Hash of the block this output was generated from.\n     */\n    struct OutputRootProof {\n        bytes32 version;\n        bytes32 stateRoot;\n        bytes32 messagePasserStorageRoot;\n        bytes32 latestBlockhash;\n    }\n\n    /**\n     * @notice Struct representing a deposit transaction (L1 => L2 transaction) created by an end\n     *         user (as opposed to a system deposit transaction generated by the system).\n     *\n     * @custom:field from        Address of the sender of the transaction.\n     * @custom:field to          Address of the recipient of the transaction.\n     * @custom:field isCreation  True if the transaction is a contract creation.\n     * @custom:field value       Value to send to the recipient.\n     * @custom:field mint        Amount of ETH to mint.\n     * @custom:field gasLimit    Gas limit of the transaction.\n     * @custom:field data        Data of the transaction.\n     * @custom:field l1BlockHash Hash of the block the transaction was submitted in.\n     * @custom:field logIndex    Index of the log in the block the transaction was submitted in.\n     */\n    struct UserDepositTransaction {\n        address from;\n        address to;\n        bool isCreation;\n        uint256 value;\n        uint256 mint;\n        uint64 gasLimit;\n        bytes data;\n        bytes32 l1BlockHash;\n        uint64 logIndex;\n    }\n\n    /**\n     * @notice Struct representing a withdrawal transaction.\n     *\n     * @custom:field nonce    Nonce of the withdrawal transaction\n     * @custom:field sender   Address of the sender of the transaction.\n     * @custom:field target   Address of the recipient of the transaction.\n     * @custom:field value    Value to send to the recipient.\n     * @custom:field gasLimit Gas limit of the transaction.\n     * @custom:field data     Data of the transaction.\n     */\n    struct WithdrawalTransaction {\n        uint256 nonce;\n        address sender;\n        address target;\n        uint256 value;\n        uint256 gasLimit;\n        bytes data;\n    }\n\n    /**\n     * @notice Struct representing a challenge.\n     */\n    struct Challenge {\n        uint256 outputIndex;\n        uint256 turn;\n        address current;\n        address next;\n        bytes32[] segments;\n        uint256 segStart;\n        uint256 segSize;\n        uint256 timeoutAt;\n        bool closed;\n    }\n}\n"
    },
    "contracts/libraries/rlp/RLPWriter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @custom:attribution https://github.com/bakaoh/solidity-rlp-encode\n * @title RLPWriter\n * @author RLPWriter is a library for encoding Solidity types to RLP bytes. Adapted from Bakaoh's\n *         RLPEncode library (https://github.com/bakaoh/solidity-rlp-encode) with minor\n *         modifications to improve legibility.\n */\nlibrary RLPWriter {\n    /**\n     * @notice RLP encodes a byte string.\n     *\n     * @param _in The byte string to encode.\n     *\n     * @return The RLP encoded string in bytes.\n     */\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\n            encoded = _in;\n        } else {\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\n        }\n\n        return encoded;\n    }\n\n    /**\n     * @notice RLP encodes a list of RLP encoded byte byte strings.\n     *\n     * @param _in The list of RLP encoded byte strings.\n     *\n     * @return The RLP encoded list of items in bytes.\n     */\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\n        bytes memory list = _flatten(_in);\n        return abi.encodePacked(_writeLength(list.length, 192), list);\n    }\n\n    /**\n     * @notice RLP encodes a string.\n     *\n     * @param _in The string to encode.\n     *\n     * @return The RLP encoded string in bytes.\n     */\n    function writeString(string memory _in) internal pure returns (bytes memory) {\n        return writeBytes(bytes(_in));\n    }\n\n    /**\n     * @notice RLP encodes an address.\n     *\n     * @param _in The address to encode.\n     *\n     * @return The RLP encoded address in bytes.\n     */\n    function writeAddress(address _in) internal pure returns (bytes memory) {\n        return writeBytes(abi.encodePacked(_in));\n    }\n\n    /**\n     * @notice RLP encodes a uint.\n     *\n     * @param _in The uint256 to encode.\n     *\n     * @return The RLP encoded uint256 in bytes.\n     */\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\n        return writeBytes(_toBinary(_in));\n    }\n\n    /**\n     * @notice RLP encodes a bool.\n     *\n     * @param _in The bool to encode.\n     *\n     * @return The RLP encoded bool in bytes.\n     */\n    function writeBool(bool _in) internal pure returns (bytes memory) {\n        bytes memory encoded = new bytes(1);\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\n        return encoded;\n    }\n\n    /**\n     * @notice Encode the first byte and then the `len` in binary form if `length` is more than 55.\n     *\n     * @param _len    The length of the string or the payload.\n     * @param _offset 128 if item is string, 192 if item is list.\n     *\n     * @return RLP encoded bytes.\n     */\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\n        } else {\n            uint256 lenLen;\n            uint256 i = 1;\n            while (_len / i != 0) {\n                lenLen++;\n                i *= 256;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\n            for (i = 1; i <= lenLen; i++) {\n                encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));\n            }\n        }\n\n        return encoded;\n    }\n\n    /**\n     * @notice Encode integer in big endian binary form with no leading zeroes.\n     *\n     * @param _x The integer to encode.\n     *\n     * @return RLP encoded bytes.\n     */\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\n        bytes memory b = abi.encodePacked(_x);\n\n        uint256 i = 0;\n        for (; i < 32; i++) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n\n        bytes memory res = new bytes(32 - i);\n        for (uint256 j = 0; j < res.length; j++) {\n            res[j] = b[i++];\n        }\n\n        return res;\n    }\n\n    /**\n     * @custom:attribution https://github.com/Arachnid/solidity-stringutils\n     * @notice Copies a piece of memory to another location.\n     *\n     * @param _dest Destination location.\n     * @param _src  Source location.\n     * @param _len  Length of memory to copy.\n     */\n    function _memcpy(\n        uint256 _dest,\n        uint256 _src,\n        uint256 _len\n    ) private pure {\n        uint256 dest = _dest;\n        uint256 src = _src;\n        uint256 len = _len;\n\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        uint256 mask;\n        unchecked {\n            mask = 256**(32 - len) - 1;\n        }\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * @custom:attribution https://github.com/sammayo/solidity-rlp-encoder\n     * @notice Flattens a list of byte strings into one byte string.\n     *\n     * @param _list List of byte strings to flatten.\n     *\n     * @return The flattened byte string.\n     */\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint256 len;\n        uint256 i = 0;\n        for (; i < _list.length; i++) {\n            len += _list[i].length;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint256 flattenedPtr;\n        assembly {\n            flattenedPtr := add(flattened, 0x20)\n        }\n\n        for (i = 0; i < _list.length; i++) {\n            bytes memory item = _list[i];\n\n            uint256 listPtr;\n            assembly {\n                listPtr := add(item, 0x20)\n            }\n\n            _memcpy(flattenedPtr, listPtr, item.length);\n            flattenedPtr += _list[i].length;\n        }\n\n        return flattened;\n    }\n}\n"
    },
    "contracts/test/AddressAliasHelper.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\n\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\n\ncontract AddressAliasHelper_applyAndUndo_Test is Test {\n    /**\n     * @notice Tests that applying and then undoing an alias results in the original address.\n     */\n    function testFuzz_applyAndUndo_succeeds(address _address) external {\n        address aliased = AddressAliasHelper.applyL1ToL2Alias(_address);\n        address unaliased = AddressAliasHelper.undoL1ToL2Alias(aliased);\n        assertEq(_address, unaliased);\n    }\n}\n"
    },
    "contracts/test/BenchmarkTest.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/* Testing utilities */\nimport { Test } from \"forge-std/Test.sol\";\nimport { Vm } from \"forge-std/Vm.sol\";\n\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport \"./CommonTest.t.sol\";\n\n// Free function for setting the prevBaseFee param in the KromaPortal.\nfunction setPrevBaseFee(\n    Vm _vm,\n    address _portal,\n    uint128 _prevBaseFee\n) {\n    _vm.store(address(_portal), bytes32(uint256(1)), bytes32((block.number << 192) | _prevBaseFee));\n}\n\ncontract SetPrevBaseFee_Test is Portal_Initializer {\n    function test_setPrevBaseFee_succeeds() external {\n        setPrevBaseFee(vm, address(portal), 100 gwei);\n        (uint128 prevBaseFee, , uint64 prevBlockNum) = portal.params();\n        assertEq(uint256(prevBaseFee), 100 gwei);\n        assertEq(uint256(prevBlockNum), block.number);\n    }\n}\n\n// Tests for obtaining pure gas cost estimates for commonly used functions.\n// The objective with these benchmarks is to strip down the actual test functions\n// so that they are nothing more than the call we want measure the gas cost of.\n// In order to achieve this we make no assertions, and handle everything else in the setUp()\n// function.\ncontract GasBenchMark_KromaPortal is Portal_Initializer {\n    uint128 internal INITIAL_BASE_FEE;\n\n    // Reusable default values for a test withdrawal\n    Types.WithdrawalTransaction _defaultTx;\n\n    uint256 _submittedOutputIndex;\n    uint256 _submittedBlockNumber;\n    bytes[] _withdrawalProof;\n    Types.OutputRootProof internal _outputRootProof;\n    bytes32 _outputRoot;\n\n    // Use a constructor to set the storage vars above, so as to minimize the number of ffi calls.\n    constructor() {\n        super.setUp();\n        _defaultTx = Types.WithdrawalTransaction({\n            nonce: 0,\n            sender: alice,\n            target: bob,\n            value: 100,\n            gasLimit: 100_000,\n            data: hex\"\"\n        });\n\n        // Get withdrawal proof data we can use for testing.\n        bytes32 _storageRoot;\n        bytes32 _stateRoot;\n        (_stateRoot, _storageRoot, _outputRoot, , _withdrawalProof) = ffi\n            .getProveWithdrawalTransactionInputs(_defaultTx);\n\n        // Setup a dummy output root proof for reuse.\n        _outputRootProof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: _stateRoot,\n            messagePasserStorageRoot: _storageRoot,\n            latestBlockhash: bytes32(uint256(0))\n        });\n        _submittedBlockNumber = oracle.nextBlockNumber();\n        _submittedOutputIndex = oracle.nextOutputIndex();\n    }\n\n    // Get the system into a nice ready-to-use state.\n    function setUp() public override {\n        // Configure the oracle to return the output root we've prepared.\n        vm.warp(oracle.computeL2Timestamp(_submittedBlockNumber) + 1);\n        vm.prank(oracle.VALIDATOR());\n        oracle.submitL2Output(_outputRoot, _submittedBlockNumber, 0, 0);\n\n        // Warp beyond the finalization period for the block we've submitted.\n        vm.warp(\n            oracle.getL2Output(_submittedOutputIndex).timestamp +\n                oracle.FINALIZATION_PERIOD_SECONDS() +\n                1\n        );\n\n        INITIAL_BASE_FEE = portal.INITIAL_BASE_FEE();\n\n        // Fund the portal so that we can withdraw ETH.\n        vm.deal(address(portal), 0xFFFFFFFF);\n    }\n\n    function test_depositTransaction_benchmark() external {\n        portal.depositTransaction{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    function test_depositTransaction_benchmark_1() external {\n        setPrevBaseFee(vm, address(portal), INITIAL_BASE_FEE);\n        portal.depositTransaction{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    function test_proveWithdrawalTransaction_benchmark() external {\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n}\n\ncontract GasBenchMark_L1CrossDomainMessenger is Messenger_Initializer {\n    uint128 internal INITIAL_BASE_FEE;\n\n    function setUp() public virtual override {\n        super.setUp();\n        INITIAL_BASE_FEE = portal.INITIAL_BASE_FEE();\n    }\n\n    function test_sendMessage_benchmark_0() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(portal), INITIAL_BASE_FEE);\n        // The amount of data typically sent during a bridge deposit.\n        bytes\n            memory data = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n        vm.resumeGasMetering();\n        L1Messenger.sendMessage(bob, data, uint32(100));\n    }\n\n    function test_sendMessage_benchmark_1() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(portal), 10 gwei);\n        // The amount of data typically sent during a bridge deposit.\n        bytes\n            memory data = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n        vm.resumeGasMetering();\n        L1Messenger.sendMessage(bob, data, uint32(100));\n    }\n}\n\n\ncontract GasBenchMark_L1StandardBridge_Deposit is Bridge_Initializer {\n    uint128 internal INITIAL_BASE_FEE;\n\n    function setUp() public virtual override {\n        super.setUp();\n        INITIAL_BASE_FEE = portal.INITIAL_BASE_FEE();\n        deal(address(L1Token), alice, 100000, true);\n        vm.startPrank(alice, alice);\n        L1Token.approve(address(L1Bridge), type(uint256).max);\n    }\n\n    function test_depositETH_benchmark_0() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(portal), INITIAL_BASE_FEE);\n        vm.resumeGasMetering();\n        L1Bridge.bridgeETH{ value: 500 }(50000, hex\"\");\n    }\n\n    function test_depositETH_benchmark_1() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(portal), 10 gwei);\n        vm.resumeGasMetering();\n        L1Bridge.bridgeETH{ value: 500 }(50000, hex\"\");\n    }\n\n    function test_depositERC20_benchmark_0() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(portal), INITIAL_BASE_FEE);\n        vm.resumeGasMetering();\n        L1Bridge.bridgeERC20({\n            _localToken: address(L1Token),\n            _remoteToken: address(L2Token),\n            _amount: 100,\n            _minGasLimit: 100_000,\n            _extraData: hex\"\"\n        });\n    }\n\n    function test_depositERC20_benchmark_1() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(portal), 10 gwei);\n        vm.resumeGasMetering();\n        L1Bridge.bridgeERC20({\n            _localToken: address(L1Token),\n            _remoteToken: address(L2Token),\n            _amount: 100,\n            _minGasLimit: 100_000,\n            _extraData: hex\"\"\n        });\n    }\n}\n\ncontract GasBenchMark_L1StandardBridge_Finalize is Bridge_Initializer {\n    function setUp() public virtual override {\n        super.setUp();\n        deal(address(L1Token), address(L1Bridge), 100, true);\n        vm.mockCall(\n            address(L1Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.startPrank(address(L1Bridge.MESSENGER()));\n        vm.deal(address(L1Bridge.MESSENGER()), 100);\n    }\n\n     function test_finalizeBridgeETH_benchmark() external {\n        // TODO: Make this more accurate. It is underestimating the cost because it pranks\n        // the call coming from the messenger, which bypasses the portal\n        // and oracle.\n        L1Bridge.finalizeBridgeETH{ value: 100 }(alice, alice, 100, hex\"\");\n    }\n}\n\ncontract GasBenchMark_L2OutputOracle is L2OutputOracle_Initializer {\n    uint256 nextBlockNumber;\n\n    function setUp() public override {\n        super.setUp();\n        nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber);\n        vm.startPrank(asserter);\n    }\n\n    function test_submitL2Output_benchmark() external {\n        oracle.submitL2Output(nonZeroHash, nextBlockNumber, 0, 0);\n    }\n}\n"
    },
    "contracts/test/Bytes.t.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\n\nimport { Bytes } from \"../libraries/Bytes.sol\";\n\ncontract Bytes_equal_Test is Test {\n    /**\n     * @notice Manually checks equality of two dynamic `bytes` arrays in memory.\n     *\n     * @param _a The first `bytes` array to compare.\n     * @param _b The second `bytes` array to compare.\n     *\n     * @return True if the two `bytes` arrays are equal in memory.\n     */\n    function manualEq(bytes memory _a, bytes memory _b) internal pure returns (bool) {\n        bool _eq;\n        assembly {\n            _eq := and(\n                // Check if the contents of the two bytes arrays are equal in memory.\n                eq(keccak256(add(0x20, _a), mload(_a)), keccak256(add(0x20, _b), mload(_b))),\n                // Check if the length of the two bytes arrays are equal in memory.\n                // This is redundant given the above check, but included for completeness.\n                eq(mload(_a), mload(_b))\n            )\n        }\n        return _eq;\n    }\n\n    /**\n     * @notice Tests that the `equal` function in the `Bytes` library returns `false` if given two\n     *         non-equal byte arrays.\n     */\n    function testFuzz_equal_notEqual_works(bytes memory _a, bytes memory _b) public {\n        vm.assume(!manualEq(_a, _b));\n        assertFalse(Bytes.equal(_a, _b));\n    }\n\n    /**\n     * @notice Test whether or not the `equal` function in the `Bytes` library is equivalent to\n     *         manually checking equality of the two dynamic `bytes` arrays in memory.\n     */\n    function testDiff_equal_works(bytes memory _a, bytes memory _b) public {\n        assertEq(Bytes.equal(_a, _b), manualEq(_a, _b));\n    }\n}\n"
    },
    "contracts/test/Colosseum.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { Types } from \"../libraries/Types.sol\";\nimport { Colosseum } from \"../L1/Colosseum.sol\";\nimport { Colosseum_Initializer } from \"./CommonTest.t.sol\";\nimport { MockProofData } from \"./MockProofData.sol\";\n\n// Test the implementations of the Colosseum\ncontract Colosseum_Test is Colosseum_Initializer {\n    mapping(uint256 => bytes32) private _actualOutputs;\n    mapping(uint256 => bytes32) private _invalidOutputs;\n\n    uint256 startBlockNumber = 0;\n\n    function _toOutputRoot(\n        uint256 _blockNumber,\n        bytes32 _prevOutput\n    ) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_blockNumber, _prevOutput));\n    }\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        uint256 interval = oracle.SUBMISSION_INTERVAL();\n        startBlockNumber = oracle.latestBlockNumber();\n        uint256 nextBlockNumber = startBlockNumber + interval;\n\n        uint256 invalidIndex = uint256(keccak256(abi.encodePacked(block.timestamp))) % interval;\n\n        for (uint256 i = 1; i <= interval * 2; i++) {\n            uint256 blockNumber = startBlockNumber + i;\n\n            _actualOutputs[blockNumber] = _toOutputRoot(\n                blockNumber,\n                _actualOutputs[blockNumber - 1]\n            );\n\n            if (i == (interval + invalidIndex)) {\n                // insert invalid output root\n                _invalidOutputs[blockNumber] = _toOutputRoot(blockNumber, bytes32(0));\n            } else {\n                _invalidOutputs[blockNumber] = _toOutputRoot(\n                    blockNumber,\n                    _invalidOutputs[blockNumber - 1]\n                );\n            }\n        }\n\n        // Roll to after the block number we'll submit\n        warpToSubmitTime(nextBlockNumber);\n        vm.prank(asserter);\n        oracle.submitL2Output(_actualOutputs[nextBlockNumber], nextBlockNumber, 0, 0);\n\n        // submit again\n        startBlockNumber = oracle.latestBlockNumber();\n        nextBlockNumber = startBlockNumber + interval;\n        warpToSubmitTime(nextBlockNumber);\n        vm.prank(asserter);\n        oracle.submitL2Output(_invalidOutputs[nextBlockNumber], nextBlockNumber, 0, 0);\n    }\n\n    function _newSegments(\n        address _sender,\n        uint256 _turn,\n        uint256 _segStart,\n        uint256 _segSize\n    ) private view returns (bytes32[] memory) {\n        uint256 segLen = colosseum.getSegmentsLength(_turn);\n\n        bytes32[] memory arr = new bytes32[](segLen);\n\n        for (uint256 i = 0; i < segLen; i++) {\n            uint256 n = _segStart + i * (_segSize / (segLen - 1));\n            arr[i] = _sender == asserter ? _invalidOutputs[n] : _actualOutputs[n];\n        }\n\n        return arr;\n    }\n\n    function _detectFault(\n        Types.Challenge memory _challenge,\n        address _sender\n    ) private view returns (uint256) {\n        if (_sender == challenger && _challenge.current == _sender) {\n            return 0;\n        }\n\n        uint256 segLen = colosseum.getSegmentsLength(_challenge.turn);\n        uint256 start = _challenge.segStart;\n        uint256 degree = _challenge.segSize / (segLen - 1);\n        uint256 current = start + degree;\n\n        for (uint256 i = 1; i < segLen; i++) {\n            bytes32 output = _sender == asserter\n                ? _invalidOutputs[current]\n                : _actualOutputs[current];\n\n            if (_challenge.segments[i] != output) {\n                return i - 1;\n            }\n\n            current += degree;\n        }\n\n        revert(\"failed to select\");\n    }\n\n    function _createChallenge() private returns (uint256) {\n        uint256 challengeId = colosseum.latestChallengeId();\n\n        uint256 end = oracle.latestBlockNumber();\n        uint256 start = end - oracle.SUBMISSION_INTERVAL();\n        uint256 outputIndex = oracle.getL2OutputIndexAfter(end);\n        Types.CheckpointOutput memory targetOutput = oracle.getL2Output(outputIndex);\n\n        assertTrue(_actualOutputs[end] != targetOutput.outputRoot, \"not an invalid output\");\n\n        bytes32[] memory segments = _newSegments(challenger, 1, start, end - start);\n\n        vm.prank(challenger);\n        colosseum.createChallenge(outputIndex, segments);\n\n        // check if challengeId is increased\n        assertEq(colosseum.latestChallengeId(), challengeId + 1);\n        challengeId = challengeId + 1;\n\n        Types.Challenge memory challenge = colosseum.getChallengeInProgress();\n\n        assertEq(challenge.outputIndex, outputIndex);\n        assertEq(challenge.current, challenger);\n        assertEq(challenge.next, oracle.VALIDATOR());\n        assertEq(challenge.timeoutAt, block.timestamp + colosseum.CHALLENGE_TIMEOUT());\n        assertEq(challenge.segments.length, colosseum.getSegmentsLength(1));\n        assertEq(challenge.segStart, start);\n        assertEq(challenge.segSize, end - start);\n        assertEq(challenge.turn, 1);\n\n        return challengeId;\n    }\n\n    function _bisect(address _sender) private {\n        Types.Challenge memory challenge = colosseum.getChallengeInProgress();\n\n        uint256 position = _detectFault(challenge, _sender);\n        uint256 segSize = challenge.segSize / (colosseum.getSegmentsLength(challenge.turn) - 1);\n        uint256 segStart = challenge.segStart + position * segSize;\n\n        bytes32[] memory segments = _newSegments(_sender, challenge.turn + 1, segStart, segSize);\n\n        vm.prank(_sender);\n        colosseum.bisect(position, segments);\n\n        Types.Challenge memory newChallenge = colosseum.getChallengeInProgress();\n        assertEq(newChallenge.turn, challenge.turn + 1);\n        assertEq(newChallenge.current, challenge.next);\n        assertEq(newChallenge.next, challenge.current);\n        assertEq(newChallenge.segments.length, segments.length);\n        assertEq(newChallenge.segStart, segStart);\n        assertEq(newChallenge.segSize, segSize);\n    }\n\n    function _proveFault() private {\n        Types.Challenge memory challenge = colosseum.getChallengeInProgress();\n\n        uint256 position = _detectFault(challenge, challenger);\n        uint256 segSize = challenge.segSize / (colosseum.getSegmentsLength(challenge.turn) - 1);\n        uint256 segStart = challenge.segStart + position * segSize;\n\n        vm.prank(challenger);\n        colosseum.proveFault(\n            position,\n            _actualOutputs[segStart + 1],\n            MockProofData.getProof(),\n            MockProofData.getPair()\n        );\n\n        assertEq(uint256(colosseum.getStatusInProgress()), uint256(Colosseum.ChallengeStatus.NONE));\n        assertEq(colosseum.isInProgress(), false);\n        assertEq(oracle.latestBlockNumber(), startBlockNumber);\n    }\n\n    function test_constructor() external {\n        assertEq(address(colosseum.L2_ORACLE()), address(oracle), \"oracle address not matched\");\n        assertEq(address(colosseum.ZK_VERIFIER()), address(zkVerifier), \"zkVerifier address not matched\");\n        assertEq(colosseum.CHALLENGE_TIMEOUT(), timeout);\n    }\n\n    function test_createChallenge() external {\n        _createChallenge();\n    }\n\n    function testCannot_createChallengeWithBadSegments() external {\n        uint256 end = oracle.latestBlockNumber();\n        uint256 start = end - oracle.SUBMISSION_INTERVAL();\n        uint256 outputIndex = oracle.getL2OutputIndexAfter(end);\n        uint256 segLen = colosseum.getSegmentsLength(1);\n\n        vm.startPrank(challenger);\n\n        // invalid segments length\n        vm.expectRevert(\"Colosseum: invalid segments length\");\n        colosseum.createChallenge(outputIndex, new bytes32[](2));\n\n        bytes32[] memory segments = new bytes32[](segLen);\n\n        // invalid output of first segment\n        for (uint256 i = 0; i < segments.length; i++) {\n            segments[i] = keccak256(abi.encodePacked(\"wrong hash\", i));\n        }\n        vm.expectRevert(\"Colosseum: the first segment must be matched\");\n        colosseum.createChallenge(outputIndex, segments);\n\n        // invalid output of last segments\n        segments[0] = _actualOutputs[start];\n        segments[segments.length - 1] = oracle.getL2OutputAfter(end).outputRoot;\n        vm.expectRevert(\"Colosseum: the last segment must not be matched\");\n        colosseum.createChallenge(outputIndex, segments);\n\n        vm.stopPrank();\n    }\n\n    function testCannot_createChallengeWhenPrevInProgress() external {\n        _createChallenge();\n\n        uint256 end = oracle.latestBlockNumber();\n        uint256 start = end - oracle.SUBMISSION_INTERVAL();\n        uint256 outputIndex = oracle.getL2OutputIndexAfter(end);\n\n        bytes32[] memory segments = _newSegments(challenger, 1, start, end - start);\n\n        vm.prank(challenger);\n        vm.expectRevert(\"Colosseum: previous challenge is in progress\");\n        colosseum.createChallenge(outputIndex, segments);\n    }\n\n    function test_bisect() external {\n        _createChallenge();\n\n        Types.Challenge memory challenge = colosseum.getChallengeInProgress();\n\n        assertEq(colosseum.isInProgress(), true);\n        assertEq(challenge.next, asserter);\n\n        _bisect(asserter);\n    }\n\n    function test_bisectIfNotYourTurn() external {\n        _createChallenge();\n        Types.Challenge memory challenge = colosseum.getChallengeInProgress();\n\n        assertEq(colosseum.isInProgress(), true);\n        assertEq(challenge.next, asserter);\n\n        vm.prank(challenger);\n        vm.expectRevert(\"Colosseum: not your turn\");\n        colosseum.bisect(0, new bytes32[](1));\n    }\n\n    function test_asserterBisectAfterTimedOut() external {\n        _createChallenge();\n        Types.Challenge memory challenge = colosseum.getChallengeInProgress();\n\n        assertEq(colosseum.isInProgress(), true);\n        assertEq(challenge.next, asserter);\n\n        uint256 segLen = colosseum.getSegmentsLength(challenge.turn + 1);\n\n        vm.warp(challenge.timeoutAt + 1);\n        vm.prank(asserter);\n        vm.expectRevert(\"Colosseum: not your turn\");\n        colosseum.bisect(0, new bytes32[](segLen));\n\n        assertEq(\n            uint256(colosseum.getStatusInProgress()),\n            uint256(Colosseum.ChallengeStatus.ASSERTER_TIMEOUT)\n        );\n    }\n\n    function test_challengerBisectAfterTimedOut() external {\n        _createChallenge();\n        Types.Challenge memory challenge = colosseum.getChallengeInProgress();\n\n        assertEq(colosseum.isInProgress(), true);\n        assertEq(challenge.next, asserter);\n\n        _bisect(asserter);\n\n        // update challenge\n        challenge = colosseum.getChallengeInProgress();\n\n        uint256 segLen = colosseum.getSegmentsLength(challenge.turn + 1);\n\n        vm.warp(challenge.timeoutAt + 1);\n        vm.prank(challenger);\n        vm.expectRevert(\"Colosseum: not your turn\");\n        colosseum.bisect(0, new bytes32[](segLen));\n\n        assertEq(\n            uint256(colosseum.getStatusInProgress()),\n            uint256(Colosseum.ChallengeStatus.CHALLENGER_TIMEOUT)\n        );\n    }\n\n    function test_proveFault() external {\n        _createChallenge();\n\n        while (colosseum.isAbleToBisect()) {\n            Types.Challenge memory challenge = colosseum.getChallengeInProgress();\n            _bisect(challenge.next);\n        }\n\n        assertEq(\n            uint256(colosseum.getStatusInProgress()),\n            uint256(Colosseum.ChallengeStatus.READY_TO_PROVE)\n        );\n        assertEq(colosseum.isInProgress(), true);\n        assertEq(colosseum.getChallengeInProgress().next, challenger);\n\n        _proveFault();\n    }\n\n    function test_timeoutWhenTimedOutAsserterTurn() external {\n        _createChallenge();\n        Types.Challenge memory challenge = colosseum.getChallengeInProgress();\n\n        assertEq(colosseum.isInProgress(), true);\n        assertEq(challenge.next, asserter);\n\n        vm.warp(challenge.timeoutAt + 1);\n        // check the asserter timeout\n        assertEq(colosseum.isInProgress(), true);\n        assertEq(\n            uint256(colosseum.getStatusInProgress()),\n            uint256(Colosseum.ChallengeStatus.ASSERTER_TIMEOUT)\n        );\n\n        vm.prank(challenger);\n        colosseum.asserterTimeout();\n    }\n\n    function test_timeoutWhenTimedOutChallengerTurn() external {\n        uint256 challengeId = _createChallenge();\n        Types.Challenge memory challenge = colosseum.getChallengeInProgress();\n\n        assertEq(colosseum.isInProgress(), true);\n        assertEq(challenge.next, asserter);\n\n        _bisect(asserter);\n\n        challenge = colosseum.getChallengeInProgress();\n        vm.warp(challenge.timeoutAt + 1);\n        // check the challenger timeout\n        assertEq(colosseum.isInProgress(), false);\n        assertEq(challenge.next, challenger);\n        assertEq(\n            uint256(colosseum.getStatusInProgress()),\n            uint256(Colosseum.ChallengeStatus.CHALLENGER_TIMEOUT)\n        );\n\n        vm.prank(asserter);\n        colosseum.challengerTimeout(challengeId);\n    }\n\n    function test_challengerNotCloseWhenAsserterTimeout() external {\n        _createChallenge();\n        Types.Challenge memory challenge = colosseum.getChallengeInProgress();\n\n        assertEq(colosseum.isInProgress(), true);\n        assertEq(challenge.next, asserter);\n\n        vm.warp(challenge.timeoutAt + 1);\n        // check the asserter timeout\n        assertEq(colosseum.isInProgress(), true);\n        assertEq(\n            uint256(colosseum.getStatusInProgress()),\n            uint256(Colosseum.ChallengeStatus.ASSERTER_TIMEOUT)\n        );\n        // then challenger do not anything\n\n        vm.warp(challenge.timeoutAt + colosseum.CHALLENGE_TIMEOUT() + 1);\n        // check the challenger timeout\n        assertEq(colosseum.isInProgress(), false);\n        assertEq(\n            uint256(colosseum.getStatusInProgress()),\n            uint256(Colosseum.ChallengeStatus.CHALLENGER_TIMEOUT)\n        );\n    }\n}\n"
    },
    "contracts/test/CommonTest.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/* Testing utilities */\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { Test, StdUtils } from \"forge-std/Test.sol\";\n\nimport { CodeDeployer } from \"../libraries/CodeDeployer.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Colosseum } from \"../L1/Colosseum.sol\";\nimport { KromaPortal } from \"../L1/KromaPortal.sol\";\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\nimport { L1ERC721Bridge } from \"../L1/L1ERC721Bridge.sol\";\nimport { L1StandardBridge } from \"../L1/L1StandardBridge.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { ZKMerkleTrie } from \"../L1/ZKMerkleTrie.sol\";\nimport { ZKVerifier } from \"../L1/ZKVerifier.sol\";\nimport { L2CrossDomainMessenger } from \"../L2/L2CrossDomainMessenger.sol\";\nimport { L2ERC721Bridge } from \"../L2/L2ERC721Bridge.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { L2StandardBridge } from \"../L2/L2StandardBridge.sol\";\nimport { KromaMintableERC20 } from \"../universal/KromaMintableERC20.sol\";\nimport { KromaMintableERC20Factory } from \"../universal/KromaMintableERC20Factory.sol\";\nimport { KromaMintableERC721Factory } from \"../universal/KromaMintableERC721Factory.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\n\ncontract CommonTest is Test {\n    address alice = address(128);\n    address bob = address(256);\n    address multisig = address(512);\n\n    address immutable ZERO_ADDRESS = address(0);\n    address immutable NON_ZERO_ADDRESS = address(1);\n    uint256 immutable NON_ZERO_VALUE = 100;\n    uint256 immutable ZERO_VALUE = 0;\n    uint64 immutable NON_ZERO_GASLIMIT = 50000;\n    bytes32 nonZeroHash = keccak256(abi.encode(\"NON_ZERO\"));\n    bytes NON_ZERO_DATA = hex\"0000111122223333444455556666777788889999aaaabbbbccccddddeeeeffff0000\";\n\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 indexed version,\n        bytes opaqueData\n    );\n\n    FFIInterface ffi;\n\n    function setUp() public virtual {\n        // Give alice and bob some ETH\n        vm.deal(alice, 1 << 16);\n        vm.deal(bob, 1 << 16);\n        vm.deal(multisig, 1 << 16);\n\n        vm.label(alice, \"alice\");\n        vm.label(bob, \"bob\");\n        vm.label(multisig, \"multisig\");\n\n        // Make sure we have a non-zero base fee\n        vm.fee(1000000000);\n\n        ffi = new FFIInterface();\n    }\n\n    function emitTransactionDeposited(\n        address _from,\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    ) internal {\n        emit TransactionDeposited(\n            _from,\n            _to,\n            0,\n            abi.encodePacked(_mint, _value, _gasLimit, _isCreation, _data)\n        );\n    }\n}\n\ncontract L2OutputOracle_Initializer is CommonTest {\n    // Test target\n    L2OutputOracle oracle;\n    L2OutputOracle oracleImpl;\n\n    L2ToL1MessagePasser messagePasser =\n        L2ToL1MessagePasser(payable(Predeploys.L2_TO_L1_MESSAGE_PASSER));\n\n    // Constructor arguments\n    address internal asserter = 0x000000000000000000000000000000000000AbBa;\n    address internal challenger = 0x000000000000000000000000000000000000ACDC;\n    uint256 internal submissionInterval = 1800;\n    uint256 internal l2BlockTime = 2;\n    uint256 internal startingBlockNumber = 200;\n    uint256 internal startingTimestamp = 1000;\n    address guardian;\n\n    // Test data\n    uint256 initL1Time;\n\n    event OutputSubmitted(\n        bytes32 indexed outputRoot,\n        uint256 indexed l2OutputIndex,\n        uint256 indexed l2BlockNumber,\n        uint256 l1Timestamp\n    );\n\n    event OutputsDeleted(uint256 indexed prevNextOutputIndex, uint256 indexed newNextOutputIndex);\n\n    // Advance the evm's time to meet the L2OutputOracle's requirements for submitL2Output\n    function warpToSubmitTime(uint256 _nextBlockNumber) public {\n        vm.warp(oracle.computeL2Timestamp(_nextBlockNumber) + 1);\n    }\n\n    function setUp() public virtual override {\n        super.setUp();\n        guardian = makeAddr(\"guardian\");\n\n        // By default the first block has timestamp and number zero, which will cause underflows in the\n        // tests, so we'll move forward to these block values.\n        initL1Time = startingTimestamp + 1;\n        vm.warp(initL1Time);\n        vm.roll(startingBlockNumber);\n        // Deploy the L2OutputOracle and transfer ownership to the asserter\n        oracleImpl = new L2OutputOracle({\n            _submissionInterval: submissionInterval,\n            _l2BlockTime: l2BlockTime,\n            _startingBlockNumber: startingBlockNumber,\n            _startingTimestamp: startingTimestamp,\n            _validator: asserter,\n            _challenger: challenger,\n            _finalizationPeriodSeconds: 7 days\n        });\n        Proxy proxy = new Proxy(multisig);\n        vm.prank(multisig);\n        proxy.upgradeToAndCall(\n            address(oracleImpl),\n            abi.encodeCall(L2OutputOracle.initialize, (startingBlockNumber, startingTimestamp))\n        );\n        oracle = L2OutputOracle(address(proxy));\n        vm.label(address(oracle), \"L2OutputOracle\");\n\n        // Set the L2ToL1MessagePasser at the correct address\n        vm.etch(Predeploys.L2_TO_L1_MESSAGE_PASSER, address(new L2ToL1MessagePasser()).code);\n\n        vm.label(Predeploys.L2_TO_L1_MESSAGE_PASSER, \"L2ToL1MessagePasser\");\n    }\n}\n\ncontract Poseidon2Deployer {\n    bytes constant poseidon2Code =\n        hex\"38600c60003961260f6000f37c010000000000000000000000000000000000000000000000000000000060003504806329a5f2f6149063299e566014176200003757fe5b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b6020527f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e06040527f2b90bba00fca0589f617e7dcbfe82e0df706ab640ceb247b791a93b74e36736d6060527f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd7716080527f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2360a0527f101071f0032379b697315876690f053d148d4e109f5fb065c8aacc55a0f89bfa60c0527f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a760e0527f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee2911610100527f19a3fc0a56702bf417ba7fee3802593fa644470307043f7773279cd71d25d5e0610120527f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000016024356004356000837f0ee9a592ba9a9518d05986d656f40c2114c4993c11bb29938d21d47304cd8e6e82089050837f00f1445235f2148c5986587169fc1bcd887b08d4d00868df5696fff40956e86483089150837f08dff3487e8ac99e1f29a058d0fa80b930c728730b7ab36ce879f3890ecf73f58408925083818180828009800909905083828180828009800909915083838180828009800909925062000249600052620025ba565b837f2f27be690fdaee46c3ce28f7532b13c856c35342c84bda6e20966310fadc01d082089050837f2b2ae1acf68b7b8d2416bebf3d4f6234b763fe04b8043ee48b8327bebca16cf283089150837f0319d062072bef7ecca5eac06f97d4d55952c175ab6b03eae64b44c7dbf11cfa84089250838181808280098009099050838281808280098009099150838381808280098009099250620002ec600052620025ba565b837f28813dcaebaeaa828a376df87af4a63bc8b7bf27ad49c6298ef7b387bf28526d82089050837f2727673b2ccbc903f181bf38e1c1d40d2033865200c352bc150928adddf9cb7883089150837f234ec45ca27727c2e74abd2b2a1494cd6efbd43e340587d6b8fb9e31e65cc632840892508381818082800980090990508382818082800980090991508383818082800980090992506200038f600052620025ba565b837f15b52534031ae18f7f862cb2cf7cf760ab10a8150a337b1ccd99ff6e8797d42882089050837f0dc8fad6d9e4b35f5ed9a3d186b79ce38e0e8a8d1b58b132d701d4eecf68d1f683089150837f1bcd95ffc211fbca600f705fad3fb567ea4eb378f62e1fec97805518a47e4d9c8408925083818180828009800909905083828180828009800909915083838180828009800909925062000432600052620025ba565b837f10520b0ab721cadfe9eff81b016fc34dc76da36c2578937817cb978d069de55982089050837f1f6d48149b8e7f7d9b257d8ed5fbbaf42932498075fed0ace88a9eb81f5627f683089150837f1d9655f652309014d29e00ef35a2089bfff8dc1c816f0dc9ca34bdb5460c870584089250838181808280098009099050620004bd600052620025ba565b837f04df5a56ff95bcafb051f7b1cd43a99ba731ff67e47032058fe3d4185697cc7d82089050837f0672d995f8fff640151b3d290cedaf148690a10a8c8424a7f6ec282b6e4be82883089150837f099952b414884454b21200d7ffafdd5f0c9a9dcc06f2708e9fc1d8209b5c75b98408925083818180828009800909905062000548600052620025ba565b837f052cba2255dfd00c7c483143ba8d469448e43586a9b4cd9183fd0e843a6b9fa682089050837f0b8badee690adb8eb0bd74712b7999af82de55707251ad7716077cb93c464ddc83089150837f119b1590f13307af5a1ee651020c07c749c15d60683a8050b963d0a8e4b2bdd184089250838181808280098009099050620005d3600052620025ba565b837f03150b7cd6d5d17b2529d36be0f67b832c4acfc884ef4ee5ce15be0bfb4a8d0982089050837f2cc6182c5e14546e3cf1951f173912355374efb83d80898abe69cb317c9ea56583089150837f005032551e6378c450cfe129a404b3764218cadedac14e2b92d2cd73111bf0f9840892508381818082800980090990506200065e600052620025ba565b837f233237e3289baa34bb147e972ebcb9516469c399fcc069fb88f9da2cc28276b582089050837f05c8f4f4ebd4a6e3c980d31674bfbe6323037f21b34ae5a4e80c2d4c24d6028083089150837f0a7b1db13042d396ba05d818a319f25252bcf35ef3aeed91ee1f09b2590fc65b84089250838181808280098009099050620006e9600052620025ba565b837f2a73b71f9b210cf5b14296572c9d32dbf156e2b086ff47dc5df542365a404ec082089050837f1ac9b0417abcc9a1935107e9ffc91dc3ec18f2c4dbe7f22976a760bb5c50c46083089150837f12c0339ae08374823fabb076707ef479269f3e4d6cb104349015ee046dc93fc08408925083818180828009800909905062000774600052620025ba565b837f0b7475b102a165ad7f5b18db4e1e704f52900aa3253baac68246682e56e9a28e82089050837f037c2849e191ca3edb1c5e49f6e8b8917c843e379366f2ea32ab3aa88d7f844883089150837f05a6811f8556f014e92674661e217e9bd5206c5c93a07dc145fdb176a716346f84089250838181808280098009099050620007ff600052620025ba565b837f29a795e7d98028946e947b75d54e9f044076e87a7b2883b47b675ef5f38bd66e82089050837f20439a0c84b322eb45a3857afc18f5826e8c7382c8a1585c507be199981fd22f83089150837f2e0ba8d94d9ecf4a94ec2050c7371ff1bb50f27799a84b6d4a2a6f2a0982c887840892508381818082800980090990506200088a600052620025ba565b837f143fd115ce08fb27ca38eb7cce822b4517822cd2109048d2e6d0ddcca17d71c882089050837f0c64cbecb1c734b857968dbbdcf813cdf8611659323dbcbfc84323623be9caf183089150837f028a305847c683f646fca925c163ff5ae74f348d62c2b670f1426cef9403da538408925083818180828009800909905062000915600052620025ba565b837f2e4ef510ff0b6fda5fa940ab4c4380f26a6bcb64d89427b824d6755b5db9e30c82089050837f0081c95bc43384e663d79270c956ce3b8925b4f6d033b078b96384f50579400e83089150837f2ed5f0c91cbd9749187e2fade687e05ee2491b349c039a0bba8a9f4023a0bb3884089250838181808280098009099050620009a0600052620025ba565b837f30509991f88da3504bbf374ed5aae2f03448a22c76234c8c990f01f33a73520682089050837f1c3f20fd55409a53221b7c4d49a356b9f0a1119fb2067b41a7529094424ec6ad83089150837f10b4e7f3ab5df003049514459b6e18eec46bb2213e8e131e170887b47ddcb96c8408925083818180828009800909905062000a2b600052620025ba565b837f2a1982979c3ff7f43ddd543d891c2abddd80f804c077d775039aa3502e43adef82089050837f1c74ee64f15e1db6feddbead56d6d55dba431ebc396c9af95cad0f1315bd5c9183089150837f07533ec850ba7f98eab9303cace01b4b9e4f2e8b82708cfa9c2fe45a0ae146a08408925083818180828009800909905062000ab6600052620025ba565b837f21576b438e500449a151e4eeaf17b154285c68f42d42c1808a11abf3764c075082089050837f2f17c0559b8fe79608ad5ca193d62f10bce8384c815f0906743d6930836d4a9e83089150837f2d477e3862d07708a79e8aae946170bc9775a4201318474ae665b0b1b7e2730e8408925083818180828009800909905062000b41600052620025ba565b837f162f5243967064c390e095577984f291afba2266c38f5abcd89be0f5b2747eab82089050837f2b4cb233ede9ba48264ecd2c8ae50d1ad7a8596a87f29f8a7777a7009239331183089150837f2c8fbcb2dd8573dc1dbaf8f4622854776db2eece6d85c4cf4254e7c35e03b07a8408925083818180828009800909905062000bcc600052620025ba565b837f1d6f347725e4816af2ff453f0cd56b199e1b61e9f601e9ade5e88db870949da982089050837f204b0c397f4ebe71ebc2d8b3df5b913df9e6ac02b68d31324cd49af5c456552983089150837f0c4cb9dc3c4fd8174f1149b3c63c3c2f9ecb827cd7dc25534ff8fb75bc79c5028408925083818180828009800909905062000c57600052620025ba565b837f174ad61a1448c899a25416474f4930301e5c49475279e0639a616ddc45bc7b5482089050837f1a96177bcf4d8d89f759df4ec2f3cde2eaaa28c177cc0fa13a9816d49a38d2ef83089150837f066d04b24331d71cd0ef8054bc60c4ff05202c126a233c1a8242ace360b8a30a8408925083818180828009800909905062000ce2600052620025ba565b837f2a4c4fc6ec0b0cf52195782871c6dd3b381cc65f72e02ad527037a62aa1bd80482089050837f13ab2d136ccf37d447e9f2e14a7cedc95e727f8446f6d9d7e55afc01219fd64983089150837f1121552fca26061619d24d843dc82769c1b04fcec26f55194c2e3e869acc6a9a8408925083818180828009800909905062000d6d600052620025ba565b837f00ef653322b13d6c889bc81715c37d77a6cd267d595c4a8909a5546c7c97cff182089050837f0e25483e45a665208b261d8ba74051e6400c776d652595d9845aca35d8a397d383089150837f29f536dcb9dd7682245264659e15d88e395ac3d4dde92d8c46448db979eeba898408925083818180828009800909905062000df8600052620025ba565b837f2a56ef9f2c53febadfda33575dbdbd885a124e2780bbea170e456baace0fa5be82089050837f1c8361c78eb5cf5decfb7a2d17b5c409f2ae2999a46762e8ee416240a8cb9af183089150837f151aff5f38b20a0fc0473089aaf0206b83e8e68a764507bfd3d0ab4be74319c58408925083818180828009800909905062000e83600052620025ba565b837f04c6187e41ed881dc1b239c88f7f9d43a9f52fc8c8b6cdd1e76e47615b51f10082089050837f13b37bd80f4d27fb10d84331f6fb6d534b81c61ed15776449e801b7ddc9c296783089150837f01a5c536273c2d9df578bfbd32c17b7a2ce3664c2a52032c9321ceb1c4e8a8e48408925083818180828009800909905062000f0e600052620025ba565b837f2ab3561834ca73835ad05f5d7acb950b4a9a2c666b9726da832239065b7c3b0282089050837f1d4d8ec291e720db200fe6d686c0d613acaf6af4e95d3bf69f7ed516a597b64683089150837f041294d2cc484d228f5784fe7919fd2bb925351240a04b711514c9c80b65af1d8408925083818180828009800909905062000f99600052620025ba565b837f154ac98e01708c611c4fa715991f004898f57939d126e392042971dd90e81fc682089050837f0b339d8acca7d4f83eedd84093aef51050b3684c88f8b0b04524563bc6ea4da483089150837f0955e49e6610c94254a4f84cfbab344598f0e71eaff4a7dd81ed95b50839c82e8408925083818180828009800909905062001024600052620025ba565b837f06746a6156eba54426b9e22206f15abca9a6f41e6f535c6f3525401ea065462682089050837f0f18f5a0ecd1423c496f3820c549c27838e5790e2bd0a196ac917c7ff32077fb83089150837f04f6eeca1751f7308ac59eff5beb261e4bb563583ede7bc92a738223d6f76e1384089250838181808280098009099050620010af600052620025ba565b837f2b56973364c4c4f5c1a3ec4da3cdce038811eb116fb3e45bc1768d26fc0b375882089050837f123769dd49d5b054dcd76b89804b1bcb8e1392b385716a5d83feb65d437f29ef83089150837f2147b424fc48c80a88ee52b91169aacea989f6446471150994257b2fb01c63e9840892508381818082800980090990506200113a600052620025ba565b837f0fdc1f58548b85701a6c5505ea332a29647e6f34ad4243c2ea54ad897cebe54d82089050837f12373a8251fea004df68abcf0f7786d4bceff28c5dbbe0c3944f685cc0a0b1f283089150837f21e4f4ea5f35f85bad7ea52ff742c9e8a642756b6af44203dd8a1f35c1a9003584089250838181808280098009099050620011c5600052620025ba565b837f16243916d69d2ca3dfb4722224d4c462b57366492f45e90d8a81934f1bc3b14782089050837f1efbe46dd7a578b4f66f9adbc88b4378abc21566e1a0453ca13a4159cac04ac283089150837f07ea5e8537cf5dd08886020e23a7f387d468d5525be66f853b672cc96a88969a8408925083818180828009800909905062001250600052620025ba565b837f05a8c4f9968b8aa3b7b478a30f9a5b63650f19a75e7ce11ca9fe16c0b76c00bc82089050837f20f057712cc21654fbfe59bd345e8dac3f7818c701b9c7882d9d57b72a32e83f83089150837f04a12ededa9dfd689672f8c67fee31636dcd8e88d01d49019bd90b33eb33db6984089250838181808280098009099050620012db600052620025ba565b837f27e88d8c15f37dcee44f1e5425a51decbd136ce5091a6767e49ec9544ccd101a82089050837f2feed17b84285ed9b8a5c8c5e95a41f66e096619a7703223176c41ee433de4d183089150837f1ed7cc76edf45c7c404241420f729cf394e5942911312a0d6972b8bd53aff2b88408925083818180828009800909905062001366600052620025ba565b837f15742e99b9bfa323157ff8c586f5660eac6783476144cdcadf2874be45466b1a82089050837f1aac285387f65e82c895fc6887ddf40577107454c6ec0317284f033f27d0c78583089150837f25851c3c845d4790f9ddadbdb6057357832e2e7a49775f71ec75a96554d67c7784089250838181808280098009099050620013f1600052620025ba565b837f15a5821565cc2ec2ce78457db197edf353b7ebba2c5523370ddccc3d9f146a6782089050837f2411d57a4813b9980efa7e31a1db5966dcf64f36044277502f15485f28c7172783089150837f002e6f8d6520cd4713e335b8c0b6d2e647e9a98e12f4cd2558828b5ef6cb4c9b840892508381818082800980090990506200147c600052620025ba565b837f2ff7bc8f4380cde997da00b616b0fcd1af8f0e91e2fe1ed7398834609e0315d282089050837f00b9831b948525595ee02724471bcd182e9521f6b7bb68f1e93be4febb0d3cbe83089150837f0a2f53768b8ebf6a86913b0e57c04e011ca408648a4743a87d77adbf0c9c35128408925083818180828009800909905062001507600052620025ba565b837f00248156142fd0373a479f91ff239e960f599ff7e94be69b7f2a290305e1198d82089050837f171d5620b87bfb1328cf8c02ab3f0c9a397196aa6a542c2350eb512a2b2bcda983089150837f170a4f55536f7dc970087c7c10d6fad760c952172dd54dd99d1045e4ec34a8088408925083818180828009800909905062001592600052620025ba565b837f29aba33f799fe66c2ef3134aea04336ecc37e38c1cd211ba482eca17e2dbfae182089050837f1e9bc179a4fdd758fdd1bb1945088d47e70d114a03f6a0e8b5ba650369e6497383089150837f1dd269799b660fad58f7f4892dfb0b5afeaad869a9c4b44f9c9e1c43bdaf8f09840892508381818082800980090990506200161d600052620025ba565b837f22cdbc8b70117ad1401181d02e15459e7ccd426fe869c7c95d1dd2cb0f24af3882089050837f0ef042e454771c533a9f57a55c503fcefd3150f52ed94a7cd5ba93b9c7dacefd83089150837f11609e06ad6c8fe2f287f3036037e8851318e8b08a0359a03b304ffca62e828484089250838181808280098009099050620016a8600052620025ba565b837f1166d9e554616dba9e753eea427c17b7fecd58c076dfe42708b08f5b783aa9af82089050837f2de52989431a859593413026354413db177fbf4cd2ac0b56f855a888357ee46683089150837f3006eb4ffc7a85819a6da492f3a8ac1df51aee5b17b8e89d74bf01cf5f71e9ad8408925083818180828009800909905062001733600052620025ba565b837f2af41fbb61ba8a80fdcf6fff9e3f6f422993fe8f0a4639f962344c822514508682089050837f119e684de476155fe5a6b41a8ebc85db8718ab27889e85e781b214bace4827c383089150837f1835b786e2e8925e188bea59ae363537b51248c23828f047cff784b97b3fd80084089250838181808280098009099050620017be600052620025ba565b837f28201a34c594dfa34d794996c6433a20d152bac2a7905c926c40e285ab32eeb682089050837f083efd7a27d1751094e80fefaf78b000864c82eb571187724a761f88c22cc4e783089150837f0b6f88a3577199526158e61ceea27be811c16df7774dd8519e079564f61fd13b8408925083818180828009800909905062001849600052620025ba565b837f0ec868e6d15e51d9644f66e1d6471a94589511ca00d29e1014390e6ee4254f5b82089050837f2af33e3f866771271ac0c9b3ed2e1142ecd3e74b939cd40d00d937ab84c9859183089150837f0b520211f904b5e7d09b5d961c6ace7734568c547dd6858b364ce5e47951f17884089250838181808280098009099050620018d4600052620025ba565b837f0b2d722d0919a1aad8db58f10062a92ea0c56ac4270e822cca228620188a1d4082089050837f1f790d4d7f8cf094d980ceb37c2453e957b54a9991ca38bbe0061d1ed6e562d483089150837f0171eb95dfbf7d1eaea97cd385f780150885c16235a2a6a8da92ceb01e504233840892508381818082800980090990506200195f600052620025ba565b837f0c2d0e3b5fd57549329bf6885da66b9b790b40defd2c8650762305381b16887382089050837f1162fb28689c27154e5a8228b4e72b377cbcafa589e283c35d3803054407a18d83089150837f2f1459b65dee441b64ad386a91e8310f282c5a92a89e19921623ef8249711bc084089250838181808280098009099050620019ea600052620025ba565b837f1e6ff3216b688c3d996d74367d5cd4c1bc489d46754eb712c243f70d1b53cfbb82089050837f01ca8be73832b8d0681487d27d157802d741a6f36cdc2a0576881f932647887583089150837f1f7735706ffe9fc586f976d5bdf223dc680286080b10cea00b9b5de315f9650e8408925083818180828009800909905062001a75600052620025ba565b837f2522b60f4ea3307640a0c2dce041fba921ac10a3d5f096ef4745ca838285f01982089050837f23f0bee001b1029d5255075ddc957f833418cad4f52b6c3f8ce16c235572575b83089150837f2bc1ae8b8ddbb81fcaac2d44555ed5685d142633e9df905f66d9401093082d598408925083818180828009800909905062001b00600052620025ba565b837f0f9406b8296564a37304507b8dba3ed162371273a07b1fc98011fcd6ad72205f82089050837f2360a8eb0cc7defa67b72998de90714e17e75b174a52ee4acb126c8cd995f0a883089150837f15871a5cddead976804c803cbaef255eb4815a5e96df8b006dcbbc2767f889488408925083818180828009800909905062001b8b600052620025ba565b837f193a56766998ee9e0a8652dd2f3b1da0362f4f54f72379544f957ccdeefb420f82089050837f2a394a43934f86982f9be56ff4fab1703b2e63c8ad334834e4309805e777ae0f83089150837f1859954cfeb8695f3e8b635dcb345192892cd11223443ba7b4166e8876c0d1428408925083818180828009800909905062001c16600052620025ba565b837f04e1181763050e58013444dbcb99f1902b11bc25d90bbdca408d3819f4fed32b82089050837f0fdb253dee83869d40c335ea64de8c5bb10eb82db08b5e8b1f5e5552bfd05f2383089150837f058cbe8a9a5027bdaa4efb623adead6275f08686f1c08984a9d7c5bae9b4f1c08408925083818180828009800909905062001ca1600052620025ba565b837f1382edce9971e186497eadb1aeb1f52b23b4b83bef023ab0d15228b4cceca59a82089050837f03464990f045c6ee0819ca51fd11b0be7f61b8eb99f14b77e1e6634601d9e8b583089150837f23f7bfc8720dc296fff33b41f98ff83c6fcab4605db2eb5aaa5bc137aeb70a588408925083818180828009800909905062001d2c600052620025ba565b837f0a59a158e3eec2117e6e94e7f0e9decf18c3ffd5e1531a9219636158bbaf62f282089050837f06ec54c80381c052b58bf23b312ffd3ce2c4eba065420af8f4c23ed0075fd07b83089150837f118872dc832e0eb5476b56648e867ec8b09340f7a7bcb1b4962f0ff9ed1f9d018408925083818180828009800909905062001db7600052620025ba565b837f13d69fa127d834165ad5c7cba7ad59ed52e0b0f0e42d7fea95e1906b520921b182089050837f169a177f63ea681270b1c6877a73d21bde143942fb71dc55fd8a49f19f10c77b83089150837f04ef51591c6ead97ef42f287adce40d93abeb032b922f66ffb7e9a5a7450544d8408925083818180828009800909905062001e42600052620025ba565b837f256e175a1dc079390ecd7ca703fb2e3b19ec61805d4f03ced5f45ee6dd0f69ec82089050837f30102d28636abd5fe5f2af412ff6004f75cc360d3205dd2da002813d3e2ceeb283089150837f10998e42dfcd3bbf1c0714bc73eb1bf40443a3fa99bef4a31fd31be182fcc7928408925083818180828009800909905062001ecd600052620025ba565b837f193edd8e9fcf3d7625fa7d24b598a1d89f3362eaf4d582efecad76f879e3686082089050837f18168afd34f2d915d0368ce80b7b3347d1c7a561ce611425f2664d7aa51f0b5d83089150837f29383c01ebd3b6ab0c017656ebe658b6a328ec77bc33626e29e2e95b33ea61118408925083818180828009800909905062001f58600052620025ba565b837f10646d2f2603de39a1f4ae5e7771a64a702db6e86fb76ab600bf573f9010c71182089050837f0beb5e07d1b27145f575f1395a55bf132f90c25b40da7b3864d0242dcb1117fb83089150837f16d685252078c133dc0d3ecad62b5c8830f95bb2e54b59abdffbf018d96fa3368408925083818180828009800909905062001fe3600052620025ba565b837f0a6abd1d833938f33c74154e0404b4b40a555bbbec21ddfafd672dd62047f01a82089050837f1a679f5d36eb7b5c8ea12a4c2dedc8feb12dffeec450317270a6f19b34cf186083089150837f0980fb233bd456c23974d50e0ebfde4726a423eada4e8f6ffbc7592e3f1b93d6840892508381818082800980090990506200206e600052620025ba565b837f161b42232e61b84cbf1810af93a38fc0cece3d5628c9282003ebacb5c312c72b82089050837f0ada10a90c7f0520950f7d47a60d5e6a493f09787f1564e5d09203db47de1a0b83089150837f1a730d372310ba82320345a29ac4238ed3f07a8a2b4e121bb50ddb9af407f45184089250838181808280098009099050620020f9600052620025ba565b837f2c8120f268ef054f817064c369dda7ea908377feaba5c4dffbda10ef58e8c55682089050837f1c7c8824f758753fa57c00789c684217b930e95313bcb73e6e7b8649a4968f7083089150837f2cd9ed31f5f8691c8e39e4077a74faa0f400ad8b491eb3f7b47b27fa3fd1cf778408925083818180828009800909905062002184600052620025ba565b837f23ff4f9d46813457cf60d92f57618399a5e022ac321ca550854ae23918a22eea82089050837f09945a5d147a4f66ceece6405dddd9d0af5a2c5103529407dff1ea58f180426d83089150837f188d9c528025d4c2b67660c6b771b90f7c7da6eaa29d3f268a6dd223ec6fc630840892508381818082800980090990506200220f600052620025ba565b837f3050e37996596b7f81f68311431d8734dba7d926d3633595e0c0d8ddf4f0f47f82089050837f15af1169396830a91600ca8102c35c426ceae5461e3f95d89d829518d30afd7883089150837f1da6d09885432ea9a06d9f37f873d985dae933e351466b2904284da3320d8acc840892508381818082800980090990506200229a600052620025ba565b837f2796ea90d269af29f5f8acf33921124e4e4fad3dbe658945e546ee411ddaa9cb82089050837f202d7dd1da0f6b4b0325c8b3307742f01e15612ec8e9304a7cb0319e01d32d6083089150837f096d6790d05bb759156a952ba263d672a2d7f9c788f4c831a29dace4c0f8be5f8408925083818180828009800909905062002325600052620025ba565b837f054efa1f65b0fce283808965275d877b438da23ce5b13e1963798cb1447d25a482089050837f1b162f83d917e93edb3308c29802deb9d8aa690113b2e14864ccf6e18e4165f183089150837f21e5241e12564dd6fd9f1cdd2a0de39eedfefc1466cc568ec5ceb745a0506edc84089250838181808280098009099050838281808280098009099150838381808280098009099250620023c8600052620025ba565b837f1cfb5662e8cf5ac9226a80ee17b36abecb73ab5f87e161927b4349e10e4bdf0882089050837f0f21177e302a771bbae6d8d1ecb373b62c99af346220ac0129c53f666eb2410083089150837f1671522374606992affb0dd7f71b12bec4236aede6290546bcef7e1f515c2320840892508381818082800980090990508382818082800980090991508383818082800980090992506200246b600052620025ba565b837f0fa3ec5b9488259c2eb4cf24501bfad9be2ec9e42c5cc8ccd419d2a692cad87082089050837f193c0e04e0bd298357cb266c1506080ed36edce85c648cc085e8c57b1ab54bba83089150837f102adf8ef74735a27e9128306dcbc3c99f6f7291cd406578ce14ea2adaba68f8840892508381818082800980090990508382818082800980090991508383818082800980090992506200250e600052620025ba565b837f0fe0af7858e49859e2a54d6f1ad945b1316aa24bfbdd23ae40a6d0cb70c3eab182089050837f216f6717bbc7dedb08536a2220843f4e2da5f1daa9ebdefde8a5ea7344798d2283089150837f1da55cc900f0d21f4a3e694391918a1b3c23b2ac773c6b3ef88e2e422832516184089250838181808280098009099050838281808280098009099150838381808280098009099250620025b1600052620025ba565b60005260206000f35b8360205182098460405184098591088460605185098591088460805183098560a05185098691088560c05186098691088560e0518409866101005186098791088661012051870987910894509250905060005156\";\n\n    function deployPoseidon2() public returns (address) {\n        return CodeDeployer.deployCode(poseidon2Code);\n    }\n}\n\ncontract Portal_Initializer is L2OutputOracle_Initializer, Poseidon2Deployer {\n    ZKMerkleTrie zkMerkleTrie;\n\n    // Test target\n    KromaPortal portalImpl;\n    KromaPortal portal;\n\n    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);\n    event WithdrawalProven(\n        bytes32 indexed withdrawalHash,\n        address indexed from,\n        address indexed to\n    );\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        zkMerkleTrie = new ZKMerkleTrie(deployPoseidon2());\n\n        portalImpl = new KromaPortal({ _l2Oracle: oracle, _guardian: guardian, _paused: true, _zkMerkleTrie: zkMerkleTrie });\n        Proxy proxy = new Proxy(multisig);\n        vm.prank(multisig);\n        proxy.upgradeToAndCall(\n            address(portalImpl),\n            abi.encodeWithSelector(KromaPortal.initialize.selector, false)\n        );\n        portal = KromaPortal(payable(address(proxy)));\n        vm.label(address(portal), \"KromaPortal\");\n    }\n}\n\ncontract Messenger_Initializer is Portal_Initializer {\n    L1CrossDomainMessenger L1Messenger;\n    L2CrossDomainMessenger L2Messenger =\n        L2CrossDomainMessenger(Predeploys.L2_CROSS_DOMAIN_MESSENGER);\n\n    event SentMessage(\n        address indexed target,\n        address indexed sender,\n        uint256 value,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n\n    event MessagePassed(\n        uint256 indexed nonce,\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes data,\n        bytes32 withdrawalHash\n    );\n\n    event RelayedMessage(bytes32 indexed msgHash);\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 mint,\n        uint256 value,\n        uint64 gasLimit,\n        bool isCreation,\n        bytes data\n    );\n\n    event WhatHappened(bool success, bytes returndata);\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        // Setup implementation\n        L1CrossDomainMessenger L1MessengerImpl = new L1CrossDomainMessenger(portal);\n\n        // Setup proxy\n        Proxy proxy = new Proxy(multisig);\n        vm.prank(multisig);\n        proxy.upgradeToAndCall(\n            address(L1MessengerImpl),\n            abi.encodeCall(L1Messenger.initialize, ())\n        );\n        L1Messenger = L1CrossDomainMessenger(address(proxy));\n\n        vm.etch(\n            Predeploys.L2_CROSS_DOMAIN_MESSENGER,\n            address(new L2CrossDomainMessenger(address(L1Messenger))).code\n        );\n\n        L2Messenger.initialize();\n\n        // Label addresses\n        vm.label(address(L1MessengerImpl), \"L1CrossDomainMessenger_Impl\");\n        vm.label(address(L1Messenger), \"L1CrossDomainMessenger_Proxy\");\n        vm.label(Predeploys.L2_CROSS_DOMAIN_MESSENGER, \"L2CrossDomainMessenger\");\n\n        vm.label(\n            AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)),\n            \"L1CrossDomainMessenger_aliased\"\n        );\n    }\n}\n\ncontract Bridge_Initializer is Messenger_Initializer {\n    L1StandardBridge L1Bridge;\n    L2StandardBridge L2Bridge;\n    KromaMintableERC20Factory L2TokenFactory;\n    KromaMintableERC20Factory L1TokenFactory;\n    ERC20 L1Token;\n    ERC20 BadL1Token;\n    KromaMintableERC20 L2Token;\n    ERC20 NativeL2Token;\n    ERC20 BadL2Token;\n    KromaMintableERC20 RemoteL1Token;\n\n    event DepositFailed(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    event ETHBridgeInitiated(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    event ETHBridgeFinalized(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    event ERC20BridgeInitiated(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    event ERC20BridgeFinalized(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        vm.label(Predeploys.L2_STANDARD_BRIDGE, \"L2StandardBridge\");\n        vm.label(Predeploys.KROMA_MINTABLE_ERC20_FACTORY, \"KromaMintableERC20Factory\");\n\n        // Deploy the L1 bridge and initialize it with the address of the\n        // L1CrossDomainMessenger\n        L1StandardBridge L1Bridge_Impl = new L1StandardBridge(payable(address(L1Messenger)));\n        Proxy proxy = new Proxy(multisig);\n        vm.prank(multisig);\n        proxy.upgradeTo(address(L1Bridge_Impl));\n\n        L1Bridge = L1StandardBridge(payable(address(proxy)));\n\n        vm.label(address(proxy), \"L1StandardBridge_Proxy\");\n        vm.label(address(L1Bridge_Impl), \"L1StandardBridge_Impl\");\n\n        // Deploy the L2StandardBridge, move it to the correct predeploy\n        // address and then initialize it\n        L2StandardBridge l2B = new L2StandardBridge(payable(proxy));\n        vm.etch(Predeploys.L2_STANDARD_BRIDGE, address(l2B).code);\n        L2Bridge = L2StandardBridge(payable(Predeploys.L2_STANDARD_BRIDGE));\n\n        // Set up the L2 mintable token factory\n        KromaMintableERC20Factory factory = new KromaMintableERC20Factory(\n            Predeploys.L2_STANDARD_BRIDGE\n        );\n        vm.etch(Predeploys.KROMA_MINTABLE_ERC20_FACTORY, address(factory).code);\n        L2TokenFactory = KromaMintableERC20Factory(Predeploys.KROMA_MINTABLE_ERC20_FACTORY);\n\n        L1Token = new ERC20(\"Native L1 Token\", \"L1T\");\n\n        // Deploy the L2 ERC20 now\n        L2Token = KromaMintableERC20(\n            L2TokenFactory.createKromaMintableERC20(\n                address(L1Token),\n                string(abi.encodePacked(\"L2-\", L1Token.name())),\n                string(abi.encodePacked(\"L2-\", L1Token.symbol()))\n            )\n        );\n\n        BadL2Token = KromaMintableERC20(\n            L2TokenFactory.createKromaMintableERC20(\n                address(1),\n                string(abi.encodePacked(\"L2-\", L1Token.name())),\n                string(abi.encodePacked(\"L2-\", L1Token.symbol()))\n            )\n        );\n\n        NativeL2Token = new ERC20(\"Native L2 Token\", \"L2T\");\n        L1TokenFactory = new KromaMintableERC20Factory(address(L1Bridge));\n\n        RemoteL1Token = KromaMintableERC20(\n            L1TokenFactory.createKromaMintableERC20(\n                address(NativeL2Token),\n                string(abi.encodePacked(\"L1-\", NativeL2Token.name())),\n                string(abi.encodePacked(\"L1-\", NativeL2Token.symbol()))\n            )\n        );\n\n        BadL1Token = KromaMintableERC20(\n            L1TokenFactory.createKromaMintableERC20(\n                address(1),\n                string(abi.encodePacked(\"L1-\", NativeL2Token.name())),\n                string(abi.encodePacked(\"L1-\", NativeL2Token.symbol()))\n            )\n        );\n    }\n}\n\ncontract ERC721Bridge_Initializer is Messenger_Initializer {\n    L1ERC721Bridge L1Bridge;\n    L2ERC721Bridge L2Bridge;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        // Deploy the L1ERC721Bridge.\n        L1Bridge = new L1ERC721Bridge(address(L1Messenger), Predeploys.L2_ERC721_BRIDGE);\n\n        // Deploy the implementation for the L2ERC721Bridge and etch it into the predeploy address.\n        vm.etch(\n            Predeploys.L2_ERC721_BRIDGE,\n            address(new L2ERC721Bridge(Predeploys.L2_CROSS_DOMAIN_MESSENGER, address(L1Bridge)))\n                .code\n        );\n\n        // Set up a reference to the L2ERC721Bridge.\n        L2Bridge = L2ERC721Bridge(Predeploys.L2_ERC721_BRIDGE);\n\n        // Label the L1 and L2 bridges.\n        vm.label(address(L1Bridge), \"L1ERC721Bridge\");\n        vm.label(address(L2Bridge), \"L2ERC721Bridge\");\n    }\n}\n\ncontract Colosseum_Initializer is L2OutputOracle_Initializer {\n    // Test target\n    Colosseum colosseumImpl;\n    Colosseum colosseum;\n\n    ZKVerifier zkVerifier;\n\n    uint256 timeout = 1 hours;\n    uint256[] segmentsLengths;\n\n    function setUp() public virtual override {\n        // Deploy the ZKVerifier\n        zkVerifier = new ZKVerifier();\n\n        // case - L2OutputOracle submissionInterval == 1800\n        segmentsLengths.push(9);\n        segmentsLengths.push(6);\n        segmentsLengths.push(10);\n        segmentsLengths.push(6);\n\n        Proxy proxy = new Proxy(multisig);\n        colosseum = Colosseum(payable(address(proxy)));\n\n        // Init L2OutputOracle after Colosseum contract deployment\n        challenger = address(colosseum);\n        super.setUp();\n\n        colosseumImpl = new Colosseum(\n            oracle,\n            zkVerifier,\n            submissionInterval,\n            timeout,\n            segmentsLengths\n        );\n        vm.prank(multisig);\n        proxy.upgradeToAndCall(\n            address(colosseumImpl),\n            abi.encodeCall(Colosseum.initialize, (segmentsLengths))\n        );\n    }\n}\n\ncontract FFIInterface is Test {\n    function getProveWithdrawalTransactionInputs(\n        Types.WithdrawalTransaction memory _tx\n    ) external returns (bytes32, bytes32, bytes32, bytes32, bytes[] memory) {\n        string[] memory cmds = new string[](8);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"getProveWithdrawalTransactionInputs\";\n        cmds[2] = vm.toString(_tx.nonce);\n        cmds[3] = vm.toString(_tx.sender);\n        cmds[4] = vm.toString(_tx.target);\n        cmds[5] = vm.toString(_tx.value);\n        cmds[6] = vm.toString(_tx.gasLimit);\n        cmds[7] = vm.toString(_tx.data);\n\n        bytes memory result = vm.ffi(cmds);\n        (\n            bytes32 stateRoot,\n            bytes32 storageRoot,\n            bytes32 outputRoot,\n            bytes32 withdrawalHash,\n            bytes[] memory withdrawalProof\n        ) = abi.decode(result, (bytes32, bytes32, bytes32, bytes32, bytes[]));\n\n        return (stateRoot, storageRoot, outputRoot, withdrawalHash, withdrawalProof);\n    }\n\n    function hashCrossDomainMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external returns (bytes32) {\n        string[] memory cmds = new string[](8);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"hashCrossDomainMessage\";\n        cmds[2] = vm.toString(_nonce);\n        cmds[3] = vm.toString(_sender);\n        cmds[4] = vm.toString(_target);\n        cmds[5] = vm.toString(_value);\n        cmds[6] = vm.toString(_gasLimit);\n        cmds[7] = vm.toString(_data);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes32));\n    }\n\n    function hashWithdrawal(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external returns (bytes32) {\n        string[] memory cmds = new string[](8);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"hashWithdrawal\";\n        cmds[2] = vm.toString(_nonce);\n        cmds[3] = vm.toString(_sender);\n        cmds[4] = vm.toString(_target);\n        cmds[5] = vm.toString(_value);\n        cmds[6] = vm.toString(_gasLimit);\n        cmds[7] = vm.toString(_data);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes32));\n    }\n\n    function hashOutputRootProof(\n        bytes32 _version,\n        bytes32 _stateRoot,\n        bytes32 _messagePasserStorageRoot,\n        bytes32 _latestBlockhash\n    ) external returns (bytes32) {\n        string[] memory cmds = new string[](6);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"hashOutputRootProof\";\n        cmds[2] = Strings.toHexString(uint256(_version));\n        cmds[3] = Strings.toHexString(uint256(_stateRoot));\n        cmds[4] = Strings.toHexString(uint256(_messagePasserStorageRoot));\n        cmds[5] = Strings.toHexString(uint256(_latestBlockhash));\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes32));\n    }\n\n    function hashDepositTransaction(\n        address _from,\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gas,\n        bytes memory _data,\n        uint64 _logIndex\n    ) external returns (bytes32) {\n        string[] memory cmds = new string[](10);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"hashDepositTransaction\";\n        cmds[2] = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n        cmds[3] = vm.toString(_logIndex);\n        cmds[4] = vm.toString(_from);\n        cmds[5] = vm.toString(_to);\n        cmds[6] = vm.toString(_mint);\n        cmds[7] = vm.toString(_value);\n        cmds[8] = vm.toString(_gas);\n        cmds[9] = vm.toString(_data);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes32));\n    }\n\n    function encodeDepositTransaction(\n        Types.UserDepositTransaction calldata txn\n    ) external returns (bytes memory) {\n        string[] memory cmds = new string[](11);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"encodeDepositTransaction\";\n        cmds[2] = vm.toString(txn.from);\n        cmds[3] = vm.toString(txn.to);\n        cmds[4] = vm.toString(txn.value);\n        cmds[5] = vm.toString(txn.mint);\n        cmds[6] = vm.toString(txn.gasLimit);\n        cmds[7] = vm.toString(txn.isCreation);\n        cmds[8] = vm.toString(txn.data);\n        cmds[9] = vm.toString(txn.l1BlockHash);\n        cmds[10] = vm.toString(txn.logIndex);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes));\n    }\n\n    function encodeCrossDomainMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external returns (bytes memory) {\n        string[] memory cmds = new string[](8);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"encodeCrossDomainMessage\";\n        cmds[2] = vm.toString(_nonce);\n        cmds[3] = vm.toString(_sender);\n        cmds[4] = vm.toString(_target);\n        cmds[5] = vm.toString(_value);\n        cmds[6] = vm.toString(_gasLimit);\n        cmds[7] = vm.toString(_data);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes));\n    }\n\n    function decodeVersionedNonce(uint256 nonce) external returns (uint256, uint256) {\n        string[] memory cmds = new string[](3);\n        cmds[0] = \"scripts/differential-testing/differential-testing\";\n        cmds[1] = \"decodeVersionedNonce\";\n        cmds[2] = vm.toString(nonce);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (uint256, uint256));\n    }\n\n    function getMerkleTrieFuzzCase(string memory variant)\n        external\n        returns (\n            bytes32,\n            bytes memory,\n            bytes memory,\n            bytes[] memory\n        )\n    {\n        string[] memory cmds = new string[](5);\n        cmds[0] = \"./test-case-generator/fuzz\";\n        cmds[1] = \"-m\";\n        cmds[2] = \"trie\";\n        cmds[3] = \"-v\";\n        cmds[4] = variant;\n\n        return abi.decode(vm.ffi(cmds), (bytes32, bytes, bytes, bytes[]));\n    }\n}\n\n// Used for testing a future upgrade beyond the current implementations.\n// We include some variables so that we can sanity check accessing storage values after an upgrade.\ncontract NextImpl is Initializable {\n    // Initializable occupies the zero-th slot.\n    bytes32 slot1;\n    bytes32[19] __gap;\n    bytes32 slot21;\n    bytes32 public constant slot21Init = bytes32(hex\"1337\");\n\n    function initialize() public reinitializer(2) {\n        // Slot21 is unused by an of our upgradeable contracts.\n        // This is used to verify that we can access this value after an upgrade.\n        slot21 = slot21Init;\n    }\n}\n\ncontract Reverter {\n    fallback() external {\n        revert();\n    }\n}\n\n// Useful for testing reentrancy guards\ncontract CallerCaller {\n    event WhatHappened(bool success, bytes returndata);\n\n    fallback() external {\n        (bool success, bytes memory returndata) = msg.sender.call(msg.data);\n        emit WhatHappened(success, returndata);\n        assembly {\n            switch success\n            case 0 {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n            default {\n                return(add(returndata, 0x20), mload(returndata))\n            }\n        }\n    }\n}\n\n// Used for testing the `CrossDomainMessenger`'s per-message reentrancy guard.\ncontract ConfigurableCaller {\n    bool doRevert = true;\n    address target;\n    bytes payload;\n\n    event WhatHappened(bool success, bytes returndata);\n\n    /**\n     * @notice Call the configured target with the configured payload OR revert.\n     */\n    function call() external {\n        if (doRevert) {\n            revert(\"ConfigurableCaller: revert\");\n        } else {\n            (bool success, bytes memory returndata) = address(target).call(payload);\n            emit WhatHappened(success, returndata);\n            assembly {\n                switch success\n                case 0 {\n                    revert(add(returndata, 0x20), mload(returndata))\n                }\n                default {\n                    return(add(returndata, 0x20), mload(returndata))\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Set whether or not to have `call` revert.\n     */\n    function setDoRevert(bool _doRevert) external {\n        doRevert = _doRevert;\n    }\n\n    /**\n     * @notice Set the target for the call made in `call`.\n     */\n    function setTarget(address _target) external {\n        target = _target;\n    }\n\n    /**\n     * @notice Set the payload for the call made in `call`.\n     */\n    function setPayload(bytes calldata _payload) external {\n        payload = _payload;\n    }\n\n    /**\n     * @notice Fallback function that reverts if `doRevert` is true.\n     *         Otherwise, it does nothing.\n     */\n    fallback() external {\n        if (doRevert) {\n            revert(\"ConfigurableCaller: revert\");\n        }\n    }\n}\n"
    },
    "contracts/test/CrossDomainMessenger.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Messenger_Initializer, Reverter, CallerCaller } from \"./CommonTest.t.sol\";\n\n// CrossDomainMessenger_Test is for testing functionality which is common to both the L1 and L2\n// CrossDomainMessenger contracts. For simplicity, we use the L1 Messenger as the test contract.\ncontract CrossDomainMessenger_BaseGas_Test is Messenger_Initializer {\n    // Ensure that baseGas passes for the max value of _minGasLimit,\n    // this is about 4 Billion.\n    function test_baseGas_succeeds() external view {\n        L1Messenger.baseGas(hex\"ff\", type(uint32).max);\n    }\n\n    // Fuzz for other values which might cause a revert in baseGas.\n    function testFuzz_baseGas_succeeds(uint32 _minGasLimit) external view {\n        L1Messenger.baseGas(hex\"ff\", _minGasLimit);\n    }\n}\n"
    },
    "contracts/test/CrossDomainOwnable.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\nimport { Vm, VmSafe } from \"forge-std/Vm.sol\";\n\nimport { CrossDomainOwnable } from \"../L2/CrossDomainOwnable.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { CommonTest, Portal_Initializer } from \"./CommonTest.t.sol\";\n\ncontract XDomainSetter is CrossDomainOwnable {\n    uint256 public value;\n\n    function set(uint256 _value) external onlyOwner {\n        value = _value;\n    }\n}\n\ncontract CrossDomainOwnable_Test is CommonTest {\n    XDomainSetter setter;\n\n    function setUp() public override {\n        super.setUp();\n        setter = new XDomainSetter();\n    }\n\n    // Check that the revert message is correct\n    function test_onlyOwner_notOwner_reverts() external {\n        vm.expectRevert(\"CrossDomainOwnable: caller is not the owner\");\n        setter.set(1);\n    }\n\n    // Check that making a call can set the value properly\n    function test_onlyOwner_succeeds() external {\n        assertEq(setter.value(), 0);\n\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(setter.owner()));\n        setter.set(1);\n        assertEq(setter.value(), 1);\n    }\n}\n\ncontract CrossDomainOwnableThroughPortal_Test is Portal_Initializer {\n    XDomainSetter setter;\n\n    function setUp() public override {\n        super.setUp();\n\n        vm.prank(alice);\n        setter = new XDomainSetter();\n    }\n\n    function test_depositTransaction_crossDomainOwner_succeeds() external {\n        vm.recordLogs();\n\n        vm.prank(alice);\n        portal.depositTransaction({\n            _to: address(setter),\n            _value: 0,\n            _gasLimit: 21_000,\n            _isCreation: false,\n            _data: abi.encodeWithSelector(XDomainSetter.set.selector, 1)\n        });\n\n        // Simulate the operation of the `kroma-node` by parsing data\n        // from logs\n        VmSafe.Log[] memory logs = vm.getRecordedLogs();\n        // Only 1 log emitted\n        assertEq(logs.length, 1);\n\n        VmSafe.Log memory log = logs[0];\n\n        // It is the expected topic\n        bytes32 topic = log.topics[0];\n        assertEq(topic, keccak256(\"TransactionDeposited(address,address,uint256,bytes)\"));\n\n        // from is indexed and the first argument to the event.\n        bytes32 _from = log.topics[1];\n        address from = Bytes32AddressLib.fromLast20Bytes(_from);\n\n        assertEq(AddressAliasHelper.undoL1ToL2Alias(from), alice);\n\n        // Make a call from the \"from\" value received from the log.\n        // In theory the opaque data could be parsed from the log\n        // and passed to a low level call to \"to\", but calling set\n        // directly on the setter is good enough.\n        vm.prank(from);\n        setter.set(1);\n        assertEq(setter.value(), 1);\n    }\n}\n"
    },
    "contracts/test/CrossDomainOwnable2.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\n\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { CrossDomainOwnable2 } from \"../L2/CrossDomainOwnable2.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { CommonTest, Messenger_Initializer } from \"./CommonTest.t.sol\";\n\ncontract XDomainSetter2 is CrossDomainOwnable2 {\n    uint256 public value;\n\n    function set(uint256 _value) external onlyOwner {\n        value = _value;\n    }\n}\n\ncontract CrossDomainOwnable2_Test is Messenger_Initializer {\n    XDomainSetter2 setter;\n\n    function setUp() public override {\n        super.setUp();\n        vm.prank(alice);\n        setter = new XDomainSetter2();\n    }\n\n    function test_onlyOwner_notMessenger_reverts() external {\n        vm.expectRevert(\"CrossDomainOwnable2: caller is not the messenger\");\n        setter.set(1);\n    }\n\n    function test_onlyOwner_notOwner_reverts() external {\n        // set the xDomainMsgSender storage slot\n        bytes32 key = bytes32(uint256(102));\n        bytes32 value = Bytes32AddressLib.fillLast12Bytes(address(alice));\n        vm.store(address(L2Messenger), key, value);\n\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"CrossDomainOwnable2: caller is not the owner\");\n        setter.set(1);\n    }\n\n    function test_onlyOwner_notOwner2_reverts() external {\n        uint240 nonce = 0;\n        address sender = bob;\n        address target = address(setter);\n        uint256 value = 0;\n        uint256 minGasLimit = 0;\n        bytes memory message = abi.encodeWithSelector(XDomainSetter2.set.selector, 1);\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: nonce, _version: 0 }),\n            sender,\n            target,\n            value,\n            minGasLimit,\n            message\n        );\n\n        // It should be a failed message. The revert is caught,\n        // so we cannot expectRevert here.\n        vm.expectEmit(true, true, true, true);\n        emit FailedRelayedMessage(hash);\n\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: nonce, _version: 0 }),\n            sender,\n            target,\n            value,\n            minGasLimit,\n            message\n        );\n\n        assertEq(setter.value(), 0);\n    }\n\n    function test_onlyOwner_succeeds() external {\n        address owner = setter.owner();\n\n        // Simulate the L2 execution where the call is coming from\n        // the L1CrossDomainMessenger\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 1, _version: 0 }),\n            owner,\n            address(setter),\n            0,\n            0,\n            abi.encodeWithSelector(XDomainSetter2.set.selector, 2)\n        );\n\n        assertEq(setter.value(), 2);\n    }\n}\n"
    },
    "contracts/test/CrossDomainOwnable3.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\n\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { CrossDomainOwnable3 } from \"../L2/CrossDomainOwnable3.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { CommonTest, Messenger_Initializer } from \"./CommonTest.t.sol\";\n\ncontract XDomainSetter3 is CrossDomainOwnable3 {\n    uint256 public value;\n\n    function set(uint256 _value) external onlyOwner {\n        value = _value;\n    }\n}\n\ncontract CrossDomainOwnable3_Test is Messenger_Initializer {\n    XDomainSetter3 setter;\n\n    /**\n     * @notice OpenZeppelin Ownable.sol transferOwnership event\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @notice CrossDomainOwnable3.sol transferOwnership event\n     */\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner,\n        bool isLocal\n    );\n\n    function setUp() public override {\n        super.setUp();\n        vm.prank(alice);\n        setter = new XDomainSetter3();\n    }\n\n    function test_constructor_succeeds() public {\n        assertEq(setter.owner(), alice);\n        assertEq(setter.isLocal(), true);\n    }\n\n    function test_localOnlyOwner_notOwner_reverts() public {\n        vm.prank(bob);\n        vm.expectRevert(\"CrossDomainOwnable3: caller is not the owner\");\n        setter.set(1);\n    }\n\n    function test_transferOwnership_notOwner_reverts() public {\n        vm.prank(bob);\n        vm.expectRevert(\"CrossDomainOwnable3: caller is not the owner\");\n        setter.transferOwnership({ _owner: bob, _isLocal: true });\n    }\n\n    function test_crossDomainOnlyOwner_notOwner_reverts() public {\n        vm.expectEmit(true, true, true, true);\n\n        // OpenZeppelin Ownable.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice);\n\n        // CrossDomainOwnable3.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice, false);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership({ _owner: alice, _isLocal: false });\n\n        // set the xDomainMsgSender storage slot\n        bytes32 key = bytes32(uint256(102));\n        bytes32 value = Bytes32AddressLib.fillLast12Bytes(bob);\n        vm.store(address(L2Messenger), key, value);\n\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"CrossDomainOwnable3: caller is not the owner\");\n        setter.set(1);\n    }\n\n    function test_crossDomainOnlyOwner_notOwner2_reverts() public {\n        vm.expectEmit(true, true, true, true);\n\n        // OpenZeppelin Ownable.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice);\n\n        // CrossDomainOwnable3.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice, false);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership({ _owner: alice, _isLocal: false });\n\n        assertEq(setter.isLocal(), false);\n\n        uint240 nonce = 0;\n        address sender = bob;\n        address target = address(setter);\n        uint256 value = 0;\n        uint256 minGasLimit = 0;\n        bytes memory message = abi.encodeWithSelector(XDomainSetter3.set.selector, 1);\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: nonce, _version: 0 }),\n            sender,\n            target,\n            value,\n            minGasLimit,\n            message\n        );\n\n        // It should be a failed message. The revert is caught,\n        // so we cannot expectRevert here.\n        vm.expectEmit(true, true, true, true, address(L2Messenger));\n        emit FailedRelayedMessage(hash);\n\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: nonce, _version: 0 }),\n            sender,\n            target,\n            value,\n            minGasLimit,\n            message\n        );\n\n        assertEq(setter.value(), 0);\n    }\n\n    function test_crossDomainOnlyOwner_notMessenger_reverts() public {\n        vm.expectEmit(true, true, true, true);\n\n        // OpenZeppelin Ownable.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice);\n\n        // CrossDomainOwnable3.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice, false);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership({ _owner: alice, _isLocal: false });\n\n        vm.prank(bob);\n        vm.expectRevert(\"CrossDomainOwnable3: caller is not the messenger\");\n        setter.set(1);\n    }\n\n    function test_transferOwnership_zeroAddress_reverts() public {\n        vm.prank(setter.owner());\n        vm.expectRevert(\"CrossDomainOwnable3: new owner is the zero address\");\n        setter.transferOwnership({ _owner: address(0), _isLocal: true });\n    }\n\n    function test_transferOwnership_noLocalZeroAddress_reverts() public {\n        vm.prank(setter.owner());\n        vm.expectRevert(\"Ownable: new owner is the zero address\");\n        setter.transferOwnership(address(0));\n    }\n\n    function test_localOnlyOwner_succeeds() public {\n        assertEq(setter.isLocal(), true);\n        vm.prank(setter.owner());\n        setter.set(1);\n        assertEq(setter.value(), 1);\n    }\n\n    function test_localTransferOwnership_succeeds() public {\n        vm.expectEmit(true, true, true, true, address(setter));\n        emit OwnershipTransferred(alice, bob);\n        emit OwnershipTransferred(alice, bob, true);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership({ _owner: bob, _isLocal: true });\n\n        assertEq(setter.isLocal(), true);\n\n        vm.prank(bob);\n        setter.set(2);\n        assertEq(setter.value(), 2);\n    }\n\n    /**\n     * @notice The existing transferOwnership(address) method\n     *         still exists on the contract\n     */\n    function test_transferOwnershipNoLocal_succeeds() public {\n        bool isLocal = setter.isLocal();\n\n        vm.expectEmit(true, true, true, true, address(setter));\n        emit OwnershipTransferred(alice, bob);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership(bob);\n\n        // isLocal has not changed\n        assertEq(setter.isLocal(), isLocal);\n\n        vm.prank(bob);\n        setter.set(2);\n        assertEq(setter.value(), 2);\n    }\n\n    function test_crossDomainTransferOwnership_succeeds() public {\n        vm.expectEmit(true, true, true, true, address(setter));\n        emit OwnershipTransferred(alice, bob);\n        emit OwnershipTransferred(alice, bob, false);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership({ _owner: bob, _isLocal: false });\n\n        assertEq(setter.isLocal(), false);\n\n        // Simulate the L2 execution where the call is coming from\n        // the L1CrossDomainMessenger\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 1, _version: 0 }),\n            bob,\n            address(setter),\n            0,\n            0,\n            abi.encodeWithSelector(XDomainSetter3.set.selector, 2)\n        );\n\n        assertEq(setter.value(), 2);\n    }\n}\n"
    },
    "contracts/test/Encoding.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract Encoding_Test is CommonTest {\n    function testFuzz_nonceVersioning_succeeds(uint240 _nonce, uint16 _version) external {\n        (uint240 nonce, uint16 version) = Encoding.decodeVersionedNonce(\n            Encoding.encodeVersionedNonce(_nonce, _version)\n        );\n        assertEq(version, _version);\n        assertEq(nonce, _nonce);\n    }\n\n    function testDiff_decodeVersionedNonce_succeeds(uint240 _nonce, uint16 _version) external {\n        uint256 nonce = uint256(Encoding.encodeVersionedNonce(_nonce, _version));\n        (uint256 decodedNonce, uint256 decodedVersion) = ffi.decodeVersionedNonce(nonce);\n\n        assertEq(_version, uint16(decodedVersion));\n\n        assertEq(_nonce, uint240(decodedNonce));\n    }\n\n    function testDiff_encodeCrossDomainMessage_succeeds(\n        uint240 _nonce,\n        uint8 _version,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        uint8 version = uint8(bound(uint256(_version), 0, 0));\n        uint256 nonce = Encoding.encodeVersionedNonce(_nonce, version);\n\n        bytes memory encoding = Encoding.encodeCrossDomainMessage(\n            nonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n\n        bytes memory _encoding = ffi.encodeCrossDomainMessage(\n            nonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n\n        assertEq(encoding, _encoding);\n    }\n\n    function testDiff_encodeDepositTransaction_succeeds(\n        address _from,\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gas,\n        bool isCreate,\n        bytes memory _data,\n        uint64 _logIndex\n    ) external {\n        Types.UserDepositTransaction memory t = Types.UserDepositTransaction(\n            _from,\n            _to,\n            isCreate,\n            _value,\n            _mint,\n            _gas,\n            _data,\n            bytes32(uint256(0)),\n            _logIndex\n        );\n\n        bytes memory txn = Encoding.encodeDepositTransaction(t);\n        bytes memory _txn = ffi.encodeDepositTransaction(t);\n\n        assertEq(txn, _txn);\n    }\n}\n"
    },
    "contracts/test/FeeVault.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { BaseFeeVault } from \"../L2/BaseFeeVault.sol\";\nimport { L1FeeVault } from \"../L2/L1FeeVault.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\n\n// Test the implementations of the FeeVault\ncontract FeeVault_Test is Bridge_Initializer {\n    BaseFeeVault baseFeeVault = BaseFeeVault(payable(Predeploys.BASE_FEE_VAULT));\n    L1FeeVault l1FeeVault = L1FeeVault(payable(Predeploys.L1_FEE_VAULT));\n\n    address constant recipient = address(0x10000);\n\n    function setUp() public override {\n        super.setUp();\n        vm.etch(Predeploys.BASE_FEE_VAULT, address(new BaseFeeVault(recipient)).code);\n        vm.etch(Predeploys.L1_FEE_VAULT, address(new L1FeeVault(recipient)).code);\n\n        vm.label(Predeploys.BASE_FEE_VAULT, \"BaseFeeVault\");\n        vm.label(Predeploys.L1_FEE_VAULT, \"L1FeeVault\");\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(baseFeeVault.RECIPIENT(), recipient);\n        assertEq(l1FeeVault.RECIPIENT(), recipient);\n    }\n\n    function test_minWithdrawalAmount_succeeds() external {\n        assertEq(baseFeeVault.MIN_WITHDRAWAL_AMOUNT(), 10 ether);\n        assertEq(l1FeeVault.MIN_WITHDRAWAL_AMOUNT(), 10 ether);\n    }\n}\n"
    },
    "contracts/test/GasPriceOracle.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { GasPriceOracle } from \"../L2/GasPriceOracle.sol\";\nimport { L1Block } from \"../L2/L1Block.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract GasPriceOracle_Test is CommonTest {\n    event OverheadUpdated(uint256);\n    event ScalarUpdated(uint256);\n    event DecimalsUpdated(uint256);\n\n    GasPriceOracle gasOracle;\n    L1Block l1Block;\n    address depositor;\n\n    // set the initial L1 context values\n    uint64 constant number = 10;\n    uint64 constant timestamp = 11;\n    uint256 constant basefee = 100;\n    bytes32 constant hash = bytes32(uint256(64));\n    uint64 constant sequenceNumber = 0;\n    bytes32 constant batcherHash = bytes32(uint256(777));\n    uint256 constant l1FeeOverhead = 310;\n    uint256 constant l1FeeScalar = 10;\n\n    function setUp() public virtual override {\n        super.setUp();\n        // place the L1Block contract at the predeploy address\n        vm.etch(Predeploys.L1_BLOCK_ATTRIBUTES, address(new L1Block()).code);\n\n        l1Block = L1Block(Predeploys.L1_BLOCK_ATTRIBUTES);\n        depositor = l1Block.DEPOSITOR_ACCOUNT();\n\n        // We are not setting the gas oracle at its predeploy\n        // address for simplicity purposes. Nothing in this test\n        // requires it to be at a particular address\n        gasOracle = new GasPriceOracle();\n\n        vm.prank(depositor);\n        l1Block.setL1BlockValues({\n            _number: number,\n            _timestamp: timestamp,\n            _basefee: basefee,\n            _hash: hash,\n            _sequenceNumber: sequenceNumber,\n            _batcherHash: batcherHash,\n            _l1FeeOverhead: l1FeeOverhead,\n            _l1FeeScalar: l1FeeScalar\n        });\n    }\n\n    function test_l1BaseFee_succeeds() external {\n        assertEq(gasOracle.l1BaseFee(), basefee);\n    }\n\n    function test_gasPrice_succeeds() external {\n        vm.fee(100);\n        uint256 gasPrice = gasOracle.gasPrice();\n        assertEq(gasPrice, 100);\n    }\n\n    function test_baseFee_succeeds() external {\n        vm.fee(64);\n        uint256 gasPrice = gasOracle.baseFee();\n        assertEq(gasPrice, 64);\n    }\n\n    function test_scalar_succeeds() external {\n        assertEq(gasOracle.scalar(), l1FeeScalar);\n    }\n\n    function test_overhead_succeeds() external {\n        assertEq(gasOracle.overhead(), l1FeeOverhead);\n    }\n\n    function test_decimals_succeeds() external {\n        assertEq(gasOracle.DECIMALS(), 6);\n    }\n}\n"
    },
    "contracts/test/Hashing.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract Hashing_hashDepositSource_Test is CommonTest {\n    /**\n     * @notice Tests that hashDepositSource returns the correct hash in a simple case.\n     */\n    function test_hashDepositSource_succeeds() external {\n        assertEq(\n            Hashing.hashDepositSource(\n                0xd25df7858efc1778118fb133ac561b138845361626dfb976699c5287ed0f4959,\n                0x1\n            ),\n            0xf923fb07134d7d287cb52c770cc619e17e82606c21a875c92f4c63b65280a5cc\n        );\n    }\n}\n\ncontract Hashing_hashCrossDomainMessage_Test is CommonTest {\n    /**\n     * @notice Tests that hashCrossDomainMessage returns the correct hash in a simple case.\n     */\n    function testDiff_hashCrossDomainMessage_succeeds(\n        uint240 _nonce,\n        uint16 _version,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        // Ensure the version is valid.\n        uint16 version = uint16(bound(uint256(_version), 0, 0));\n        uint256 nonce = Encoding.encodeVersionedNonce(_nonce, version);\n\n        assertEq(\n            Hashing.hashCrossDomainMessage(nonce, _sender, _target, _value, _gasLimit, _data),\n            ffi.hashCrossDomainMessage(nonce, _sender, _target, _value, _gasLimit, _data)\n        );\n    }\n}\n\ncontract Hashing_hashWithdrawal_Test is CommonTest {\n    /**\n     * @notice Tests that hashWithdrawal returns the correct hash in a simple case.\n     */\n    function testDiff_hashWithdrawal_succeeds(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        assertEq(\n            Hashing.hashWithdrawal(\n                Types.WithdrawalTransaction(_nonce, _sender, _target, _value, _gasLimit, _data)\n            ),\n            ffi.hashWithdrawal(_nonce, _sender, _target, _value, _gasLimit, _data)\n        );\n    }\n}\n\ncontract Hashing_hashOutputRootProof_Test is CommonTest {\n    /**\n     * @notice Tests that hashOutputRootProof returns the correct hash in a simple case.\n     */\n    function testDiff_hashOutputRootProof_succeeds(\n        bytes32 _version,\n        bytes32 _stateRoot,\n        bytes32 _messagePasserStorageRoot,\n        bytes32 _latestBlockhash\n    ) external {\n        assertEq(\n            Hashing.hashOutputRootProof(\n                Types.OutputRootProof({\n                    version: _version,\n                    stateRoot: _stateRoot,\n                    messagePasserStorageRoot: _messagePasserStorageRoot,\n                    latestBlockhash: _latestBlockhash\n                })\n            ),\n            ffi.hashOutputRootProof(\n                _version,\n                _stateRoot,\n                _messagePasserStorageRoot,\n                _latestBlockhash\n            )\n        );\n    }\n}\n\ncontract Hashing_hashDepositTransaction_Test is CommonTest {\n    /**\n     * @notice Tests that hashDepositTransaction returns the correct hash in a simple case.\n     */\n    function testDiff_hashDepositTransaction_succeeds(\n        address _from,\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gas,\n        bytes memory _data,\n        uint64 _logIndex\n    ) external {\n        assertEq(\n            Hashing.hashDepositTransaction(\n                Types.UserDepositTransaction(\n                    _from,\n                    _to,\n                    false, // isCreate\n                    _value,\n                    _mint,\n                    _gas,\n                    _data,\n                    bytes32(uint256(0)),\n                    _logIndex\n                )\n            ),\n            ffi.hashDepositTransaction(_from, _to, _mint, _value, _gas, _data, _logIndex)\n        );\n    }\n}\n"
    },
    "contracts/test/KromaMintableERC20.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {\n    IKromaMintableERC20\n} from \"../universal/IKromaMintableERC20.sol\";\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\n\ncontract KromaMintableERC20_Test is Bridge_Initializer {\n    event Mint(address indexed account, uint256 amount);\n    event Burn(address indexed account, uint256 amount);\n\n    function test_semver_succeeds() external {\n        assertEq(L2Token.version(), \"0.1.0\");\n    }\n\n    function test_remoteToken_succeeds() external {\n        assertEq(L2Token.REMOTE_TOKEN(), address(L1Token));\n    }\n\n    function test_bridge_succeeds() external {\n        assertEq(L2Token.BRIDGE(), address(L2Bridge));\n    }\n\n    function test_mint_succeeds() external {\n        vm.expectEmit(true, true, true, true);\n        emit Mint(alice, 100);\n\n        vm.prank(address(L2Bridge));\n        L2Token.mint(alice, 100);\n\n        assertEq(L2Token.balanceOf(alice), 100);\n    }\n\n    function test_mint_notBridge_reverts() external {\n        // NOT the bridge\n        vm.expectRevert(\"KromaMintableERC20: only bridge can mint and burn\");\n        vm.prank(address(alice));\n        L2Token.mint(alice, 100);\n    }\n\n    function test_burn_succeeds() external {\n        vm.prank(address(L2Bridge));\n        L2Token.mint(alice, 100);\n\n        vm.expectEmit(true, true, true, true);\n        emit Burn(alice, 100);\n\n        vm.prank(address(L2Bridge));\n        L2Token.burn(alice, 100);\n\n        assertEq(L2Token.balanceOf(alice), 0);\n    }\n\n    function test_burn_notBridge_reverts() external {\n        // NOT the bridge\n        vm.expectRevert(\"KromaMintableERC20: only bridge can mint and burn\");\n        vm.prank(address(alice));\n        L2Token.burn(alice, 100);\n    }\n\n    function test_erc165_supportsInterface_succeeds() external {\n        // The assertEq calls in this test are comparing the manual calculation of the iface,\n        // with what is returned by the solidity's type().interfaceId, just to be safe.\n        bytes4 iface1 = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n        assertEq(iface1, type(IERC165).interfaceId);\n        assert(L2Token.supportsInterface(iface1));\n\n        bytes4 iface2 = L2Token.REMOTE_TOKEN.selector ^\n            L2Token.BRIDGE.selector ^\n            L2Token.mint.selector ^\n            L2Token.burn.selector;\n        assertEq(iface2, type(IKromaMintableERC20).interfaceId);\n        assert(L2Token.supportsInterface(iface2));\n    }\n}\n"
    },
    "contracts/test/KromaMintableERC20Factory.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\nimport { LibRLP } from \"./RLP.t.sol\";\n\ncontract KromaMintableTokenFactory_Test is Bridge_Initializer {\n    event KromaMintableERC20Created(\n        address indexed localToken,\n        address indexed remoteToken,\n        address deployer\n    );\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_bridge_succeeds() external {\n        assertEq(address(L2TokenFactory.BRIDGE()), address(L2Bridge));\n    }\n\n    function test_createKromaMintableERC20_succeeds() external {\n        address remote = address(4);\n        address local = LibRLP.computeAddress(address(L2TokenFactory), 2);\n\n        vm.expectEmit(true, true, true, true);\n        emit KromaMintableERC20Created(local, remote, alice);\n\n        vm.prank(alice);\n        L2TokenFactory.createKromaMintableERC20(remote, \"Beep\", \"BOOP\");\n    }\n\n    function test_createKromaMintableERC20_sameTwice_succeeds() external {\n        address remote = address(4);\n\n        vm.prank(alice);\n        L2TokenFactory.createKromaMintableERC20(remote, \"Beep\", \"BOOP\");\n\n        address local = LibRLP.computeAddress(address(L2TokenFactory), 3);\n\n        vm.expectEmit(true, true, true, true);\n        emit KromaMintableERC20Created(local, remote, alice);\n\n        vm.prank(alice);\n        L2TokenFactory.createKromaMintableERC20(remote, \"Beep\", \"BOOP\");\n    }\n\n    function test_createKromaMintableERC20_remoteIsZero_succeeds() external {\n        address remote = address(0);\n        vm.expectRevert(\"KromaMintableERC20Factory: must provide remote token address\");\n        L2TokenFactory.createKromaMintableERC20(remote, \"Beep\", \"BOOP\");\n    }\n}\n"
    },
    "contracts/test/KromaMintableERC721.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport { KromaMintableERC721 } from \"../universal/KromaMintableERC721.sol\";\nimport { ERC721Bridge_Initializer } from \"./CommonTest.t.sol\";\n\ncontract KromaMintableERC721_Test is ERC721Bridge_Initializer {\n    ERC721 internal L1Token;\n    KromaMintableERC721 internal L2Token;\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    event Mint(address indexed account, uint256 tokenId);\n\n    event Burn(address indexed account, uint256 tokenId);\n\n    function setUp() public override {\n        super.setUp();\n\n        // Set up the token pair.\n        L1Token = new ERC721(\"L1Token\", \"L1T\");\n        L2Token = new KromaMintableERC721(\n            address(L2Bridge),\n            1,\n            address(L1Token),\n            \"L2Token\",\n            \"L2T\"\n        );\n\n        // Label the addresses for nice traces.\n        vm.label(address(L1Token), \"L1ERC721Token\");\n        vm.label(address(L2Token), \"L2ERC721Token\");\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(L2Token.name(), \"L2Token\");\n        assertEq(L2Token.symbol(), \"L2T\");\n        assertEq(L2Token.remoteChainId(), 1);\n        assertEq(L2Token.REMOTE_TOKEN(), address(L1Token));\n        assertEq(L2Token.BRIDGE(), address(L2Bridge));\n        assertEq(L2Token.REMOTE_CHAIN_ID(), 1);\n    }\n\n    function test_safeMint_succeeds() external {\n        // Expect a transfer event.\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(0), alice, 1);\n\n        // Expect a mint event.\n        vm.expectEmit(true, true, true, true);\n        emit Mint(alice, 1);\n\n        // Mint the token.\n        vm.prank(address(L2Bridge));\n        L2Token.safeMint(alice, 1);\n\n        // Token should be owned by alice.\n        assertEq(L2Token.ownerOf(1), alice);\n    }\n\n    function test_safeMint_notBridge_reverts() external {\n        // Try to mint the token.\n        vm.expectRevert(\"KromaMintableERC721: only bridge can call this function\");\n        vm.prank(address(alice));\n        L2Token.safeMint(alice, 1);\n    }\n\n    function test_burn_succeeds() external {\n        // Mint the token first.\n        vm.prank(address(L2Bridge));\n        L2Token.safeMint(alice, 1);\n\n        // Expect a transfer event.\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(alice, address(0), 1);\n\n        // Expect a burn event.\n        vm.expectEmit(true, true, true, true);\n        emit Burn(alice, 1);\n\n        // Burn the token.\n        vm.prank(address(L2Bridge));\n        L2Token.burn(alice, 1);\n\n        // Token should be owned by address(0).\n        vm.expectRevert(\"ERC721: invalid token ID\");\n        L2Token.ownerOf(1);\n    }\n\n    function test_burn_notBridge_reverts() external {\n        // Mint the token first.\n        vm.prank(address(L2Bridge));\n        L2Token.safeMint(alice, 1);\n\n        // Try to burn the token.\n        vm.expectRevert(\"KromaMintableERC721: only bridge can call this function\");\n        vm.prank(address(alice));\n        L2Token.burn(alice, 1);\n    }\n\n    function test_tokenURI_succeeds() external {\n        // Mint the token first.\n        vm.prank(address(L2Bridge));\n        L2Token.safeMint(alice, 1);\n\n        // Token URI should be correct.\n        assertEq(\n            L2Token.tokenURI(1),\n            string(\n                abi.encodePacked(\n                    \"ethereum:\",\n                    Strings.toHexString(uint160(address(L1Token)), 20),\n                    \"@\",\n                    Strings.toString(1),\n                    \"/tokenURI?uint256=\",\n                    Strings.toString(1)\n                )\n            )\n        );\n    }\n}\n"
    },
    "contracts/test/KromaMintableERC721Factory.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport { KromaMintableERC721 } from \"../universal/KromaMintableERC721.sol\";\nimport { KromaMintableERC721Factory } from \"../universal/KromaMintableERC721Factory.sol\";\nimport { ERC721Bridge_Initializer } from \"./CommonTest.t.sol\";\nimport { LibRLP } from \"./RLP.t.sol\";\n\ncontract KromaMintableERC721Factory_Test is ERC721Bridge_Initializer {\n    KromaMintableERC721Factory internal factory;\n\n    event KromaMintableERC721Created(\n        address indexed localToken,\n        address indexed remoteToken,\n        address deployer\n    );\n\n    function setUp() public override {\n        super.setUp();\n\n        // Set up the token pair.\n        factory = new KromaMintableERC721Factory(address(L2Bridge), 1);\n\n        // Label the addresses for nice traces.\n        vm.label(address(factory), \"KromaMintableERC721Factory\");\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(factory.BRIDGE(), address(L2Bridge));\n        assertEq(factory.REMOTE_CHAIN_ID(), 1);\n    }\n\n    function test_createKromaMintableERC721_succeeds() external {\n        // Predict the address based on the factory address and nonce.\n        address predicted = LibRLP.computeAddress(address(factory), 1);\n\n        // Expect a token creation event.\n        vm.expectEmit(true, true, true, true);\n        emit KromaMintableERC721Created(predicted, address(1234), alice);\n\n        // Create the token.\n        vm.prank(alice);\n        KromaMintableERC721 created = KromaMintableERC721(\n            factory.createKromaMintableERC721(address(1234), \"L2Token\", \"L2T\")\n        );\n\n        // Token address should be correct.\n        assertEq(address(created), predicted);\n\n        // Should be marked as created by the factory.\n        assertEq(factory.isKromaMintableERC721(address(created)), true);\n\n        // Token should've been constructed correctly.\n        assertEq(created.name(), \"L2Token\");\n        assertEq(created.symbol(), \"L2T\");\n        assertEq(created.REMOTE_TOKEN(), address(1234));\n        assertEq(created.BRIDGE(), address(L2Bridge));\n        assertEq(created.REMOTE_CHAIN_ID(), 1);\n    }\n\n    function test_createKromaMintableERC721_zeroRemoteToken_reverts() external {\n        // Try to create a token with a zero remote token address.\n        vm.expectRevert(\"KromaMintableERC721Factory: L1 token address cannot be address(0)\");\n        factory.createKromaMintableERC721(address(0), \"L2Token\", \"L2T\");\n    }\n}\n"
    },
    "contracts/test/KromaPortal.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { stdError } from \"forge-std/Test.sol\";\n\nimport { KromaPortal } from \"../L1/KromaPortal.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Portal_Initializer, CommonTest, NextImpl } from \"./CommonTest.t.sol\";\n\ncontract KromaPortal_Test is Portal_Initializer {\n    event Paused(address);\n    event Unpaused(address);\n\n    function test_constructor_succeeds() external {\n        assertEq(address(portal.L2_ORACLE()), address(oracle));\n        assertEq(portal.l2Sender(), 0x000000000000000000000000000000000000dEaD);\n        assertEq(portal.paused(), false);\n    }\n\n    /**\n     * @notice The KromaPortal can be paused by the GUARDIAN\n     */\n    function test_pause_succeeds() external {\n        address guardian = portal.GUARDIAN();\n\n        assertEq(portal.paused(), false);\n\n        vm.expectEmit(true, true, true, true, address(portal));\n        emit Paused(guardian);\n\n        vm.prank(guardian);\n        portal.pause();\n\n        assertEq(portal.paused(), true);\n    }\n\n    /**\n     * @notice The KromaPortal reverts when an account that is not the\n     *         GUARDIAN calls `pause()`\n     */\n    function test_pause_onlyGuardian_reverts() external {\n        assertEq(portal.paused(), false);\n\n        assertTrue(portal.GUARDIAN() != alice);\n        vm.expectRevert(\"KromaPortal: only guardian can pause\");\n        vm.prank(alice);\n        portal.pause();\n\n        assertEq(portal.paused(), false);\n    }\n\n    /**\n     * @notice The KromaPortal can be unpaused by the GUARDIAN\n     */\n    function test_unpause_succeeds() external {\n        address guardian = portal.GUARDIAN();\n\n        vm.prank(guardian);\n        portal.pause();\n        assertEq(portal.paused(), true);\n\n        vm.expectEmit(true, true, true, true, address(portal));\n        emit Unpaused(guardian);\n        vm.prank(guardian);\n        portal.unpause();\n\n        assertEq(portal.paused(), false);\n    }\n\n    /**\n     * @notice The KromaPortal reverts when an account that is not\n     *         the GUARDIAN calls `unpause()`\n     */\n    function test_unpause_onlyGuardian_reverts() external {\n        address guardian = portal.GUARDIAN();\n\n        vm.prank(guardian);\n        portal.pause();\n        assertEq(portal.paused(), true);\n\n        assertTrue(portal.GUARDIAN() != alice);\n        vm.expectRevert(\"KromaPortal: only guardian can unpause\");\n        vm.prank(alice);\n        portal.unpause();\n\n        assertEq(portal.paused(), true);\n    }\n\n    function test_receive_succeeds() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(alice, alice, 100, 100, 100_000, false, hex\"\");\n\n        // give alice money and send as an eoa\n        vm.deal(alice, 2**64);\n        vm.prank(alice, alice);\n        (bool s, ) = address(portal).call{ value: 100 }(hex\"\");\n\n        assert(s);\n        assertEq(address(portal).balance, 100);\n    }\n\n    // Test: depositTransaction fails when contract creation has a non-zero destination address\n    function test_depositTransaction_contractCreation_reverts() external {\n        // contract creation must have a target of address(0)\n        vm.expectRevert(\"KromaPortal: must send to address(0) when creating a contract\");\n        portal.depositTransaction(address(1), 1, 0, true, hex\"\");\n    }\n\n    /**\n     * @notice Prevent gasless deposits from being force processed in L2 by\n     *         ensuring that they have a large enough gas limit set.\n     */\n    function test_depositTransaction_smallGasLimit_reverts() external {\n        vm.expectRevert(\"KromaPortal: gas limit must cover instrinsic gas cost\");\n        portal.depositTransaction({\n            _to: address(1),\n            _value: 0,\n            _gasLimit: 0,\n            _isCreation: false,\n            _data: hex\"\"\n        });\n    }\n\n    // Test: depositTransaction should emit the correct log when an EOA deposits a tx with 0 value\n    function test_depositTransaction_noValueEOA_succeeds() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            address(this),\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        portal.depositTransaction(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    // Test: depositTransaction should emit the correct log when a contract deposits a tx with 0 value\n    function test_depositTransaction_noValueContract_succeeds() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        portal.depositTransaction(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    // Test: depositTransaction should emit the correct log when an EOA deposits a contract creation with 0 value\n    function test_depositTransaction_createWithZeroValueForEOA_succeeds() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            address(this),\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n\n        portal.depositTransaction(ZERO_ADDRESS, ZERO_VALUE, NON_ZERO_GASLIMIT, true, NON_ZERO_DATA);\n    }\n\n    // Test: depositTransaction should emit the correct log when a contract deposits a contract creation with 0 value\n    function test_depositTransaction_createWithZeroValueForContract_succeeds() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n\n        portal.depositTransaction(ZERO_ADDRESS, ZERO_VALUE, NON_ZERO_GASLIMIT, true, NON_ZERO_DATA);\n    }\n\n    // Test: depositTransaction should increase its eth balance when an EOA deposits a transaction with ETH\n    function test_depositTransaction_withEthValueFromEOA_succeeds() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            address(this),\n            NON_ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        portal.depositTransaction{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n        assertEq(address(portal).balance, NON_ZERO_VALUE);\n    }\n\n    // Test: depositTransaction should increase its eth balance when a contract deposits a transaction with ETH\n    function test_depositTransaction_withEthValueFromContract_succeeds() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            NON_ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        portal.depositTransaction{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    // Test: depositTransaction should increase its eth balance when an EOA deposits a contract creation with ETH\n    function test_depositTransaction_withEthValueAndEOAContractCreation_succeeds() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            address(this),\n            ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            hex\"\"\n        );\n\n        portal.depositTransaction{ value: NON_ZERO_VALUE }(\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            hex\"\"\n        );\n        assertEq(address(portal).balance, NON_ZERO_VALUE);\n    }\n\n    // Test: depositTransaction should increase its eth balance when a contract deposits a contract creation with ETH\n    function test_depositTransaction_withEthValueAndContractContractCreation_succeeds() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n\n        portal.depositTransaction{ value: NON_ZERO_VALUE }(\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n        assertEq(address(portal).balance, NON_ZERO_VALUE);\n    }\n\n    function test_simple_isOutputFinalized_succeeds() external {\n        uint256 ts = block.timestamp;\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.CheckpointOutput(bytes32(uint256(1)), uint128(ts), uint128(startingBlockNumber))\n            )\n        );\n\n        // warp to the finalization period\n        vm.warp(ts + oracle.FINALIZATION_PERIOD_SECONDS());\n        assertEq(portal.isOutputFinalized(0), false);\n\n        // warp past the finalization period\n        vm.warp(ts + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        assertEq(portal.isOutputFinalized(0), true);\n    }\n\n    function test_isOutputFinalized_succeeds() external {\n        uint256 checkpoint = oracle.nextBlockNumber();\n        uint256 nextOutputIndex = oracle.nextOutputIndex();\n        vm.roll(checkpoint);\n        vm.warp(oracle.computeL2Timestamp(checkpoint) + 1);\n        vm.prank(oracle.VALIDATOR());\n        oracle.submitL2Output(keccak256(abi.encode(2)), checkpoint, 0, 0);\n\n        // warp to the final second of the finalization period\n        uint256 finalizationHorizon = block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS();\n        vm.warp(finalizationHorizon);\n        // The checkpointed block should not be finalized until 1 second from now.\n        assertEq(portal.isOutputFinalized(nextOutputIndex), false);\n        // Nor should a block after it\n        vm.expectRevert(stdError.indexOOBError);\n        assertEq(portal.isOutputFinalized(nextOutputIndex + 1), false);\n\n        // warp past the finalization period\n        vm.warp(finalizationHorizon + 1);\n        // It should now be finalized.\n        assertEq(portal.isOutputFinalized(nextOutputIndex), true);\n        // But not the block after it.\n        vm.expectRevert(stdError.indexOOBError);\n        assertEq(portal.isOutputFinalized(nextOutputIndex + 1), false);\n    }\n}\n\ncontract KromaPortal_FinalizeWithdrawal_Test is Portal_Initializer {\n    // Reusable default values for a test withdrawal\n    Types.WithdrawalTransaction _defaultTx;\n\n    uint256 _submittedOutputIndex;\n    uint256 _submittedBlockNumber;\n    bytes32 _stateRoot;\n    bytes32 _storageRoot;\n    bytes32 _outputRoot;\n    bytes32 _withdrawalHash;\n    bytes[] _withdrawalProof;\n    Types.OutputRootProof internal _outputRootProof;\n\n    // Use a constructor to set the storage vars above, so as to minimize the number of ffi calls.\n    constructor() {\n        super.setUp();\n        _defaultTx = Types.WithdrawalTransaction({\n            nonce: 0,\n            sender: alice,\n            target: bob,\n            value: 100,\n            gasLimit: 100_000,\n            data: hex\"\"\n        });\n        // Get withdrawal proof data we can use for testing.\n        (_stateRoot, _storageRoot, _outputRoot, _withdrawalHash, _withdrawalProof) = ffi\n            .getProveWithdrawalTransactionInputs(_defaultTx);\n\n        // Setup a dummy output root proof for reuse.\n        _outputRootProof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: _stateRoot,\n            messagePasserStorageRoot: _storageRoot,\n            latestBlockhash: bytes32(uint256(0))\n        });\n        _submittedBlockNumber = oracle.nextBlockNumber();\n        _submittedOutputIndex = oracle.nextOutputIndex();\n    }\n\n    // Get the system into a nice ready-to-use state.\n    function setUp() public override {\n        // Configure the oracle to return the output root we've prepared.\n        vm.warp(oracle.computeL2Timestamp(_submittedBlockNumber) + 1);\n        vm.prank(oracle.VALIDATOR());\n        oracle.submitL2Output(_outputRoot, _submittedBlockNumber, 0, 0);\n\n        // Warp beyond the finalization period for the block we've submitted.\n        vm.warp(\n            oracle.getL2Output(_submittedOutputIndex).timestamp +\n                oracle.FINALIZATION_PERIOD_SECONDS() +\n                1\n        );\n        // Fund the portal so that we can withdraw ETH.\n        vm.deal(address(portal), 0xFFFFFFFF);\n    }\n\n    // Utility function used in the subsequent test. This is necessary to assert that the\n    // reentrant call will revert.\n    function callPortalAndExpectRevert() external payable {\n        vm.expectRevert(\"KromaPortal: can only trigger one withdrawal per transaction\");\n        // Arguments here don't matter, as the require check is the first thing that happens.\n        // We assume that this has already been proven.\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n        // Assert that the withdrawal was not finalized.\n        assertFalse(portal.finalizedWithdrawals(Hashing.hashWithdrawal(_defaultTx)));\n    }\n\n    /**\n     * @notice Proving withdrawal transactions should revert when paused\n     */\n    function test_proveWithdrawalTransaction_paused_reverts() external {\n        vm.prank(portal.GUARDIAN());\n        portal.pause();\n\n        vm.expectRevert(\"KromaPortal: paused\");\n        portal.proveWithdrawalTransaction({\n            _tx: _defaultTx,\n            _l2OutputIndex: _submittedOutputIndex,\n            _outputRootProof: _outputRootProof,\n            _withdrawalProof: _withdrawalProof\n        });\n    }\n\n    // Test: proveWithdrawalTransaction cannot prove a withdrawal with itself (the KromaPortal) as the target.\n    function test_proveWithdrawalTransaction_onSelfCall_reverts() external {\n        _defaultTx.target = address(portal);\n        vm.expectRevert(\"KromaPortal: you cannot send messages to the portal contract\");\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n\n    // Test: proveWithdrawalTransaction reverts if the outputRootProof does not match the output root\n    function test_proveWithdrawalTransaction_onInvalidOutputRootProof_reverts() external {\n        // Modify the version to invalidate the withdrawal proof.\n        _outputRootProof.version = bytes32(uint256(1));\n        vm.expectRevert(\"KromaPortal: invalid output root proof\");\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n\n    // Test: proveWithdrawalTransaction reverts if the passed transaction's withdrawalHash has\n    // already been proven.\n    function test_proveWithdrawalTransaction_replayProve_reverts() external {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        vm.expectRevert(\"KromaPortal: withdrawal hash has already been proven\");\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n\n    // Test: proveWithdrawalTransaction succeeds if the passed transaction's withdrawalHash has\n    // already been proven AND the output root has changed AND the l2BlockNumber stays the same.\n    function test_proveWithdrawalTransaction_replayProveChangedOutputRoot_succeeds() external {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Compute the storage slot of the outputRoot corresponding to the `withdrawalHash`\n        // inside of the `provenWithdrawal`s mapping.\n        bytes32 slot;\n        assembly {\n            mstore(0x00, sload(_withdrawalHash.slot))\n            mstore(0x20, 52) // 52 is the slot of the `provenWithdrawals` mapping in KromaPortal\n            slot := keccak256(0x00, 0x40)\n        }\n\n        // Store a different output root within the `provenWithdrawals` mapping without\n        // touching the l2BlockNumber or timestamp.\n        vm.store(address(portal), slot, bytes32(0));\n\n        // Warp ahead 1 second\n        vm.warp(block.timestamp + 1);\n\n        // Even though we have already proven this withdrawalHash, we should be allowed to re-submit\n        // our proof with a changed outputRoot\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Ensure that the withdrawal was updated within the mapping\n        (, uint128 timestamp, ) = portal.provenWithdrawals(_withdrawalHash);\n        assertEq(timestamp, block.timestamp);\n    }\n\n    // Test: proveWithdrawalTransaction succeeds if the passed transaction's withdrawalHash has\n    // already been proven AND the output root + output index + l2BlockNumber changes.\n    function test_proveWithdrawalTransaction_replayProveChangedOutputRootAndOutputIndex_succeeds()\n        external\n    {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Compute the storage slot of the outputRoot corresponding to the `withdrawalHash`\n        // inside of the `provenWithdrawal`s mapping.\n        bytes32 slot;\n        assembly {\n            mstore(0x00, sload(_withdrawalHash.slot))\n            mstore(0x20, 52) // 52 is the slot of the `provenWithdrawals` mapping in KromaPortal\n            slot := keccak256(0x00, 0x40)\n        }\n\n        // Store a dummy output root within the `provenWithdrawals` mapping without touching the\n        // l2BlockNumber or timestamp.\n        vm.store(address(portal), slot, bytes32(0));\n\n        // Fetch the checkpoint output at `_submittedOutputIndex` from the L2OutputOracle\n        Types.CheckpointOutput memory output = portal.L2_ORACLE().getL2Output(_submittedOutputIndex);\n\n        // Propose the same output root again, creating the same output at a different index + l2BlockNumber.\n        vm.startPrank(portal.L2_ORACLE().VALIDATOR());\n        portal.L2_ORACLE().submitL2Output(\n            output.outputRoot,\n            portal.L2_ORACLE().nextBlockNumber(),\n            blockhash(block.number),\n            block.number\n        );\n        vm.stopPrank();\n\n        // Warp ahead 1 second\n        vm.warp(block.timestamp + 1);\n\n        // Even though we have already proven this withdrawalHash, we should be allowed to re-submit\n        // our proof with a changed outputRoot + a different output index\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex + 1,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Ensure that the withdrawal was updated within the mapping\n        (, uint128 timestamp, ) = portal.provenWithdrawals(_withdrawalHash);\n        assertEq(timestamp, block.timestamp);\n    }\n\n    // Test: proveWithdrawalTransaction succeeds and emits the WithdrawalProven event.\n    function test_proveWithdrawalTransaction_validWithdrawalProof_succeeds() external {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n\n    // Test: finalizeWithdrawalTransaction succeeds and emits the WithdrawalFinalized event.\n    function test_finalizeWithdrawalTransaction_provenWithdrawalHash_succeeds() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        vm.expectEmit(true, true, false, true);\n        emit WithdrawalFinalized(_withdrawalHash, true);\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        assert(address(bob).balance == bobBalanceBefore + 100);\n    }\n\n    /**\n     * @notice Finalizing withdrawal transactions should revert when paused\n     */\n    function test_finalizeWithdrawalTransaction_paused_reverts() external {\n        vm.prank(portal.GUARDIAN());\n        portal.pause();\n\n        vm.expectRevert(\"KromaPortal: paused\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the withdrawal has not been proven.\n    function test_finalizeWithdrawalTransaction_ifWithdrawalNotProven_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        vm.expectRevert(\"KromaPortal: withdrawal has not been proven yet\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        assert(address(bob).balance == bobBalanceBefore);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if withdrawal not proven long enough ago.\n    function test_finalizeWithdrawalTransaction_ifWithdrawalProofNotOldEnough_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Mock a call where the resulting output root is anything but the original output root. In\n        // this case we just use bytes32(uint256(1)).\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(bytes32(uint256(1)), _submittedBlockNumber)\n        );\n\n        vm.expectRevert(\"KromaPortal: proven withdrawal finalization period has not elapsed\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        assert(address(bob).balance == bobBalanceBefore);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the provenWithdrawal's timestamp is less\n    // than the L2 output oracle's starting timestamp\n    function test_finalizeWithdrawalTransaction_timestampLessThanL2OracleStart_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        // Prove our withdrawal\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Warp to after the finalization period\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Mock a startingTimestamp change on the L2 Oracle\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSignature(\"startingTimestamp()\"),\n            abi.encode(block.timestamp + 1)\n        );\n\n        // Attempt to finalize the withdrawal\n        vm.expectRevert(\n            \"KromaPortal: withdrawal timestamp less than L2 Oracle starting timestamp\"\n        );\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        // Ensure that bob's balance has remained the same\n        assertEq(bobBalanceBefore, address(bob).balance);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the output root proven is not the same as the\n    // output root at the time of finalization.\n    function test_finalizeWithdrawalTransaction_ifOutputRootChanges_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        // Prove our withdrawal\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Warp to after the finalization period\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Mock an outputRoot change on the checkpoint output before attempting\n        // to finalize the withdrawal.\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.CheckpointOutput(\n                    bytes32(uint256(0)),\n                    uint128(block.timestamp),\n                    uint128(_submittedBlockNumber)\n                )\n            )\n        );\n\n        // Attempt to finalize the withdrawal\n        vm.expectRevert(\n            \"KromaPortal: output root proven is not the same as current output root\"\n        );\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        // Ensure that bob's balance has remained the same\n        assertEq(bobBalanceBefore, address(bob).balance);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the checkpoint output's timestamp has\n    // not passed the finalization period.\n    function test_finalizeWithdrawalTransaction_ifOutputTimestampIsNotFinalized_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        // Prove our withdrawal\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Warp to after the finalization period\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Mock a timestamp change on the checkpoint output that has not passed the\n        // finalization period.\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.CheckpointOutput(\n                    _outputRoot,\n                    uint128(block.timestamp + 1),\n                    uint128(_submittedBlockNumber)\n                )\n            )\n        );\n\n        // Attempt to finalize the withdrawal\n        vm.expectRevert(\"KromaPortal: checkpoint output finalization period has not elapsed\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        // Ensure that bob's balance has remained the same\n        assertEq(bobBalanceBefore, address(bob).balance);\n    }\n\n    // Test: finalizeWithdrawalTransaction fails because the target reverts,\n    // and emits the WithdrawalFinalized event with success=false.\n    function test_finalizeWithdrawalTransaction_targetFails_fails() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n        vm.etch(bob, hex\"fe\"); // Contract with just the invalid opcode.\n\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalFinalized(_withdrawalHash, false);\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        assert(address(bob).balance == bobBalanceBefore);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the finalization period has not yet passed.\n    function test_finalizeWithdrawalTransaction_onRecentWithdrawal_reverts() external {\n        // Setup the Oracle to return an output with a recent timestamp\n        uint256 recentTimestamp = block.timestamp - 1000;\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.CheckpointOutput(\n                    _outputRoot,\n                    uint128(recentTimestamp),\n                    uint128(_submittedBlockNumber)\n                )\n            )\n        );\n\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        vm.expectRevert(\"KromaPortal: proven withdrawal finalization period has not elapsed\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the withdrawal has already been finalized.\n    function test_finalizeWithdrawalTransaction_onReplay_reverts() external {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalFinalized(_withdrawalHash, true);\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        vm.expectRevert(\"KromaPortal: withdrawal has already been finalized\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if insufficient gas is supplied.\n    function test_finalizeWithdrawalTransaction_onInsufficientGas_reverts() external {\n        // This number was identified through trial and error.\n        uint256 gasLimit = 150_000;\n        Types.WithdrawalTransaction memory insufficientGasTx = Types.WithdrawalTransaction({\n            nonce: 0,\n            sender: alice,\n            target: bob,\n            value: 100,\n            gasLimit: gasLimit,\n            data: hex\"\"\n        });\n\n        // Get updated proof inputs.\n        (bytes32 stateRoot, bytes32 storageRoot, , , bytes[] memory withdrawalProof) = ffi\n            .getProveWithdrawalTransactionInputs(insufficientGasTx);\n        Types.OutputRootProof memory outputRootProof = Types.OutputRootProof({\n            version: bytes32(0),\n            stateRoot: stateRoot,\n            messagePasserStorageRoot: storageRoot,\n            latestBlockhash: bytes32(0)\n        });\n\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.CheckpointOutput(\n                    Hashing.hashOutputRootProof(outputRootProof),\n                    uint128(block.timestamp),\n                    uint128(_submittedBlockNumber)\n                )\n            )\n        );\n\n        portal.proveWithdrawalTransaction(\n            insufficientGasTx,\n            _submittedOutputIndex,\n            outputRootProof,\n            withdrawalProof\n        );\n\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        vm.expectRevert(\"SafeCall: Not enough gas\");\n        portal.finalizeWithdrawalTransaction{ gas: gasLimit }(insufficientGasTx);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if a sub-call attempts to finalize another\n    // withdrawal.\n    function test_finalizeWithdrawalTransaction_onReentrancy_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        // Copy and modify the default test values to attempt a reentrant call by first calling to\n        // this contract's callPortalAndExpectRevert() function above.\n        Types.WithdrawalTransaction memory _testTx = _defaultTx;\n        _testTx.target = address(this);\n        _testTx.data = abi.encodeWithSelector(this.callPortalAndExpectRevert.selector);\n\n        // Get modified proof inputs.\n        (\n            bytes32 stateRoot,\n            bytes32 storageRoot,\n            bytes32 outputRoot,\n            bytes32 withdrawalHash,\n            bytes[] memory withdrawalProof\n        ) = ffi.getProveWithdrawalTransactionInputs(_testTx);\n        Types.OutputRootProof memory outputRootProof = Types.OutputRootProof({\n            version: bytes32(0),\n            stateRoot: stateRoot,\n            messagePasserStorageRoot: storageRoot,\n            latestBlockhash: bytes32(0)\n        });\n\n        // Setup the Oracle to return the outputRoot we want as well as a finalized timestamp.\n        uint256 finalizedTimestamp = block.timestamp - oracle.FINALIZATION_PERIOD_SECONDS() - 1;\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.CheckpointOutput(\n                    outputRoot,\n                    uint128(finalizedTimestamp),\n                    uint128(_submittedBlockNumber)\n                )\n            )\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(withdrawalHash, alice, address(this));\n        portal.proveWithdrawalTransaction(\n            _testTx,\n            _submittedBlockNumber,\n            outputRootProof,\n            withdrawalProof\n        );\n\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        vm.expectCall(address(this), _testTx.data);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalFinalized(withdrawalHash, true);\n        portal.finalizeWithdrawalTransaction(_testTx);\n\n        // Ensure that bob's balance was not changed by the reentrant call.\n        assert(address(bob).balance == bobBalanceBefore);\n    }\n\n    /*\n    NOTE(chokobole): disable this test as Optimism also fails.\n    function testDiff_finalizeWithdrawalTransaction_succeeds(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        // Cannot call the kroma portal\n        vm.assume(_target != address(portal));\n        // Total ETH supply is currently about 120M ETH.\n        uint256 value = bound(_value, 0, 200_000_000 ether);\n        uint256 gasLimit = bound(_gasLimit, 0, 50_000_000);\n        uint256 nonce = messagePasser.messageNonce();\n        Types.WithdrawalTransaction memory _tx = Types.WithdrawalTransaction({\n            nonce: nonce,\n            sender: _sender,\n            target: _target,\n            value: value,\n            gasLimit: gasLimit,\n            data: _data\n        });\n        (\n            bytes32 stateRoot,\n            bytes32 storageRoot,\n            bytes32 outputRoot,\n            bytes32 withdrawalHash,\n            bytes[] memory withdrawalProof\n        ) = ffi.getProveWithdrawalTransactionInputs(_tx);\n\n        Types.OutputRootProof memory proof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: stateRoot,\n            messagePasserStorageRoot: storageRoot,\n            latestBlockhash: bytes32(uint256(0))\n        });\n\n        // Ensure the values returned from ffi are correct\n        assertEq(outputRoot, Hashing.hashOutputRootProof(proof));\n        assertEq(withdrawalHash, Hashing.hashWithdrawal(_tx));\n\n        // Mock the call to the oracle\n        vm.mockCall(\n            address(oracle),\n            abi.encodeWithSelector(oracle.getL2Output.selector),\n            abi.encode(outputRoot, 0)\n        );\n\n        // Start the withdrawal, it must be initiated by the _sender and the\n        // correct value must be passed along\n        vm.deal(_tx.sender, _tx.value);\n        vm.prank(_tx.sender);\n        messagePasser.initiateWithdrawal{ value: _tx.value }(_tx.target, _tx.gasLimit, _tx.data);\n\n        // Ensure that the sentMessages is correct\n        assertEq(messagePasser.sentMessages(withdrawalHash), true);\n\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        portal.proveWithdrawalTransaction(\n            _tx,\n            100, // l2BlockNumber\n            proof,\n            withdrawalProof\n        );\n    }\n    */\n}\n\ncontract KromaPortalUpgradeable_Test is Portal_Initializer {\n    Proxy internal proxy;\n    uint64 initialBlockNum;\n\n    function setUp() public override {\n        super.setUp();\n        initialBlockNum = uint64(block.number);\n        proxy = Proxy(payable(address(portal)));\n    }\n\n    function test_params_initValuesOnProxy_succeeds() external {\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = KromaPortal(\n            payable(address(proxy))\n        ).params();\n        assertEq(prevBaseFee, portalImpl.INITIAL_BASE_FEE());\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum);\n    }\n\n    function test_initialize_cannotInitProxy_reverts() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        KromaPortal(payable(proxy)).initialize(false);\n    }\n\n    function test_initialize_cannotInitImpl_reverts() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        KromaPortal(portalImpl).initialize(false);\n    }\n\n    function test_upgradeToAndCall_upgrading_succeeds() external {\n        // Check an unused slot before upgrading.\n        bytes32 slot21Before = vm.load(address(portal), bytes32(uint256(21)));\n        assertEq(bytes32(0), slot21Before);\n\n        NextImpl nextImpl = new NextImpl();\n        vm.startPrank(multisig);\n        proxy.upgradeToAndCall(\n            address(nextImpl),\n            abi.encodeWithSelector(NextImpl.initialize.selector)\n        );\n        assertEq(proxy.implementation(), address(nextImpl));\n\n        // Verify that the NextImpl contract initialized its values according as expected\n        bytes32 slot21After = vm.load(address(portal), bytes32(uint256(21)));\n        bytes32 slot21Expected = NextImpl(address(portal)).slot21Init();\n        assertEq(slot21Expected, slot21After);\n    }\n}\n"
    },
    "contracts/test/L1Block.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { L1Block } from \"../L2/L1Block.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract L1BlockTest is CommonTest {\n    L1Block lb;\n    address depositor;\n    bytes32 immutable NON_ZERO_HASH = keccak256(abi.encode(1));\n\n    function setUp() public override {\n        super.setUp();\n        lb = new L1Block();\n        depositor = lb.DEPOSITOR_ACCOUNT();\n        vm.prank(depositor);\n        lb.setL1BlockValues({\n            _number: uint64(1),\n            _timestamp: uint64(2),\n            _basefee: 3,\n            _hash: NON_ZERO_HASH,\n            _sequenceNumber: uint64(4),\n            _batcherHash: bytes32(0),\n            _l1FeeOverhead: 2,\n            _l1FeeScalar: 3\n        });\n    }\n\n    function testFuzz_updatesValues_succeeds(\n        uint64 n,\n        uint64 t,\n        uint256 b,\n        bytes32 h,\n        uint64 s,\n        bytes32 bt,\n        uint256 fo,\n        uint256 fs\n    ) external {\n        vm.prank(depositor);\n        lb.setL1BlockValues(n, t, b, h, s, bt, fo, fs);\n        assertEq(lb.number(), n);\n        assertEq(lb.timestamp(), t);\n        assertEq(lb.basefee(), b);\n        assertEq(lb.hash(), h);\n        assertEq(lb.sequenceNumber(), s);\n        assertEq(lb.batcherHash(), bt);\n        assertEq(lb.l1FeeOverhead(), fo);\n        assertEq(lb.l1FeeScalar(), fs);\n    }\n\n    function test_number_succeeds() external {\n        assertEq(lb.number(), uint64(1));\n    }\n\n    function test_timestamp_succeeds() external {\n        assertEq(lb.timestamp(), uint64(2));\n    }\n\n    function test_basefee_succeeds() external {\n        assertEq(lb.basefee(), 3);\n    }\n\n    function test_hash_succeeds() external {\n        assertEq(lb.hash(), NON_ZERO_HASH);\n    }\n\n    function test_sequenceNumber_succeeds() external {\n        assertEq(lb.sequenceNumber(), uint64(4));\n    }\n\n    function test_updateValues_succeeds() external {\n        vm.prank(depositor);\n        lb.setL1BlockValues({\n            _number: type(uint64).max,\n            _timestamp: type(uint64).max,\n            _basefee: type(uint256).max,\n            _hash: keccak256(abi.encode(1)),\n            _sequenceNumber: type(uint64).max,\n            _batcherHash: bytes32(type(uint256).max),\n            _l1FeeOverhead: type(uint256).max,\n            _l1FeeScalar: type(uint256).max\n        });\n    }\n}\n"
    },
    "contracts/test/L1CrossDomainMessenger.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n\n\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { KromaPortal } from \"../L1/KromaPortal.sol\";\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Messenger_Initializer, Reverter, ConfigurableCaller } from \"./CommonTest.t.sol\";\nimport { L2OutputOracle_Initializer } from \"./L2OutputOracle.t.sol\";\n\ncontract L1CrossDomainMessenger_Test is Messenger_Initializer {\n    // Receiver address for testing\n    address recipient = address(0xabbaacdc);\n\n    // Storage slot of the l2Sender\n    uint256 constant senderSlotIndex = 50;\n\n    // the version is encoded in the nonce\n    function test_messageVersion_succeeds() external {\n        (, uint16 version) = Encoding.decodeVersionedNonce(L1Messenger.messageNonce());\n        assertEq(version, L1Messenger.MESSAGE_VERSION());\n    }\n\n    // sendMessage: should be able to send a single message\n    function test_sendMessage_succeeds() external {\n        // deposit transaction on the kroma portal should be called\n        vm.expectCall(\n            address(portal),\n            abi.encodeWithSelector(\n                KromaPortal.depositTransaction.selector,\n                Predeploys.L2_CROSS_DOMAIN_MESSENGER,\n                0,\n                L1Messenger.baseGas(hex\"ff\", 100),\n                false,\n                Encoding.encodeCrossDomainMessage(\n                    L1Messenger.messageNonce(),\n                    alice,\n                    recipient,\n                    0,\n                    100,\n                    hex\"ff\"\n                )\n            )\n        );\n\n        // TransactionDeposited event\n        vm.expectEmit(true, true, true, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)),\n            Predeploys.L2_CROSS_DOMAIN_MESSENGER,\n            0,\n            0,\n            L1Messenger.baseGas(hex\"ff\", 100),\n            false,\n            Encoding.encodeCrossDomainMessage(\n                L1Messenger.messageNonce(),\n                alice,\n                recipient,\n                0,\n                100,\n                hex\"ff\"\n            )\n        );\n\n        // SentMessage event\n        vm.expectEmit(true, true, true, true);\n        emit SentMessage(recipient, alice, 0, hex\"ff\", L1Messenger.messageNonce(), 100);\n\n        vm.prank(alice);\n        L1Messenger.sendMessage(recipient, hex\"ff\", uint32(100));\n    }\n\n    // sendMessage: should be able to send the same message twice\n    function test_sendMessage_twice_succeeds() external {\n        uint256 nonce = L1Messenger.messageNonce();\n        L1Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        L1Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        // the nonce increments for each message sent\n        assertEq(nonce + 2, L1Messenger.messageNonce());\n    }\n\n    function test_xDomainSender_notSet_reverts() external {\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L1Messenger.xDomainMessageSender();\n    }\n\n    // xDomainMessageSender: should return the xDomainMsgSender address\n    // TODO: might need a test contract\n    // function test_xDomainSenderSetCorrectly() external {}\n\n    function test_relayMessage_v2_reverts() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        // Set the value of portal.l2Sender() to be the L2 Cross Domain Messenger.\n        vm.store(address(portal), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n\n        // Expect a revert.\n        vm.expectRevert(\n            \"CrossDomainMessenger: only version 0 messages is supported at this time\"\n        );\n\n        // Try to relay a v2 message.\n        vm.prank(address(portal));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 2 }), // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            hex\"1111\"\n        );\n    }\n\n    // relayMessage: should send a successful call to the target contract\n    function test_relayMessage_succeeds() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        vm.expectCall(target, hex\"1111\");\n\n        // set the value of portal.l2Sender() to be the L2 Cross Domain Messenger.\n        vm.store(address(portal), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n        vm.prank(address(portal));\n\n        vm.expectEmit(true, true, true, true);\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            hex\"1111\"\n        );\n\n        emit RelayedMessage(hash);\n\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            hex\"1111\"\n        );\n\n        // the message hash is in the successfulMessages mapping\n        assert(L1Messenger.successfulMessages(hash));\n        // it is not in the received messages mapping\n        assertEq(L1Messenger.failedMessages(hash), false);\n    }\n\n    // relayMessage: should revert if attempting to relay a message sent to an L1 system contract\n    function test_relayMessage_toSystemContract_reverts() external {\n        // set the target to be the KromaPortal\n        address target = address(portal);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n        bytes memory message = hex\"1111\";\n\n        vm.prank(address(portal));\n        vm.expectRevert(\"CrossDomainMessenger: message cannot be replayed\");\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            message\n        );\n\n        vm.store(address(portal), 0, bytes32(abi.encode(sender)));\n        vm.expectRevert(\"CrossDomainMessenger: message cannot be replayed\");\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            message\n        );\n    }\n\n    // relayMessage: should revert if eth is sent from a contract other than the standard bridge\n    function test_replayMessage_withValue_reverts() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n        bytes memory message = hex\"1111\";\n\n        vm.expectRevert(\n            \"CrossDomainMessenger: value must be zero unless message is from a system address\"\n        );\n        L1Messenger.relayMessage{ value: 100 }(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            message\n        );\n    }\n\n    // relayMessage: the xDomainMessageSender is reset to the original value\n    function test_xDomainMessageSender_reset_succeeds() external {\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L1Messenger.xDomainMessageSender();\n\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        vm.store(address(portal), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n        vm.prank(address(portal));\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            address(0),\n            address(0),\n            0,\n            0,\n            hex\"\"\n        );\n\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L1Messenger.xDomainMessageSender();\n    }\n\n    // relayMessage: should send a successful call to the target contract after the first message\n    // fails and ETH gets stuck, but the second message succeeds\n    function test_relayMessage_retryAfterFailure_succeeds() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n        uint256 value = 100;\n\n        vm.expectCall(target, hex\"1111\");\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        vm.store(address(portal), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n        vm.etch(target, address(new Reverter()).code);\n        vm.deal(address(portal), value);\n        vm.prank(address(portal));\n        L1Messenger.relayMessage{ value: value }(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        assertEq(address(L1Messenger).balance, value);\n        assertEq(address(target).balance, 0);\n        assertEq(L1Messenger.successfulMessages(hash), false);\n        assertEq(L1Messenger.failedMessages(hash), true);\n\n        vm.expectEmit(true, true, true, true);\n\n        emit RelayedMessage(hash);\n\n        vm.etch(target, address(0).code);\n        vm.prank(address(sender));\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        assertEq(address(L1Messenger).balance, 0);\n        assertEq(address(target).balance, value);\n        assertEq(L1Messenger.successfulMessages(hash), true);\n        assertEq(L1Messenger.failedMessages(hash), true);\n    }\n\n    // relayMessage: Should revert if the recipient is trying to reenter with the\n    // same message.\n    function test_relayMessage_reentrancySameMessage_reverts() external {\n        ConfigurableCaller caller = new ConfigurableCaller();\n        address target = address(caller);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n        bytes memory callMessage = abi.encodeWithSelector(caller.call.selector);\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            callMessage\n        );\n\n        // Set the portal's `l2Sender` to the `sender`.\n        vm.store(address(portal), bytes32(senderSlotIndex), bytes32(uint256(uint160(sender))));\n\n        // Act as the portal and call the `relayMessage` function with the `innerMessage`.\n        vm.prank(address(portal));\n        vm.expectCall(target, callMessage);\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            callMessage\n        );\n\n        // Assert that the message failed to be relayed\n        assertFalse(L1Messenger.successfulMessages(hash));\n        assertTrue(L1Messenger.failedMessages(hash));\n\n        // Set the configurable caller's target to `L1Messenger` and set the payload to `relayMessage(...)`.\n        caller.setDoRevert(false);\n        caller.setTarget(address(L1Messenger));\n        caller.setPayload(\n            abi.encodeWithSelector(\n                L1Messenger.relayMessage.selector,\n                Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n                sender,\n                target,\n                0,\n                0,\n                callMessage\n            )\n        );\n\n        // Attempt to replay the failed message, which will *not* immediately revert this time around,\n        // but attempt to reenter `relayMessage` with the same message hash. The reentrancy attempt should\n        // revert.\n        vm.expectEmit(true, true, true, true, target);\n        emit WhatHappened(\n            false,\n            abi.encodeWithSignature(\"Error(string)\", \"ReentrancyGuard: reentrant call\")\n        );\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            0,\n            0,\n            callMessage\n        );\n\n        // Assert that the message still failed to be relayed.\n        assertFalse(L1Messenger.successfulMessages(hash));\n        assertTrue(L1Messenger.failedMessages(hash));\n    }\n\n    // relayMessage: should not revert if the recipient reenters `relayMessage` with a different\n    // message hash.\n    function test_relayMessage_reentrancyDiffMessage_succeeds() external {\n        ConfigurableCaller caller = new ConfigurableCaller();\n        address target = address(caller);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n        bytes memory messageA = abi.encodeWithSelector(caller.call.selector);\n        bytes memory messageB = hex\"\";\n\n        bytes32 hashA = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            messageA\n        );\n        bytes32 hashB = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            messageB\n        );\n\n        // Set the portal's `l2Sender` to the `sender`.\n        vm.store(address(portal), bytes32(senderSlotIndex), bytes32(uint256(uint160(sender))));\n\n        // Act as the portal and call the `relayMessage` function with both `messageA` and `messageB`.\n        vm.startPrank(address(portal));\n\n        vm.expectCall(target, messageA);\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            messageA\n        );\n        vm.expectCall(target, messageB);\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            messageB\n        );\n\n        // Stop acting as the portal\n        vm.stopPrank();\n\n        // Assert that both messages failed to be relayed\n        assertFalse(L1Messenger.successfulMessages(hashA));\n        assertFalse(L1Messenger.successfulMessages(hashB));\n        assertTrue(L1Messenger.failedMessages(hashA));\n        assertTrue(L1Messenger.failedMessages(hashB));\n\n        // Set the configurable caller's target to `L1Messenger` and set the payload to `relayMessage(...)`.\n        caller.setDoRevert(false);\n        caller.setTarget(address(L1Messenger));\n        caller.setPayload(\n            abi.encodeWithSelector(\n                L1Messenger.relayMessage.selector,\n                Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n                sender,\n                target,\n                0,\n                0,\n                messageB\n            )\n        );\n\n        // Attempt to replay the failed message, which will *not* immediately revert this time around,\n        // but attempt to reenter `relayMessage` with messageB. The reentrancy attempt should succeed\n        // because the message hashes are different.\n        vm.expectEmit(true, true, true, true, target);\n        emit WhatHappened(true, hex\"\");\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            messageA\n        );\n\n        // Assert that both messages are now in the `successfulMessages` mapping.\n        assertTrue(L1Messenger.successfulMessages(hashA));\n        assertTrue(L1Messenger.successfulMessages(hashB));\n    }\n}\n"
    },
    "contracts/test/L1ERC721Bridge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport { L1ERC721Bridge } from \"../L1/L1ERC721Bridge.sol\";\nimport { L2ERC721Bridge } from \"../L2/L2ERC721Bridge.sol\";\nimport { Messenger_Initializer } from \"./CommonTest.t.sol\";\n\ncontract TestERC721 is ERC721 {\n    constructor() ERC721(\"Test\", \"TST\") {}\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n}\n\ncontract L1ERC721Bridge_Test is Messenger_Initializer {\n    TestERC721 internal localToken;\n    TestERC721 internal remoteToken;\n    L1ERC721Bridge internal bridge;\n    address internal constant otherBridge = address(0x3456);\n    uint256 internal constant tokenId = 1;\n\n    event ERC721BridgeInitiated(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    event ERC721BridgeFinalized(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    function setUp() public override {\n        super.setUp();\n\n        // Create necessary contracts.\n        bridge = new L1ERC721Bridge(address(L1Messenger), otherBridge);\n        localToken = new TestERC721();\n        remoteToken = new TestERC721();\n\n        // Label the bridge so we get nice traces.\n        vm.label(address(bridge), \"L1ERC721Bridge\");\n\n        // Mint alice a token.\n        localToken.mint(alice, tokenId);\n\n        // Approve the bridge to transfer the token.\n        vm.prank(alice);\n        localToken.approve(address(bridge), tokenId);\n    }\n\n    function test_constructor_succeeds() public {\n        assertEq(address(bridge.MESSENGER()), address(L1Messenger));\n        assertEq(address(bridge.OTHER_BRIDGE()), otherBridge);\n    }\n\n    function test_bridgeERC721_succeeds() public {\n        // Expect a call to the messenger.\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeCall(\n                L1Messenger.sendMessage,\n                (\n                    address(otherBridge),\n                    abi.encodeCall(\n                        L2ERC721Bridge.finalizeBridgeERC721,\n                        (\n                            address(remoteToken),\n                            address(localToken),\n                            alice,\n                            alice,\n                            tokenId,\n                            hex\"5678\"\n                        )\n                    ),\n                    1234\n                )\n            )\n        );\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeInitiated(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), true);\n        assertEq(localToken.ownerOf(tokenId), address(bridge));\n    }\n\n    function test_bridgeERC721_fromContract_reverts() external {\n        // Bridge the token.\n        vm.etch(alice, hex\"01\");\n        vm.prank(alice);\n        vm.expectRevert(\"ERC721Bridge: account is not externally owned\");\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_localTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert();\n        bridge.bridgeERC721(address(0), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_remoteTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert(\"L1ERC721Bridge: remote token cannot be address(0)\");\n        bridge.bridgeERC721(address(localToken), address(0), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_wrongOwner_reverts() external {\n        // Bridge the token.\n        vm.prank(bob);\n        vm.expectRevert(\"ERC721: transfer from incorrect owner\");\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_succeeds() external {\n        // Expect a call to the messenger.\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeCall(\n                L1Messenger.sendMessage,\n                (\n                    address(otherBridge),\n                    abi.encodeCall(\n                        L2ERC721Bridge.finalizeBridgeERC721,\n                        (address(remoteToken), address(localToken), alice, bob, tokenId, hex\"5678\")\n                    ),\n                    1234\n                )\n            )\n        );\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeInitiated(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            bob,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721To(\n            address(localToken),\n            address(remoteToken),\n            bob,\n            tokenId,\n            1234,\n            hex\"5678\"\n        );\n\n        // Token is locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), true);\n        assertEq(localToken.ownerOf(tokenId), address(bridge));\n    }\n\n    function test_bridgeERC721To_localTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert();\n        bridge.bridgeERC721To(address(0), address(remoteToken), bob, tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_remoteTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert(\"L1ERC721Bridge: remote token cannot be address(0)\");\n        bridge.bridgeERC721To(address(localToken), address(0), bob, tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_wrongOwner_reverts() external {\n        // Bridge the token.\n        vm.prank(bob);\n        vm.expectRevert(\"ERC721: transfer from incorrect owner\");\n        bridge.bridgeERC721To(\n            address(localToken),\n            address(remoteToken),\n            bob,\n            tokenId,\n            1234,\n            hex\"5678\"\n        );\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_finalizeBridgeERC721_succeeds() external {\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeFinalized(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(L1Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L1Messenger));\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_finalizeBridgeERC721_notViaLocalMessenger_reverts() external {\n        // Finalize a withdrawal.\n        vm.prank(alice);\n        vm.expectRevert(\"ERC721Bridge: function can only be called from the other bridge\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_notFromRemoteMessenger_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(L1Messenger.xDomainMessageSender.selector),\n            abi.encode(alice)\n        );\n        vm.prank(address(L1Messenger));\n        vm.expectRevert(\"ERC721Bridge: function can only be called from the other bridge\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_selfToken_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(L1Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L1Messenger));\n        vm.expectRevert(\"L1ERC721Bridge: local token cannot be self\");\n        bridge.finalizeBridgeERC721(\n            address(bridge),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_notEscrowed_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(L1Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L1Messenger));\n        vm.expectRevert(\"L1ERC721Bridge: Token ID is not escrowed in the L1 Bridge\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n}\n"
    },
    "contracts/test/L1StandardBridge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { stdStorage, StdStorage } from \"forge-std/Test.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { KromaPortal } from \"../L1/KromaPortal.sol\";\nimport { L2StandardBridge } from \"../L2/L2StandardBridge.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\n\ncontract L1StandardBridge_Getter_Test is Bridge_Initializer {\n    function test_getters_succeeds() external {\n        assert(L1Bridge.OTHER_BRIDGE() == L2Bridge);\n        assert(L1Bridge.MESSENGER() == L1Messenger);\n        assertEq(L1Bridge.version(), \"0.1.0\");\n    }\n}\n\ncontract L1StandardBridge_Initialize_Test is Bridge_Initializer {\n    function test_initialize_succeeds() external {\n        assertEq(address(L1Bridge.MESSENGER()), address(L1Messenger));\n\n        assertEq(address(L1Bridge.OTHER_BRIDGE()), Predeploys.L2_STANDARD_BRIDGE);\n\n        assertEq(address(L2Bridge), Predeploys.L2_STANDARD_BRIDGE);\n    }\n}\n\ncontract L1StandardBridge_Initialize_TestFail is Bridge_Initializer {}\n\ncontract L1StandardBridge_Receive_Test is Bridge_Initializer {\n    // receive\n    // - can accept ETH\n    function test_receive_succeeds() external {\n        assertEq(address(portal).balance, 0);\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHBridgeInitiated(alice, alice, 100, hex\"\");\n\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                abi.encodeWithSelector(\n                    StandardBridge.finalizeBridgeETH.selector,\n                    alice,\n                    alice,\n                    100,\n                    hex\"\"\n                ),\n                200_000\n            )\n        );\n\n        vm.prank(alice, alice);\n        (bool success, ) = address(L1Bridge).call{ value: 100 }(hex\"\");\n        assertEq(success, true);\n        assertEq(address(portal).balance, 100);\n    }\n}\n\ncontract L1StandardBridge_Receive_TestFail {}\n\ncontract PreBridgeETH is Bridge_Initializer {\n    function _preBridgeETH() internal {\n        assertEq(address(portal).balance, 0);\n        uint256 nonce = L1Messenger.messageNonce();\n        uint256 version = 0; // Internal constant in the KromaPortal: DEPOSIT_VERSION\n        address l1MessengerAliased = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeETH.selector,\n            alice,\n            alice,\n            500,\n            hex\"dead\"\n        );\n\n        vm.expectCall(\n            address(L1Bridge),\n            500,\n            abi.encodeWithSelector(L1Bridge.bridgeETH.selector, 50000, hex\"dead\")\n        );\n\n        vm.expectCall(\n            address(L1Messenger),\n            500,\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                message,\n                50000\n            )\n        );\n\n        bytes memory innerMessage = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L1Bridge),\n            address(L2Bridge),\n            500,\n            50000,\n            message\n        );\n\n        uint64 baseGas = L1Messenger.baseGas(message, 50000);\n        vm.expectCall(\n            address(portal),\n            500,\n            abi.encodeWithSelector(\n                KromaPortal.depositTransaction.selector,\n                address(L2Messenger),\n                500,\n                baseGas,\n                false,\n                innerMessage\n            )\n        );\n\n        bytes memory opaqueData = abi.encodePacked(\n            uint256(500),\n            uint256(500),\n            baseGas,\n            false,\n            innerMessage\n        );\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHBridgeInitiated(alice, alice, 500, hex\"dead\");\n\n        // KromaPortal emits a TransactionDeposited event on `depositTransaction` call\n        vm.expectEmit(true, true, true, true, address(portal));\n        emit TransactionDeposited(l1MessengerAliased, address(L2Messenger), version, opaqueData);\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L1Messenger));\n        emit SentMessage(address(L2Bridge), address(L1Bridge), 500, message, nonce, 50000);\n\n        vm.prank(alice, alice);\n    }\n}\n\ncontract L1StandardBridge_BridgeETH_Test is PreBridgeETH {\n    // BridgeETH\n    // - emits ETHBridgeInitiated\n    // - calls kromaPortal.depositTransaction\n    // - only EOA\n    // - ETH ends up in the kromaPortal\n    function test_bridgeETH_succeeds() external {\n        _preBridgeETH();\n        L1Bridge.bridgeETH{ value: 500 }(50000, hex\"dead\");\n        assertEq(address(portal).balance, 500);\n    }\n}\n\ncontract L1StandardBridge_BridgeETH_TestFail is Bridge_Initializer {\n    function test_BridgeETH_notEoa_reverts() external {\n        // turn alice into a contract\n        vm.etch(alice, address(L1Token).code);\n\n        vm.expectRevert(\"StandardBridge: function can only be called from an EOA\");\n        vm.prank(alice);\n        L1Bridge.bridgeETH{ value: 1 }(300, hex\"\");\n    }\n}\n\ncontract PreBridgeETHTo is Bridge_Initializer {\n    function _preBridgeETHTo() internal {\n        assertEq(address(portal).balance, 0);\n        uint256 nonce = L1Messenger.messageNonce();\n        uint256 version = 0; // Internal constant in the KromaPortal: DEPOSIT_VERSION\n        address l1MessengerAliased = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        vm.expectCall(\n            address(L1Bridge),\n            600,\n            abi.encodeWithSelector(L1Bridge.bridgeETHTo.selector, bob, 60000, hex\"dead\")\n        );\n\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeETH.selector,\n            alice,\n            bob,\n            600,\n            hex\"dead\"\n        );\n\n        // the L1 bridge should call\n        // L1CrossDomainMessenger.sendMessage\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                message,\n                60000\n            )\n        );\n\n        bytes memory innerMessage = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L1Bridge),\n            address(L2Bridge),\n            600,\n            60000,\n            message\n        );\n\n        uint64 baseGas = L1Messenger.baseGas(message, 60000);\n        vm.expectCall(\n            address(portal),\n            abi.encodeWithSelector(\n                KromaPortal.depositTransaction.selector,\n                address(L2Messenger),\n                600,\n                baseGas,\n                false,\n                innerMessage\n            )\n        );\n\n        bytes memory opaqueData = abi.encodePacked(\n            uint256(600),\n            uint256(600),\n            baseGas,\n            false,\n            innerMessage\n        );\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHBridgeInitiated(alice, bob, 600, hex\"dead\");\n\n        // KromaPortal emits a TransactionDeposited event on `depositTransaction` call\n        vm.expectEmit(true, true, true, true, address(portal));\n        emit TransactionDeposited(l1MessengerAliased, address(L2Messenger), version, opaqueData);\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L1Messenger));\n        emit SentMessage(address(L2Bridge), address(L1Bridge), 600, message, nonce, 60000);\n\n        // deposit eth to bob\n        vm.prank(alice, alice);\n    }\n}\n\ncontract L1StandardBridge_BridgeETHTo_Test is PreBridgeETHTo {\n    // BridgeETHTo\n    // - emits ETHBridgeInitiated\n    // - calls kromaPortal.depositTransaction\n    // - only EOA\n    // - ETH ends up in the kromaPortal\n    function test_bridgeETHTo_succeeds() external {\n        _preBridgeETHTo();\n        L1Bridge.bridgeETHTo{ value: 600 }(bob, 60000, hex\"dead\");\n        assertEq(address(portal).balance, 600);\n    }\n}\n\ncontract L1StandardBridge_BridgeETHTo_TestFail is Bridge_Initializer {}\n\ncontract L1StandardBridge_BridgeERC20_Test is Bridge_Initializer {\n    using stdStorage for StdStorage;\n\n    // bridgeERC20\n    // - updates bridge.deposits\n    // - calls kromaPortal.depositTransaction\n    // - only callable by EOA\n    function test_bridgeERC20_succeeds() external {\n        uint256 nonce = L1Messenger.messageNonce();\n        uint256 version = 0; // Internal constant in the KromaPortal: DEPOSIT_VERSION\n        address l1MessengerAliased = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        // Deal Alice's ERC20 State\n        deal(address(L1Token), alice, 100000, true);\n        vm.prank(alice);\n        L1Token.approve(address(L1Bridge), type(uint256).max);\n\n        // The L1Bridge should transfer alice's tokens to itself\n        vm.expectCall(\n            address(L1Token),\n            abi.encodeWithSelector(ERC20.transferFrom.selector, alice, address(L1Bridge), 100)\n        );\n\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeERC20.selector,\n            address(L2Token),\n            address(L1Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n\n        // the L1 bridge should call L1CrossDomainMessenger.sendMessage\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                message,\n                10000\n            )\n        );\n\n        bytes memory innerMessage = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L1Bridge),\n            address(L2Bridge),\n            0,\n            10000,\n            message\n        );\n\n        uint64 baseGas = L1Messenger.baseGas(message, 10000);\n        vm.expectCall(\n            address(portal),\n            abi.encodeWithSelector(\n                KromaPortal.depositTransaction.selector,\n                address(L2Messenger),\n                0,\n                baseGas,\n                false,\n                innerMessage\n            )\n        );\n\n        bytes memory opaqueData = abi.encodePacked(\n            uint256(0),\n            uint256(0),\n            baseGas,\n            false,\n            innerMessage\n        );\n\n        // ERC20BridgeInitiated event emitted by the StandardBridge\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ERC20BridgeInitiated(address(L1Token), address(L2Token), alice, alice, 100, hex\"\");\n\n        // KromaPortal emits a TransactionDeposited event on `depositTransaction` call\n        vm.expectEmit(true, true, true, true, address(portal));\n        emit TransactionDeposited(l1MessengerAliased, address(L2Messenger), version, opaqueData);\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L1Messenger));\n        emit SentMessage(address(L2Bridge), address(L1Bridge), 0, message, nonce, 10000);\n\n        vm.prank(alice);\n        L1Bridge.bridgeERC20(address(L1Token), address(L2Token), 100, 10000, hex\"\");\n        assertEq(L1Bridge.deposits(address(L1Token), address(L2Token)), 100);\n    }\n}\n\ncontract L1StandardBridge_BridgeERC20_TestFail is Bridge_Initializer {\n    function test_bridgeERC20_notEoa_reverts() external {\n        // turn alice into a contract\n        vm.etch(alice, hex\"ffff\");\n\n        vm.expectRevert(\"StandardBridge: function can only be called from an EOA\");\n        vm.prank(alice, alice);\n        L1Bridge.bridgeERC20(address(0), address(0), 100, 100, hex\"\");\n    }\n}\n\ncontract L1StandardBridge_BridgeERC20To_Test is Bridge_Initializer {\n    // bridgeERC20To\n    // - updates bridge.deposits\n    // - calls kromaPortal.depositTransaction\n    // - callable by a contract\n    function test_bridgeERC20To_succeeds() external {\n        uint256 nonce = L1Messenger.messageNonce();\n        uint256 version = 0; // Internal constant in the KromaPortal: DEPOSIT_VERSION\n        address l1MessengerAliased = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeERC20.selector,\n            address(L2Token),\n            address(L1Token),\n            alice,\n            bob,\n            1000,\n            hex\"\"\n        );\n\n        // the L1 bridge should call L1CrossDomainMessenger.sendMessage\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                message,\n                10000\n            )\n        );\n\n        bytes memory innerMessage = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L1Bridge),\n            address(L2Bridge),\n            0,\n            10000,\n            message\n        );\n\n        uint64 baseGas = L1Messenger.baseGas(message, 10000);\n        vm.expectCall(\n            address(portal),\n            abi.encodeWithSelector(\n                KromaPortal.depositTransaction.selector,\n                address(L2Messenger),\n                0,\n                baseGas,\n                false,\n                innerMessage\n            )\n        );\n\n        bytes memory opaqueData = abi.encodePacked(\n            uint256(0),\n            uint256(0),\n            baseGas,\n            false,\n            innerMessage\n        );\n\n        // ERC20BridgeInitiated event emitted by the StandardBridge\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ERC20BridgeInitiated(address(L1Token), address(L2Token), alice, bob, 1000, hex\"\");\n\n        // KromaPortal emits a TransactionDeposited event on `depositTransaction` call\n        vm.expectEmit(true, true, true, true, address(portal));\n        emit TransactionDeposited(l1MessengerAliased, address(L2Messenger), version, opaqueData);\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L1Messenger));\n        emit SentMessage(address(L2Bridge), address(L1Bridge), 0, message, nonce, 10000);\n\n        deal(address(L1Token), alice, 100000, true);\n\n        vm.prank(alice);\n        L1Token.approve(address(L1Bridge), type(uint256).max);\n\n        vm.expectCall(\n            address(L1Token),\n            abi.encodeWithSelector(ERC20.transferFrom.selector, alice, address(L1Bridge), 1000)\n        );\n\n        vm.prank(alice);\n        L1Bridge.bridgeERC20To(address(L1Token), address(L2Token), bob, 1000, 10000, hex\"\");\n\n        assertEq(L1Bridge.deposits(address(L1Token), address(L2Token)), 1000);\n    }\n}\n\ncontract L1StandardBridge_FinalizeETHWithdrawal_Test is Bridge_Initializer {\n    using stdStorage for StdStorage;\n\n    // finalizeETHWithdrawal\n    // - only callable by L2 bridge\n    function test_finalizeETHWithdrawal_succeeds() external {\n        uint256 aliceBalance = alice.balance;\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHBridgeFinalized(alice, alice, 100, hex\"\");\n\n        vm.expectCall(alice, hex\"\");\n\n        vm.mockCall(\n            address(L1Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        // ensure that the messenger has ETH to call with\n        vm.deal(address(L1Bridge.MESSENGER()), 100);\n        vm.prank(address(L1Bridge.MESSENGER()));\n        L1Bridge.finalizeBridgeETH{ value: 100 }(alice, alice, 100, hex\"\");\n\n        assertEq(address(L1Bridge.MESSENGER()).balance, 0);\n        assertEq(aliceBalance + 100, alice.balance);\n    }\n}\n\ncontract L1StandardBridge_FinalizeETHWithdrawal_TestFail is Bridge_Initializer {}\n\ncontract L1StandardBridge_FinalizeBridgeERC20Withdrawal_Test is Bridge_Initializer {\n    using stdStorage for StdStorage;\n\n    // finalizeBridgeERC20Withdrawal\n    // - updates bridge.deposits\n    // - only callable by L2 bridge\n    function test_finalizeBridgeERC20Withdrawal_succeeds() external {\n        deal(address(L1Token), address(L1Bridge), 100, true);\n\n        uint256 slot = stdstore\n            .target(address(L1Bridge))\n            .sig(\"deposits(address,address)\")\n            .with_key(address(L1Token))\n            .with_key(address(L2Token))\n            .find();\n\n        // Give the L1 bridge some ERC20 tokens\n        vm.store(address(L1Bridge), bytes32(slot), bytes32(uint256(100)));\n        assertEq(L1Bridge.deposits(address(L1Token), address(L2Token)), 100);\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ERC20BridgeFinalized(address(L1Token), address(L2Token), alice, alice, 100, hex\"\");\n\n        vm.expectCall(\n            address(L1Token),\n            abi.encodeWithSelector(ERC20.transfer.selector, alice, 100)\n        );\n\n        vm.mockCall(\n            address(L1Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.prank(address(L1Bridge.MESSENGER()));\n        L1Bridge.finalizeBridgeERC20(\n            address(L1Token),\n            address(L2Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n\n        assertEq(L1Token.balanceOf(address(L1Bridge)), 0);\n        assertEq(L1Token.balanceOf(address(alice)), 100);\n    }\n}\n\ncontract L1StandardBridge_FinalizeBridgeERC20Withdrawal_TestFail is Bridge_Initializer {\n    function test_finalizeBridgeERC20Withdrawal_notMessenger_reverts() external {\n        vm.mockCall(\n            address(L1Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.prank(address(28));\n        vm.expectRevert(\"StandardBridge: function can only be called from the other bridge\");\n        L1Bridge.finalizeBridgeERC20(\n            address(L1Token),\n            address(L2Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n    }\n\n    function test_finalizeBridgeERC20Withdrawal_notOtherBridge_reverts() external {\n        vm.mockCall(\n            address(L1Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(address(0)))\n        );\n        vm.prank(address(L1Bridge.MESSENGER()));\n        vm.expectRevert(\"StandardBridge: function can only be called from the other bridge\");\n        L1Bridge.finalizeBridgeERC20(\n            address(L1Token),\n            address(L2Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n    }\n}\n\ncontract L1StandardBridge_FinalizeBridgeETH_Test is Bridge_Initializer {\n    function test_finalizeBridgeETH_succeeds() external {\n        address messenger = address(L1Bridge.MESSENGER());\n        vm.mockCall(\n            messenger,\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(messenger, 100);\n        vm.prank(messenger);\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHBridgeFinalized(alice, alice, 100, hex\"\");\n\n        L1Bridge.finalizeBridgeETH{ value: 100 }(alice, alice, 100, hex\"\");\n    }\n}\n\ncontract L1StandardBridge_FinalizeBridgeETH_TestFail is Bridge_Initializer {\n    function test_finalizeBridgeETH_incorrectValue_reverts() external {\n        address messenger = address(L1Bridge.MESSENGER());\n        vm.mockCall(\n            messenger,\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(messenger, 100);\n        vm.prank(messenger);\n        vm.expectRevert(\"StandardBridge: amount sent does not match amount required\");\n        L1Bridge.finalizeBridgeETH{ value: 50 }(alice, alice, 100, hex\"\");\n    }\n\n    function test_finalizeBridgeETH_sendToSelf_reverts() external {\n        address messenger = address(L1Bridge.MESSENGER());\n        vm.mockCall(\n            messenger,\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(messenger, 100);\n        vm.prank(messenger);\n        vm.expectRevert(\"StandardBridge: cannot send to self\");\n        L1Bridge.finalizeBridgeETH{ value: 100 }(alice, address(L1Bridge), 100, hex\"\");\n    }\n\n    function test_finalizeBridgeETH_sendToMessenger_reverts() external {\n        address messenger = address(L1Bridge.MESSENGER());\n        vm.mockCall(\n            messenger,\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(messenger, 100);\n        vm.prank(messenger);\n        vm.expectRevert(\"StandardBridge: cannot send to messenger\");\n        L1Bridge.finalizeBridgeETH{ value: 100 }(alice, messenger, 100, hex\"\");\n    }\n}\n"
    },
    "contracts/test/L2CrossDomainMessenger.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { L2CrossDomainMessenger } from \"../L2/L2CrossDomainMessenger.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Messenger_Initializer, Reverter, ConfigurableCaller } from \"./CommonTest.t.sol\";\n\ncontract L2CrossDomainMessenger_Test is Messenger_Initializer {\n    // Receiver address for testing\n    address recipient = address(0xabbaacdc);\n\n    function test_messageVersion_succeeds() external {\n        (, uint16 version) = Encoding.decodeVersionedNonce(L2Messenger.messageNonce());\n        assertEq(version, L2Messenger.MESSAGE_VERSION());\n    }\n\n    function test_sendMessage_succeeds() external {\n        bytes memory xDomainCallData = Encoding.encodeCrossDomainMessage(\n            L2Messenger.messageNonce(),\n            alice,\n            recipient,\n            0,\n            100,\n            hex\"ff\"\n        );\n        vm.expectCall(\n            address(messagePasser),\n            abi.encodeWithSelector(\n                L2ToL1MessagePasser.initiateWithdrawal.selector,\n                address(L1Messenger),\n                L2Messenger.baseGas(hex\"ff\", 100),\n                xDomainCallData\n            )\n        );\n\n        // MessagePassed event\n        vm.expectEmit(true, true, true, true);\n        emit MessagePassed(\n            messagePasser.messageNonce(),\n            address(L2Messenger),\n            address(L1Messenger),\n            0,\n            L2Messenger.baseGas(hex\"ff\", 100),\n            xDomainCallData,\n            Hashing.hashWithdrawal(\n                Types.WithdrawalTransaction({\n                    nonce: messagePasser.messageNonce(),\n                    sender: address(L2Messenger),\n                    target: address(L1Messenger),\n                    value: 0,\n                    gasLimit: L2Messenger.baseGas(hex\"ff\", 100),\n                    data: xDomainCallData\n                })\n            )\n        );\n\n        vm.prank(alice);\n        L2Messenger.sendMessage(recipient, hex\"ff\", uint32(100));\n    }\n\n    function test_sendMessage_twice_succeeds() external {\n        uint256 nonce = L2Messenger.messageNonce();\n        L2Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        L2Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        // the nonce increments for each message sent\n        assertEq(nonce + 2, L2Messenger.messageNonce());\n    }\n\n    function test_xDomainSender_senderNotSet_reverts() external {\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L2Messenger.xDomainMessageSender();\n    }\n\n    function test_relayMessage_v1_reverts() external {\n        address target = address(0xabcd);\n        address sender = address(L1Messenger);\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        // Expect a revert.\n        vm.expectRevert(\n            \"CrossDomainMessenger: only version 0 messages is supported at this time\"\n        );\n\n        // Try to relay a v1 message.\n        vm.prank(caller);\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 1 }), // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            hex\"1111\"\n        );\n    }\n\n    function test_relayMessage_succeeds() external {\n        address target = address(0xabcd);\n        address sender = address(L1Messenger);\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        vm.expectCall(target, hex\"1111\");\n\n        vm.prank(caller);\n\n        vm.expectEmit(true, true, true, true);\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            hex\"1111\"\n        );\n\n        emit RelayedMessage(hash);\n\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            hex\"1111\"\n        );\n\n        // the message hash is in the successfulMessages mapping\n        assert(L2Messenger.successfulMessages(hash));\n        // it is not in the received messages mapping\n        assertEq(L2Messenger.failedMessages(hash), false);\n    }\n\n    // relayMessage: should revert if attempting to relay a message sent to an L1 system contract\n    function test_relayMessage_toSystemContract_reverts() external {\n        address target = address(messagePasser);\n        address sender = address(L1Messenger);\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n        bytes memory message = hex\"1111\";\n\n        vm.prank(caller);\n        vm.expectRevert(\"CrossDomainMessenger: message cannot be replayed\");\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            message\n        );\n    }\n\n    // relayMessage: the xDomainMessageSender is reset to the original value\n    function test_xDomainMessageSender_reset_succeeds() external {\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L2Messenger.xDomainMessageSender();\n\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n        vm.prank(caller);\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            address(0),\n            address(0),\n            0,\n            0,\n            hex\"\"\n        );\n\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L2Messenger.xDomainMessageSender();\n    }\n\n    // relayMessage: should send a successful call to the target contract after the first message\n    // fails and ETH gets stuck, but the second message succeeds\n    function test_relayMessage_retry_succeeds() external {\n        address target = address(0xabcd);\n        address sender = address(L1Messenger);\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n        uint256 value = 100;\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        vm.etch(target, address(new Reverter()).code);\n        vm.deal(address(caller), value);\n        vm.prank(caller);\n        L2Messenger.relayMessage{ value: value }(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        assertEq(address(L2Messenger).balance, value);\n        assertEq(address(target).balance, 0);\n        assertEq(L2Messenger.successfulMessages(hash), false);\n        assertEq(L2Messenger.failedMessages(hash), true);\n\n        vm.expectEmit(true, true, true, true);\n\n        emit RelayedMessage(hash);\n\n        vm.etch(target, address(0).code);\n        vm.prank(address(sender));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        assertEq(address(L2Messenger).balance, 0);\n        assertEq(address(target).balance, value);\n        assertEq(L2Messenger.successfulMessages(hash), true);\n        assertEq(L2Messenger.failedMessages(hash), true);\n    }\n\n    // relayMessage: Should revert if the recipient is trying to reenter with the\n    // same message.\n    function test_relayMessage_reentrancySameMessage_reverts() external {\n        ConfigurableCaller caller = new ConfigurableCaller();\n        address target = address(caller);\n        address sender = address(L1Messenger);\n        address l1XDMAlias = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n        bytes memory callMessage = abi.encodeWithSelector(caller.call.selector);\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            callMessage\n        );\n\n        // Act as the L1XDM and call the `relayMessage` function with the `innerMessage`.\n        vm.prank(l1XDMAlias);\n        vm.expectCall(target, callMessage);\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            callMessage\n        );\n\n        // Assert that the message failed to be relayed\n        assertFalse(L2Messenger.successfulMessages(hash));\n        assertTrue(L2Messenger.failedMessages(hash));\n\n        // Set the configurable caller's target to `L2Messenger` and set the payload to `relayMessage(...)`.\n        caller.setDoRevert(false);\n        caller.setTarget(address(L2Messenger));\n        caller.setPayload(\n            abi.encodeWithSelector(\n                L2Messenger.relayMessage.selector,\n                Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n                sender,\n                target,\n                0,\n                0,\n                callMessage\n            )\n        );\n\n        // Attempt to replay the failed message, which will *not* immediately revert this time around,\n        // but attempt to reenter `relayMessage` with the same message hash. The reentrancy attempt should\n        // revert.\n        vm.expectEmit(true, true, true, true, target);\n        emit WhatHappened(\n            false,\n            abi.encodeWithSignature(\"Error(string)\", \"ReentrancyGuard: reentrant call\")\n        );\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            callMessage\n        );\n\n        // Assert that the message still failed to be relayed.\n        assertFalse(L2Messenger.successfulMessages(hash));\n        assertTrue(L2Messenger.failedMessages(hash));\n    }\n\n    // relayMessage: should not revert if the recipient reenters `relayMessage` with a different\n    // message hash.\n    function test_relayMessage_reentrancyDiffMessage_succeeds() external {\n        ConfigurableCaller caller = new ConfigurableCaller();\n        address target = address(caller);\n        address sender = address(L1Messenger);\n        address l1XDMAlias = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        bytes memory messageA = abi.encodeWithSelector(caller.call.selector);\n        bytes memory messageB = hex\"\";\n\n        bytes32 hashA = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            messageA\n        );\n        bytes32 hashB = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            messageB\n        );\n\n        // Act as the L1XDM and call the `relayMessage` function with both `messageA` and `messageB`.\n        vm.startPrank(l1XDMAlias);\n\n        vm.expectCall(target, messageA);\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            messageA\n        );\n        vm.expectCall(target, messageB);\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            messageB\n        );\n\n        // Stop acting as the L1XDM\n        vm.stopPrank();\n\n        // Assert that both messages failed to be relayed\n        assertFalse(L2Messenger.successfulMessages(hashA));\n        assertFalse(L2Messenger.successfulMessages(hashB));\n        assertTrue(L2Messenger.failedMessages(hashA));\n        assertTrue(L2Messenger.failedMessages(hashB));\n\n        // Set the configurable caller's target to `L2Messenger` and set the payload to `relayMessage(...)`.\n        caller.setDoRevert(false);\n        caller.setTarget(address(L2Messenger));\n        caller.setPayload(\n            abi.encodeWithSelector(\n                L2Messenger.relayMessage.selector,\n                Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n                sender,\n                target,\n                0,\n                0,\n                messageB\n            )\n        );\n\n        // Attempt to replay the failed message, which will *not* immediately revert this time around,\n        // but attempt to reenter `relayMessage` with messageB. The reentrancy attempt should succeed\n        // because the message hashes are different.\n        vm.expectEmit(true, true, true, true, target);\n        emit WhatHappened(true, hex\"\");\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            messageA\n        );\n\n        // Assert that both messages are now in the `successfulMessages` mapping.\n        assertTrue(L2Messenger.successfulMessages(hashA));\n        assertTrue(L2Messenger.successfulMessages(hashB));\n    }\n}\n"
    },
    "contracts/test/L2ERC721Bridge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport { L1ERC721Bridge } from \"../L1/L1ERC721Bridge.sol\";\nimport { L2ERC721Bridge } from \"../L2/L2ERC721Bridge.sol\";\nimport { KromaMintableERC721 } from \"../universal/KromaMintableERC721.sol\";\nimport { Messenger_Initializer } from \"./CommonTest.t.sol\";\n\ncontract TestERC721 is ERC721 {\n    constructor() ERC721(\"Test\", \"TST\") {}\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n}\n\ncontract TestMintableERC721 is KromaMintableERC721 {\n    constructor(address _bridge, address _remoteToken)\n        KromaMintableERC721(_bridge, 1, _remoteToken, \"Test\", \"TST\")\n    {}\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n}\n\ncontract L2ERC721Bridge_Test is Messenger_Initializer {\n    TestMintableERC721 internal localToken;\n    TestERC721 internal remoteToken;\n    L2ERC721Bridge internal bridge;\n    address internal constant otherBridge = address(0x3456);\n    uint256 internal constant tokenId = 1;\n\n    event ERC721BridgeInitiated(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    event ERC721BridgeFinalized(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    function setUp() public override {\n        super.setUp();\n\n        // Create necessary contracts.\n        bridge = new L2ERC721Bridge(address(L2Messenger), otherBridge);\n        remoteToken = new TestERC721();\n        localToken = new TestMintableERC721(address(bridge), address(remoteToken));\n\n        // Label the bridge so we get nice traces.\n        vm.label(address(bridge), \"L2ERC721Bridge\");\n\n        // Mint alice a token.\n        localToken.mint(alice, tokenId);\n\n        // Approve the bridge to transfer the token.\n        vm.prank(alice);\n        localToken.approve(address(bridge), tokenId);\n    }\n\n    function test_constructor_succeeds() public {\n        assertEq(address(bridge.MESSENGER()), address(L2Messenger));\n        assertEq(address(bridge.OTHER_BRIDGE()), otherBridge);\n    }\n\n    function test_bridgeERC721_succeeds() public {\n        // Expect a call to the messenger.\n        vm.expectCall(\n            address(L2Messenger),\n            abi.encodeCall(\n                L2Messenger.sendMessage,\n                (\n                    address(otherBridge),\n                    abi.encodeCall(\n                        L2ERC721Bridge.finalizeBridgeERC721,\n                        (\n                            address(remoteToken),\n                            address(localToken),\n                            alice,\n                            alice,\n                            tokenId,\n                            hex\"5678\"\n                        )\n                    ),\n                    1234\n                )\n            )\n        );\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeInitiated(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is burned.\n        vm.expectRevert(\"ERC721: invalid token ID\");\n        localToken.ownerOf(tokenId);\n    }\n\n    function test_bridgeERC721_fromContract_reverts() external {\n        // Bridge the token.\n        vm.etch(alice, hex\"01\");\n        vm.prank(alice);\n        vm.expectRevert(\"ERC721Bridge: account is not externally owned\");\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_localTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert();\n        bridge.bridgeERC721(address(0), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_remoteTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert(\"L2ERC721Bridge: remote token cannot be address(0)\");\n        bridge.bridgeERC721(address(localToken), address(0), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_wrongOwner_reverts() external {\n        // Bridge the token.\n        vm.prank(bob);\n        vm.expectRevert(\"L2ERC721Bridge: Withdrawal is not being initiated by NFT owner\");\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_succeeds() external {\n        // Expect a call to the messenger.\n        vm.expectCall(\n            address(L2Messenger),\n            abi.encodeCall(\n                L2Messenger.sendMessage,\n                (\n                    address(otherBridge),\n                    abi.encodeCall(\n                        L1ERC721Bridge.finalizeBridgeERC721,\n                        (address(remoteToken), address(localToken), alice, bob, tokenId, hex\"5678\")\n                    ),\n                    1234\n                )\n            )\n        );\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeInitiated(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            bob,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721To(\n            address(localToken),\n            address(remoteToken),\n            bob,\n            tokenId,\n            1234,\n            hex\"5678\"\n        );\n\n        // Token is burned.\n        vm.expectRevert(\"ERC721: invalid token ID\");\n        localToken.ownerOf(tokenId);\n    }\n\n    function test_bridgeERC721To_localTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert();\n        bridge.bridgeERC721To(address(0), address(remoteToken), bob, tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_remoteTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert(\"L2ERC721Bridge: remote token cannot be address(0)\");\n        bridge.bridgeERC721To(address(localToken), address(0), bob, tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_wrongOwner_reverts() external {\n        // Bridge the token.\n        vm.prank(bob);\n        vm.expectRevert(\"L2ERC721Bridge: Withdrawal is not being initiated by NFT owner\");\n        bridge.bridgeERC721To(\n            address(localToken),\n            address(remoteToken),\n            bob,\n            tokenId,\n            1234,\n            hex\"5678\"\n        );\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_finalizeBridgeERC721_succeeds() external {\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeFinalized(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(L2Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L2Messenger));\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_finalizeBridgeERC721_interfaceNotCompliant_reverts() external {\n        // Create a non-compliant token\n        NonCompliantERC721 nonCompliantToken = new NonCompliantERC721(alice);\n\n        // Bridge the non-compliant token.\n        vm.prank(alice);\n        bridge.bridgeERC721(address(nonCompliantToken), address(0x01), tokenId, 1234, hex\"5678\");\n\n        // Attempt to finalize the withdrawal. Should revert because the token does not claim\n        // to be compliant with the `IKromaMintableERC721` interface.\n        vm.mockCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(L2Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"L2ERC721Bridge: local token interface is not compliant\");\n        bridge.finalizeBridgeERC721(\n            address(address(nonCompliantToken)),\n            address(address(0x01)),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_notViaLocalMessenger_reverts() external {\n        // Finalize a withdrawal.\n        vm.prank(alice);\n        vm.expectRevert(\"ERC721Bridge: function can only be called from the other bridge\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_notFromRemoteMessenger_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(L2Messenger.xDomainMessageSender.selector),\n            abi.encode(alice)\n        );\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"ERC721Bridge: function can only be called from the other bridge\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_selfToken_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(L2Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"L2ERC721Bridge: local token cannot be self\");\n        bridge.finalizeBridgeERC721(\n            address(bridge),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_alreadyExists_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(L2Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"ERC721: token already minted\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n}\n\n/**\n * @dev A non-compliant ERC721 token that does not implement the full ERC721 interface.\n *\n * This is used to test that the bridge will revert if the token does not claim to support\n * the ERC721 interface.\n */\ncontract NonCompliantERC721 {\n    address internal immutable owner;\n\n    address public immutable REMOTE_TOKEN;\n\n    constructor(address _owner) {\n        owner = _owner;\n        REMOTE_TOKEN = address(0x01);\n    }\n\n    function ownerOf(uint256) external view returns (address) {\n        return owner;\n    }\n\n    function burn(address, uint256) external {\n        // Do nothing.\n    }\n\n    function supportsInterface(bytes4) external pure returns (bool) {\n        return false;\n    }\n}\n"
    },
    "contracts/test/L2OutputOracle.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { stdError } from \"forge-std/Test.sol\";\n\nimport { Types } from \"../libraries/Types.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { L2OutputOracle_Initializer, NextImpl } from \"./CommonTest.t.sol\";\n\ncontract L2OutputOracleTest is L2OutputOracle_Initializer {\n    bytes32 submittedOutput1 = keccak256(abi.encode(1));\n\n    function test_constructor_succeeds() external {\n        assertEq(oracle.VALIDATOR(), asserter);\n        assertEq(oracle.CHALLENGER(), challenger);\n        assertEq(oracle.SUBMISSION_INTERVAL(), submissionInterval);\n        assertEq(oracle.latestBlockNumber(), startingBlockNumber);\n        assertEq(oracle.startingBlockNumber(), startingBlockNumber);\n        assertEq(oracle.startingTimestamp(), startingTimestamp);\n    }\n\n    function test_constructor_badTimestamp_reverts() external {\n        vm.expectRevert(\"L2OutputOracle: starting L2 timestamp must be less than current time\");\n\n        new L2OutputOracle({\n            _submissionInterval: submissionInterval,\n            _l2BlockTime: l2BlockTime,\n            _startingBlockNumber: startingBlockNumber,\n            _startingTimestamp: block.timestamp + 1,\n            _validator: asserter,\n            _challenger: challenger,\n            _finalizationPeriodSeconds: 7 days\n        });\n    }\n\n    function test_constructor_l2BlockTimeZero_reverts() external {\n        vm.expectRevert(\"L2OutputOracle: L2 block time must be greater than 0\");\n        new L2OutputOracle({\n            _submissionInterval: submissionInterval,\n            _l2BlockTime: 0,\n            _startingBlockNumber: startingBlockNumber,\n            _startingTimestamp: block.timestamp,\n            _validator: asserter,\n            _challenger: challenger,\n            _finalizationPeriodSeconds: 7 days\n        });\n    }\n\n    function testFuzz_constructor_submissionIntervalLteL2BlockTime_reverts(\n        uint256 _submissionInterval,\n        uint256 _l2BlockTime\n    ) external {\n        // Bound the _l2blockTime to be in the range of [1, type(uint256).max]\n        _l2BlockTime = bound(_l2BlockTime, 1, type(uint256).max);\n        // Roll the block number to _l2blockTime (the starting L2 timestamp must be less than or equal to the current time)\n        vm.roll(_l2BlockTime);\n        // Bound _submissionInterval to be less than or equal to _l2BlockTime\n        _submissionInterval = bound(_submissionInterval, 0, _l2BlockTime);\n\n        vm.expectRevert(\"L2OutputOracle: submission interval must be greater than L2 block time\");\n        new L2OutputOracle({\n            _submissionInterval: _submissionInterval,\n            _l2BlockTime: _l2BlockTime,\n            _startingBlockNumber: startingBlockNumber,\n            _startingTimestamp: block.timestamp,\n            _validator: asserter,\n            _challenger: challenger,\n            _finalizationPeriodSeconds: 7 days\n        });\n    }\n\n    /****************\n     * Getter Tests *\n     ****************/\n\n    // Test: latestBlockNumber() should return the correct value\n    function test_latestBlockNumber_succeeds() external {\n        uint256 submittedNumber = oracle.nextBlockNumber();\n\n        // Roll to after the block number we'll submit\n        warpToSubmitTime(submittedNumber);\n        vm.prank(asserter);\n        oracle.submitL2Output(submittedOutput1, submittedNumber, 0, 0);\n        assertEq(oracle.latestBlockNumber(), submittedNumber);\n    }\n\n    // Test: getL2Output() should return the correct value\n    function test_getL2Output_succeeds() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        uint256 nextOutputIndex = oracle.nextOutputIndex();\n        warpToSubmitTime(nextBlockNumber);\n        vm.prank(asserter);\n        oracle.submitL2Output(submittedOutput1, nextBlockNumber, 0, 0);\n\n        Types.CheckpointOutput memory output = oracle.getL2Output(nextOutputIndex);\n        assertEq(output.outputRoot, submittedOutput1);\n        assertEq(output.timestamp, block.timestamp);\n\n        // The block number is larger than the latest submitted output:\n        vm.expectRevert(stdError.indexOOBError);\n        oracle.getL2Output(nextOutputIndex + 1);\n    }\n\n    // Test: getL2OutputIndexAfter() returns correct value when input is exact block\n    function test_getL2OutputIndexAfter_sameBlock_succeeds() external {\n        bytes32 output1 = keccak256(abi.encode(1));\n        uint256 nextBlockNumber1 = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber1);\n        vm.prank(asserter);\n        oracle.submitL2Output(output1, nextBlockNumber1, 0, 0);\n\n        // Querying with exact same block as submitted returns the output.\n        uint256 index1 = oracle.getL2OutputIndexAfter(nextBlockNumber1);\n        assertEq(index1, 0);\n    }\n\n    // Test: getL2OutputIndexAfter() returns correct value when input is previous block\n    function test_getL2OutputIndexAfter_previousBlock_succeeds() external {\n        bytes32 output1 = keccak256(abi.encode(1));\n        uint256 nextBlockNumber1 = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber1);\n        vm.prank(asserter);\n        oracle.submitL2Output(output1, nextBlockNumber1, 0, 0);\n\n        // Querying with previous block returns the output too.\n        uint256 index1 = oracle.getL2OutputIndexAfter(nextBlockNumber1 - 1);\n        assertEq(index1, 0);\n    }\n\n    // Test: getL2OutputIndexAfter() returns correct value during binary search\n    function test_getL2OutputIndexAfter_multipleOutputsExist_succeeds() external {\n        bytes32 output1 = keccak256(abi.encode(1));\n        uint256 nextBlockNumber1 = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber1);\n        vm.prank(asserter);\n        oracle.submitL2Output(output1, nextBlockNumber1, 0, 0);\n\n        bytes32 output2 = keccak256(abi.encode(2));\n        uint256 nextBlockNumber2 = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber2);\n        vm.prank(asserter);\n        oracle.submitL2Output(output2, nextBlockNumber2, 0, 0);\n\n        bytes32 output3 = keccak256(abi.encode(3));\n        uint256 nextBlockNumber3 = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber3);\n        vm.prank(asserter);\n        oracle.submitL2Output(output3, nextBlockNumber3, 0, 0);\n\n        bytes32 output4 = keccak256(abi.encode(4));\n        uint256 nextBlockNumber4 = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber4);\n        vm.prank(asserter);\n        oracle.submitL2Output(output4, nextBlockNumber4, 0, 0);\n\n        // Querying with a block number between the first and second output\n        uint256 index1 = oracle.getL2OutputIndexAfter(nextBlockNumber1 + 1);\n        assertEq(index1, 1);\n\n        // Querying with a block number between the second and third output\n        uint256 index2 = oracle.getL2OutputIndexAfter(nextBlockNumber2 + 1);\n        assertEq(index2, 2);\n\n        // Querying with a block number between the third and fourth output\n        uint256 index3 = oracle.getL2OutputIndexAfter(nextBlockNumber3 + 1);\n        assertEq(index3, 3);\n    }\n\n    // Test: getL2OutputIndexAfter() reverts when no output exists yet\n    function test_getL2OutputIndexAfter_noOutputsExis_reverts() external {\n        vm.expectRevert(\"L2OutputOracle: cannot get output as no outputs have been submitted yet\");\n        oracle.getL2OutputIndexAfter(0);\n    }\n\n    // Test: nextBlockNumber() should return the correct value\n    function test_nextBlockNumber_succeeds() external {\n        assertEq(\n            oracle.nextBlockNumber(),\n            // The return value should match this arithmetic\n            oracle.latestBlockNumber() + oracle.SUBMISSION_INTERVAL()\n        );\n    }\n\n    function test_computeL2Timestamp_succeeds() external {\n        // reverts if timestamp is too low\n        vm.expectRevert(stdError.arithmeticError);\n        oracle.computeL2Timestamp(startingBlockNumber - 1);\n\n        // returns the correct value...\n        // ... for the very first block\n        assertEq(oracle.computeL2Timestamp(startingBlockNumber), startingTimestamp);\n\n        // ... for the first block after the starting block\n        assertEq(\n            oracle.computeL2Timestamp(startingBlockNumber + 1),\n            startingTimestamp + l2BlockTime\n        );\n\n        // ... for some other block number\n        assertEq(\n            oracle.computeL2Timestamp(startingBlockNumber + 96024),\n            startingTimestamp + l2BlockTime * 96024\n        );\n    }\n\n    /*****************************\n     * Submit Tests - Happy Path *\n     *****************************/\n\n    // Test: submitL2Output succeeds when given valid input, and no block hash and number are\n    // specified.\n    function test_submitL2Output_submitAnotherOutput_succeeds() public {\n        bytes32 submittedOutput2 = keccak256(abi.encode());\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        uint256 nextOutputIndex = oracle.nextOutputIndex();\n        warpToSubmitTime(nextBlockNumber);\n        uint256 submittedNumber = oracle.latestBlockNumber();\n\n        // Ensure the submissionInterval is enforced\n        assertEq(nextBlockNumber, submittedNumber + submissionInterval);\n\n        vm.roll(nextBlockNumber + 1);\n\n        vm.expectEmit(true, true, true, true);\n        emit OutputSubmitted(submittedOutput2, nextOutputIndex, nextBlockNumber, block.timestamp);\n\n        vm.prank(asserter);\n        oracle.submitL2Output(submittedOutput2, nextBlockNumber, 0, 0);\n    }\n\n    // Test: submitL2Output succeeds when given valid input, and when a block hash and number are\n    // specified for reorg protection.\n    function test_submitWithBlockhashAndHeight_succeeds() external {\n        // Get the number and hash of a previous block in the chain\n        uint256 prevL1BlockNumber = block.number - 1;\n        bytes32 prevL1BlockHash = blockhash(prevL1BlockNumber);\n\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber);\n        vm.prank(asserter);\n        oracle.submitL2Output(nonZeroHash, nextBlockNumber, prevL1BlockHash, prevL1BlockNumber);\n    }\n\n    /***************************\n     * Submit Tests - Sad Path *\n     ***************************/\n\n    // Test: submitL2Output fails if called by a party that is not the validator.\n    function test_submitL2Output_notValidator_reverts() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber);\n\n        vm.prank(address(128));\n        vm.expectRevert(\"L2OutputOracle: only the validator address can submit new outputs\");\n        oracle.submitL2Output(nonZeroHash, nextBlockNumber, 0, 0);\n    }\n\n    // Test: submitL2Output fails given a zero blockhash.\n    function test_submitL2Output_emptyOutput_reverts() external {\n        bytes32 outputToSubmit = bytes32(0);\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber);\n        vm.prank(asserter);\n        vm.expectRevert(\"L2OutputOracle: L2 checkpoint output cannot be the zero hash\");\n        oracle.submitL2Output(outputToSubmit, nextBlockNumber, 0, 0);\n    }\n\n    // Test: submitL2Output fails if the block number doesn't match the next expected number.\n    function test_submitL2Output_unexpectedBlockNumber_reverts() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber);\n        vm.prank(asserter);\n        vm.expectRevert(\"L2OutputOracle: block number must be equal to next expected block number\");\n        oracle.submitL2Output(nonZeroHash, nextBlockNumber - 1, 0, 0);\n    }\n\n    // Test: submitL2Output fails if it would have a timestamp in the future.\n    function test_submitL2Output_futureTimetamp_reverts() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        uint256 nextTimestamp = oracle.computeL2Timestamp(nextBlockNumber);\n        vm.warp(nextTimestamp);\n        vm.prank(asserter);\n        vm.expectRevert(\"L2OutputOracle: cannot submit L2 output in the future\");\n        oracle.submitL2Output(nonZeroHash, nextBlockNumber, 0, 0);\n    }\n\n    // Test: submitL2Output fails if a non-existent L1 block hash and number are provided for reorg\n    // protection.\n    function test_submitL2Output_wrongFork_reverts() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber);\n        vm.prank(asserter);\n        vm.expectRevert(\n            \"L2OutputOracle: block hash does not match the hash at the expected height\"\n        );\n        oracle.submitL2Output(\n            nonZeroHash,\n            nextBlockNumber,\n            bytes32(uint256(0x01)),\n            block.number - 1\n        );\n    }\n\n    // Test: submitL2Output fails when given valid input, but the block hash and number do not\n    // match.\n    function test_submitL2Output_unmatchedBlockhash_reverts() external {\n        // Move ahead to block 100 so that we can reference historical blocks\n        vm.roll(100);\n\n        // Get the number and hash of a previous block in the chain\n        uint256 l1BlockNumber = block.number - 1;\n        bytes32 l1BlockHash = blockhash(l1BlockNumber);\n\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime(nextBlockNumber);\n        vm.prank(asserter);\n\n        // This will fail when foundry no longer returns zerod block hashes\n        vm.expectRevert(\n            \"L2OutputOracle: block hash does not match the hash at the expected height\"\n        );\n        oracle.submitL2Output(nonZeroHash, nextBlockNumber, l1BlockHash, l1BlockNumber - 1);\n    }\n\n    /*****************************\n     * Delete Tests - Happy Path *\n     *****************************/\n\n    function test_deleteOutputs_singleOutput_succeeds() external {\n        test_submitL2Output_submitAnotherOutput_succeeds();\n        test_submitL2Output_submitAnotherOutput_succeeds();\n\n        uint256 latestBlockNumber = oracle.latestBlockNumber();\n        uint256 latestOutputIndex = oracle.latestOutputIndex();\n        Types.CheckpointOutput memory newLatestOutput = oracle.getL2Output(latestOutputIndex - 1);\n\n        vm.prank(challenger);\n        vm.expectEmit(true, true, false, false);\n        emit OutputsDeleted(latestOutputIndex + 1, latestOutputIndex);\n        oracle.deleteL2Outputs(latestOutputIndex);\n\n        // validate latestBlockNumber has been reduced\n        uint256 latestBlockNumberAfter = oracle.latestBlockNumber();\n        uint256 latestOutputIndexAfter = oracle.latestOutputIndex();\n        assertEq(latestBlockNumber - submissionInterval, latestBlockNumberAfter);\n\n        // validate that the new latest output is as expected.\n        Types.CheckpointOutput memory output = oracle.getL2Output(latestOutputIndexAfter);\n        assertEq(newLatestOutput.outputRoot, output.outputRoot);\n        assertEq(newLatestOutput.timestamp, output.timestamp);\n    }\n\n    function test_deleteOutputs_multipleOutputs_succeeds() external {\n        test_submitL2Output_submitAnotherOutput_succeeds();\n        test_submitL2Output_submitAnotherOutput_succeeds();\n        test_submitL2Output_submitAnotherOutput_succeeds();\n        test_submitL2Output_submitAnotherOutput_succeeds();\n\n        uint256 latestBlockNumber = oracle.latestBlockNumber();\n        uint256 latestOutputIndex = oracle.latestOutputIndex();\n        Types.CheckpointOutput memory newLatestOutput = oracle.getL2Output(latestOutputIndex - 3);\n\n        vm.prank(challenger);\n        vm.expectEmit(true, true, false, false);\n        emit OutputsDeleted(latestOutputIndex + 1, latestOutputIndex - 2);\n        oracle.deleteL2Outputs(latestOutputIndex - 2);\n\n        // validate latestBlockNumber has been reduced\n        uint256 latestBlockNumberAfter = oracle.latestBlockNumber();\n        uint256 latestOutputIndexAfter = oracle.latestOutputIndex();\n        assertEq(latestBlockNumber - submissionInterval * 3, latestBlockNumberAfter);\n\n        // validate that the new latest output is as expected.\n        Types.CheckpointOutput memory output = oracle.getL2Output(latestOutputIndexAfter);\n        assertEq(newLatestOutput.outputRoot, output.outputRoot);\n        assertEq(newLatestOutput.timestamp, output.timestamp);\n    }\n\n    /***************************\n     * Delete Tests - Sad Path *\n     ***************************/\n\n    function test_deleteL2Outputs_ifNotChallenger_reverts() external {\n        uint256 latestBlockNumber = oracle.latestBlockNumber();\n\n        vm.expectRevert(\"L2OutputOracle: only the challenger address can delete outputs\");\n        oracle.deleteL2Outputs(latestBlockNumber);\n    }\n\n    function test_deleteL2Outputs_nonExistent_reverts() external {\n        test_submitL2Output_submitAnotherOutput_succeeds();\n\n        uint256 latestBlockNumber = oracle.latestBlockNumber();\n\n        vm.prank(challenger);\n        vm.expectRevert(\"L2OutputOracle: cannot delete outputs after the latest output index\");\n        oracle.deleteL2Outputs(latestBlockNumber + 1);\n    }\n\n    function test_deleteL2Outputs_afterLatest_reverts() external {\n        // Start by submitting three outputs\n        test_submitL2Output_submitAnotherOutput_succeeds();\n        test_submitL2Output_submitAnotherOutput_succeeds();\n        test_submitL2Output_submitAnotherOutput_succeeds();\n\n        // Delete the latest two outputs\n        uint256 latestOutputIndex = oracle.latestOutputIndex();\n        vm.prank(challenger);\n        oracle.deleteL2Outputs(latestOutputIndex - 2);\n\n        // Now try to delete the same output again\n        vm.prank(challenger);\n        vm.expectRevert(\"L2OutputOracle: cannot delete outputs after the latest output index\");\n        oracle.deleteL2Outputs(latestOutputIndex - 2);\n    }\n\n    function test_deleteL2Outputs_finalized_reverts() external {\n        test_submitL2Output_submitAnotherOutput_succeeds();\n\n        // Warp past the finalization period + 1 second\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        uint256 latestOutputIndex = oracle.latestOutputIndex();\n\n        // Try to delete a finalized output\n        vm.prank(challenger);\n        vm.expectRevert(\"L2OutputOracle: cannot delete outputs that have already been finalized\");\n        oracle.deleteL2Outputs(latestOutputIndex);\n    }\n}\n\ncontract L2OutputOracleUpgradeable_Test is L2OutputOracle_Initializer {\n    Proxy internal proxy;\n\n    function setUp() public override {\n        super.setUp();\n        proxy = Proxy(payable(address(oracle)));\n    }\n\n    function test_initValuesOnProxy_succeeds() external {\n        assertEq(submissionInterval, oracleImpl.SUBMISSION_INTERVAL());\n        assertEq(l2BlockTime, oracleImpl.L2_BLOCK_TIME());\n        assertEq(startingBlockNumber, oracleImpl.startingBlockNumber());\n        assertEq(startingTimestamp, oracleImpl.startingTimestamp());\n\n        assertEq(asserter, oracleImpl.VALIDATOR());\n        assertEq(challenger, oracleImpl.CHALLENGER());\n    }\n\n    function test_initializeProxy_alreadyInitialized_reverts() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        L2OutputOracle(payable(proxy)).initialize(startingBlockNumber, startingTimestamp);\n    }\n\n    function test_initializeImpl_alreadyInitialized_reverts() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        L2OutputOracle(oracleImpl).initialize(startingBlockNumber, startingTimestamp);\n    }\n\n    function test_upgrading_succeeds() external {\n        // Check an unused slot before upgrading.\n        bytes32 slot21Before = vm.load(address(oracle), bytes32(uint256(21)));\n        assertEq(bytes32(0), slot21Before);\n\n        NextImpl nextImpl = new NextImpl();\n        vm.startPrank(multisig);\n        proxy.upgradeToAndCall(\n            address(nextImpl),\n            abi.encodeWithSelector(NextImpl.initialize.selector)\n        );\n        assertEq(proxy.implementation(), address(nextImpl));\n\n        // Verify that the NextImpl contract initialized its values according as expected\n        bytes32 slot21After = vm.load(address(oracle), bytes32(uint256(21)));\n        bytes32 slot21Expected = NextImpl(address(oracle)).slot21Init();\n        assertEq(slot21Expected, slot21After);\n    }\n}\n"
    },
    "contracts/test/L2StandardBridge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { stdStorage, StdStorage } from \"forge-std/Test.sol\";\n\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { KromaMintableERC20 } from \"../universal/KromaMintableERC20.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\n\ncontract L2StandardBridge_Test is Bridge_Initializer {\n    using stdStorage for StdStorage;\n\n    function test_initialize_succeeds() external {\n        assertEq(address(L2Bridge.MESSENGER()), address(L2Messenger));\n        assertEq(address(L1Bridge.OTHER_BRIDGE()), address(L2Bridge));\n        assertEq(address(L2Bridge.OTHER_BRIDGE()), address(L1Bridge));\n    }\n\n    // receive\n    // - can accept ETH\n    function test_receive_succeeds() external {\n        assertEq(address(messagePasser).balance, 0);\n        vm.prank(alice, alice);\n        (bool success, ) = address(L2Bridge).call{ value: 100 }(hex\"\");\n        assertEq(success, true);\n        assertEq(address(messagePasser).balance, 100);\n    }\n}\n\ncontract PreBridgeERC20 is Bridge_Initializer {\n    function _preBridgeERC20() internal {\n        // Alice has 100 L2Token\n        deal(address(L2Token), alice, 100, true);\n        assertEq(L2Token.balanceOf(alice), 100);\n        uint256 nonce = L2Messenger.messageNonce();\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeERC20.selector,\n            address(L1Token),\n            address(L2Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n        uint64 baseGas = L2Messenger.baseGas(message, 1000);\n        bytes memory withdrawalData = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L2Bridge),\n            address(L1Bridge),\n            0,\n            1000,\n            message\n        );\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction({\n                nonce: nonce,\n                sender: address(L2Messenger),\n                target: address(L1Messenger),\n                value: 0,\n                gasLimit: baseGas,\n                data: withdrawalData\n            })\n        );\n\n        vm.expectCall(\n            address(L2Bridge),\n            abi.encodeWithSelector(\n                L2Bridge.bridgeERC20.selector,\n                address(L2Token),\n                address(L1Token),\n                100,\n                1000,\n                hex\"\"\n            )\n        );\n\n        vm.expectCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L1Bridge),\n                message,\n                1000\n            )\n        );\n\n        vm.expectCall(\n            Predeploys.L2_TO_L1_MESSAGE_PASSER,\n            abi.encodeWithSelector(\n                L2ToL1MessagePasser.initiateWithdrawal.selector,\n                address(L1Messenger),\n                baseGas,\n                withdrawalData\n            )\n        );\n\n        // The L2Bridge should burn the tokens\n        vm.expectCall(\n            address(L2Token),\n            abi.encodeWithSelector(KromaMintableERC20.burn.selector, alice, 100)\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit ERC20BridgeInitiated(address(L2Token), address(L1Token), alice, alice, 100, hex\"\");\n\n        vm.expectEmit(true, true, true, true);\n        emit MessagePassed(\n            nonce,\n            address(L2Messenger),\n            address(L1Messenger),\n            0,\n            baseGas,\n            withdrawalData,\n            withdrawalHash\n        );\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true);\n        emit SentMessage(address(L1Bridge), address(L2Bridge), 0, message, nonce, 1000);\n\n        vm.prank(alice, alice);\n    }\n}\n\ncontract L2StandardBridge_BridgeERC20_Test is PreBridgeERC20 {\n    // BridgeERC20\n    // - token is burned\n    // - emits ERC20BridgeInitiated\n    // - calls Withdrawer.initiateWithdrawal\n    function test_bridgeERC20_succeeds() external {\n        _preBridgeERC20();\n        L2Bridge.bridgeERC20(address(L2Token), address(L1Token), 100, 1000, hex\"\");\n\n        assertEq(L2Token.balanceOf(alice), 0);\n    }\n}\n\ncontract PreBridgeERC20To is Bridge_Initializer {\n    function _preBridgeERC20To() internal {\n        deal(address(L2Token), alice, 100, true);\n        assertEq(L2Token.balanceOf(alice), 100);\n        uint256 nonce = L2Messenger.messageNonce();\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeERC20.selector,\n            address(L1Token),\n            address(L2Token),\n            alice,\n            bob,\n            100,\n            hex\"\"\n        );\n        uint64 baseGas = L2Messenger.baseGas(message, 1000);\n        bytes memory withdrawalData = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L2Bridge),\n            address(L1Bridge),\n            0,\n            1000,\n            message\n        );\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction({\n                nonce: nonce,\n                sender: address(L2Messenger),\n                target: address(L1Messenger),\n                value: 0,\n                gasLimit: baseGas,\n                data: withdrawalData\n            })\n        );\n\n        vm.expectEmit(true, true, true, true, address(L2Bridge));\n        emit ERC20BridgeInitiated(address(L2Token), address(L1Token), alice, bob, 100, hex\"\");\n\n        vm.expectEmit(true, true, true, true, address(messagePasser));\n        emit MessagePassed(\n            nonce,\n            address(L2Messenger),\n            address(L1Messenger),\n            0,\n            baseGas,\n            withdrawalData,\n            withdrawalHash\n        );\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L2Messenger));\n        emit SentMessage(address(L1Bridge), address(L2Bridge), 0, message, nonce, 1000);\n\n        vm.expectCall(\n            address(L2Bridge),\n            abi.encodeWithSelector(\n                L2Bridge.bridgeERC20To.selector,\n                address(L2Token),\n                address(L1Token),\n                bob,\n                100,\n                1000,\n                hex\"\"\n            )\n        );\n\n        vm.expectCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L1Bridge),\n                message,\n                1000\n            )\n        );\n\n        vm.expectCall(\n            Predeploys.L2_TO_L1_MESSAGE_PASSER,\n            abi.encodeWithSelector(\n                L2ToL1MessagePasser.initiateWithdrawal.selector,\n                address(L1Messenger),\n                baseGas,\n                withdrawalData\n            )\n        );\n\n        // The L2Bridge should burn the tokens\n        vm.expectCall(\n            address(L2Token),\n            abi.encodeWithSelector(KromaMintableERC20.burn.selector, alice, 100)\n        );\n\n        vm.prank(alice, alice);\n    }\n}\n\ncontract L2StandardBridge_BridgeERC20To_Test is PreBridgeERC20To {\n    // bridgeERC20To\n    // - token is burned\n    // - emits ERC20BridgeInitiated w/ correct recipient\n    // - calls Withdrawer.initiateWithdrawal\n    function test_bridgeERC20To_succeeds() external {\n        _preBridgeERC20To();\n        L2Bridge.bridgeERC20To(address(L2Token), address(L1Token), bob, 100, 1000, hex\"\");\n        assertEq(L2Token.balanceOf(alice), 0);\n    }\n}\n\ncontract L2StandardBridge_Bridge_Test is Bridge_Initializer {\n    // finalizeDeposit\n    // - only callable by l1Bridge\n    // - supported token pair emits ERC20BridgeFinalized\n    // - invalid deposit calls Withdrawer.initiateWithdrawal\n    function test_finalizeBridgeERC20_succeeds() external {\n        vm.mockCall(\n            address(L2Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.OTHER_BRIDGE()))\n        );\n\n        vm.expectCall(\n            address(L2Token),\n            abi.encodeWithSelector(KromaMintableERC20.mint.selector, alice, 100)\n        );\n\n        vm.expectEmit(true, true, true, true, address(L2Bridge));\n        emit ERC20BridgeFinalized(address(L2Token), address(L1Token), alice, alice, 100, hex\"\");\n\n        vm.prank(address(L2Messenger));\n        L2Bridge.finalizeBridgeERC20(address(L2Token), address(L1Token), alice, alice, 100, hex\"\");\n    }\n\n    function test_finalizeBridgeETH_incorrectValue_reverts() external {\n        vm.mockCall(\n            address(L2Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(address(L2Messenger), 100);\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"StandardBridge: amount sent does not match amount required\");\n        L2Bridge.finalizeBridgeETH{ value: 50 }(alice, alice, 100, hex\"\");\n    }\n\n    function test_finalizeBridgeETH_sendToSelf_reverts() external {\n        vm.mockCall(\n            address(L2Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(address(L2Messenger), 100);\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"StandardBridge: cannot send to self\");\n        L2Bridge.finalizeBridgeETH{ value: 100 }(alice, address(L2Bridge), 100, hex\"\");\n    }\n\n    function test_finalizeBridgeETH_sendToMessenger_reverts() external {\n        vm.mockCall(\n            address(L2Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(address(L2Messenger), 100);\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"StandardBridge: cannot send to messenger\");\n        L2Bridge.finalizeBridgeETH{ value: 100 }(alice, address(L2Messenger), 100, hex\"\");\n    }\n}\n\ncontract L2StandardBridge_FinalizeBridgeETH_Test is Bridge_Initializer {\n    function test_finalizeBridgeETH_succeeds() external {\n        address messenger = address(L2Bridge.MESSENGER());\n        vm.mockCall(\n            messenger,\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(messenger, 100);\n        vm.prank(messenger);\n\n        vm.expectEmit(true, true, true, true);\n        emit ETHBridgeFinalized(alice, alice, 100, hex\"\");\n\n        L2Bridge.finalizeBridgeETH{ value: 100 }(alice, alice, 100, hex\"\");\n    }\n}\n"
    },
    "contracts/test/L2ToL1MessagePasser.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract L2ToL1MessagePasserTest is CommonTest {\n    L2ToL1MessagePasser messagePasser;\n\n    event MessagePassed(\n        uint256 indexed nonce,\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes data,\n        bytes32 withdrawalHash\n    );\n\n    event WithdrawerBalanceBurnt(uint256 indexed amount);\n\n    function setUp() public override {\n        super.setUp();\n        messagePasser = new L2ToL1MessagePasser();\n    }\n\n    function testFuzz_initiateWithdrawal_succeeds(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        uint256 nonce = messagePasser.messageNonce();\n\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction({\n                nonce: nonce,\n                sender: _sender,\n                target: _target,\n                value: _value,\n                gasLimit: _gasLimit,\n                data: _data\n            })\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit MessagePassed(nonce, _sender, _target, _value, _gasLimit, _data, withdrawalHash);\n\n        vm.deal(_sender, _value);\n        vm.prank(_sender);\n        messagePasser.initiateWithdrawal{ value: _value }(_target, _gasLimit, _data);\n\n        assertEq(messagePasser.sentMessages(withdrawalHash), true);\n\n        bytes32 slot = keccak256(bytes.concat(withdrawalHash, bytes32(0)));\n\n        assertEq(vm.load(address(messagePasser), slot), bytes32(uint256(1)));\n    }\n\n    // Test: initiateWithdrawal should emit the correct log when called by a contract\n    function test_initiateWithdrawal_fromContract_succeeds() external {\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction(\n                messagePasser.messageNonce(),\n                address(this),\n                address(4),\n                100,\n                64000,\n                hex\"\"\n            )\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit MessagePassed(\n            messagePasser.messageNonce(),\n            address(this),\n            address(4),\n            100,\n            64000,\n            hex\"\",\n            withdrawalHash\n        );\n\n        vm.deal(address(this), 2**64);\n        messagePasser.initiateWithdrawal{ value: 100 }(address(4), 64000, hex\"\");\n    }\n\n    // Test: initiateWithdrawal should emit the correct log when called by an EOA\n    function test_initiateWithdrawal_fromEOA_succeeds() external {\n        uint256 gasLimit = 64000;\n        address target = address(4);\n        uint256 value = 100;\n        bytes memory data = hex\"ff\";\n        uint256 nonce = messagePasser.messageNonce();\n\n        // EOA emulation\n        vm.prank(alice, alice);\n        vm.deal(alice, 2**64);\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction(nonce, alice, target, value, gasLimit, data)\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit MessagePassed(nonce, alice, target, value, gasLimit, data, withdrawalHash);\n\n        messagePasser.initiateWithdrawal{ value: value }(target, gasLimit, data);\n\n        // the sent messages mapping is filled\n        assertEq(messagePasser.sentMessages(withdrawalHash), true);\n        // the nonce increments\n        assertEq(nonce + 1, messagePasser.messageNonce());\n    }\n\n    // Test: burn should destroy the ETH held in the contract\n    function test_burn_succeeds() external {\n        messagePasser.initiateWithdrawal{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            NON_ZERO_GASLIMIT,\n            NON_ZERO_DATA\n        );\n\n        assertEq(address(messagePasser).balance, NON_ZERO_VALUE);\n        vm.expectEmit(true, false, false, false);\n        emit WithdrawerBalanceBurnt(NON_ZERO_VALUE);\n        messagePasser.burn();\n\n        // The Withdrawer should have no balance\n        assertEq(address(messagePasser).balance, 0);\n    }\n}\n"
    },
    "contracts/test/MockProofData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nlibrary MockProofData {\n    function getProof() internal pure returns (uint256[] memory proof) {\n        proof = new uint256[](145);\n        proof[0] = 0x2db84b4be2adf33a9442a48e35273b442afb13491b53b5ddda9d28afa4bcc94f;\n        proof[1] = 0x250d0813a637b6894bcfda982e940ace442939d02d7d308bd269da5bc0d90c75;\n        proof[2] = 0x2490d94e7a9603f18a9a56bac4a4b9e8bade53765f36c8f47538723c99327c4a;\n        proof[3] = 0x2a9abdbc434023d970e442cc2b7faa601e2ab1056fd84d436e0f52fcbd166780;\n        proof[4] = 0x2cc4cf0d5d6183bb6e5d08abfe3f8ec7657979e9f36c63bc11bdbdc12f20f37c;\n        proof[5] = 0x13815ac8dd7a6a9fa4d8fc7ec4a6a873673edf90aade9e0dbe04ce14c42dda;\n        proof[6] = 0x04aa40d93c70c51f3bbf328d859be6a26fa47d42e20b90d588327735848403ad;\n        proof[7] = 0x0df93b34368a431946abd12d067ce6d53931b53bac92d60694caf306e72d2a50;\n        proof[8] = 0x11bab1ba91e7fc49ce58a1289a6a2d7fa4d93cf04cfc371edcb7b11c4a2b4bfc;\n        proof[9] = 0x248829f768e0b1cd3cb41dd2b1482a9a05d58e458d3e025f86cc84c5d5da3fb4;\n        proof[10] = 0x184b5e7a6fb160ac14f2a53ce08b28954b43b223e976f46b64c8995f84def8c3;\n        proof[11] = 0x20b15c5b8b8b44f49235ed5c6e1f8666188d11351b77d46b2856c4a33b48fec0;\n        proof[12] = 0x226cd7be86dfc4bca11d05ba1e9ba1ebef9d1616d58a17f6d3fec001d0067c30;\n        proof[13] = 0x0a261d4c6019b229b5294470107816b2f79cb244b424e15c1778a257f9cd4790;\n        proof[14] = 0x1852f911c1ea051ea2a50f9e5f39dee0852d4badbad834ac148b8b369846e907;\n        proof[15] = 0x2288c4537d56b6a28fa0a2cfe09766e93e90f2eb92c81688ea2cdeef0afc72ba;\n        proof[16] = 0x0d81a02023adaf01abe3590c13673e7c581aef8bd581a80aee86761f71f90b21;\n        proof[17] = 0x10d44a001fee7e0dbc06b6b57e4d8393437ed0412a449a4801f22058b67b0bd1;\n        proof[18] = 0x19332e828f4096178fe74522eabce81df92b68210b1b16d09778c3f9e687b1b6;\n        proof[19] = 0x13bf83223bc5e1073739b33ec41a99929db83dc3a00ab5129f35fb93c63f4f0c;\n        proof[20] = 0x1e382c6a607aa3d0a86b3c7378a6bec5e83e322efc33d87ba95b8edc656c2ffe;\n        proof[21] = 0x1d4e41c3f10623e542a1a554c1a0599d921ea0583a80c5f5801a6be0b36ff769;\n        proof[22] = 0x14798c2f163d17e71bd1b7f9748a544729c7e5dc1f8b69b845b7e02aede0e411;\n        proof[23] = 0x022c93db9a989e57489a594ea5a1c304e29e163f2adcad0a5010425370adb624;\n        proof[24] = 0x28fe543b1afdb31116b0c5e53e91a010dfa016703b8e9b04316029db1a11510c;\n        proof[25] = 0x124c6ee5db1ca2bdd3f962f2e3cce58a10650ac6b967829530e687f000c214a2;\n        proof[26] = 0x2d60c72ba9a3a0d187491b06c4df0c41e130a5d2df33920cdab35fe93f578d4e;\n        proof[27] = 0x2dc1271c3caa3a5864fe162ba3522ed39cd7aef06064fd03df0cfd54461999d0;\n        proof[28] = 0xfa4fef5681a8cb9644672210a01bc2a58ba899993de49f0a77134349ea9761;\n        proof[29] = 0x1960979499d99f991de05360b62b03ded924e108efaa4801cc79dbd4f85278f7;\n        proof[30] = 0x115a6687310ea2d9c49a9f85ca3a0b99d1a8ec6a18330743bbca6e0347664871;\n        proof[31] = 0x2eb8b744498591ffdc3e48fca13343accb0031e75767b8eb9c5ba01a862c413a;\n        proof[32] = 0x0114854f677f1947572248f21e615e4bbdbfee6ce2fd929d59e9e08d8c923d77;\n        proof[33] = 0x131046b319403852d7c020cb46caa55f725f050065c9188be78f29994a92281f;\n        proof[34] = 0x0188fee4217392d9bb7706d6a69f2e74351495b76fd73b77ec3c869ac9c66924;\n        proof[35] = 0x1cc8b335c07d157f2d55d7c2d38345bc4d73da18b5b6ca02b5d4a31fe353d11e;\n        proof[36] = 0x14f3a9e0b502d8ac7f64ef0a7d05429f67b6ebadd76bc5b61c8ab52332dacf99;\n        proof[37] = 0x19945e1f83400748b639727337349beefead70716cdedd9478b78ad228043cd9;\n        proof[38] = 0x12744893971ccde3ace7c85cfc2f239875f2a8c146f90e85b690d5b404beb474;\n        proof[39] = 0x04ef6e29fd15a5abe467245d1fe9a2d026fb545e41ccc16ac8b177d0421bd6b3;\n        proof[40] = 0x23d6063a0ced33b3b6425a328459edc1b65a84a03c017197f811f8739420ece7;\n        proof[41] = 0x1b3a63370c5c8870929204d5ae96fa6c94370c8c2b801090d87edd82c739ebc2;\n        proof[42] = 0x0260fc633ac72379d6e4114feaf38fb3fa3384f39a8e0cad4c825d2f5ebd8dc5;\n        proof[43] = 0x1a1e87a3b3337abc1d56a9f0260106ae1033689397b9e25b3847e2fafb69f649;\n        proof[44] = 0x21caaab53935e64ca343bf4aae9e01bb59cf8523d41757af3241a396be50f7df;\n        proof[45] = 0x01989a630f1dacc2e93e790600027e77f71b0c4cf09bb2c3a2407fab32951850;\n        proof[46] = 0x2b6b6beda62c3b6aa93194d39ab4f0f8709f7324496b4f4cbab666c6f15f0482;\n        proof[47] = 0x2d245ac58fb7feb64de4d83398fae025dc249eae59ef4969cce90e68803e68e1;\n        proof[48] = 0x1dc774f206d611c88cecfd81459c0e0e2778b1ea9e23b48d5a21a260a85b882c;\n        proof[49] = 0x29c93dd2e91809ccecf63d2dba8b69e3f3d4f2d1846590bdec28055c150d5665;\n        proof[50] = 0x1ba848ee49f53210dc1503f36bf92982628d9760d3c06fae021f50e99403b943;\n        proof[51] = 0x11d2a769e44495989e1ec075249c7cb6d8e26d12b834355b895017a7f92ffb38;\n        proof[52] = 0x0e3874c7ce21a8c229097fe511fcfb145e8f982f9a7a89efcc658a744ae9667a;\n        proof[53] = 0x227b6c05d9ddf0e45d8072e83105ca6054afa7f9343aa384ee993871be72a63b;\n        proof[54] = 0x1655bc2672198f8eed1944b9c5c10cc83da835fa6b3b65027539b69cc152dc6a;\n        proof[55] = 0x5dd989cf88d741e5cbeb6c7406ef33dad7667d9acbac2ecede2a546993ae4b;\n        proof[56] = 0x00;\n        proof[57] = 0x00;\n        proof[58] = 0x2d76c2e02aa6d2aaeb5bca6079c4701825ac73336b66ed69e508bae79f46c4f1;\n        proof[59] = 0x201a372c82f860bd5691cf0062560f6cbddf0ef1ee7e0d1762590ccfcc7c8597;\n        proof[60] = 0x298980f45d7a9d8f7de17d8b2992a1eb866111fbcc5308ad1f42ee97f666a8da;\n        proof[61] = 0x1112ccfc43917a7fadf94a93e1fd20671316e3abb44f1116170feb413ec7d104;\n        proof[62] = 0x05e2d7cd66f8c1ca5336b26f2e98f183a627b198147e8085022c3a940dd3196b;\n        proof[63] = 0x215766098fb23c74696d3706393ddb9a396ca17758bd63cdbd472157fd9f29df;\n        proof[64] = 0x05748fdf0f3353b25462c3365e0d7d5e5ef3fc42760e74c9bdb1ce33af18766d;\n        proof[65] = 0x026a7759962fa812bfbadcf5b0f57dcb70d6b693e87faf9078e640a0f58d0c73;\n        proof[66] = 0x0df6fc918932db1f885601a8bcd8765f2ae47b3ab8e6057b8032394c97ab2a0a;\n        proof[67] = 0x01f7c49650d7ad562aa1f40bc068d463d51eb92664221e3bea5d37df79de23bd;\n        proof[68] = 0x17f4510bfc9f8272f0920ab367148da96589621ad49087fe462c67c5000424c5;\n        proof[69] = 0x2e09167ff264977e20b815fa6af5074d501132a36e7828d60027a287589adddd;\n        proof[70] = 0x2163af6bc43129a82f8ef845174977866bfc62fe289bcff07e65601820d87547;\n        proof[71] = 0x1b176a40533b9244b19a5022763eb6716fe57be2f19ca57bd5b3075924e66e2c;\n        proof[72] = 0x0b0faa8423dfbeab0f2a8c56330e0b6de0101241f1a0bc25d44b5f48d73c60d3;\n        proof[73] = 0x1994b2e08132822991c92222b71d7425402d4aa38114ea43aed804cc8fa5850f;\n        proof[74] = 0x02e8759280468e1fc2b831734154a63238b9e8766b67c57d34e63d692963e94e;\n        proof[75] = 0x07b5df97dff873ffd28a1aac69d0cf0eff3d2d327a19a97908919133b9102538;\n        proof[76] = 0x2e05d794ef0fa654f4319bdf071bc2e18b7c84ab71a5526f7027035183f5080c;\n        proof[77] = 0x210ecfd49532a3beeda06210ca026b1558dcce83e4468cfd174ffe100858259e;\n        proof[78] = 0x29c9ac5471e1d9b9ef46ddb5eede61f52684ce4cb82886fa478f45696d9de7d7;\n        proof[79] = 0x15680777ad270e04d48d69b00c93d59b9456d69b6378a49c107535dd0f66b5d2;\n        proof[80] = 0x2cd8ada9d3bfa05bcd4ac63ecbd16a2d0f6e8f3041a4477d6d9b35f37edd4a37;\n        proof[81] = 0x0aaf4bc683e3967d07c96343a25648b07d237ae33d1da5971b77ae9dae2955df;\n        proof[82] = 0x2cc473cead4472dbea390fa73bb61766c94090c6e34d8da1db57dee735a3efd8;\n        proof[83] = 0x194fb396d45beefe932befe4f67e23431f5f529f2005b49ae553f30495ef9353;\n        proof[84] = 0x25c2bf9c4d955b4a71bba35c46c114a2fa8e9ed171918e3dce6cf80410f87940;\n        proof[85] = 0x0b06ab766e7a8824c4506cfa82e33fc4c9255161d10d8caee641bebe1c146ec8;\n        proof[86] = 0x109d6860031accac7b6a3de0281ce548411a183e255489e2db47cec180d46222;\n        proof[87] = 0x15183c73e1a213e84c08ef462f386d0e8ed43b68aee9d3e60af90b4f25a740e1;\n        proof[88] = 0x21e05690a731c64c3de54ffc544f5fdf0f1983cc6c648438a9d549da56ec79bc;\n        proof[89] = 0x0b06ab766e7a8824c4506cfa82e33fc4c9255161d10d8caee641bebe1c146ec8;\n        proof[90] = 0x00;\n        proof[91] = 0x0b2c8caabaa2caf038b83bbfc7739f991d635de720c3e5cc895801b241933c23;\n        proof[92] = 0x2e93bb3a5dfbdcb8cbad6fd1bc85002769831bdf102db42140b79cd8f5ae851a;\n        proof[93] = 0x2af618448e46a8cc8ba91c7211c8bc37c8e1e8c5ec123a71b3ea684229a92061;\n        proof[94] = 0x19da634c22e60424bf6a9dd10bb28d6ec8d22aceceb1a21259b7ad512b80d7d8;\n        proof[95] = 0x19f0c7ab77bc981eeeb03defc3300bb3eb73eeb116368e353b37df4d1026bdd9;\n        proof[96] = 0x231bb3c25d644facb72a230652a00e3eb8c69d7e97d918a35c99fbeb96b283ae;\n        proof[97] = 0x25ce5cab38dd6fe45eb58a54db8965b229533b9026e629d01a0ff5e93fb36613;\n        proof[98] = 0x101f0fe2780f5df9659ceef59699edc843c63ea21d06ccb9de952896bae3367d;\n        proof[99] = 0x16186ed2512656f776c97498ce2576f28ebb54e8c86a0da7f41835264c4629ed;\n        proof[100] = 0x04e96ea6dc24ed0cec658845c1f4bcdbea3de9a796d69df9f59a2612a1ab9607;\n        proof[101] = 0x2a54185888e01ef4dafc8517bed9edabaafec3fc81124b505ae21ac43001319f;\n        proof[102] = 0x2a3c6af9332905821d87edbadaa97c3fd17db5d4cbe9757210d9735f0ceec752;\n        proof[103] = 0x05c5a92af02e95a6a0a69eb25694d0fb74462f315fa1ad1818e5a85f33e491a2;\n        proof[104] = 0x1bc3abe88a59e2c92f4e1280305854058f0021c760e64203bb5fbcb66f896126;\n        proof[105] = 0x25956f67e3a354fbd7ff67e032190f0d158d3f874b7b5bad3c38afb6e903a642;\n        proof[106] = 0x105ede25ccaee90ac72f6708c8a38bf2850815dc69ea60a7736bafa1f1f2ac86;\n        proof[107] = 0x11df505e995d9610be41329fb0ca1c01e5b2bed405b41054816fce6669d6295c;\n        proof[108] = 0x0848561d29d0c2d5258586217ac15ef0ce03fcf01e605af9c515e3570dc425fe;\n        proof[109] = 0x2980e3871aa6bfc828920c1ee3783c2e17f1ef598b4a584255ed947944b074cf;\n        proof[110] = 0x0a105490d794934fdf7736e205dc95a97edac64c22e1dd5e291ee3183188701c;\n        proof[111] = 0x082a220ee89fdf4b6a30e72f5a1b82d5aec1a87662232483cf68d6c3c2a1253e;\n        proof[112] = 0x0f87b14b92855e790ed930a65bbd5d46ffd07cd2988ee6bc3539179d85f670d6;\n        proof[113] = 0x08bf58730a1f7c62121dae23d291b9cb02733d2e7af22a04e66b92bf1f54fdac;\n        proof[114] = 0x0cf23d10dca096f4e5fced9df398b59d9c0824344847874364d689eeecf12710;\n        proof[115] = 0x254abac420c9ef64fc68d874129ba838624ba2f3311282825632e8cf47821e2a;\n        proof[116] = 0x06127cea34afb05ce8ec3195449fc48ffdc8657ecb11bc7a9fc8db1e4dc3603e;\n        proof[117] = 0x30621754c15ee309248b234cc075f50ed8877d15f85d77fbff1c6de28c23dacf;\n        proof[118] = 0x13dff59922f93949189c27f30415ca9d54accb449dd119b9475b2d15cad9a6f3;\n        proof[119] = 0x05031a89082237448f24a66ffd905666246c2d85a49f7b4eb0da3875fa2660be;\n        proof[120] = 0x10f5edd2e9fa1feebe23a308d315aab10d6974f2e3d552a2981755d403dd2736;\n        proof[121] = 0x01e26f56d99ccbfaf01af471bffd470ce8a3e27bc679e2720985b9a1c09449d5;\n        proof[122] = 0x0b5a2123fa330a2e336e3442d7397e4987fef041d1d97837a552d3ad24e6fb89;\n        proof[123] = 0x1817d114ac9114e78db222a7c74b02fc30764bd11cdad32754a7aa72666ab623;\n        proof[124] = 0x2a00f0c2cee59c02158e8db512c73385f28ab1eb70b7ef73e86341228e808c2c;\n        proof[125] = 0x0dcc90c63560947d908d34924d5d2514f7bb1be784b1c010ae2bb6719586b38a;\n        proof[126] = 0x281af6ca14665d0794140820893ebb480e8d1ef8cdf0fe37094fb71f34612efc;\n        proof[127] = 0x07a67b4ab73ddd87281b6b021a4b2f19eb88367695fb6066abfacef5fa02c825;\n        proof[128] = 0x255568cf81305745af3dcb913e6f4077e2d48aa352f60c6e707869c6cfb73e3c;\n        proof[129] = 0x1229b93581b80ff61a1ad68c537f8af5d883fc11a140f76c62629d58a7d2c845;\n        proof[130] = 0x147ba8fab506e63208261ab6c22276ec35844aabef134aba290c6590f571d3e6;\n        proof[131] = 0x0edd6a1fe0fad061c6a45e8c0aa4d262a31f0904350ed34337243d2d276962f8;\n        proof[132] = 0x11477afad1a93575ef7bfa68c0e04484a9108e79ef63d616ca614b05baa7682e;\n        proof[133] = 0x0146480b406ef84e790dfea079f512525dcbf361341faa069531fbd44aef0425;\n        proof[134] = 0x0365d0de11cfad24fbd45f19d074d47e08fd3061115ab25de33aae7593db8275;\n        proof[135] = 0x29c6c9fefedb97686bcc4a71342dabe64c0c263ba7136cc4354177418370d819;\n        proof[136] = 0x0942c5e91535d5709f74e17107b787fdaf245b0711e2c1309340a47daef6d935;\n        proof[137] = 0x0ee6d8ea0859a1b88b041585d306351a67fb45f200dd966533a3da400091ca2f;\n        proof[138] = 0x2faa206c54f151b6421a4377d3a90068f0b488e27de457b468be4cd13bd66137;\n        proof[139] = 0x22a59373bcc665291647afc23f16af49e218a499c70fdfbe6c3d32220ba949a9;\n        proof[140] = 0x2667d6f5bf28ebfc754e1bc3214234bf14853c097473bbe5574e7c91b09a08ee;\n        proof[141] = 0x117425b1586f174cbae9dae1325482e2c239e15d5354f8e952674cf847cd97bb;\n        proof[142] = 0x242881b0dacfde429de1a253a9866681e0d2a02b0a84b7f21b2cfd195210ab12;\n        proof[143] = 0x1e15ec1297adf2bd19b2098779edcfc324e5a140c3f43b225a0337177acd7d66;\n        proof[144] = 0x10735949561e38cbf5801fc6f4005a165325ab8b08b7cd40d7e9d76729b5999d;\n\n        return proof;\n    }\n\n    function getPair() internal pure returns (uint256[] memory pair) {\n        pair = new uint256[](4);\n        pair[0] = 11043928860274208474100222903659720401105736444942783912777777731178123111009;\n        pair[1] = 4733049234560598175814075307329400052685708929235536361180057682884349522951;\n        pair[2] = 12927143393367435583780384041605583199602086804808450831263369829150907626360;\n        pair[3] = 4387398449564854858399845335905273397295727913637629556341886693575315457608;\n\n        return pair;\n    }\n}\n"
    },
    "contracts/test/NodeReader.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { NodeReader } from \"../libraries/NodeReader.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract NodeReader_Test is CommonTest {\n    function test_readUint8_bytestring00() external {\n        NodeReader.Item memory item = NodeReader.toItem(hex\"00\");\n        assertEq(NodeReader.readUint8(item), uint8(0x00));\n    }\n\n    function test_readUint8_bytestring01() external {\n        NodeReader.Item memory item = NodeReader.toItem(hex\"01\");\n        assertEq(NodeReader.readUint8(item), uint8(0x01));\n    }\n\n    function test_readUint8_bytestring7f() external {\n        NodeReader.Item memory item = NodeReader.toItem(hex\"7f\");\n        assertEq(NodeReader.readUint8(item), uint8(0x7f));\n    }\n\n    function test_readUint8_too_short_bytestring() external {\n        vm.expectRevert(\"NodeReader: too short for uint8\");\n        NodeReader.Item memory item = NodeReader.toItem(hex\"\");\n        NodeReader.readUint8(item);\n    }\n\n    function test_readCompressedFlags_length01_and_flag000003() external {\n        NodeReader.Item memory item = NodeReader.toItem(hex\"01030000\");\n        (uint32 compressedFlags, uint8 len) = NodeReader.readCompressedFlags(item);\n        assertEq(compressedFlags, uint32(3));\n        assertEq(len, uint8(1));\n    }\n\n    function test_readCompressedFlags_too_short_byte() external {\n        vm.expectRevert(\"NodeReader: too short for uint32\");\n        NodeReader.Item memory item = NodeReader.toItem(hex\"\");\n        NodeReader.readCompressedFlags(item);\n    }\n\n    function test_readBytes32_32bytesting() external {\n        NodeReader.Item memory item = NodeReader.toItem(\n            hex\"000102030405060708090a0b0c0d0e0f101112131415161718192a2b2c2d2e2f\"\n        );\n        assertEq(\n            NodeReader.readBytes32(item),\n            hex\"000102030405060708090a0b0c0d0e0f101112131415161718192a2b2c2d2e2f\"\n        );\n    }\n\n    function test_readBytes32_too_short_byte() external {\n        vm.expectRevert(\"NodeReader: too short for bytes32\");\n        NodeReader.Item memory item = NodeReader.toItem(hex\"\");\n        NodeReader.readBytes32(item);\n    }\n\n    function test_readBytesN_4bytesting() external {\n        NodeReader.Item memory item = NodeReader.toItem(hex\"0001020304\");\n        assertEq(NodeReader.readBytesN(item, 4), bytes32(uint256(0x010203)));\n    }\n\n    function test_readBytesN_too_short_byte() external {\n        vm.expectRevert(\"NodeReader: too short for n bytes\");\n        NodeReader.Item memory item = NodeReader.toItem(hex\"0001020304\");\n        NodeReader.readBytesN(item, 6);\n    }\n\n    function test_readNode_middle_node() external {\n        bytes memory middleHex = new bytes(65);\n        bytes32 childL = hex\"0000000000000000000000000000000000000000000000000000000000000000\";\n        bytes32 childR = hex\"04470b58d80eeb26da85b2c2db5c254900656fb459c07729f556ff02534ab32a\";\n        assembly {\n            mstore8(add(middleHex, 32), 0)\n            mstore(add(middleHex, 33), childL)\n            mstore(add(middleHex, 65), childR)\n        }\n        NodeReader.Node memory node = NodeReader.readNode(middleHex);\n        assertEq(uint256(node.nodeType), uint256(NodeReader.NodeType.MIDDLE));\n        assertEq(node.childL, childL);\n        assertEq(node.childR, childR);\n    }\n\n    function test_readNode_leaf_node() external {\n        bytes memory leafHex = new bytes(102);\n        bytes32 nodeKey = hex\"7f9d3bbc51d12566ecc6049ca6bf76e32828c22b197405f63a833b566fe7da0a\";\n        bytes32 value = hex\"0000000000000000000000000000000000000000000000000000000000000001\";\n        assembly {\n            mstore8(add(leafHex, 32), 1)\n            mstore(add(leafHex, 33), nodeKey)\n            mstore8(add(leafHex, 65), 1)\n            mstore8(add(leafHex, 66), 1)\n            mstore8(add(leafHex, 67), 0)\n            mstore8(add(leafHex, 68), 0)\n            mstore(add(leafHex, 69), value)\n            mstore8(add(leafHex, 101), 0)\n        }\n        NodeReader.Node memory node = NodeReader.readNode(leafHex);\n        assertEq(uint256(node.nodeType), uint256(NodeReader.NodeType.LEAF));\n        assertEq(node.nodeKey, nodeKey);\n        assertEq(node.compressedFlags, 1);\n        assertEq(node.valuePreimage.length, 1);\n        assertEq(node.valuePreimage[0], value);\n    }\n\n    function test_readNode_empty_node() external {\n        bytes memory emptyHex = new bytes(1);\n        assembly {\n            mstore8(add(emptyHex, 32), 2)\n        }\n        NodeReader.Node memory node = NodeReader.readNode(emptyHex);\n        assertEq(uint256(node.nodeType), uint256(NodeReader.NodeType.EMPTY));\n    }\n\n    function test_readNode_root_node() external {\n        vm.expectRevert(\"NodeReader: unexpected root node type\");\n        bytes memory rootHex = new bytes(1);\n        assembly {\n            mstore8(add(rootHex, 32), 3)\n        }\n        NodeReader.readNode(rootHex);\n    }\n\n    function test_readNode_invalid_node() external {\n        vm.expectRevert(\"NodeReader: invalid node type\");\n        bytes memory invalidHex = new bytes(1);\n        assembly {\n            mstore8(add(invalidHex, 32), 4)\n        }\n        NodeReader.readNode(invalidHex);\n    }\n}\n"
    },
    "contracts/test/ProposerFeeVault.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { ProposerFeeVault } from \"../L2/ProposerFeeVault.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\n\ncontract ProposerFeeVault_Test is Bridge_Initializer {\n    ProposerFeeVault vault = ProposerFeeVault(payable(Predeploys.PROPOSER_FEE_WALLET));\n    address constant recipient = address(256);\n\n    event Withdrawal(uint256 value, address to, address from);\n\n    function setUp() public override {\n        super.setUp();\n        vm.etch(Predeploys.PROPOSER_FEE_WALLET, address(new ProposerFeeVault(recipient)).code);\n        vm.label(Predeploys.PROPOSER_FEE_WALLET, \"ProposerFeeVault\");\n    }\n\n    function test_minWithdrawalAmount_succeeds() external {\n        assertEq(vault.MIN_WITHDRAWAL_AMOUNT(), 10 ether);\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(vault.RECIPIENT(), recipient);\n    }\n\n    function test_receive_succeeds() external {\n        uint256 balance = address(vault).balance;\n\n        vm.prank(alice);\n        (bool success, ) = address(vault).call{ value: 100 }(hex\"\");\n\n        assertEq(success, true);\n        assertEq(address(vault).balance, balance + 100);\n    }\n\n    function test_withdraw_notEnough_reverts() external {\n        assert(address(vault).balance < vault.MIN_WITHDRAWAL_AMOUNT());\n\n        vm.expectRevert(\n            \"FeeVault: withdrawal amount must be greater than minimum withdrawal amount\"\n        );\n        vault.withdraw();\n    }\n\n    function test_withdraw_succeeds() external {\n        uint256 amount = vault.MIN_WITHDRAWAL_AMOUNT() + 1;\n        vm.deal(address(vault), amount);\n\n        // No ether has been withdrawn yet\n        assertEq(vault.totalProcessed(), 0);\n\n        vm.expectEmit(true, true, true, true, address(Predeploys.PROPOSER_FEE_WALLET));\n        emit Withdrawal(address(vault).balance, vault.RECIPIENT(), address(this));\n\n        // The entire vault's balance is withdrawn\n        vm.expectCall(\n            Predeploys.L2_STANDARD_BRIDGE,\n            address(vault).balance,\n            abi.encodeWithSelector(\n                StandardBridge.bridgeETHTo.selector,\n                vault.RECIPIENT(),\n                35_000,\n                bytes(\"\")\n            )\n        );\n\n        vault.withdraw();\n\n        // The withdrawal was successful\n        assertEq(vault.totalProcessed(), amount);\n    }\n}\n"
    },
    "contracts/test/Proxy.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\nimport { Test } from \"forge-std/Test.sol\";\n\nimport { Proxy } from \"../universal/Proxy.sol\";\n\ncontract SimpleStorage {\n    mapping(uint256 => uint256) internal store;\n\n    function get(uint256 key) external payable returns (uint256) {\n        return store[key];\n    }\n\n    function set(uint256 key, uint256 value) external payable {\n        store[key] = value;\n    }\n}\n\ncontract Clasher {\n    function upgradeTo(address) external pure {\n        revert(\"upgradeTo\");\n    }\n}\n\ncontract Proxy_Test is Test {\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    address alice = address(64);\n\n    bytes32 internal constant IMPLEMENTATION_KEY =\n        bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1);\n\n    bytes32 internal constant OWNER_KEY = bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1);\n\n    Proxy proxy;\n    SimpleStorage simpleStorage;\n\n    function setUp() external {\n        // Deploy a proxy and simple storage contract as\n        // the implementation\n        proxy = new Proxy(alice);\n        simpleStorage = new SimpleStorage();\n\n        vm.prank(alice);\n        proxy.upgradeTo(address(simpleStorage));\n    }\n\n    function test_implementationKey_succeeds() external {\n        // The hardcoded implementation key should be correct\n        vm.prank(alice);\n        proxy.upgradeTo(address(6));\n\n        bytes32 key = vm.load(address(proxy), IMPLEMENTATION_KEY);\n        assertEq(address(6), Bytes32AddressLib.fromLast20Bytes(key));\n\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(6));\n    }\n\n    function test_ownerKey_succeeds() external {\n        // The hardcoded owner key should be correct\n        vm.prank(alice);\n        proxy.changeAdmin(address(6));\n\n        bytes32 key = vm.load(address(proxy), OWNER_KEY);\n        assertEq(address(6), Bytes32AddressLib.fromLast20Bytes(key));\n\n        vm.prank(address(6));\n        address owner = proxy.admin();\n        assertEq(owner, address(6));\n    }\n\n    function test_proxyCallToImp_notAdmin_succeeds() external {\n        // The implementation does not have a `upgradeTo`\n        // method, calling `upgradeTo` not as the owner\n        // should revert.\n        vm.expectRevert();\n        proxy.upgradeTo(address(64));\n\n        // Call `upgradeTo` as the owner, it should succeed\n        // and emit the `Upgraded` event.\n        vm.expectEmit(true, true, true, true);\n        emit Upgraded(address(64));\n        vm.prank(alice);\n        proxy.upgradeTo(address(64));\n\n        // Get the implementation as the owner\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(64));\n    }\n\n    function test_ownerProxyCall_notAdmin_succeeds() external {\n        // Calling `changeAdmin` not as the owner should revert\n        // as the implementation does not have a `changeAdmin` method.\n        vm.expectRevert();\n        proxy.changeAdmin(address(1));\n\n        // Call `changeAdmin` as the owner, it should succeed\n        // and emit the `AdminChanged` event.\n        vm.expectEmit(true, true, true, true);\n        emit AdminChanged(alice, address(1));\n        vm.prank(alice);\n        proxy.changeAdmin(address(1));\n\n        // Calling `admin` not as the owner should\n        // revert as the implementation does not have\n        // a `admin` method.\n        vm.expectRevert();\n        proxy.admin();\n\n        // Calling `admin` as the owner should work.\n        vm.prank(address(1));\n        address owner = proxy.admin();\n        assertEq(owner, address(1));\n    }\n\n    function test_delegatesToImpl_succeeds() external {\n        // Call the storage setter on the proxy\n        SimpleStorage(address(proxy)).set(1, 1);\n\n        // The key should not be set in the implementation\n        uint256 result = simpleStorage.get(1);\n        assertEq(result, 0);\n        {\n            // The key should be set in the proxy\n            uint256 expect = SimpleStorage(address(proxy)).get(1);\n            assertEq(expect, 1);\n        }\n\n        {\n            // The owner should be able to call through the proxy\n            // when there is not a function selector crash\n            vm.prank(alice);\n            uint256 expect = SimpleStorage(address(proxy)).get(1);\n            assertEq(expect, 1);\n        }\n    }\n\n    function test_upgradeToAndCall_succeeds() external {\n        {\n            // There should be nothing in the current proxy storage\n            uint256 expect = SimpleStorage(address(proxy)).get(1);\n            assertEq(expect, 0);\n        }\n\n        // Deploy a new SimpleStorage\n        simpleStorage = new SimpleStorage();\n\n        // Set the new SimpleStorage as the implementation\n        // and call.\n        vm.expectEmit(true, true, true, true);\n        emit Upgraded(address(simpleStorage));\n        vm.prank(alice);\n        proxy.upgradeToAndCall(\n            address(simpleStorage),\n            abi.encodeWithSelector(simpleStorage.set.selector, 1, 1)\n        );\n\n        // The call should have impacted the state\n        uint256 result = SimpleStorage(address(proxy)).get(1);\n        assertEq(result, 1);\n    }\n\n    function test_upgradeToAndCall_functionDoesNotExist_reverts() external {\n        // Get the current implementation address\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(simpleStorage));\n\n        // Deploy a new SimpleStorage\n        simpleStorage = new SimpleStorage();\n\n        // Set the new SimpleStorage as the implementation\n        // and call. This reverts because the calldata doesn't\n        // match a function on the implementation.\n        vm.expectRevert(\"Proxy: delegatecall to new implementation contract failed\");\n        vm.prank(alice);\n        proxy.upgradeToAndCall(address(simpleStorage), hex\"\");\n\n        // The implementation address should have not\n        // updated because the call to `upgradeToAndCall`\n        // reverted.\n        vm.prank(alice);\n        address postImpl = proxy.implementation();\n        assertEq(impl, postImpl);\n\n        // The attempt to `upgradeToAndCall`\n        // should revert when it is not called by the owner.\n        vm.expectRevert();\n        proxy.upgradeToAndCall(\n            address(simpleStorage),\n            abi.encodeWithSelector(simpleStorage.set.selector, 1, 1)\n        );\n    }\n\n    function test_upgradeToAndCall_isPayable_succeeds() external {\n        // Give alice some funds\n        vm.deal(alice, 1 ether);\n        // Set the implementation and call and send\n        // value.\n        vm.prank(alice);\n        proxy.upgradeToAndCall{ value: 1 ether }(\n            address(simpleStorage),\n            abi.encodeWithSelector(simpleStorage.set.selector, 1, 1)\n        );\n\n        // The implementation address should be correct\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(simpleStorage));\n\n        // The proxy should have a balance\n        assertEq(address(proxy).balance, 1 ether);\n    }\n\n    function test_upgradeTo_clashingFunctionSignatures_succeeds() external {\n        // Clasher has a clashing function with the proxy.\n        Clasher clasher = new Clasher();\n\n        // Set the clasher as the implementation.\n        vm.prank(alice);\n        proxy.upgradeTo(address(clasher));\n\n        {\n            // Assert that the implementation was set properly.\n            vm.prank(alice);\n            address impl = proxy.implementation();\n            assertEq(impl, address(clasher));\n        }\n\n        // Call the clashing function on the proxy\n        // not as the owner so that the call passes through.\n        // The implementation will revert so we can be\n        // sure that the call passed through.\n        vm.expectRevert(bytes(\"upgradeTo\"));\n        proxy.upgradeTo(address(0));\n\n        {\n            // Now call the clashing function as the owner\n            // and be sure that it doesn't pass through to\n            // the implementation.\n            vm.prank(alice);\n            proxy.upgradeTo(address(0));\n            vm.prank(alice);\n            address impl = proxy.implementation();\n            assertEq(impl, address(0));\n        }\n    }\n\n    // Allow for `eth_call` to call proxy methods\n    // by setting \"from\" to `address(0)`.\n    function test_implementation_zeroAddressCaller_succeeds() external {\n        vm.prank(address(0));\n        address impl = proxy.implementation();\n        assertEq(impl, address(simpleStorage));\n    }\n\n    function test_implementation_isZeroAddress_reverts() external {\n        // Set `address(0)` as the implementation.\n        vm.prank(alice);\n        proxy.upgradeTo(address(0));\n\n        (bool success, bytes memory returndata) = address(proxy).call(hex\"\");\n        assertEq(success, false);\n\n        bytes memory err = abi.encodeWithSignature(\n            \"Error(string)\",\n            \"Proxy: implementation not initialized\"\n        );\n\n        assertEq(returndata, err);\n    }\n}\n"
    },
    "contracts/test/ProxyAdmin.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\n\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { ProxyAdmin } from \"../universal/ProxyAdmin.sol\";\nimport { SimpleStorage } from \"./Proxy.t.sol\";\n\ncontract ProxyAdmin_Test is Test {\n    address alice = address(64);\n\n    Proxy proxy;\n\n    ProxyAdmin admin;\n\n    SimpleStorage implementation;\n\n    function setUp() external {\n        // Deploy the proxy admin\n        admin = new ProxyAdmin(alice);\n        // Deploy the standard proxy\n        proxy = new Proxy(address(admin));\n\n        implementation = new SimpleStorage();\n    }\n\n    function test_owner_succeeds() external {\n        assertEq(admin.owner(), alice);\n    }\n\n    function test_getProxyImplementation_succeeds() external {\n        {\n            address impl = admin.getProxyImplementation(payable(proxy));\n            assertEq(impl, address(0));\n        }\n\n        vm.prank(alice);\n        admin.upgrade(payable(proxy), address(implementation));\n\n        {\n            address impl = admin.getProxyImplementation(payable(proxy));\n            assertEq(impl, address(implementation));\n        }\n    }\n\n    function test_getProxyAdmin_succeeds() external {\n        address owner = admin.getProxyAdmin(payable(proxy));\n        assertEq(owner, address(admin));\n    }\n\n    function test_changeProxyAdmin_succeeds() external {\n        vm.prank(alice);\n        admin.changeProxyAdmin(payable(proxy), address(128));\n\n        // The proxy is no longer the admin and can\n        // no longer call the proxy interface.\n        vm.expectRevert(\"Proxy: implementation not initialized\");\n        admin.getProxyAdmin(payable(proxy));\n\n        // Call the proxy contract directly to get the admin.\n        // Different proxy types have different interfaces.\n        vm.prank(address(128));\n        assertEq(Proxy(payable(proxy)).admin(), address(128));\n    }\n\n    function test_upgrade_succeeds() external {\n        vm.prank(alice);\n        admin.upgrade(payable(proxy), address(implementation));\n\n        address impl = admin.getProxyImplementation(payable(proxy));\n        assertEq(impl, address(implementation));\n    }\n\n    function test_upgradeAndCall_succeeds() external {\n        vm.prank(alice);\n        admin.upgradeAndCall(\n            payable(proxy),\n            address(implementation),\n            abi.encodeWithSelector(SimpleStorage.set.selector, 1, 1)\n        );\n\n        address impl = admin.getProxyImplementation(payable(proxy));\n        assertEq(impl, address(implementation));\n\n        uint256 got = SimpleStorage(address(proxy)).get(1);\n        assertEq(got, 1);\n    }\n\n    function test_onlyOwner_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        admin.changeProxyAdmin(payable(proxy), address(0));\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        admin.upgrade(payable(proxy), address(implementation));\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        admin.upgradeAndCall(payable(proxy), address(implementation), hex\"\");\n    }\n}\n"
    },
    "contracts/test/RLP.t.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\n\n/**\n * @title LibRLP\n * @notice Via https://github.com/Rari-Capital/solmate/issues/207.\n */\nlibrary LibRLP {\n    using Bytes32AddressLib for bytes32;\n\n    function computeAddress(address deployer, uint256 nonce) internal pure returns (address) {\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\n        // A one byte integer uses its own value as its length prefix, there is no additional \"0x80 + length\" prefix that comes before it.\n        if (nonce == 0x00)\n            return\n                keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80)))\n                    .fromLast20Bytes();\n        if (nonce <= 0x7f)\n            return\n                keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce)))\n                    .fromLast20Bytes();\n\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\n        if (nonce <= type(uint8).max)\n            return\n                keccak256(\n                    abi.encodePacked(\n                        bytes1(0xd7),\n                        bytes1(0x94),\n                        deployer,\n                        bytes1(0x81),\n                        uint8(nonce)\n                    )\n                ).fromLast20Bytes();\n        if (nonce <= type(uint16).max)\n            return\n                keccak256(\n                    abi.encodePacked(\n                        bytes1(0xd8),\n                        bytes1(0x94),\n                        deployer,\n                        bytes1(0x82),\n                        uint16(nonce)\n                    )\n                ).fromLast20Bytes();\n        if (nonce <= type(uint24).max)\n            return\n                keccak256(\n                    abi.encodePacked(\n                        bytes1(0xd9),\n                        bytes1(0x94),\n                        deployer,\n                        bytes1(0x83),\n                        uint24(nonce)\n                    )\n                ).fromLast20Bytes();\n\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\n        return\n            keccak256(\n                abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce))\n            ).fromLast20Bytes();\n    }\n}\n"
    },
    "contracts/test/ResourceMetering.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\n\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\n\ncontract MeterUser is ResourceMetering {\n    constructor() {\n        initialize();\n    }\n\n    function initialize() public initializer {\n        __ResourceMetering_init();\n    }\n\n    function use(uint64 _amount) public metered(_amount) {}\n\n    function set(\n        uint128 _prevBaseFee,\n        uint64 _prevBoughtGas,\n        uint64 _prevBlockNum\n    ) public {\n        params = ResourceMetering.ResourceParams({\n            prevBaseFee: _prevBaseFee,\n            prevBoughtGas: _prevBoughtGas,\n            prevBlockNum: _prevBlockNum\n        });\n    }\n}\n\ncontract ResourceMetering_Test is Test {\n    MeterUser internal meter;\n    uint64 initialBlockNum;\n\n    function setUp() public {\n        meter = new MeterUser();\n        initialBlockNum = uint64(block.number);\n    }\n\n    /**\n     * @notice The INITIAL_BASE_FEE must be less than the MAXIMUM_BASE_FEE\n     *         and greater than the MINIMUM_BASE_FEE.\n     */\n    function test_meter_initialBaseFee_succeeds() external {\n        uint256 max = uint256(meter.MAXIMUM_BASE_FEE());\n        uint256 min = uint256(meter.MINIMUM_BASE_FEE());\n        uint256 initial = uint256(meter.INITIAL_BASE_FEE());\n        assertTrue(max >= initial);\n        assertTrue(min <= initial);\n    }\n\n    /**\n     * @notice The MINIMUM_BASE_FEE must be less than the MAXIMUM_BASE_FEE.\n     */\n    function test_meter_minBaseFeeLessThanMaxBaseFee_succeeds() external {\n        uint256 max = uint256(meter.MAXIMUM_BASE_FEE());\n        uint256 min = uint256(meter.MINIMUM_BASE_FEE());\n        assertTrue(max > min);\n    }\n\n    function test_meter_initialResourceParams_succeeds() external {\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, meter.INITIAL_BASE_FEE());\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum);\n    }\n\n    function test_meter_maxValue_succeeds() external {\n        uint256 max = uint256(meter.MAX_RESOURCE_LIMIT());\n        uint256 target = uint256(meter.TARGET_RESOURCE_LIMIT());\n        uint256 elasticity = uint256(meter.ELASTICITY_MULTIPLIER());\n        assertEq(max / elasticity, target);\n    }\n\n    function test_meter_updateParamsNoChange_succeeds() external {\n        meter.use(0); // equivalent to just updating the base fee and block number\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n        meter.use(0);\n        (uint128 postBaseFee, uint64 postBoughtGas, uint64 postBlockNum) = meter.params();\n\n        assertEq(postBaseFee, prevBaseFee);\n        assertEq(postBoughtGas, prevBoughtGas);\n        assertEq(postBlockNum, prevBlockNum);\n    }\n\n    function test_meter_updateOneEmptyBlock_succeeds() external {\n        vm.roll(initialBlockNum + 1);\n        meter.use(0);\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, 1 gwei);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum + 1);\n    }\n\n    function test_meter_updateTwoEmptyBlocks_succeeds() external {\n        vm.roll(initialBlockNum + 2);\n        meter.use(0);\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, 1 gwei);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum + 2);\n    }\n\n    function test_meter_updateTenEmptyBlocks_succeeds() external {\n        vm.roll(initialBlockNum + 10);\n        meter.use(0);\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, 1 gwei);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum + 10);\n    }\n\n    function test_meter_updateNoGasDelta_succeeds() external {\n        uint64 target = uint64(uint256(meter.TARGET_RESOURCE_LIMIT()));\n        meter.use(target);\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, 1000000000);\n        assertEq(prevBoughtGas, target);\n        assertEq(prevBlockNum, initialBlockNum);\n    }\n\n    function test_meter_useMax_succeeds() external {\n        uint64 target = uint64(uint256(meter.TARGET_RESOURCE_LIMIT()));\n        uint64 elasticity = uint64(uint256(meter.ELASTICITY_MULTIPLIER()));\n        meter.use(target * elasticity);\n\n        (, uint64 prevBoughtGas, ) = meter.params();\n        assertEq(prevBoughtGas, target * elasticity);\n\n        vm.roll(initialBlockNum + 1);\n        meter.use(0);\n        (uint128 postBaseFee, , ) = meter.params();\n        assertEq(postBaseFee, 2125000000);\n    }\n\n    function test_meter_useMoreThanMax_reverts() external {\n        uint64 target = uint64(uint256(meter.TARGET_RESOURCE_LIMIT()));\n        uint64 elasticity = uint64(uint256(meter.ELASTICITY_MULTIPLIER()));\n        vm.expectRevert(\"ResourceMetering: cannot buy more gas than available gas limit\");\n        meter.use(target * elasticity + 1);\n    }\n\n    // Demonstrates that the resource metering arithmetic can tolerate very large gaps between\n    // deposits.\n    function testFuzz_meter_largeBlockDiff_succeeds(uint64 _amount, uint256 _blockDiff) external {\n        // This test fails if the following line is commented out.\n        // At 12 seconds per block, this number is effectively unreachable.\n        vm.assume(_blockDiff < 433576281058164217753225238677900874458691);\n\n        uint64 target = uint64(uint256(meter.TARGET_RESOURCE_LIMIT()));\n        uint64 elasticity = uint64(uint256(meter.ELASTICITY_MULTIPLIER()));\n        vm.assume(_amount < target * elasticity);\n        vm.roll(initialBlockNum + _blockDiff);\n        meter.use(_amount);\n    }\n}\n\n\n/**\n * @title CustomMeterUser\n * @notice A simple wrapper around `ResourceMetering` that allows the initial\n *         params to be set in the constructor.\n */\ncontract CustomMeterUser is ResourceMetering {\n    uint256 public startGas;\n    uint256 public endGas;\n\n    constructor(\n        uint128 _prevBaseFee,\n        uint64 _prevBoughtGas,\n        uint64 _prevBlockNum\n    ) {\n        params = ResourceMetering.ResourceParams({\n            prevBaseFee: _prevBaseFee,\n            prevBoughtGas: _prevBoughtGas,\n            prevBlockNum: _prevBlockNum\n        });\n    }\n\n    function use(uint64 _amount) public returns (uint256) {\n        uint256 initialGas = gasleft();\n        _metered(_amount, initialGas);\n        return initialGas - gasleft();\n    }\n}\n\n/**\n * @title ArtifactResourceMetering_Test\n * @notice A table test that sets the state of the ResourceParams and then requests\n *         various amounts of gas. This test ensures that a wide range of values\n *         can safely be used with the `ResourceMetering` contract.\n *         It also writes a CSV file to disk that includes useful information\n *         about how much gas is used and how expensive it is in USD terms to\n *         purchase the deposit gas.\n */\ncontract ArtifactResourceMetering_Test is Test {\n    uint128 internal minimumBaseFee;\n    uint128 internal maximumBaseFee;\n    uint64 internal maxResourceLimit;\n    uint64 internal targetResourceLimit;\n\n    string internal outfile;\n\n    // keccak256(abi.encodeWithSignature(\"Error(string)\", \"ResourceMetering: cannot buy more gas than available gas limit\"))\n    bytes32 internal cannotBuyMoreGas =\n        0x84edc668cfd5e050b8999f43ff87a1faaa93e5f935b20bc1dd4d3ff157ccf429;\n    // keccak256(abi.encodeWithSignature(\"Panic(uint256)\", 0x11))\n    bytes32 internal overflowErr =\n        0x1ca389f2c8264faa4377de9ce8e14d6263ef29c68044a9272d405761bab2db27;\n    // keccak256(hex\"\")\n    bytes32 internal emptyReturnData =\n        0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n    /**\n     * @notice Sets up the tests by getting constants from the ResourceMetering\n     *         contract.\n     */\n    function setUp() public {\n        vm.roll(1_000_000);\n\n        MeterUser base = new MeterUser();\n        minimumBaseFee = uint128(uint256(base.MINIMUM_BASE_FEE()));\n        maximumBaseFee = uint128(uint256(base.MAXIMUM_BASE_FEE()));\n        maxResourceLimit = uint64(uint256(base.MAX_RESOURCE_LIMIT()));\n        targetResourceLimit = uint64(uint256(base.TARGET_RESOURCE_LIMIT()));\n\n        outfile = string.concat(vm.projectRoot(), \"/.resource-metering.csv\");\n        try vm.removeFile(outfile) {} catch {}\n    }\n\n    /**\n     * @notice Generate a CSV file. The call to `meter` should be called with at\n     *         most the L1 block gas limit. Without specifying the amount of\n     *         gas, it can take very long to execute.\n     */\n    function test_meter_generateArtifact_succeeds() external {\n        vm.writeLine(\n            outfile,\n            \"prevBaseFee,prevBoughtGas,prevBlockNumDiff,l1BaseFee,requestedGas,gasConsumed,ethPrice,usdCost,success\"\n        );\n\n        // prevBaseFee value in ResourceParams\n        uint128[] memory prevBaseFees = new uint128[](5);\n        prevBaseFees[0] = minimumBaseFee;\n        prevBaseFees[1] = maximumBaseFee;\n        prevBaseFees[2] = uint128(50 gwei);\n        prevBaseFees[3] = uint128(100 gwei);\n        prevBaseFees[4] = uint128(200 gwei);\n\n        // prevBoughtGas value in ResourceParams\n        uint64[] memory prevBoughtGases = new uint64[](1);\n        prevBoughtGases[0] = uint64(0);\n\n        // prevBlockNum diff, simulates blocks with no deposits when non zero\n        uint64[] memory prevBlockNumDiffs = new uint64[](2);\n        prevBlockNumDiffs[0] = 0;\n        prevBlockNumDiffs[1] = 1;\n\n        // The amount of L2 gas that a user requests\n        uint64[] memory requestedGases = new uint64[](3);\n        requestedGases[0] = maxResourceLimit;\n        requestedGases[1] = targetResourceLimit;\n        requestedGases[2] = uint64(100_000);\n\n        // The L1 base fee\n        uint256[] memory l1BaseFees = new uint256[](4);\n        l1BaseFees[0] = 1 gwei;\n        l1BaseFees[1] = 50 gwei;\n        l1BaseFees[2] = 75 gwei;\n        l1BaseFees[3] = 100 gwei;\n\n        // USD price of 1 ether\n        uint256[] memory ethPrices = new uint256[](2);\n        ethPrices[0] = 1600;\n        ethPrices[1] = 3200;\n\n        // Iterate over all of the test values and run a test\n        for (uint256 i; i < prevBaseFees.length; i++) {\n            for (uint256 j; j < prevBoughtGases.length; j++) {\n                for (uint256 k; k < prevBlockNumDiffs.length; k++) {\n                    for (uint256 l; l < requestedGases.length; l++) {\n                        for (uint256 m; m < l1BaseFees.length; m++) {\n                            for (uint256 n; n < ethPrices.length; n++) {\n                                uint256 snapshotId = vm.snapshot();\n\n                                uint128 prevBaseFee = prevBaseFees[i];\n                                uint64 prevBoughtGas = prevBoughtGases[j];\n                                uint64 prevBlockNumDiff = prevBlockNumDiffs[k];\n                                uint64 requestedGas = requestedGases[l];\n                                uint256 l1BaseFee = l1BaseFees[m];\n                                uint256 ethPrice = ethPrices[n];\n                                string memory result = \"success\";\n\n                                vm.fee(l1BaseFee);\n\n                                CustomMeterUser meter = new CustomMeterUser({\n                                    _prevBaseFee: prevBaseFee,\n                                    _prevBoughtGas: prevBoughtGas,\n                                    _prevBlockNum: uint64(block.number)\n                                });\n\n                                vm.roll(block.number + prevBlockNumDiff);\n\n                                // Call the metering code and catch the various\n                                // types of errors.\n                                uint256 gasConsumed = 0;\n                                try meter.use{ gas: 30_000_000 }(requestedGas) returns (\n                                    uint256 _gasConsumed\n                                ) {\n                                    gasConsumed = _gasConsumed;\n                                } catch (bytes memory err) {\n                                    bytes32 hash = keccak256(err);\n                                    if (hash == cannotBuyMoreGas) {\n                                        result = \"ResourceMetering: cannot buy more gas than available gas limit\";\n                                    } else if (hash == overflowErr) {\n                                        result = \"arithmetic overflow/underflow\";\n                                    } else if (hash == emptyReturnData) {\n                                        result = \"out of gas\";\n                                    } else {\n                                        result = \"UNKNOWN ERROR\";\n                                    }\n                                }\n\n                                // Compute the USD cost of the gas used\n                                uint256 usdCost = (gasConsumed * l1BaseFee * ethPrice) / 1 ether;\n\n                                vm.writeLine(\n                                    outfile,\n                                    string.concat(\n                                        vm.toString(prevBaseFee),\n                                        \",\",\n                                        vm.toString(prevBoughtGas),\n                                        \",\",\n                                        vm.toString(prevBlockNumDiff),\n                                        \",\",\n                                        vm.toString(l1BaseFee),\n                                        \",\",\n                                        vm.toString(requestedGas),\n                                        \",\",\n                                        vm.toString(gasConsumed),\n                                        \",\",\n                                        \"$\",\n                                        vm.toString(ethPrice),\n                                        \",\",\n                                        \"$\",\n                                        vm.toString(usdCost),\n                                        \",\",\n                                        result\n                                    )\n                                );\n\n                                assertTrue(vm.revertTo(snapshotId));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/test/SafeCall.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract SafeCall_call_Test is CommonTest {\n    function testFuzz_call_succeeds(\n        address from,\n        address to,\n        uint256 gas,\n        uint64 value,\n        bytes memory data\n    ) external {\n        vm.assume(from.balance == 0);\n        vm.assume(to.balance == 0);\n        // no precompiles (mainnet)\n        assumeNoPrecompiles(to, 1);\n        // don't call the vm\n        vm.assume(to != address(vm));\n        vm.assume(from != address(vm));\n        // don't call the console\n        vm.assume(to != address(0x000000000000000000636F6e736F6c652e6c6f67));\n        // don't call the create2 deployer\n        vm.assume(to != address(0x4e59b44847b379578588920cA78FbF26c0B4956C));\n\n        assertEq(from.balance, 0, \"from balance is 0\");\n        vm.deal(from, value);\n        assertEq(from.balance, value, \"from balance not dealt\");\n\n        uint256[2] memory balancesBefore = [from.balance, to.balance];\n\n        vm.expectCall(to, value, data);\n        vm.prank(from);\n        bool success = SafeCall.call(to, gas, value, data);\n\n        assertTrue(success, \"call not successful\");\n        if (from == to) {\n            assertEq(from.balance, balancesBefore[0], \"Self-send did not change balance\");\n        } else {\n            assertEq(from.balance, balancesBefore[0] - value, \"from balance not drained\");\n            assertEq(to.balance, balancesBefore[1] + value, \"to balance received\");\n        }\n    }\n\n    /*\n    NOTE(chokobole): disable this test as Optimism also fails.\n    function testFuzz_callWithMinGas_hasEnough_succeeds(\n        address from,\n        address to,\n        uint64 minGas,\n        uint64 value,\n        bytes memory data\n    ) external {\n        vm.assume(from.balance == 0);\n        vm.assume(to.balance == 0);\n        // no precompiles (mainnet)\n        assumeNoPrecompiles(to, 1);\n        // don't call the vm\n        vm.assume(to != address(vm));\n        vm.assume(from != address(vm));\n        // don't call the console\n        vm.assume(to != address(0x000000000000000000636F6e736F6c652e6c6f67));\n        // don't call the create2 deployer\n        vm.assume(to != address(0x4e59b44847b379578588920cA78FbF26c0B4956C));\n\n        assertEq(from.balance, 0, \"from balance is 0\");\n        vm.deal(from, value);\n        assertEq(from.balance, value, \"from balance not dealt\");\n\n        // Bound minGas to [0, l1_block_gas_limit]\n        minGas = uint64(bound(minGas, 0, 30_000_000));\n\n        uint256[2] memory balancesBefore = [from.balance, to.balance];\n\n        vm.expectCallMinGas(to, value, minGas, data);\n        vm.prank(from);\n        bool success = SafeCall.callWithMinGas(to, minGas, value, data);\n\n        assertTrue(success, \"call not successful\");\n        if (from == to) {\n            assertEq(from.balance, balancesBefore[0], \"Self-send did not change balance\");\n        } else {\n            assertEq(from.balance, balancesBefore[0] - value, \"from balance not drained\");\n            assertEq(to.balance, balancesBefore[1] + value, \"to balance received\");\n        }\n    }\n\n    function test_callWithMinGas_noLeakageLow_succeeds() external {\n        SimpleSafeCaller caller = new SimpleSafeCaller();\n\n        for (uint64 i = 5000; i < 50_000; i++) {\n            uint256 snapshot = vm.snapshot();\n\n            // 26,071 is the exact amount of gas required to make the safe call\n            // successfully.\n            if (i < 26_071) {\n                assertFalse(caller.makeSafeCall(i, 25_000));\n            } else {\n                vm.expectCallMinGas(\n                    address(caller),\n                    0,\n                    25_000,\n                    abi.encodeWithSelector(caller.setA.selector, 1)\n                );\n                assertTrue(caller.makeSafeCall(i, 25_000));\n            }\n\n            assertTrue(vm.revertTo(snapshot));\n        }\n    }\n\n    function test_callWithMinGas_noLeakageHigh_succeeds() external {\n        SimpleSafeCaller caller = new SimpleSafeCaller();\n\n        for (uint64 i = 15_200_000; i < 15_300_000; i++) {\n            uint256 snapshot = vm.snapshot();\n\n            // 15,238,769 is the exact amount of gas required to make the safe call\n            // successfully.\n            if (i < 15_238_769) {\n                assertFalse(caller.makeSafeCall(i, 15_000_000));\n            } else {\n                vm.expectCallMinGas(\n                    address(caller),\n                    0,\n                    15_000_000,\n                    abi.encodeWithSelector(caller.setA.selector, 1)\n                );\n                assertTrue(caller.makeSafeCall(i, 15_000_000));\n            }\n\n            assertTrue(vm.revertTo(snapshot));\n        }\n    }\n    */\n}\n\ncontract SimpleSafeCaller {\n    uint256 public a;\n\n    function makeSafeCall(uint64 gas, uint64 minGas) external returns (bool) {\n        return\n            SafeCall.call(\n                address(this),\n                gas,\n                0,\n                abi.encodeWithSelector(this.makeSafeCallMinGas.selector, minGas)\n            );\n    }\n\n    function makeSafeCallMinGas(uint64 minGas) external returns (bool) {\n        return\n            SafeCall.callWithMinGas(\n                address(this),\n                minGas,\n                0,\n                abi.encodeWithSelector(this.setA.selector, 1)\n            );\n    }\n\n    function setA(uint256 _a) external {\n        a = _a;\n    }\n}\n"
    },
    "contracts/test/Semver.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\n/**\n * @notice Test the Semver contract that is used for semantic versioning\n *         of various contracts.\n */\ncontract Semver_Test is CommonTest {\n    /**\n     * @notice Global semver contract deployed in setUp. This is used in\n     *         the test cases.\n     */\n    Semver semver;\n\n    /**\n     * @notice Deploy a Semver contract\n     */\n    function setUp() public virtual override {\n        super.setUp();\n        semver = new Semver(7, 8, 0);\n    }\n\n    /**\n     * @notice Test the version getter\n     */\n    function test_version_succeeds() external {\n        assertEq(semver.version(), \"7.8.0\");\n    }\n\n    /**\n     * @notice Since the versions are all immutable, they should\n     *         be able to be accessed from behind a proxy without needing\n     *         to initialize the contract.\n     */\n    function test_behindProxy_succeeds() external {\n        Proxy proxy = new Proxy(alice);\n        vm.prank(alice);\n        proxy.upgradeTo(address(semver));\n\n        assertEq(Semver(address(proxy)).version(), \"7.8.0\");\n    }\n}\n"
    },
    "contracts/test/StandardBridge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { KromaMintableERC20 } from \"../universal/KromaMintableERC20.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\n/**\n * @title StandardBridgeTester\n * @notice Simple wrapper around the StandardBridge contract that exposes\n *         internal functions so they can be more easily tested directly.\n */\ncontract StandardBridgeTester is StandardBridge {\n    constructor(address payable _messenger, address payable _otherBridge)\n        StandardBridge(_messenger, _otherBridge)\n    {}\n\n    function isKromaMintableERC20(address _token) external view returns (bool) {\n        return _isKromaMintableERC20(_token);\n    }\n\n    function isCorrectTokenPair(address _mintableToken, address _otherToken)\n        external\n        view\n        returns (bool)\n    {\n        return _isCorrectTokenPair(_mintableToken, _otherToken);\n    }\n\n    receive() external payable override {}\n}\n\n/**\n * @title StandardBridge_Stateless_Test\n * @notice Tests internal functions that require no existing state or contract\n *         interactions with the messenger.\n */\ncontract StandardBridge_Stateless_Test is CommonTest {\n    StandardBridgeTester internal bridge;\n    KromaMintableERC20 internal mintable;\n    ERC20 internal erc20;\n\n    function setUp() public override {\n        super.setUp();\n\n        bridge = new StandardBridgeTester({\n            _messenger: payable(address(0)),\n            _otherBridge: payable(address(0))\n        });\n\n        mintable = new KromaMintableERC20({\n            _bridge: address(0),\n            _remoteToken: address(0),\n            _name: \"Stonks\",\n            _symbol: \"STONK\"\n        });\n\n        erc20 = new ERC20(\"Altcoin\", \"ALT\");\n    }\n\n    /**\n     * @notice Test coverage for identifying KromaMintableERC20 tokens.\n     *         This function should return true for\n     *         KromaMintableERC20 tokens and false for any accounts that\n     *         do not implement the interface.\n     */\n    function test_isKromaMintableERC20_succeeds() external {\n        // Both the modern and legacy mintable tokens should return true\n        assertTrue(bridge.isKromaMintableERC20(address(mintable)));\n        // A regular ERC20 should return false\n        assertFalse(bridge.isKromaMintableERC20(address(erc20)));\n        // Non existent contracts should return false and not revert\n        assertEq(address(0x20).code.length, 0);\n        assertFalse(bridge.isKromaMintableERC20(address(0x20)));\n    }\n\n    /**\n     * @notice Test coverage of isCorrectTokenPair under different types of\n     *         tokens.\n     */\n    function test_isCorrectTokenPair_succeeds() external {\n        // Modern + known to be correct remote token\n        assertTrue(bridge.isCorrectTokenPair(address(mintable), mintable.REMOTE_TOKEN()));\n        // Modern + known to be incorrect remote token\n        assertTrue(mintable.REMOTE_TOKEN() != address(0x20));\n        assertFalse(bridge.isCorrectTokenPair(address(mintable), address(0x20)));\n    }\n}\n"
    },
    "contracts/test/SystemConfig.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { SystemConfig } from \"../L1/SystemConfig.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract SystemConfig_Init is CommonTest {\n    SystemConfig sysConf;\n\n    function setUp() public virtual override {\n        super.setUp();\n        sysConf = new SystemConfig({\n            _owner: alice,\n            _overhead: 2100,\n            _scalar: 1000000,\n            _batcherHash: bytes32(hex\"abcd\"),\n            _gasLimit: 9_000_000,\n            _unsafeBlockSigner: address(1)\n        });\n    }\n}\n\ncontract SystemConfig_Initialize_TestFail is CommonTest {\n    function test_initialize_lowGasLimit_reverts() external {\n        vm.expectRevert(\"SystemConfig: gas limit too low\");\n\n        // The minimum gas limit defined in SystemConfig:\n        uint64 MINIMUM_GAS_LIMIT = 8_000_000;\n        new SystemConfig({\n            _owner: alice,\n            _overhead: 0,\n            _scalar: 0,\n            _batcherHash: bytes32(hex\"\"),\n            _gasLimit: MINIMUM_GAS_LIMIT - 1,\n            _unsafeBlockSigner: address(1)\n        });\n    }\n}\n\ncontract SystemConfig_Setters_TestFail is SystemConfig_Init {\n    function test_setBatcherHash_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sysConf.setBatcherHash(bytes32(hex\"\"));\n    }\n\n    function test_setGasConfig_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sysConf.setGasConfig(0, 0);\n    }\n\n    function test_setGasLimit_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sysConf.setGasLimit(0);\n    }\n\n    function test_setUnsafeBlockSigner_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sysConf.setUnsafeBlockSigner(address(0x20));\n    }\n}\n\ncontract SystemConfig_Setters_Test is SystemConfig_Init {\n    event ConfigUpdate(\n        uint256 indexed version,\n        SystemConfig.UpdateType indexed updateType,\n        bytes data\n    );\n\n    function testFuzz_setBatcherHash_succeeds(bytes32 newBatcherHash) external {\n        vm.expectEmit(true, true, true, true);\n        emit ConfigUpdate(0, SystemConfig.UpdateType.BATCHER, abi.encode(newBatcherHash));\n\n        vm.prank(sysConf.owner());\n        sysConf.setBatcherHash(newBatcherHash);\n        assertEq(sysConf.batcherHash(), newBatcherHash);\n    }\n\n    function testFuzz_setGasConfig_succeeds(uint256 newOverhead, uint256 newScalar) external {\n        vm.expectEmit(true, true, true, true);\n        emit ConfigUpdate(\n            0,\n            SystemConfig.UpdateType.GAS_CONFIG,\n            abi.encode(newOverhead, newScalar)\n        );\n\n        vm.prank(sysConf.owner());\n        sysConf.setGasConfig(newOverhead, newScalar);\n        assertEq(sysConf.overhead(), newOverhead);\n        assertEq(sysConf.scalar(), newScalar);\n    }\n\n    function testFuzz_setGasLimit_succeeds(uint64 newGasLimit) external {\n        uint64 minimumGasLimit = sysConf.MINIMUM_GAS_LIMIT();\n        newGasLimit = uint64(\n            bound(uint256(newGasLimit), uint256(minimumGasLimit), uint256(type(uint64).max))\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit ConfigUpdate(0, SystemConfig.UpdateType.GAS_LIMIT, abi.encode(newGasLimit));\n\n        vm.prank(sysConf.owner());\n        sysConf.setGasLimit(newGasLimit);\n        assertEq(sysConf.gasLimit(), newGasLimit);\n    }\n\n    function testFuzz_setUnsafeBlockSigner_succeeds(address newUnsafeSigner) external {\n        vm.expectEmit(true, true, true, true);\n        emit ConfigUpdate(\n            0,\n            SystemConfig.UpdateType.UNSAFE_BLOCK_SIGNER,\n            abi.encode(newUnsafeSigner)\n        );\n\n        vm.prank(sysConf.owner());\n        sysConf.setUnsafeBlockSigner(newUnsafeSigner);\n        assertEq(sysConf.unsafeBlockSigner(), newUnsafeSigner);\n    }\n}\n"
    },
    "contracts/test/ZKMerkleTrie.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Portal_Initializer } from \"./CommonTest.t.sol\";\n\ncontract ZKMerkleTrie_Test is Portal_Initializer {\n    function test_verifyInclustionProof_valid_0() external {\n        bytes[] memory proofs = new bytes[](2);\n        proofs[\n            0\n        ] = hex\"012098f5fb9e239eab3ceac3f27b81e481dc3124d55ffed523a839ee8446b64864010100000000000000000000000000000000000000000000000000000000000000003039202098f5fb9e239eab3ceac3f27b81e481dc3124d55ffed523a839ee8446b64864\";\n        proofs[\n            1\n        ] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n        assertTrue(\n            zkMerkleTrie.verifyInclusionProof(\n                hex\"0000000000000000000000000000000000000000000000000000000000000000\",\n                hex\"0000000000000000000000000000000000000000000000000000000000003039\",\n                proofs,\n                hex\"1a71d0943087a54143a948ccb9d9f0bd07c99d3a4899c9ceeb890976c32186c1\"\n            )\n        );\n    }\n\n    function test_verifyInclustionProof_valid_1() external {\n        bytes[] memory proofs = new bytes[](8);\n        proofs[\n            0\n        ] = hex\"000ab62fdcebb5220c92b96d38cef426d805217d1760140b2b1eebecd436c8fcc50f3dcecebf602601ceb35f1996e70c802634bb3d7ccbc7ad6b923e00066e8b00\";\n        proofs[\n            1\n        ] = hex\"0006be779477fdea72fc037851ef2baa70afdeff1075cfaa3b4f385e9d2336afd42583e724fe0eb10e675ab6be869557ca5d2f9fc13de9274a0a1742236e349caf\";\n        proofs[\n            2\n        ] = hex\"000ded681649ba8fee8a5cb411c9a2d1c525e796ca2566cebf2c0244c2a66491662c67be5020784f6a1eb8d7f1bfc7d921455e231d9bd9f171dffa4202763e2d28\";\n        proofs[\n            3\n        ] = hex\"0009543051b94eaaf3560c2f33cd8bf9a9b93f712b1f9b41ab67cab4f12733a67d167c33ebb5960ce90cf4042434bc4f9cd75c5ecc46e250c5c4b06a76a4627b2b\";\n        proofs[\n            4\n        ] = hex\"0010c440dc7007099878005966c61e751fe67bafcdb37615213c8ff9d111b4f7251167fcaa928ceeb39b9318cea6306ac2cd6252f6ef8d96cfeffd937810b29b1a\";\n        proofs[\n            5\n        ] = hex\"00271dd669b4787c31020d57ee2b2e56ff139994b52bf56ecc9f7432a272ce5f78032d185fae0284cbf7292557e98dfd08dea8b108eb6e4289d803d2b7d2e74644\";\n        proofs[\n            6\n        ] = hex\"0109d279cfc7bcba04074acfebd9974c1d2c9516b2c1f18ec34ac3ed422158c8a8010100000000000000000000000000000000000000000000000000000000000000000018200e9449cefab8e4070797d09578e909e10a0ce4374ea5e4d4c608c2e11961af68\";\n        proofs[\n            7\n        ] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n        assertFalse(\n            zkMerkleTrie.verifyInclusionProof(\n                hex\"0000000000000000000000000000000000000000000000000000000000000005\",\n                hex\"0000000000000000000000000000000000000000000000000000000000000032\",\n                proofs,\n                hex\"0ef999685f185097340822d0b30f846398e641087ba3bcff823ed87538038943\"\n            )\n        );\n    }\n\n    function test_verifyInclustionProof_valid_2() external {\n        bytes[] memory proofs = new bytes[](8);\n        proofs[\n            0\n        ] = hex\"000ab62fdcebb5220c92b96d38cef426d805217d1760140b2b1eebecd436c8fcc50f3dcecebf602601ceb35f1996e70c802634bb3d7ccbc7ad6b923e00066e8b00\";\n        proofs[\n            1\n        ] = hex\"0006be779477fdea72fc037851ef2baa70afdeff1075cfaa3b4f385e9d2336afd42583e724fe0eb10e675ab6be869557ca5d2f9fc13de9274a0a1742236e349caf\";\n        proofs[\n            2\n        ] = hex\"0017c443967900c45fb5b11c7a40cfc8e4aa5c699f2f80add51e3cf998ed9872b80022374777da27caa6013c01e2cb3b2d974a998a4f38f2f25baa3c87ad12a007\";\n        proofs[\n            3\n        ] = hex\"0024622a111942a41d45c768f89da131621e0fa266b9b7e324d33e458702a2987e0e67ba58319668fa44fe1f5e20f5a7978e6577bcb1b9809e101224c2988edd38\";\n        proofs[\n            4\n        ] = hex\"00139b85edf9b10c2b2330eb06a1eeb66f2058a8d9cd6fea738157f951e8079905068c3814e7511d563e5bfea099e5368ee7a8e38e4856e85b45b33339621ff50c\";\n        proofs[\n            5\n        ] = hex\"000b1bb0d1d5eaa0e39a52d08db2e92b79294959ea25cef6757a4d54bff691fb902ee69c6f3bb0450146447b2f9865d2e396b7b9e7b37d7f2ff181c85941ef98cf\";\n        proofs[\n            6\n        ] = hex\"0117f011179feb4d1c750e4c139df9e5d1940dffa118c8d489c852389aa7afaf460101000000000000000000000000000000000000000000000000000000000000000000062017f011179feb4d1c750e4c139df9e5d1940dffa118c8d489c852389aa7afaf46\";\n        proofs[\n            7\n        ] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n        assertTrue(\n            zkMerkleTrie.verifyInclusionProof(\n                hex\"101e368776582e57ab3d116ffe2517c0a585cd5b23174b01e275c2d8329c3d83\",\n                hex\"0000000000000000000000000000000000000000000000000000000000000006\",\n                proofs,\n                hex\"0ef999685f185097340822d0b30f846398e641087ba3bcff823ed87538038943\"\n            )\n        );\n    }\n\n    function test_verifyInclustionProof_valid_3() external {\n        bytes[] memory proofs = new bytes[](9);\n        proofs[\n            0\n        ] = hex\"000ab62fdcebb5220c92b96d38cef426d805217d1760140b2b1eebecd436c8fcc50f3dcecebf602601ceb35f1996e70c802634bb3d7ccbc7ad6b923e00066e8b00\";\n        proofs[\n            1\n        ] = hex\"00064ef83727d84baa6f69e7b6d2aa09c06a0a684aee47027b0b364011ec29a61617909e79d23c9ffd920c6e0cb9929782348bcd170d8a5d806467fbcf9d56b437\";\n        proofs[\n            2\n        ] = hex\"0016b9762acc15c49266ff4561a8975cbd5e132ad5129caa0b811b374cff9480101152ad4e5c71d0348e3b9041315496011ab29e79a54851d0d79d7d03dd2423c8\";\n        proofs[\n            3\n        ] = hex\"0017ae8d541b010b836adb59a87754efee7740f33b96520754ca5f6f6ae9d3b73e09827fa4836bb60157a2e4e358d897b23d735c3b23f55490e76f2e6ae2b68b04\";\n        proofs[\n            4\n        ] = hex\"0016c3abb95e2baec8aab3dc244eac879d60ac0ef6275cd4fa5c3a526049fdeb8c11b76fb8c45df3936b13c24dff4da46b947a2844f06ac6221e8c8eb7feb32970\";\n        proofs[\n            5\n        ] = hex\"000ccffa8b08f54fc92c60c9c19f379d5759ecdd8fded0b24c2266be5a6fafb7c4295abf4ea1b55932420231efee9fe391a90b3fb077aee16e26ebba7997795e7f\";\n        proofs[\n            6\n        ] = hex\"0014ed76b6e85369cd2549423310e621bbcbcac05402162d085be4368168ca506b0000000000000000000000000000000000000000000000000000000000000000\";\n        proofs[7] = hex\"02\";\n        proofs[\n            8\n        ] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n        assertFalse(\n            zkMerkleTrie.verifyInclusionProof(\n                hex\"bc36789e7a1e281436464229828f817d6612f7b477d66591ff96a9e064bcc98a\",\n                hex\"0000000000000000000000000000000000000000000000000000000000000032\",\n                proofs,\n                hex\"0ef999685f185097340822d0b30f846398e641087ba3bcff823ed87538038943\"\n            )\n        );\n    }\n\n    function test_verifyInclustionProof_valid_4() external {\n        bytes[] memory proofs = new bytes[](13);\n        proofs[\n            0\n        ] = hex\"0007cbd8ed414f4c32c8f24bcd4a092ca1fc48c5dc95acb388fa3c08ec3422be2f11dd580249f54d7db79ee465707fa4e23c4287a4649248df30583903858aa90d\";\n        proofs[\n            1\n        ] = hex\"0023baa0bbc530f48f150951aa7670aa3c8f6570a5c763c05413a3e12a6c0b7cce10f98a7af3a8a73a3a20af4a000ef3663712967ec273a58e9ade9e661394c9d6\";\n        proofs[\n            2\n        ] = hex\"00284ac3e3a591145890ace584756f6ba06c701f395c8db9d0313adcdaf954270b006c473617966db462b9fd00299d683a15c0b74454ca7ac3ef2d8aa087ac7dac\";\n        proofs[\n            3\n        ] = hex\"00296063f48eb3a4f4ff8fdc10316f114be5bedfbf79c9c86d325f92ff877a1a532ff1456213f17f8b67c69ea1821714fc7fb5073bf7c1fc4f77adaec58d083c6e\";\n        proofs[\n            4\n        ] = hex\"002c58643b19811246202ac95ce7122cf63eb17687e12a670542c2bd76546184ef02acd9795883b244ab8c5c9b232c7a6f598ab360bcd5b6fdab4ca93250b74ce8\";\n        proofs[\n            5\n        ] = hex\"00015421c239dc34b78b2fa31b208aa368cd1eae4b98aa10ae03bc2c5b80cdd8ef2d6c19f2f3b16de567490f18819cae1e3f4ea29d2bc5c34400276cf57f0e3b63\";\n        proofs[\n            6\n        ] = hex\"002d961fc76c9c30673b93f089451bce1d3af8ada972ad8c735f60cd0e145751801962d7c2d9d222562ae4476172398601558339c4414a807d280ec23938fa6d78\";\n        proofs[\n            7\n        ] = hex\"0000000000000000000000000000000000000000000000000000000000000000000949fcaefea105109e6bd0c339373e06d8a7856fc82c3185041642ed42f07585\";\n        proofs[\n            8\n        ] = hex\"0014660f419e10516425d4f78bbf7457cfd1381fff1223606dc530792059176c3f20ae2c31258e0712e4e39ecd2eae272ec13fadb2f057027e7fad2b378fc249f6\";\n        proofs[\n            9\n        ] = hex\"00163340375c6665b9878b1443e55b943de727fd6ccb1647ec9ca2e09a0f6b81110000000000000000000000000000000000000000000000000000000000000000\";\n        proofs[\n            10\n        ] = hex\"00224e3507691f5789978473cf4a307908f5a08761112466f1cf970bc8fad921d9258216ceb8dffd636ddc9570e526bc6741d8f76e8f2d8cb843104656c8a93ae5\";\n        proofs[\n            11\n        ] = hex\"011fd5bbabb0ebd74c646925592018a1f5d06dd11a6b5be33f025241736e454087010100000000000000000000000000000000000000000000000000000000000000000005201fd5bbabb0ebd74c646925592018a1f5d06dd11a6b5be33f025241736e454087\";\n        proofs[\n            12\n        ] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n        assertTrue(\n            zkMerkleTrie.verifyInclusionProof(\n                hex\"2b232c97452f0950c94e2539fdc7e69d21166113cf7a9bcb99b220a3fe5d720a\",\n                hex\"0000000000000000000000000000000000000000000000000000000000000005\",\n                proofs,\n                hex\"122f20d691c10bf842b594733bdc73e6a67a131def85ef444ce58a18cc4cd757\"\n            )\n        );\n    }\n\n    function test_verifyInclustionProof_valid_5() external {\n        bytes[] memory proofs = new bytes[](11);\n        proofs[\n            0\n        ] = hex\"00284ec4ede7c4da8296ce6d515233c2eea76fd5c07116c56949fda88770fad4b811b40ba55c3d2ec14871670b38cec7c71ea67ddb0ceaa0fea936e8b6fd8e0511\";\n        proofs[\n            1\n        ] = hex\"000d12650b10e106a7644599be80c71ab31cf093d7f99c34d866315ca1c12972022409d4725c6af5e20a9e32a61d79e85571181d65c45dc10bfc11ba2857923830\";\n        proofs[\n            2\n        ] = hex\"00296bec9e31b0aa1c5128fca361dd3875609520c9b0c8e7dd73bda2a1313c18d72eed91ecfef85e13834fda24ddf9060a69eec25abba55115c517de9f8a4ee9ec\";\n        proofs[\n            3\n        ] = hex\"00131748240aea4f74ae3be5a6a9f11d6bbb3129241f36de98275c32423592de8b16c111e32818a1cdc9b30d4855817e3193945bbf2594291bb229d85d2ed81658\";\n        proofs[\n            4\n        ] = hex\"001cdea41e120cf4086d178996edcf44e2003f2d0225cbac864c7e60af23540f2f010f74b267d3bd19343889f0d2a525d7054c007e507c5ca0164be42f72215ff6\";\n        proofs[\n            5\n        ] = hex\"000ac5febcd01ab220937cef032f250f499fe68911bc094ebe5c7b8abb59e41dc6191416975dbc10cf89f6428771b2251e9023598fcbc59ad33be4f05c6e7b8eec\";\n        proofs[\n            6\n        ] = hex\"0026080a7dc62fc9fafc28adb4775111ee0d6818d6fc07375f751f602f0708a17f211fc5be39244df796912c7360f30219760366342a9c4306d710ec2bd2b5db39\";\n        proofs[\n            7\n        ] = hex\"0013867a8f88775425fc040b935515ce4966f9492956f96e7355fadfba44e1f67d0000000000000000000000000000000000000000000000000000000000000000\";\n        proofs[\n            8\n        ] = hex\"00233da726018d913514b4dd9398bc1a01c98b0a8ef4c33dc20efae3c38e1fe1912ef80e02108f98b180588ae6580404cfb5fb52b22ebfa1345da5654587b5aec5\";\n        proofs[\n            9\n        ] = hex\"012f6fdd1ad0dd1863abaa7b339f6f56b17a97720aeddd790f4507b95a5ef6df55010100000000000000000000000000000000000000000000000000000000000000000005202f6fdd1ad0dd1863abaa7b339f6f56b17a97720aeddd790f4507b95a5ef6df55\";\n        proofs[\n            10\n        ] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n        assertTrue(\n            zkMerkleTrie.verifyInclusionProof(\n                hex\"e2689cd4a84e23ad2f564004f1c9013e9589d260bde6380aba3ca7e09e4df40c\",\n                hex\"0000000000000000000000000000000000000000000000000000000000000005\",\n                proofs,\n                hex\"2f362a32462155cc2f9d2d7aa2f70c0c80cd3ff834c69de7bcc4fb2d493b0e9b\"\n            )\n        );\n    }\n\n    // Real withdrawal example\n    function test_verifyInclustionProof_valid_6() external {\n        bytes[] memory proofs = new bytes[](7);\n        proofs[\n            0\n        ] = hex\"002c4b1cef0d03c37f45c631f7fc85ea4b78eeb096708ea63bd810463e246f13d40eb41f1061285f9c13a21519bdb76cba404832d33945ad471fa215153d9b020d\";\n        proofs[\n            1\n        ] = hex\"0000000000000000000000000000000000000000000000000000000000000000001dc169aab556ca90e4a7c3365ab27ba5ca93d222cd9e25e3ae1e38b7bf3a9e94\";\n        proofs[\n            2\n        ] = hex\"0007dcec580d43183a7dbe05d3a5a1f8b3ce38d5bb22676dfa1439ab44219de2a0036b366d8dcd20a1872355bb66868eb50f78599e926963ca33d35b8535e9525b\";\n        proofs[\n            3\n        ] = hex\"0000000000000000000000000000000000000000000000000000000000000000001747ce9cfac94135832e7e7d983a44e894446ca8ff1e6bda10ebcdaae36eba3d\";\n        proofs[\n            4\n        ] = hex\"0020438463bdf532b3eaa113e69847b469b76425d47195ed7a41462a79ba6511f715cb3972fcd254f29388ca61de787fe3654d776941fb4eaf00a946e8d4c73720\";\n        proofs[\n            5\n        ] = hex\"0105a0af8df2be333495be279be0eb5ef7da41b240832f2d74d34631333cebc3ee0101000000000000000000000000000000000000000000000000000000000000000000012085359a58748add24fbe1c5aedbd158736f50a45baf8715b9f32c9432ea7c179a\";\n        proofs[\n            6\n        ] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n        assertTrue(\n            zkMerkleTrie.verifyInclusionProof(\n                hex\"85359a58748add24fbe1c5aedbd158736f50a45baf8715b9f32c9432ea7c179a\",\n                hex\"0000000000000000000000000000000000000000000000000000000000000001\",\n                proofs,\n                hex\"2830ab4d0fa292abe8f69ac23b8d98a9f9a950ace6ae50d0f77eefa01a644cb1\"\n            )\n        );\n    }\n}\n"
    },
    "contracts/test/invariants/CrossDomainMessenger.t.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { StdUtils } from \"forge-std/StdUtils.sol\";\nimport { Vm } from \"forge-std/Vm.sol\";\n\nimport { Encoding } from \"../../libraries/Encoding.sol\";\nimport { Hashing } from \"../../libraries/Hashing.sol\";\nimport { Predeploys } from \"../../libraries/Predeploys.sol\";\nimport { Types } from \"../../libraries/Types.sol\";\nimport { L1CrossDomainMessenger } from \"../../L1/L1CrossDomainMessenger.sol\";\nimport { KromaPortal } from \"../../L1/KromaPortal.sol\";\nimport { Messenger_Initializer } from \"../CommonTest.t.sol\";\n\ncontract RelayActor is StdUtils {\n    // Storage slot of the l2Sender\n    uint256 constant senderSlotIndex = 50;\n\n    uint256 public numHashes;\n    bytes32[] public hashes;\n    bool public reverted = false;\n\n    KromaPortal portal;\n    L1CrossDomainMessenger xdm;\n    Vm vm;\n\n    constructor(\n        KromaPortal _portal,\n        L1CrossDomainMessenger _xdm,\n        Vm _vm\n    ) {\n        portal = _portal;\n        xdm = _xdm;\n        vm = _vm;\n    }\n\n    /**\n     * Relays a message to the `L1CrossDomainMessenger` with a random `version`, `_minGasLimit`\n     * and `_message`.\n     */\n    function relay(\n        uint32 _minGasLimit,\n        bytes memory _message\n    ) external {\n        address target = address(0x04); // ID precompile\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        // set the value of op.l2Sender() to be the L2 Cross Domain Messenger.\n        vm.store(address(portal), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n\n        // Restrict `_minGasLimit` to a number in the range of the block gas limit.\n        _minGasLimit = uint32(bound(_minGasLimit, 0, block.gaslimit));\n\n        // Compute the cross domain message hash and store it in `hashes`.\n        bytes32 _hash = Hashing.hashCrossDomainMessageV0(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0, // value\n            _minGasLimit,\n            _message\n        );\n\n        // Act as the kroma portal and call `relayMessage` on the `L1CrossDomainMessenger` with\n        // the outer min gas limit.\n        vm.startPrank(address(portal));\n        vm.expectCall(target, _message);\n        try\n            xdm.relayMessage{ gas: xdm.baseGas(_message, _minGasLimit) }(\n                Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n                sender,\n                target,\n                0, // value\n                _minGasLimit,\n                _message\n            )\n        {} catch {\n            // If any of these calls revert, set `reverted` to true to fail the invariant test.\n            // NOTE: This is to get around forge's invariant fuzzer ignoring reverted calls\n            // to this function.\n            reverted = true;\n        }\n        vm.stopPrank();\n\n        hashes.push(_hash);\n        numHashes += 1;\n    }\n}\n\ncontract XDM_MinGasLimits is Messenger_Initializer {\n    RelayActor actor;\n\n    function setUp() public virtual override {\n        // Set up the `L1CrossDomainMessenger` and `KromaPortal` contracts.\n        super.setUp();\n\n        // Deploy a relay actor\n        actor = new RelayActor(portal, L1Messenger, vm);\n\n        // Target the `RelayActor` contract\n        targetContract(address(actor));\n\n        // Target the actor's `relay` function\n        bytes4[] memory selectors = new bytes4[](1);\n        selectors[0] = actor.relay.selector;\n        targetSelector(FuzzSelector({ addr: address(actor), selectors: selectors }));\n    }\n\n    /**\n     * @custom:invariant A call to `relayMessage` should never revert if at least the proper minimum\n     * gas limits are supplied.\n     *\n     * There are two minimum gas limits here:\n     *\n     * - The outer min gas limit is for the call from the `KromaPortal` to the\n     * `L1CrossDomainMessenger`,  and it can be retrieved by calling the xdm's `baseGas` function\n     * with the `message` and inner limit.\n     *\n     * - The inner min gas limit is for the call from the `L1CrossDomainMessenger` to the target\n     * contract.\n     */\n    /*\n    NOTE(chokobole): disable this test as Optimism also fails.\n    function invariant_minGasLimits() public {\n        uint256 length = actor.numHashes();\n        for (uint256 i = 0; i < length; ++i) {\n            bytes32 hash = actor.hashes(i);\n            // the message hash is in the successfulMessages mapping\n            assertTrue(L1Messenger.successfulMessages(hash));\n            // it is not in the received messages mapping\n            assertFalse(L1Messenger.failedMessages(hash));\n        }\n        assertFalse(actor.reverted());\n    }\n    */\n}\n"
    },
    "contracts/test/invariants/KromaPortal.t.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Types } from \"../../libraries/Types.sol\";\nimport { Portal_Initializer } from \"../CommonTest.t.sol\";\n\ncontract KromaPortal_Invariant_Harness is Portal_Initializer {\n    // Reusable default values for a test withdrawal\n    Types.WithdrawalTransaction _defaultTx;\n\n    uint256 _submittedOutputIndex;\n    uint256 _submittedBlockNumber;\n    bytes32 _stateRoot;\n    bytes32 _storageRoot;\n    bytes32 _outputRoot;\n    bytes32 _withdrawalHash;\n    bytes[] _withdrawalProof;\n    Types.OutputRootProof internal _outputRootProof;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        _defaultTx = Types.WithdrawalTransaction({\n            nonce: 0,\n            sender: alice,\n            target: bob,\n            value: 100,\n            gasLimit: 100_000,\n            data: hex\"\"\n        });\n        // Get withdrawal proof data we can use for testing.\n        (_stateRoot, _storageRoot, _outputRoot, _withdrawalHash, _withdrawalProof) = ffi\n            .getProveWithdrawalTransactionInputs(_defaultTx);\n\n        // Setup a dummy output root proof for reuse.\n        _outputRootProof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: _stateRoot,\n            messagePasserStorageRoot: _storageRoot,\n            latestBlockhash: bytes32(uint256(0))\n        });\n        _submittedBlockNumber = oracle.nextBlockNumber();\n        _submittedOutputIndex = oracle.nextOutputIndex();\n\n        // Configure the oracle to return the output root we've prepared.\n        vm.warp(oracle.computeL2Timestamp(_submittedBlockNumber) + 1);\n        vm.prank(oracle.VALIDATOR());\n        oracle.submitL2Output(_outputRoot, _submittedBlockNumber, 0, 0);\n\n        // Warp beyond the finalization period for the block we've submitted.\n        vm.warp(\n            oracle.getL2Output(_submittedOutputIndex).timestamp +\n                oracle.FINALIZATION_PERIOD_SECONDS() +\n                1\n        );\n        // Fund the portal so that we can withdraw ETH.\n        vm.deal(address(portal), 0xFFFFFFFF);\n    }\n}\n\ncontract KromaPortal_CannotTimeTravel is KromaPortal_Invariant_Harness {\n    function setUp() public override {\n        super.setUp();\n\n        // Prove the withdrawal transaction\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Set the target contract to the portal proxy\n        targetContract(address(portal));\n        // Exclude the proxy multisig from the senders so that the proxy cannot be upgraded\n        excludeSender(address(multisig));\n    }\n\n    /**\n     * @custom:invariant `finalizeWithdrawalTransaction` should revert if the finalization\n     * period has not elapsed.\n     *\n     * A withdrawal that has been proven should not be able to be finalized until after\n     * the finalization period has elapsed.\n     */\n    function invariant_cannotFinalizeBeforePeriodHasPassed() external {\n        vm.expectRevert(\"KromaPortal: proven withdrawal finalization period has not elapsed\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n    }\n}\n\ncontract KromaPortal_CannotFinalizeTwice is KromaPortal_Invariant_Harness {\n    function setUp() public override {\n        super.setUp();\n\n        // Prove the withdrawal transaction\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Warp past the finalization period.\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Finalize the withdrawal transaction.\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        // Set the target contract to the portal proxy\n        targetContract(address(portal));\n        // Exclude the proxy multisig from the senders so that the proxy cannot be upgraded\n        excludeSender(address(multisig));\n    }\n\n    /**\n     * @custom:invariant `finalizeWithdrawalTransaction` should revert if the withdrawal\n     * has already been finalized.\n     *\n     * Ensures that there is no chain of calls that can be made that allows a withdrawal\n     * to be finalized twice.\n     */\n    function invariant_cannotFinalizeTwice() external {\n        vm.expectRevert(\"KromaPortal: withdrawal has already been finalized\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n    }\n}\n\ncontract KromaPortal_CanAlwaysFinalizeAfterWindow is KromaPortal_Invariant_Harness {\n    function setUp() public override {\n        super.setUp();\n\n        // Prove the withdrawal transaction\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Warp past the finalization period.\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Set the target contract to the portal proxy\n        targetContract(address(portal));\n        // Exclude the proxy multisig from the senders so that the proxy cannot be upgraded\n        excludeSender(address(multisig));\n    }\n\n    /**\n     * @custom:invariant A withdrawal should **always** be able to be finalized\n     * `FINALIZATION_PERIOD_SECONDS` after it was successfully proven.\n     *\n     * This invariant asserts that there is no chain of calls that can be made that\n     * will prevent a withdrawal from being finalized exactly `FINALIZATION_PERIOD_SECONDS`\n     * after it was successfully proven.\n     */\n    function invariant_canAlwaysFinalize() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        assertEq(address(bob).balance, bobBalanceBefore + _defaultTx.value);\n    }\n}\n"
    },
    "contracts/test/invariants/L2OutputOracle.t.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Vm } from \"forge-std/Vm.sol\";\n\nimport { L2OutputOracle } from \"../../L1/L2OutputOracle.sol\";\nimport { L2OutputOracle_Initializer } from \"../CommonTest.t.sol\";\n\ncontract L2OutputOracle_Validator {\n    L2OutputOracle internal oracle;\n    Vm internal vm;\n\n    constructor(L2OutputOracle _oracle, Vm _vm) {\n        oracle = _oracle;\n        vm = _vm;\n    }\n\n    /**\n     * @dev Allows the actor to submit an L2 output to the `L2OutputOracle`\n     */\n    function submitL2Output(\n        bytes32 _outputRoot,\n        uint256 _l2BlockNumber,\n        bytes32 _l1BlockHash,\n        uint256 _l1BlockNumber\n    ) external {\n        // Act as the validator and submit a new output.\n        vm.prank(oracle.VALIDATOR());\n        oracle.submitL2Output(_outputRoot, _l2BlockNumber, _l1BlockHash, _l1BlockNumber);\n    }\n}\n\n\ncontract L2OutputOracle_MonotonicBlockNumIncrease_Invariant is L2OutputOracle_Initializer {\n    L2OutputOracle_Validator internal actor;\n\n    function setUp() public override {\n        super.setUp();\n\n        // Create a proposer actor.\n        actor = new L2OutputOracle_Validator(oracle, vm);\n\n        // Set the target contract to the validator actor\n        targetContract(address(actor));\n\n        // Set the target selector for `submitL2Output`\n        // `submitL2Output` is the only function we care about, as it is the only function\n        // that can modify the `l2Outputs` array in the oracle.\n        bytes4[] memory selectors = new bytes4[](1);\n        selectors[0] = actor.submitL2Output.selector;\n        FuzzSelector memory selector = FuzzSelector({\n            addr: address(actor),\n            selectors: selectors\n        });\n        targetSelector(selector);\n    }\n\n    /**\n     * @custom:invariant The block number of the checkpoint output should monotonically\n     * increase.\n     *\n     * When a new output is submitted, it should never be allowed to correspond to a block\n     * number that is less than the current output.\n     */\n    function invariant_monotonicBlockNumIncrease() external {\n        // Assert that the block number of checkpoint output must monotonically increase.\n        assertTrue(oracle.nextBlockNumber() >= oracle.latestBlockNumber());\n    }\n}\n"
    },
    "contracts/test/invariants/SafeCall.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { StdUtils } from \"forge-std/StdUtils.sol\";\nimport { Test } from \"forge-std/Test.sol\";\nimport { Vm } from \"forge-std/Vm.sol\";\n\nimport { SafeCall } from \"../../libraries/SafeCall.sol\";\n\ncontract SafeCall_Succeeds_Invariants is Test {\n    SafeCaller_Actor actor;\n\n    function setUp() public {\n        // Create a new safe caller actor.\n        actor = new SafeCaller_Actor(vm, false);\n\n        // Set the caller to this contract\n        targetSender(address(this));\n\n        // Target the safe caller actor.\n        targetContract(address(actor));\n    }\n\n    /**\n     * @custom:invariant If `callWithMinGas` performs a call, then it must always\n     * provide at least the specified minimum gas limit to the subcontext.\n     *\n     * If the check for remaining gas in `SafeCall.callWithMinGas` passes, the\n     * subcontext of the call below it must be provided at least `minGas` gas.\n     */\n    function invariant_callWithMinGas_alwaysForwardsMinGas_succeeds() public {\n        assertEq(actor.numCalls(), 0, \"no failed calls allowed\");\n    }\n\n    function performSafeCallMinGas(uint64 minGas) external {\n        SafeCall.callWithMinGas(address(0), minGas, 0, hex\"\");\n    }\n}\n\ncontract SafeCall_Fails_Invariants is Test {\n    SafeCaller_Actor actor;\n\n    function setUp() public {\n        // Create a new safe caller actor.\n        actor = new SafeCaller_Actor(vm, true);\n\n        // Set the caller to this contract\n        targetSender(address(this));\n\n        // Target the safe caller actor.\n        targetContract(address(actor));\n    }\n\n    /**\n     * @custom:invariant `callWithMinGas` reverts if there is not enough gas to pass\n     * to the subcontext.\n     *\n     * If there is not enough gas in the callframe to ensure that `callWithMinGas`\n     * can provide the specified minimum gas limit to the subcontext of the call,\n     * then `callWithMinGas` must revert.\n     */\n    function invariant_callWithMinGas_neverForwardsMinGas_reverts() public {\n        assertEq(actor.numCalls(), 0, \"no successful calls allowed\");\n    }\n\n    function performSafeCallMinGas(uint64 minGas) external {\n        SafeCall.callWithMinGas(address(0), minGas, 0, hex\"\");\n    }\n}\n\ncontract SafeCaller_Actor is StdUtils {\n    bool internal immutable FAILS;\n\n    Vm internal vm;\n    uint256 public numCalls;\n\n    constructor(Vm _vm, bool _fails) {\n        vm = _vm;\n        FAILS = _fails;\n    }\n\n    function performSafeCallMinGas(uint64 gas, uint64 minGas) external {\n        if (FAILS) {\n            // Bound the minimum gas amount to [2500, type(uint48).max]\n            minGas = uint64(bound(minGas, 2500, type(uint48).max));\n            // Bound the gas passed to [minGas, (((minGas + 200) * 64) / 63)]\n            gas = uint64(bound(gas, minGas, (((minGas + 200) * 64) / 63)));\n        } else {\n            // Bound the minimum gas amount to [2500, type(uint48).max]\n            minGas = uint64(bound(minGas, 2500, type(uint48).max));\n            // Bound the gas passed to [(((minGas + 200) * 64) / 63) + 500, type(uint64).max]\n            gas = uint64(bound(gas, (((minGas + 200) * 64) / 63) + 500, type(uint64).max));\n        }\n\n        vm.expectCallMinGas(address(0x00), 0, minGas, hex\"\");\n        bool success = SafeCall.call(\n            msg.sender,\n            gas,\n            0,\n            abi.encodeWithSelector(0x2ae57a41, minGas)\n        );\n\n        if (success && FAILS) numCalls++;\n        if (!FAILS && !success) numCalls++;\n    }\n}\n"
    },
    "contracts/test/invariants/SystemConfig.t.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\n\nimport { SystemConfig } from \"../../L1/SystemConfig.sol\";\n\ncontract SystemConfig_GasLimitLowerBound_Invariant is Test {\n    SystemConfig public config;\n\n    function setUp() public {\n        config = new SystemConfig({\n            _owner: address(0xbeef),\n            _overhead: 2100,\n            _scalar: 1000000,\n            _batcherHash: bytes32(hex\"abcd\"),\n            _gasLimit: 8_000_000,\n            _unsafeBlockSigner: address(1)\n        });\n\n        // Set the target contract to the `config`\n        targetContract(address(config));\n        // Set the target sender to the `config`'s owner (0xbeef)\n        targetSender(address(0xbeef));\n        // Set the target selector for `setGasLimit`\n        // `setGasLimit` is the only function we care about, as it is the only function\n        // that can modify the gas limit within the SystemConfig.\n        bytes4[] memory selectors = new bytes4[](1);\n        selectors[0] = config.setGasLimit.selector;\n        FuzzSelector memory selector = FuzzSelector({\n            addr: address(config),\n            selectors: selectors\n        });\n        targetSelector(selector);\n    }\n\n    /**\n     * @custom:invariant The gas limit of the `SystemConfig` contract can never be lower\n     * than the hard-coded lower bound.\n     */\n    function invariant_gasLimitLowerBound() external {\n        assertTrue(config.gasLimit() >= config.MINIMUM_GAS_LIMIT());\n    }\n}\n"
    },
    "contracts/universal/CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    PausableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\n\n/**\n * @custom:upgradeable\n * @title CrossDomainMessenger\n * @notice CrossDomainMessenger is a base contract that provides the core logic for the L1 and L2\n *         cross-chain messenger contracts. It's designed to be a universal interface that only\n *         needs to be extended slightly to provide low-level message passing functionality on each\n *         chain it's deployed on. Currently only designed for message passing between two paired\n *         chains and does not support one-to-many interactions.\n *\n *         Any changes to this contract MUST result in a semver bump for contracts that inherit it.\n */\nabstract contract CrossDomainMessenger is\n    PausableUpgradeable\n{\n    /**\n     * @notice Current message version identifier.\n     */\n    uint16 public constant MESSAGE_VERSION = 0;\n\n    /**\n     * @notice Constant overhead added to the base gas for a message.\n     */\n    uint64 public constant MIN_GAS_CONSTANT_OVERHEAD = 200_000;\n\n    /**\n     * @notice Numerator for dynamic overhead added to the base gas for a message.\n     */\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR = 1016;\n\n    /**\n     * @notice Denominator for dynamic overhead added to the base gas for a message.\n     */\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR = 1000;\n\n    /**\n     * @notice Extra gas added to base gas for each byte of calldata in a message.\n     */\n    uint64 public constant MIN_GAS_CALLDATA_OVERHEAD = 16;\n\n    /**\n     * @notice Address of the paired CrossDomainMessenger contract on the other chain.\n     */\n    address public immutable OTHER_MESSENGER;\n\n    /**\n     * @notice Mapping of message hashes to boolean receipt values. Note that a message will only\n     *         be present in this mapping if it has successfully been relayed on this chain, and\n     *         can therefore not be relayed again.\n     */\n    mapping(bytes32 => bool) public successfulMessages;\n\n    /**\n     * @notice Address of the sender of the currently executing message on the other chain. If the\n     *         value of this variable is the default value (0x00000000...dead) then no message is\n     *         currently being executed. Use the xDomainMessageSender getter which will throw an\n     *         error if this is the case.\n     */\n    address internal xDomainMsgSender;\n\n    /**\n     * @notice Nonce for the next message to be sent, without the message version applied. Use the\n     *         messageNonce getter which will insert the message version into the nonce to give you\n     *         the actual nonce to be used for the message.\n     */\n    uint240 internal msgNonce;\n\n    /**\n     * @notice Mapping of message hashes to a boolean if and only if the message has failed to be\n     *         executed at least once. A message will not be present in this mapping if it\n     *         successfully executed on the first attempt.\n     */\n    mapping(bytes32 => bool) public failedMessages;\n\n    /**\n     * @notice A mapping of hashes to reentrancy locks.\n     */\n    mapping(bytes32 => bool) internal reentrancyLocks;\n\n\n    /**\n     * @notice Reserve extra slots in the storage layout for future upgrades.\n     *         A gap size of 44 was chosen here, so that the first slot used in a child contract\n     *         would be a multiple of 50.\n     */\n    uint256[44] private __gap;\n\n    /**\n     * @notice Emitted whenever a message is sent to the other chain.\n     *\n     * @param target       Address of the recipient of the message.\n     * @param sender       Address of the sender of the message.\n     * @param value        ETH value sent along with the message to the recipient.\n     * @param message      Message to trigger the recipient address with.\n     * @param messageNonce Unique nonce attached to the message.\n     * @param gasLimit     Minimum gas limit that the message can be executed with.\n     */\n    event SentMessage(\n        address indexed target,\n        address indexed sender,\n        uint256 value,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n\n    /**\n     * @notice Emitted whenever a message is successfully relayed on this chain.\n     *\n     * @param msgHash Hash of the message that was relayed.\n     */\n    event RelayedMessage(bytes32 indexed msgHash);\n\n    /**\n     * @notice Emitted whenever a message fails to be relayed on this chain.\n     *\n     * @param msgHash Hash of the message that failed to be relayed.\n     */\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /**\n     * @param _otherMessenger Address of the messenger on the paired chain.\n     */\n    constructor(address _otherMessenger) {\n        OTHER_MESSENGER = _otherMessenger;\n    }\n\n    /**\n     * @notice Sends a message to some target address on the other chain. Note that if the call\n     *         always reverts, then the message will be unrelayable, and any ETH sent will be\n     *         permanently locked. The same will occur if the target on the other chain is\n     *         considered unsafe (see the _isUnsafeTarget() function).\n     *\n     * @param _target      Target contract or wallet address.\n     * @param _message     Message to trigger the target address with.\n     * @param _minGasLimit Minimum gas limit that the message can be executed with.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _minGasLimit\n    ) external payable {\n        // Triggers a message to the other messenger. Note that the amount of gas provided to the\n        // message is the amount of gas requested by the user PLUS the base gas value. We want to\n        // guarantee the property that the call to the target contract will always have at least\n        // the minimum gas limit specified by the user.\n        _sendMessage(\n            OTHER_MESSENGER,\n            baseGas(_message, _minGasLimit),\n            msg.value,\n            abi.encodeWithSelector(\n                this.relayMessage.selector,\n                messageNonce(),\n                msg.sender,\n                _target,\n                msg.value,\n                _minGasLimit,\n                _message\n            )\n        );\n\n        emit SentMessage(_target, msg.sender, msg.value, _message, messageNonce(), _minGasLimit);\n\n        unchecked {\n            ++msgNonce;\n        }\n    }\n\n    /**\n     * @notice Relays a message that was sent by the other CrossDomainMessenger contract. Can only\n     *         be executed via cross-chain call from the other messenger OR if the message was\n     *         already received once and is currently being replayed.\n     *\n     * @param _nonce       Nonce of the message being relayed.\n     * @param _sender      Address of the user who sent the message.\n     * @param _target      Address that the message is targeted at.\n     * @param _value       ETH value to send with the message.\n     * @param _minGasLimit Minimum amount of gas that the message can be executed with.\n     * @param _message     Message to send to the target.\n     */\n    function relayMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _minGasLimit,\n        bytes calldata _message\n    ) external payable {\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\n        require(\n            version < 1,\n            \"CrossDomainMessenger: only version 0 messages is supported at this time\"\n        );\n\n        // We use the v0 message hash as the unique identifier for the message because it commits\n        // to the value and minimum gas limit of the message.\n        bytes32 versionedHash = Hashing.hashCrossDomainMessageV0(\n            _nonce,\n            _sender,\n            _target,\n            _value,\n            _minGasLimit,\n            _message\n        );\n\n        // Check if the reentrancy lock for the `versionedHash` is already set.\n        if (reentrancyLocks[versionedHash]) {\n            revert(\"ReentrancyGuard: reentrant call\");\n        }\n        // Trigger the reentrancy lock for `versionedHash`\n        reentrancyLocks[versionedHash] = true;\n\n        if (_isOtherMessenger()) {\n            // These properties should always hold when the message is first submitted (as\n            // opposed to being replayed).\n            assert(msg.value == _value);\n            assert(!failedMessages[versionedHash]);\n        } else {\n            require(\n                msg.value == 0,\n                \"CrossDomainMessenger: value must be zero unless message is from a system address\"\n            );\n\n            require(\n                failedMessages[versionedHash],\n                \"CrossDomainMessenger: message cannot be replayed\"\n            );\n        }\n\n        require(\n            _isUnsafeTarget(_target) == false,\n            \"CrossDomainMessenger: cannot send message to blocked system address\"\n        );\n\n        require(\n            successfulMessages[versionedHash] == false,\n            \"CrossDomainMessenger: message has already been relayed\"\n        );\n\n        xDomainMsgSender = _sender;\n        bool success = SafeCall.callWithMinGas(_target, _minGasLimit, _value, _message);\n        xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\n\n        if (success) {\n            successfulMessages[versionedHash] = true;\n            emit RelayedMessage(versionedHash);\n        } else {\n            failedMessages[versionedHash] = true;\n            emit FailedRelayedMessage(versionedHash);\n\n            // Revert in this case if the transaction was triggered by the estimation address. This\n            // should only be possible during gas estimation or we have bigger problems. Reverting\n            // here will make the behavior of gas estimation change such that the gas limit\n            // computed will be the amount required to relay the message, even if that amount is\n            // greater than the minimum gas limit specified by the user.\n            if (tx.origin == Constants.ESTIMATION_ADDRESS) {\n                revert(\"CrossDomainMessenger: failed to relay message\");\n            }\n        }\n\n        // Clear the reentrancy lock for `versionedHash`\n        reentrancyLocks[versionedHash] = false;\n    }\n\n    /**\n     * @notice Retrieves the address of the contract or wallet that initiated the currently\n     *         executing message on the other chain. Will throw an error if there is no message\n     *         currently being executed. Allows the recipient of a call to see who triggered it.\n     *\n     * @return Address of the sender of the currently executing message on the other chain.\n     */\n    function xDomainMessageSender() external view returns (address) {\n        require(\n            xDomainMsgSender != Constants.DEFAULT_L2_SENDER,\n            \"CrossDomainMessenger: xDomainMessageSender is not set\"\n        );\n\n        return xDomainMsgSender;\n    }\n\n    /**\n     * @notice Retrieves the next message nonce. Message version will be added to the upper two\n     *         bytes of the message nonce. Message version allows us to treat messages as having\n     *         different structures.\n     *\n     * @return Nonce of the next message to be sent, with added message version.\n     */\n    function messageNonce() public view returns (uint256) {\n        return Encoding.encodeVersionedNonce(msgNonce, MESSAGE_VERSION);\n    }\n\n    /**\n     * @notice Computes the amount of gas required to guarantee that a given message will be\n     *         received on the other chain without running out of gas. Guaranteeing that a message\n     *         will not run out of gas is important because this ensures that a message can always\n     *         be replayed on the other chain if it fails to execute completely.\n     *\n     * @param _message     Message to compute the amount of required gas for.\n     * @param _minGasLimit Minimum desired gas limit when message goes to target.\n     *\n     * @return Amount of gas required to guarantee message receipt.\n     */\n    function baseGas(bytes calldata _message, uint32 _minGasLimit) public pure returns (uint64) {\n        // We peform the following math on uint64s to avoid overflow errors. Multiplying the\n        // by MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR would otherwise limit the _minGasLimit to\n        // type(uint32).max / MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR ~= 4.2m.\n        return\n            // Dynamic overhead\n            ((uint64(_minGasLimit) * MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR) /\n                MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR) +\n            // Calldata overhead\n            (uint64(_message.length) * MIN_GAS_CALLDATA_OVERHEAD) +\n            // Constant overhead\n            MIN_GAS_CONSTANT_OVERHEAD;\n    }\n\n    /**\n     * @notice Intializer.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __CrossDomainMessenger_init() internal onlyInitializing {\n        xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\n    }\n\n    /**\n     * @notice Sends a low-level message to the other messenger. Needs to be implemented by child\n     *         contracts because the logic for this depends on the network where the messenger is\n     *         being deployed.\n     *\n     * @param _to       Recipient of the message on the other chain.\n     * @param _gasLimit Minimum gas limit the message can be executed with.\n     * @param _value    Amount of ETH to send with the message.\n     * @param _data     Message data.\n     */\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal virtual;\n\n    /**\n     * @notice Checks whether the message is coming from the other messenger. Implemented by child\n     *         contracts because the logic for this depends on the network where the messenger is\n     *         being deployed.\n     *\n     * @return Whether the message is coming from the other messenger.\n     */\n    function _isOtherMessenger() internal view virtual returns (bool);\n\n    /**\n     * @notice Checks whether a given call target is a system address that could cause the\n     *         messenger to peform an unsafe action. This is NOT a mechanism for blocking user\n     *         addresses. This is ONLY used to prevent the execution of messages to specific\n     *         system addresses that could cause security issues, e.g., having the\n     *         CrossDomainMessenger send messages to itself.\n     *\n     * @param _target Address of the contract to check.\n     *\n     * @return Whether or not the address is an unsafe system address.\n     */\n    function _isUnsafeTarget(address _target) internal view virtual returns (bool);\n}\n"
    },
    "contracts/universal/ERC721Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { CrossDomainMessenger } from \"./CrossDomainMessenger.sol\";\n\n/**\n * @title ERC721Bridge\n * @notice ERC721Bridge is a base contract for the L1 and L2 ERC721 bridges.\n */\nabstract contract ERC721Bridge {\n    /**\n     * @notice Messenger contract on this domain.\n     */\n    CrossDomainMessenger public immutable MESSENGER;\n\n    /**\n     * @notice Address of the bridge on the other network.\n     */\n    address public immutable OTHER_BRIDGE;\n\n    /**\n     * @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\n     */\n    uint256[49] private __gap;\n\n    /**\n     * @notice Emitted when an ERC721 bridge to the other network is initiated.\n     *\n     * @param localToken  Address of the token on this domain.\n     * @param remoteToken Address of the token on the remote domain.\n     * @param from        Address that initiated bridging action.\n     * @param to          Address to receive the token.\n     * @param tokenId     ID of the specific token deposited.\n     * @param extraData   Extra data for use on the client-side.\n     */\n    event ERC721BridgeInitiated(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    /**\n     * @notice Emitted when an ERC721 bridge from the other network is finalized.\n     *\n     * @param localToken  Address of the token on this domain.\n     * @param remoteToken Address of the token on the remote domain.\n     * @param from        Address that initiated bridging action.\n     * @param to          Address to receive the token.\n     * @param tokenId     ID of the specific token deposited.\n     * @param extraData   Extra data for use on the client-side.\n     */\n    event ERC721BridgeFinalized(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    /**\n     * @notice Ensures that the caller is a cross-chain message from the other bridge.\n     */\n    modifier onlyOtherBridge() {\n        require(\n            msg.sender == address(MESSENGER) && MESSENGER.xDomainMessageSender() == OTHER_BRIDGE,\n            \"ERC721Bridge: function can only be called from the other bridge\"\n        );\n        _;\n    }\n\n    /**\n     * @param _messenger   Address of the CrossDomainMessenger on this network.\n     * @param _otherBridge Address of the ERC721 bridge on the other network.\n     */\n    constructor(address _messenger, address _otherBridge) {\n        require(_messenger != address(0), \"ERC721Bridge: messenger cannot be address(0)\");\n        require(_otherBridge != address(0), \"ERC721Bridge: other bridge cannot be address(0)\");\n\n        MESSENGER = CrossDomainMessenger(_messenger);\n        OTHER_BRIDGE = _otherBridge;\n    }\n\n    /**\n     * @notice Initiates a bridge of an NFT to the caller's account on the other chain. Note that\n     *         this function can only be called by EOAs. Smart contract wallets should use the\n     *         `bridgeERC721To` function after ensuring that the recipient address on the remote\n     *         chain exists. Also note that the current owner of the token on this chain must\n     *         approve this contract to operate the NFT before it can be bridged.\n     *         **WARNING**: Do not bridge an ERC721 that was originally deployed on Kroma. This\n     *         bridge only supports ERC721s originally deployed on Ethereum. Users will need to\n     *         wait for the one-week challenge period to elapse before their Kroma-native NFT\n     *         can be refunded on L2.\n     *\n     * @param _localToken  Address of the ERC721 on this domain.\n     * @param _remoteToken Address of the ERC721 on the remote domain.\n     * @param _tokenId     Token ID to bridge.\n     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.\n     * @param _extraData   Optional data to forward to the other chain. Data supplied here will not\n     *                     be used to execute any code on the other chain and is only emitted as\n     *                     extra data for the convenience of off-chain tooling.\n     */\n    function bridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        uint256 _tokenId,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external {\n        // Modifier requiring sender to be EOA. This prevents against a user error that would occur\n        // if the sender is a smart contract wallet that has a different address on the remote chain\n        // (or doesn't have an address on the remote chain at all). The user would fail to receive\n        // the NFT if they use this function because it sends the NFT to the same address as the\n        // caller. This check could be bypassed by a malicious contract via initcode, but it takes\n        // care of the user error we want to avoid.\n        require(!Address.isContract(msg.sender), \"ERC721Bridge: account is not externally owned\");\n\n        _initiateBridgeERC721(\n            _localToken,\n            _remoteToken,\n            msg.sender,\n            msg.sender,\n            _tokenId,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @notice Initiates a bridge of an NFT to some recipient's account on the other chain. Note\n     *         that the current owner of the token on this chain must approve this contract to\n     *         operate the NFT before it can be bridged.\n     *         **WARNING**: Do not bridge an ERC721 that was originally deployed on Kroma. This\n     *         bridge only supports ERC721s originally deployed on Ethereum. Users will need to\n     *         wait for the one-week challenge period to elapse before their Kroma-native NFT\n     *         can be refunded on L2.\n     *\n     * @param _localToken  Address of the ERC721 on this domain.\n     * @param _remoteToken Address of the ERC721 on the remote domain.\n     * @param _to          Address to receive the token on the other domain.\n     * @param _tokenId     Token ID to bridge.\n     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.\n     * @param _extraData   Optional data to forward to the other chain. Data supplied here will not\n     *                     be used to execute any code on the other chain and is only emitted as\n     *                     extra data for the convenience of off-chain tooling.\n     */\n    function bridgeERC721To(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _tokenId,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external {\n        require(_to != address(0), \"ERC721Bridge: nft recipient cannot be address(0)\");\n\n        _initiateBridgeERC721(\n            _localToken,\n            _remoteToken,\n            msg.sender,\n            _to,\n            _tokenId,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @notice Internal function for initiating a token bridge to the other domain.\n     *\n     * @param _localToken  Address of the ERC721 on this domain.\n     * @param _remoteToken Address of the ERC721 on the remote domain.\n     * @param _from        Address of the sender on this domain.\n     * @param _to          Address to receive the token on the other domain.\n     * @param _tokenId     Token ID to bridge.\n     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.\n     * @param _extraData   Optional data to forward to the other domain. Data supplied here will\n     *                     not be used to execute any code on the other domain and is only emitted\n     *                     as extra data for the convenience of off-chain tooling.\n     */\n    function _initiateBridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) internal virtual;\n}\n"
    },
    "contracts/universal/FeeVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { L2StandardBridge } from \"../L2/L2StandardBridge.sol\";\n\n/**\n * @title FeeVault\n * @notice The FeeVault contract contains the basic logic for the various different vault contracts\n *         used to hold fee revenue generated by the L2 system.\n */\nabstract contract FeeVault {\n    /**\n     * @notice Emits each time that a withdrawal occurs.\n     *\n     * @param value Amount that was withdrawn (in wei).\n     * @param to    Address that the funds were sent to.\n     * @param from  Address that triggered the withdrawal.\n     */\n    event Withdrawal(uint256 value, address to, address from);\n\n    /**\n     * @notice Minimum balance before a withdrawal can be triggered.\n     */\n    uint256 public immutable MIN_WITHDRAWAL_AMOUNT;\n\n    /**\n     * @notice Wallet that will receive the fees on L1.\n     */\n    address public immutable RECIPIENT;\n\n    /**\n     * @notice The minimum gas limit for the FeeVault withdrawal transaction.\n     */\n    uint32 internal constant WITHDRAWAL_MIN_GAS = 35_000;\n\n    /**\n     * @notice Total amount of wei processed by the contract.\n     */\n    uint256 public totalProcessed;\n\n    /**\n     * @param _recipient           Wallet that will receive the fees on L1.\n     * @param _minWithdrawalAmount Minimum balance before a withdrawal can be triggered.\n     */\n    constructor(address _recipient, uint256 _minWithdrawalAmount) {\n        MIN_WITHDRAWAL_AMOUNT = _minWithdrawalAmount;\n        RECIPIENT = _recipient;\n    }\n\n    /**\n     * @notice Allow the contract to receive ETH.\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Triggers a withdrawal of funds to the L1 fee wallet.\n     */\n    function withdraw() external {\n        require(\n            address(this).balance >= MIN_WITHDRAWAL_AMOUNT,\n            \"FeeVault: withdrawal amount must be greater than minimum withdrawal amount\"\n        );\n\n        uint256 value = address(this).balance;\n        totalProcessed += value;\n\n        emit Withdrawal(value, RECIPIENT, msg.sender);\n\n        L2StandardBridge(payable(Predeploys.L2_STANDARD_BRIDGE)).bridgeETHTo{ value: value }(\n            RECIPIENT,\n            WITHDRAWAL_MIN_GAS,\n            bytes(\"\")\n        );\n    }\n}\n"
    },
    "contracts/universal/IKromaMintableERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title IKromaMintableERC20\n * @notice This interface is available on the KromaMintableERC20 contract. We declare it as a\n *         separate interface so that it can be used in custom implementations of\n *         KromaMintableERC20.\n */\ninterface IKromaMintableERC20 {\n    function REMOTE_TOKEN() external view returns (address);\n\n    function BRIDGE() external view returns (address);\n\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n}\n"
    },
    "contracts/universal/IKromaMintableERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {\n    IERC721Enumerable\n} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\n\n/**\n * @title IKromaMintableERC721\n * @notice Interface for contracts that are compatible with the KromaMintableERC721 standard.\n *         Tokens that follow this standard can be easily transferred across the ERC721 bridge.\n */\ninterface IKromaMintableERC721 is IERC721Enumerable {\n    /**\n     * @notice Emitted when a token is minted.\n     *\n     * @param account Address of the account the token was minted to.\n     * @param tokenId Token ID of the minted token.\n     */\n    event Mint(address indexed account, uint256 tokenId);\n\n    /**\n     * @notice Emitted when a token is burned.\n     *\n     * @param account Address of the account the token was burned from.\n     * @param tokenId Token ID of the burned token.\n     */\n    event Burn(address indexed account, uint256 tokenId);\n\n    /**\n     * @notice Mints some token ID for a user, checking first that contract recipients\n     *         are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * @param _to      Address of the user to mint the token for.\n     * @param _tokenId Token ID to mint.\n     */\n    function safeMint(address _to, uint256 _tokenId) external;\n\n    /**\n     * @notice Burns a token ID from a user.\n     *\n     * @param _from    Address of the user to burn the token from.\n     * @param _tokenId Token ID to burn.\n     */\n    function burn(address _from, uint256 _tokenId) external;\n\n    /**\n     * @notice Chain ID of the chain where the remote token is deployed.\n     */\n    function REMOTE_CHAIN_ID() external view returns (uint256);\n\n    /**\n     * @notice Address of the token on the remote domain.\n     */\n    function REMOTE_TOKEN() external view returns (address);\n\n    /**\n     * @notice Address of the ERC721 bridge on this network.\n     */\n    function BRIDGE() external view returns (address);\n\n    /**\n     * @notice Chain ID of the chain where the remote token is deployed.\n     */\n    function remoteChainId() external view returns (uint256);\n\n    /**\n     * @notice Address of the token on the remote domain.\n     */\n    function remoteToken() external view returns (address);\n\n    /**\n     * @notice Address of the ERC721 bridge on this network.\n     */\n    function bridge() external view returns (address);\n}\n"
    },
    "contracts/universal/KromaMintableERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport { Semver } from \"../universal/Semver.sol\";\nimport { IKromaMintableERC20 } from \"./IKromaMintableERC20.sol\";\n\n/**\n * @title KromaMintableERC20\n * @notice KromaMintableERC20 is a standard extension of the base ERC20 token contract designed\n *         to allow the StandardBridge contracts to mint and burn tokens. This makes it possible to\n *         use a KromaMintableRC20 as the L2 representation of an L1 token, or vice-versa.\n *         Designed to be backwards compatible with the older StandardL2ERC20 token which was only\n *         meant for use on L2.\n */\ncontract KromaMintableERC20 is IKromaMintableERC20, ERC20, Semver {\n    /**\n     * @notice Address of the corresponding version of this token on the remote chain.\n     */\n    address public immutable REMOTE_TOKEN;\n\n    /**\n     * @notice Address of the StandardBridge on this network.\n     */\n    address public immutable BRIDGE;\n\n    /**\n     * @notice Emitted whenever tokens are minted for an account.\n     *\n     * @param account Address of the account tokens are being minted for.\n     * @param amount  Amount of tokens minted.\n     */\n    event Mint(address indexed account, uint256 amount);\n\n    /**\n     * @notice Emitted whenever tokens are burned from an account.\n     *\n     * @param account Address of the account tokens are being burned from.\n     * @param amount  Amount of tokens burned.\n     */\n    event Burn(address indexed account, uint256 amount);\n\n    /**\n     * @notice A modifier that only allows the bridge to call\n     */\n    modifier onlyBridge() {\n        require(msg.sender == BRIDGE, \"KromaMintableERC20: only bridge can mint and burn\");\n        _;\n    }\n\n    /**\n    * @custom:semver 0.1.0\n     *\n     * @param _bridge      Address of the L2 standard bridge.\n     * @param _remoteToken Address of the corresponding L1 token.\n     * @param _name        ERC20 name.\n     * @param _symbol      ERC20 symbol.\n     */\n    constructor(\n        address _bridge,\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) Semver(0, 1, 0) {\n        REMOTE_TOKEN = _remoteToken;\n        BRIDGE = _bridge;\n    }\n\n    /**\n     * @notice Allows the StandardBridge on this network to mint tokens.\n     *\n     * @param _to     Address to mint tokens to.\n     * @param _amount Amount of tokens to mint.\n     */\n    function mint(address _to, uint256 _amount)\n        external\n        virtual\n        override(IKromaMintableERC20)\n        onlyBridge\n    {\n        _mint(_to, _amount);\n        emit Mint(_to, _amount);\n    }\n\n    /**\n     * @notice Allows the StandardBridge on this network to burn tokens.\n     *\n     * @param _from   Address to burn tokens from.\n     * @param _amount Amount of tokens to burn.\n     */\n    function burn(address _from, uint256 _amount)\n        external\n        virtual\n        override(IKromaMintableERC20)\n        onlyBridge\n    {\n        _burn(_from, _amount);\n        emit Burn(_from, _amount);\n    }\n\n    /**\n     * @notice ERC165 interface check function.\n     *\n     * @param _interfaceId Interface ID to check.\n     *\n     * @return Whether or not the interface is supported by this contract.\n     */\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool) {\n        bytes4 iface1 = type(IERC165).interfaceId;\n        // Interface corresponding to the updated KromaMintableERC20 (this contract).\n        bytes4 iface2 = type(IKromaMintableERC20).interfaceId;\n        return _interfaceId == iface1 || _interfaceId == iface2;\n    }\n}\n"
    },
    "contracts/universal/KromaMintableERC20Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/* Contract Imports */\nimport { KromaMintableERC20 } from \"../universal/KromaMintableERC20.sol\";\nimport { Semver } from \"./Semver.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeployed 0x420000000000000000000000000000000000000B\n * @title KromaMintableERC20Factory\n * @notice KromaMintableERC20Factory is a factory contract that generates KromaMintableERC20\n *         contracts on the network it's deployed to. Simplifies the deployment process for users\n *         who may be less familiar with deploying smart contracts. Designed to be backwards\n *         compatible with the older StandardL2ERC20Factory contract.\n */\ncontract KromaMintableERC20Factory is Semver {\n    /**\n     * @notice Address of the StandardBridge on this chain.\n     */\n    address public immutable BRIDGE;\n\n    /**\n     * @notice Emitted whenever a new KromaMintableERC20 is created.\n     *\n     * @param localToken  Address of the created token on the local chain.\n     * @param remoteToken Address of the corresponding token on the remote chain.\n     * @param deployer    Address of the account that deployed the token.\n     */\n    event KromaMintableERC20Created(\n        address indexed localToken,\n        address indexed remoteToken,\n        address deployer\n    );\n\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @notice The semver MUST be bumped any time that there is a change in\n     *         the KromaMintableERC20 token contract since this contract\n     *         is responsible for deploying KromaMintableERC20 contracts.\n     *\n     * @param _bridge Address of the StandardBridge on this chain.\n     */\n    constructor(address _bridge) Semver(0, 1, 0) {\n        BRIDGE = _bridge;\n    }\n\n    /**\n     * @notice Creates an instance of the KromaMintableERC20 contract.\n     *\n     * @param _remoteToken Address of the token on the remote chain.\n     * @param _name        ERC20 name.\n     * @param _symbol      ERC20 symbol.\n     *\n     * @return Address of the newly created token.\n     */\n    function createKromaMintableERC20(\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) public returns (address) {\n        require(\n            _remoteToken != address(0),\n            \"KromaMintableERC20Factory: must provide remote token address\"\n        );\n\n        address localToken = address(\n            new KromaMintableERC20(BRIDGE, _remoteToken, _name, _symbol)\n        );\n\n        emit KromaMintableERC20Created(localToken, _remoteToken, msg.sender);\n\n        return localToken;\n    }\n}\n"
    },
    "contracts/universal/KromaMintableERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {\n    ERC721Enumerable\n} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport { Semver } from \"../universal/Semver.sol\";\nimport { IKromaMintableERC721 } from \"./IKromaMintableERC721.sol\";\n\n/**\n * @title KromaMintableERC721\n * @notice This contract is the remote representation for some token that lives on another network,\n *         typically a Kroma representation of an Ethereum-based token. Standard reference\n *         implementation that can be extended or modified according to your needs.\n */\ncontract KromaMintableERC721 is ERC721Enumerable, IKromaMintableERC721, Semver {\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    uint256 public immutable REMOTE_CHAIN_ID;\n\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    address public immutable REMOTE_TOKEN;\n\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    address public immutable BRIDGE;\n\n    /**\n     * @notice Base token URI for this token.\n     */\n    string public baseTokenURI;\n\n    /**\n     * @notice Modifier that prevents callers other than the bridge from calling the function.\n     */\n    modifier onlyBridge() {\n        require(msg.sender == BRIDGE, \"KromaMintableERC721: only bridge can call this function\");\n        _;\n    }\n\n    /**\n     * @custom:semver 0.1.0\n     *\n     * @param _bridge        Address of the bridge on this network.\n     * @param _remoteChainId Chain ID where the remote token is deployed.\n     * @param _remoteToken   Address of the corresponding token on the other network.\n     * @param _name          ERC721 name.\n     * @param _symbol        ERC721 symbol.\n     */\n    constructor(\n        address _bridge,\n        uint256 _remoteChainId,\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) Semver(0, 1, 0) {\n        require(_bridge != address(0), \"KromaMintableERC721: bridge cannot be address(0)\");\n        require(_remoteChainId != 0, \"KromaMintableERC721: remote chain id cannot be zero\");\n        require(\n            _remoteToken != address(0),\n            \"KromaMintableERC721: remote token cannot be address(0)\"\n        );\n\n        REMOTE_CHAIN_ID = _remoteChainId;\n        REMOTE_TOKEN = _remoteToken;\n        BRIDGE = _bridge;\n\n        // Creates a base URI in the format specified by EIP-681:\n        // https://eips.ethereum.org/EIPS/eip-681\n        baseTokenURI = string(\n            abi.encodePacked(\n                \"ethereum:\",\n                Strings.toHexString(uint160(_remoteToken), 20),\n                \"@\",\n                Strings.toString(_remoteChainId),\n                \"/tokenURI?uint256=\"\n            )\n        );\n    }\n\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    function remoteChainId() external view returns (uint256) {\n        return REMOTE_CHAIN_ID;\n    }\n\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    function remoteToken() external view returns (address) {\n        return REMOTE_TOKEN;\n    }\n\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    function bridge() external view returns (address) {\n        return BRIDGE;\n    }\n\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    function safeMint(address _to, uint256 _tokenId) external virtual onlyBridge {\n        _safeMint(_to, _tokenId);\n\n        emit Mint(_to, _tokenId);\n    }\n\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    function burn(address _from, uint256 _tokenId) external virtual onlyBridge {\n        _burn(_tokenId);\n\n        emit Burn(_from, _tokenId);\n    }\n\n    /**\n     * @notice Checks if a given interface ID is supported by this contract.\n     *\n     * @param _interfaceId The interface ID to check.\n     *\n     * @return True if the interface ID is supported, false otherwise.\n     */\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        override(ERC721Enumerable, IERC165)\n        returns (bool)\n    {\n        bytes4 iface1 = type(IERC165).interfaceId;\n        bytes4 iface2 = type(IKromaMintableERC721).interfaceId;\n        return\n            _interfaceId == iface1 ||\n            _interfaceId == iface2 ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /**\n     * @notice Returns the base token URI.\n     *\n     * @return Base token URI.\n     */\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseTokenURI;\n    }\n}\n"
    },
    "contracts/universal/KromaMintableERC721Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { KromaMintableERC721 } from \"./KromaMintableERC721.sol\";\nimport { Semver } from \"./Semver.sol\";\n\n/**\n * @title KromaMintableERC721Factory\n * @notice Factory contract for creating KromaMintableERC721 contracts.\n */\ncontract KromaMintableERC721Factory is Semver {\n    /**\n     * @notice Address of the ERC721 bridge on this network.\n     */\n    address public immutable BRIDGE;\n\n    /**\n     * @notice Chain ID for the remote network.\n     */\n    uint256 public immutable REMOTE_CHAIN_ID;\n\n    /**\n     * @notice Tracks addresses created by this factory.\n     */\n    mapping(address => bool) public isKromaMintableERC721;\n\n    /**\n     * @notice Emitted whenever a new KromaMintableERC721 contract is created.\n     *\n     * @param localToken  Address of the token on the this domain.\n     * @param remoteToken Address of the token on the remote domain.\n     * @param deployer    Address of the initiator of the deployment\n     */\n    event KromaMintableERC721Created(\n        address indexed localToken,\n        address indexed remoteToken,\n        address deployer\n    );\n\n    /**\n     * @custom:semver 0.1.0\n     * @notice The semver MUST be bumped any time that there is a change in\n     *         the KromaMintableERC721 token contract since this contract\n     *         is responsible for deploying KromaMintableERC721 contracts.\n     *\n     * @param _bridge Address of the ERC721 bridge on this network.\n     * @param _remoteChainId Chain ID for the remote network.\n     */\n    constructor(address _bridge, uint256 _remoteChainId) Semver(0, 1, 0) {\n        BRIDGE = _bridge;\n        REMOTE_CHAIN_ID = _remoteChainId;\n    }\n\n    /**\n     * @notice Creates an instance of the standard ERC721.\n     *\n     * @param _remoteToken Address of the corresponding token on the other domain.\n     * @param _name        ERC721 name.\n     * @param _symbol      ERC721 symbol.\n     */\n    function createKromaMintableERC721(\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) external returns (address) {\n        require(\n            _remoteToken != address(0),\n            \"KromaMintableERC721Factory: L1 token address cannot be address(0)\"\n        );\n\n        address localToken = address(\n            new KromaMintableERC721(BRIDGE, REMOTE_CHAIN_ID, _remoteToken, _name, _symbol)\n        );\n\n        isKromaMintableERC721[localToken] = true;\n        emit KromaMintableERC721Created(localToken, _remoteToken, msg.sender);\n\n        return localToken;\n    }\n}\n"
    },
    "contracts/universal/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title Proxy\n * @notice Proxy is a transparent proxy that passes through the call if the caller is the owner or\n *         if the caller is address(0), meaning that the call originated from an off-chain\n *         simulation.\n */\ncontract Proxy {\n    /**\n     * @notice The storage slot that holds the address of the implementation.\n     *         bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\n     */\n    bytes32 internal constant IMPLEMENTATION_KEY =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @notice The storage slot that holds the address of the owner.\n     *         bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\n     */\n    bytes32 internal constant OWNER_KEY =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @notice An event that is emitted each time the implementation is changed. This event is part\n     *         of the EIP-1967 specification.\n     *\n     * @param implementation The address of the implementation contract\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @notice An event that is emitted each time the owner is upgraded. This event is part of the\n     *         EIP-1967 specification.\n     *\n     * @param previousAdmin The previous owner of the contract\n     * @param newAdmin      The new owner of the contract\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @notice A modifier that reverts if not called by the owner or by address(0) to allow\n     *         eth_call to interact with this proxy without needing to use low-level storage\n     *         inspection. We assume that nobody is able to trigger calls from address(0) during\n     *         normal EVM execution.\n     */\n    modifier proxyCallIfNotAdmin() {\n        if (msg.sender == _getAdmin() || msg.sender == address(0)) {\n            _;\n        } else {\n            // This WILL halt the call frame on completion.\n            _doProxyCall();\n        }\n    }\n\n    /**\n     * @notice Sets the initial admin during contract deployment. Admin address is stored at the\n     *         EIP-1967 admin storage slot so that accidental storage collision with the\n     *         implementation is not possible.\n     *\n     * @param _admin Address of the initial contract admin. Admin as the ability to access the\n     *               transparent proxy interface.\n     */\n    constructor(address _admin) {\n        _changeAdmin(_admin);\n    }\n\n    // slither-disable-next-line locked-ether\n    receive() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    // slither-disable-next-line locked-ether\n    fallback() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    /**\n     * @notice Set the implementation contract address. The code at the given address will execute\n     *         when this contract is called.\n     *\n     * @param _implementation Address of the implementation contract.\n     */\n    function upgradeTo(address _implementation) external proxyCallIfNotAdmin {\n        _setImplementation(_implementation);\n    }\n\n    /**\n     * @notice Set the implementation and call a function in a single transaction. Useful to ensure\n     *         atomic execution of initialization-based upgrades.\n     *\n     * @param _implementation Address of the implementation contract.\n     * @param _data           Calldata to delegatecall the new implementation with.\n     */\n    function upgradeToAndCall(address _implementation, bytes calldata _data)\n        external\n        payable\n        proxyCallIfNotAdmin\n        returns (bytes memory)\n    {\n        _setImplementation(_implementation);\n        (bool success, bytes memory returndata) = _implementation.delegatecall(_data);\n        require(success, \"Proxy: delegatecall to new implementation contract failed\");\n        return returndata;\n    }\n\n    /**\n     * @notice Changes the owner of the proxy contract. Only callable by the owner.\n     *\n     * @param _admin New owner of the proxy contract.\n     */\n    function changeAdmin(address _admin) external proxyCallIfNotAdmin {\n        _changeAdmin(_admin);\n    }\n\n    /**\n     * @notice Gets the owner of the proxy contract.\n     *\n     * @return Owner address.\n     */\n    function admin() external proxyCallIfNotAdmin returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @notice Queries the implementation address.\n     *\n     * @return Implementation address.\n     */\n    function implementation() external proxyCallIfNotAdmin returns (address) {\n        return _getImplementation();\n    }\n\n    /**\n     * @notice Sets the implementation address.\n     *\n     * @param _implementation New implementation address.\n     */\n    function _setImplementation(address _implementation) internal {\n        assembly {\n            sstore(IMPLEMENTATION_KEY, _implementation)\n        }\n        emit Upgraded(_implementation);\n    }\n\n    /**\n     * @notice Changes the owner of the proxy contract.\n     *\n     * @param _admin New owner of the proxy contract.\n     */\n    function _changeAdmin(address _admin) internal {\n        address previous = _getAdmin();\n        assembly {\n            sstore(OWNER_KEY, _admin)\n        }\n        emit AdminChanged(previous, _admin);\n    }\n\n    /**\n     * @notice Performs the proxy call via a delegatecall.\n     */\n    function _doProxyCall() internal {\n        address impl = _getImplementation();\n        require(impl != address(0), \"Proxy: implementation not initialized\");\n\n        assembly {\n            // Copy calldata into memory at 0x0....calldatasize.\n            calldatacopy(0x0, 0x0, calldatasize())\n\n            // Perform the delegatecall, make sure to pass all available gas.\n            let success := delegatecall(gas(), impl, 0x0, calldatasize(), 0x0, 0x0)\n\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\n            // overwrite the calldata that we just copied into memory but that doesn't really\n            // matter because we'll be returning in a second anyway.\n            returndatacopy(0x0, 0x0, returndatasize())\n\n            // Success == 0 means a revert. We'll revert too and pass the data up.\n            if iszero(success) {\n                revert(0x0, returndatasize())\n            }\n\n            // Otherwise we'll just return and pass the data up.\n            return(0x0, returndatasize())\n        }\n    }\n\n    /**\n     * @notice Queries the implementation address.\n     *\n     * @return Implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        address impl;\n        assembly {\n            impl := sload(IMPLEMENTATION_KEY)\n        }\n        return impl;\n    }\n\n    /**\n     * @notice Queries the owner of the proxy contract.\n     *\n     * @return Owner address.\n     */\n    function _getAdmin() internal view returns (address) {\n        address owner;\n        assembly {\n            owner := sload(OWNER_KEY)\n        }\n        return owner;\n    }\n}\n"
    },
    "contracts/universal/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { Proxy } from \"./Proxy.sol\";\n\n/**\n * @title IStaticERC1967Proxy\n * @notice IStaticERC1967Proxy is a static version of the ERC1967 proxy interface.\n */\ninterface IStaticERC1967Proxy {\n    function implementation() external view returns (address);\n\n    function admin() external view returns (address);\n}\n\n/**\n * @title ProxyAdmin\n * @notice This is an auxiliary contract meant to be assigned as the admin of an ERC1967 Proxy,\n *         based on the OpenZeppelin implementation.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @param _owner Address of the initial owner of this contract.\n     */\n    constructor(address _owner) Ownable() {\n        _transferOwnership(_owner);\n    }\n\n    /**\n     * @notice Returns the implementation of the given proxy address.\n     *\n     * @param _proxy Address of the proxy to get the implementation of.\n     *\n     * @return Address of the implementation of the proxy.\n     */\n    function getProxyImplementation(address _proxy) external view returns (address) {\n        return IStaticERC1967Proxy(_proxy).implementation();\n    }\n\n    /**\n     * @notice Returns the admin of the given proxy address.\n     *\n     * @param _proxy Address of the proxy to get the admin of.\n     *\n     * @return Address of the admin of the proxy.\n     */\n    function getProxyAdmin(address payable _proxy) external view returns (address) {\n        return IStaticERC1967Proxy(_proxy).admin();\n    }\n\n    /**\n     * @notice Updates the admin of the given proxy address.\n     *\n     * @param _proxy    Address of the proxy to update.\n     * @param _newAdmin Address of the new proxy admin.\n     */\n    function changeProxyAdmin(address payable _proxy, address _newAdmin) external onlyOwner {\n        Proxy(_proxy).changeAdmin(_newAdmin);\n    }\n\n    /**\n     * @notice Changes a proxy's implementation contract.\n     *\n     * @param _proxy          Address of the proxy to upgrade.\n     * @param _implementation Address of the new implementation address.\n     */\n    function upgrade(address payable _proxy, address _implementation) public onlyOwner {\n        Proxy(_proxy).upgradeTo(_implementation);\n    }\n\n    /**\n     * @notice Changes a proxy's implementation contract and delegatecalls the new implementation\n     *         with some given data. Useful for atomic upgrade-and-initialize calls.\n     *\n     * @param _proxy          Address of the proxy to upgrade.\n     * @param _implementation Address of the new implementation address.\n     * @param _data           Data to trigger the new implementation with.\n     */\n    function upgradeAndCall(\n        address payable _proxy,\n        address _implementation,\n        bytes memory _data\n    ) external payable onlyOwner {\n        Proxy(_proxy).upgradeToAndCall{ value: msg.value }(_implementation, _data);\n    }\n}\n"
    },
    "contracts/universal/Semver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\n/**\n * @title Semver\n * @notice Semver is a simple contract for managing contract versions.\n */\ncontract Semver {\n    /**\n     * @notice Contract version number (major).\n     */\n    uint256 private immutable MAJOR_VERSION;\n\n    /**\n     * @notice Contract version number (minor).\n     */\n    uint256 private immutable MINOR_VERSION;\n\n    /**\n     * @notice Contract version number (patch).\n     */\n    uint256 private immutable PATCH_VERSION;\n\n    /**\n     * @param _major Version number (major).\n     * @param _minor Version number (minor).\n     * @param _patch Version number (patch).\n     */\n    constructor(\n        uint256 _major,\n        uint256 _minor,\n        uint256 _patch\n    ) {\n        MAJOR_VERSION = _major;\n        MINOR_VERSION = _minor;\n        PATCH_VERSION = _patch;\n    }\n\n    /**\n     * @notice Returns the full semver contract version.\n     *\n     * @return Semver contract version as a string.\n     */\n    function version() public view returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    Strings.toString(MAJOR_VERSION),\n                    \".\",\n                    Strings.toString(MINOR_VERSION),\n                    \".\",\n                    Strings.toString(PATCH_VERSION)\n                )\n            );\n    }\n}\n"
    },
    "contracts/universal/StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { CrossDomainMessenger } from \"./CrossDomainMessenger.sol\";\nimport { IKromaMintableERC20 } from \"./IKromaMintableERC20.sol\";\nimport { KromaMintableERC20 } from \"./KromaMintableERC20.sol\";\n\n/**\n * @custom:upgradeable\n * @title StandardBridge\n * @notice StandardBridge is a base contract for the L1 and L2 standard ERC20 bridges. It handles\n *         the core bridging logic, including escrowing tokens that are native to the local chain\n *         and minting/burning tokens that are native to the remote chain.\n */\nabstract contract StandardBridge {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice The L2 gas limit set when eth is depoisited using the receive() function.\n     */\n    uint32 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 200_000;\n\n    /**\n     * @notice Messenger contract on this domain.\n     */\n    CrossDomainMessenger public immutable MESSENGER;\n\n    /**\n     * @notice Corresponding bridge on the other domain.\n     */\n    StandardBridge public immutable OTHER_BRIDGE;\n\n    /**\n     * @notice Mapping that stores deposits for a given pair of local and remote tokens.\n     */\n    mapping(address => mapping(address => uint256)) public deposits;\n\n    /**\n     * @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\n     *         A gap size of 49 was chosen here, so that the first slot used in a child contract\n     *         would be a multiple of 50.\n     */\n    uint256[49] private __gap;\n\n    /**\n     * @notice Emitted when an ETH bridge is initiated to the other chain.\n     *\n     * @param from      Address of the sender.\n     * @param to        Address of the receiver.\n     * @param amount    Amount of ETH sent.\n     * @param extraData Extra data sent with the transaction.\n     */\n    event ETHBridgeInitiated(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @notice Emitted when an ETH bridge is finalized on this chain.\n     *\n     * @param from      Address of the sender.\n     * @param to        Address of the receiver.\n     * @param amount    Amount of ETH sent.\n     * @param extraData Extra data sent with the transaction.\n     */\n    event ETHBridgeFinalized(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @notice Emitted when an ERC20 bridge is initiated to the other chain.\n     *\n     * @param localToken  Address of the ERC20 on this chain.\n     * @param remoteToken Address of the ERC20 on the remote chain.\n     * @param from        Address of the sender.\n     * @param to          Address of the receiver.\n     * @param amount      Amount of the ERC20 sent.\n     * @param extraData   Extra data sent with the transaction.\n     */\n    event ERC20BridgeInitiated(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @notice Emitted when an ERC20 bridge is finalized on this chain.\n     *\n     * @param localToken  Address of the ERC20 on this chain.\n     * @param remoteToken Address of the ERC20 on the remote chain.\n     * @param from        Address of the sender.\n     * @param to          Address of the receiver.\n     * @param amount      Amount of the ERC20 sent.\n     * @param extraData   Extra data sent with the transaction.\n     */\n    event ERC20BridgeFinalized(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @notice Only allow EOAs to call the functions. Note that this is not safe against contracts\n     *         calling code within their constructors, but also doesn't really matter since we're\n     *         just trying to prevent users accidentally depositing with smart contract wallets.\n     */\n    modifier onlyEOA() {\n        require(\n            !Address.isContract(msg.sender),\n            \"StandardBridge: function can only be called from an EOA\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Ensures that the caller is a cross-chain message from the other bridge.\n     */\n    modifier onlyOtherBridge() {\n        require(\n            msg.sender == address(MESSENGER) &&\n                MESSENGER.xDomainMessageSender() == address(OTHER_BRIDGE),\n            \"StandardBridge: function can only be called from the other bridge\"\n        );\n        _;\n    }\n\n    /**\n     * @param _messenger   Address of CrossDomainMessenger on this network.\n     * @param _otherBridge Address of the other StandardBridge contract.\n     */\n    constructor(address payable _messenger, address payable _otherBridge) {\n        MESSENGER = CrossDomainMessenger(_messenger);\n        OTHER_BRIDGE = StandardBridge(_otherBridge);\n    }\n\n    /**\n     * @notice Allows EOAs to bridge ETH by sending directly to the bridge.\n     *         Must be implemented by contracts that inherit.\n     */\n    receive() external payable virtual;\n\n    /**\n     * @notice Sends ETH to the sender's address on the other chain.\n     *\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function bridgeETH(uint32 _minGasLimit, bytes calldata _extraData) public payable onlyEOA {\n        _initiateBridgeETH(msg.sender, msg.sender, msg.value, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @notice Sends ETH to a receiver's address on the other chain. Note that if ETH is sent to a\n     *         smart contract and the call fails, the ETH will be temporarily locked in the\n     *         StandardBridge on the other chain until the call is replayed. If the call cannot be\n     *         replayed with any amount of gas (call always reverts), then the ETH will be\n     *         permanently locked in the StandardBridge on the other chain. ETH will also\n     *         be locked if the receiver is the other bridge, because finalizeBridgeETH will revert\n     *         in that case.\n     *\n     * @param _to          Address of the receiver.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function bridgeETHTo(\n        address _to,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) public payable {\n        _initiateBridgeETH(msg.sender, _to, msg.value, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @notice Sends ERC20 tokens to the sender's address on the other chain. Note that if the\n     *         ERC20 token on the other chain does not recognize the local token as the correct\n     *         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\n     *         this chain.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _amount      Amount of local tokens to deposit.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function bridgeERC20(\n        address _localToken,\n        address _remoteToken,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) public onlyEOA {\n        _initiateBridgeERC20(\n            _localToken,\n            _remoteToken,\n            msg.sender,\n            msg.sender,\n            _amount,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @notice Sends ERC20 tokens to a receiver's address on the other chain. Note that if the\n     *         ERC20 token on the other chain does not recognize the local token as the correct\n     *         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\n     *         this chain.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of local tokens to deposit.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function bridgeERC20To(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) public {\n        _initiateBridgeERC20(\n            _localToken,\n            _remoteToken,\n            msg.sender,\n            _to,\n            _amount,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @notice Finalizes an ETH bridge on this chain. Can only be triggered by the other\n     *         StandardBridge contract on the remote chain.\n     *\n     * @param _from      Address of the sender.\n     * @param _to        Address of the receiver.\n     * @param _amount    Amount of ETH being bridged.\n     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will\n     *                   not be triggered with this data, but it will be emitted and can be used\n     *                   to identify the transaction.\n     */\n    function finalizeBridgeETH(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _extraData\n    ) public payable onlyOtherBridge {\n        require(msg.value == _amount, \"StandardBridge: amount sent does not match amount required\");\n        require(_to != address(this), \"StandardBridge: cannot send to self\");\n        require(_to != address(MESSENGER), \"StandardBridge: cannot send to messenger\");\n\n        emit ETHBridgeFinalized(_from, _to, _amount, _extraData);\n\n        bool success = SafeCall.call(_to, gasleft(), _amount, hex\"\");\n        require(success, \"StandardBridge: ETH transfer failed\");\n    }\n\n    /**\n     * @notice Finalizes an ERC20 bridge on this chain. Can only be triggered by the other\n     *         StandardBridge contract on the remote chain.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _from        Address of the sender.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of the ERC20 being bridged.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function finalizeBridgeERC20(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _extraData\n    ) public onlyOtherBridge {\n        if (_isKromaMintableERC20(_localToken)) {\n            require(\n                _isCorrectTokenPair(_localToken, _remoteToken),\n                \"StandardBridge: wrong remote token for Kroma Mintable ERC20 local token\"\n            );\n\n            KromaMintableERC20(_localToken).mint(_to, _amount);\n        } else {\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] - _amount;\n            IERC20(_localToken).safeTransfer(_to, _amount);\n        }\n\n        emit ERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n    }\n\n    /**\n     * @notice Initiates a bridge of ETH through the CrossDomainMessenger.\n     *\n     * @param _from        Address of the sender.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of ETH being bridged.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function _initiateBridgeETH(\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes memory _extraData\n    ) internal {\n        require(\n            msg.value == _amount,\n            \"StandardBridge: bridging ETH must include sufficient ETH value\"\n        );\n\n        emit ETHBridgeInitiated(_from, _to, _amount, _extraData);\n\n        MESSENGER.sendMessage{ value: _amount }(\n            address(OTHER_BRIDGE),\n            abi.encodeWithSelector(\n                this.finalizeBridgeETH.selector,\n                _from,\n                _to,\n                _amount,\n                _extraData\n            ),\n            _minGasLimit\n        );\n    }\n\n    /**\n     * @notice Sends ERC20 tokens to a receiver's address on the other chain.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of local tokens to deposit.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function _initiateBridgeERC20(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes memory _extraData\n    ) internal {\n        if (_isKromaMintableERC20(_localToken)) {\n            require(\n                _isCorrectTokenPair(_localToken, _remoteToken),\n                \"StandardBridge: wrong remote token for Kroma Mintable ERC20 local token\"\n            );\n\n            KromaMintableERC20(_localToken).burn(_from, _amount);\n        } else {\n            IERC20(_localToken).safeTransferFrom(_from, address(this), _amount);\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] + _amount;\n        }\n\n        emit ERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n\n        MESSENGER.sendMessage(\n            address(OTHER_BRIDGE),\n            abi.encodeWithSelector(\n                this.finalizeBridgeERC20.selector,\n                // Because this call will be executed on the remote chain, we reverse the order of\n                // the remote and local token addresses relative to their order in the\n                // finalizeBridgeERC20 function.\n                _remoteToken,\n                _localToken,\n                _from,\n                _to,\n                _amount,\n                _extraData\n            ),\n            _minGasLimit\n        );\n    }\n\n    /**\n     * @notice Checks if a given address is a KromaMintableERC20. Not perfect, but good enough.\n     *         Just the way we like it.\n     *\n     * @param _token Address of the token to check.\n     *\n     * @return True if the token is a KromaMintableERC20.\n     */\n    function _isKromaMintableERC20(address _token) internal view returns (bool) {\n        return ERC165Checker.supportsInterface(_token, type(IKromaMintableERC20).interfaceId);\n    }\n\n    /**\n     * @notice Checks if the \"other token\" is the correct pair token for the KromaMintableERC20.\n     *\n     * @param _mintableToken KromaMintableERC20 to check against.\n     * @param _otherToken    Pair token to check.\n     *\n     * @return True if the other token is the correct pair token for the KromaMintableERC20.\n     */\n    function _isCorrectTokenPair(address _mintableToken, address _otherToken)\n        internal\n        view\n        returns (bool)\n    {\n        return _otherToken == KromaMintableERC20(_mintableToken).REMOTE_TOKEN();\n    }\n}\n"
    },
    "contracts/vendor/AddressAliasHelper.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nlibrary AddressAliasHelper {\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + offset);\n        }\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        unchecked {\n            l1Address = address(uint160(l2Address) - offset);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.2) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "node_modules/@rari-capital/solmate/src/utils/Bytes32AddressLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Library for converting between addresses and bytes32 values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\nlibrary Bytes32AddressLib {\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue));\n    }\n}\n"
    },
    "node_modules/@rari-capital/solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\n        return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.\n    }\n\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is < 0.5 we return zero. This happens when\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n            if (x <= -42139678854452767551) return 0;\n\n            // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\n            // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\n            if (x >= 135305999368893231589) revert(\"EXP_OVERFLOW\");\n\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5**18;\n\n            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // k is in the range [-61, 195].\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // p is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range (0.09, 0.25) * 2**96.\n\n            // We now need to multiply r by:\n            // * the scale factor s = ~6.031367120.\n            // * the 2**k factor from the range reduction.\n            // * the 1e18 / 2**96 factor for base conversion.\n            // We do this all at once, with an intermediate result in 2**213\n            // basis, so the final right shift is always by a positive amount.\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n        }\n    }\n\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            require(x > 0, \"UNDEFINED\");\n\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n            // We do this by multiplying by 2**96 / 10**18. But since\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n            // and add ln(2**96 / 10**18) at the end.\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            int256 k = int256(log2(uint256(x))) - 96;\n            x <<= uint256(159 - k);\n            x = int256(uint256(x) >> 159);\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // p is made monic, we will multiply by a scale factor later.\n            int256 p = x + 3273285459638523848632254066296;\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\n            p = p * x - (795164235651350426258249787498 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            // q is monic by convention.\n            int256 q = x + 5573035233440673466300451813936;\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial is known not to have zeros in the domain.\n                // No scaling required because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r is in the range (0, 0.125) * 2**96\n\n            // Finalization, we need to:\n            // * multiply by the scale factor s = 5.549…\n            // * add ln(2**96 / 10**18)\n            // * add k * ln(2)\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\n\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n            r *= 1677202110996718588342820967067443963516166;\n            // add ln(2) * k * 5e18 * 2**192\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n            // base conversion: mul 2**18 / 2**192\n            r >>= 174;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        require(x > 0, \"UNDEFINED\");\n\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\n            r := or(r, lt(0x1, shr(r, x)))\n        }\n    }\n}\n"
    },
    "node_modules/ds-test/src/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.0;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool private _failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function failed() public returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            bool globalFailed = false;\n            if (hasHEVMContext()) {\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\n                    abi.encodePacked(\n                        bytes4(keccak256(\"load(address,bytes32)\")),\n                        abi.encode(HEVM_ADDRESS, bytes32(\"failed\"))\n                    )\n                );\n                globalFailed = abi.decode(retdata, (bool));\n            }\n            return globalFailed;\n        }\n    } \n\n    function fail() internal {\n        if (hasHEVMContext()) {\n            (bool status, ) = HEVM_ADDRESS.call(\n                abi.encodePacked(\n                    bytes4(keccak256(\"store(address,bytes32,bytes32)\")),\n                    abi.encode(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x01)))\n                )\n            );\n            status; // Silence compiler warnings\n        }\n        _failed = true;\n    }\n\n    function hasHEVMContext() internal view returns (bool) {\n        uint256 hevmCodeSize = 0;\n        assembly {\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\n        }\n        return hevmCodeSize > 0;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Expected\", b);\n            emit log_named_string(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", b);\n            emit log_named_bytes(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "node_modules/forge-std/src/Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {StdStorage} from \"./StdStorage.sol\";\nimport {Vm, VmSafe} from \"./Vm.sol\";\n\nabstract contract CommonBase {\n    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.\n    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(\"hevm cheat code\"))));\n    // console.sol and console2.sol work by executing a staticcall to this address.\n    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;\n    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.\n    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(\"foundry default caller\"))));\n    // Address of the test contract, deployed by the DEFAULT_SENDER.\n    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\n    // Deterministic deployment address of the Multicall3 contract.\n    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    Vm internal constant vm = Vm(VM_ADDRESS);\n    StdStorage internal stdstore;\n}\n\nabstract contract TestBase is CommonBase {}\n\nabstract contract ScriptBase is CommonBase {\n    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);\n}\n"
    },
    "node_modules/forge-std/src/StdAssertions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {DSTest} from \"ds-test/test.sol\";\nimport {stdMath} from \"./StdMath.sol\";\n\nabstract contract StdAssertions is DSTest {\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertFalse(bool data, string memory err) internal virtual {\n        assertTrue(!data, err);\n    }\n\n    function assertEq(bool a, bool b) internal virtual {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bool]\");\n            emit log_named_string(\"      Left\", a ? \"true\" : \"false\");\n            emit log_named_string(\"     Right\", b ? \"true\" : \"false\");\n            fail();\n        }\n    }\n\n    function assertEq(bool a, bool b, string memory err) internal virtual {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes memory a, bytes memory b) internal virtual {\n        assertEq0(a, b);\n    }\n\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal virtual {\n        assertEq0(a, b, err);\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [uint[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [int[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [address[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    // Legacy helper\n    function assertEqUint(uint256 a, uint256 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"      Left\", a);\n            emit log_named_uint(\"     Right\", b);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_decimal_uint(\"      Left\", a, decimals);\n            emit log_named_decimal_uint(\"     Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max Delta\", maxDelta, decimals);\n            emit log_named_decimal_uint(\"     Delta\", delta, decimals);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\n        }\n    }\n\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int(\"       Left\", a);\n            emit log_named_int(\"      Right\", b);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_decimal_int(\"      Left\", a, decimals);\n            emit log_named_decimal_int(\"     Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max Delta\", maxDelta, decimals);\n            emit log_named_decimal_uint(\"     Delta\", delta, decimals);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"        Left\", a);\n            emit log_named_uint(\"       Right\", b);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_decimal_uint(\"        Left\", a, decimals);\n            emit log_named_decimal_uint(\"       Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals,\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\n        }\n    }\n\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int(\"        Left\", a);\n            emit log_named_int(\"       Right\", b);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_decimal_int(\"        Left\", a, decimals);\n            emit log_named_decimal_int(\"       Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\n        }\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdChains.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n/**\n * StdChains provides information about EVM compatible chains that can be used in scripts/tests.\n * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are\n * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of\n * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the\n * alias used in this contract, which can be found as the first argument to the\n * `setChainWithDefaultRpcUrl` call in the `initialize` function.\n *\n * There are two main ways to use this contract:\n *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or\n *      `setChain(string memory chainAlias, Chain memory chain)`\n *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.\n *\n * The first time either of those are used, chains are initialized with the default set of RPC URLs.\n * This is done in `initialize`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in\n * `defaultRpcUrls`.\n *\n * The `setChain` function is straightforward, and it simply saves off the given chain data.\n *\n * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say\n * we want to retrieve `mainnet`'s RPC URL:\n *   - If you haven't set any mainnet chain info with `setChain`, you haven't specified that\n *     chain in `foundry.toml` and no env var is set, the default data and RPC URL will be returned.\n *   - If you have set a mainnet RPC URL in `foundry.toml` it will return that, if valid (e.g. if\n *     a URL is given or if an environment variable is given and that environment variable exists).\n *     Otherwise, the default data is returned.\n *   - If you specified data with `setChain` it will return that.\n *\n * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.\n */\nabstract contract StdChains {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private initialized;\n\n    struct ChainData {\n        string name;\n        uint256 chainId;\n        string rpcUrl;\n    }\n\n    struct Chain {\n        // The chain name.\n        string name;\n        // The chain's Chain ID.\n        uint256 chainId;\n        // The chain's alias. (i.e. what gets specified in `foundry.toml`).\n        string chainAlias;\n        // A default RPC endpoint for this chain.\n        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and\n        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy\n        // usage as you will be throttled and this is a disservice to others who need this endpoint.\n        string rpcUrl;\n    }\n\n    // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.\n    mapping(string => Chain) private chains;\n    // Maps from the chain's alias to it's default RPC URL.\n    mapping(string => string) private defaultRpcUrls;\n    // Maps from a chain ID to it's alias.\n    mapping(uint256 => string) private idToAlias;\n\n    bool private fallbackToDefaultRpcUrls = true;\n\n    // The RPC URL will be fetched from config or defaultRpcUrls if possible.\n    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {\n        require(bytes(chainAlias).length != 0, \"StdChains getChain(string): Chain alias cannot be the empty string.\");\n\n        initialize();\n        chain = chains[chainAlias];\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(string): Chain with alias \\\"\", chainAlias, \"\\\" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {\n        require(chainId != 0, \"StdChains getChain(uint256): Chain ID cannot be 0.\");\n        initialize();\n        string memory chainAlias = idToAlias[chainId];\n\n        chain = chains[chainAlias];\n\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(uint256): Chain with ID \", vm.toString(chainId), \" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {\n        require(\n            bytes(chainAlias).length != 0,\n            \"StdChains setChain(string,ChainData): Chain alias cannot be the empty string.\"\n        );\n\n        require(chain.chainId != 0, \"StdChains setChain(string,ChainData): Chain ID cannot be 0.\");\n\n        initialize();\n        string memory foundAlias = idToAlias[chain.chainId];\n\n        require(\n            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),\n            string(\n                abi.encodePacked(\n                    \"StdChains setChain(string,ChainData): Chain ID \",\n                    vm.toString(chain.chainId),\n                    \" already used by \\\"\",\n                    foundAlias,\n                    \"\\\".\"\n                )\n            )\n        );\n\n        uint256 oldChainId = chains[chainAlias].chainId;\n        delete idToAlias[oldChainId];\n\n        chains[chainAlias] =\n            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});\n        idToAlias[chain.chainId] = chainAlias;\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, Chain memory chain) internal virtual {\n        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));\n    }\n\n    function _toUpper(string memory str) private pure returns (string memory) {\n        bytes memory strb = bytes(str);\n        bytes memory copy = new bytes(strb.length);\n        for (uint256 i = 0; i < strb.length; i++) {\n            bytes1 b = strb[i];\n            if (b >= 0x61 && b <= 0x7A) {\n                copy[i] = bytes1(uint8(b) - 32);\n            } else {\n                copy[i] = b;\n            }\n        }\n        return string(copy);\n    }\n\n    // lookup rpcUrl, in descending order of priority:\n    // current -> config (foundry.toml) -> environment variable -> default\n    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain) private returns (Chain memory) {\n        if (bytes(chain.rpcUrl).length == 0) {\n            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {\n                chain.rpcUrl = configRpcUrl;\n            } catch (bytes memory err) {\n                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), \"_RPC_URL\"));\n                if (fallbackToDefaultRpcUrls) {\n                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);\n                } else {\n                    chain.rpcUrl = vm.envString(envName);\n                }\n                // distinguish 'not found' from 'cannot read'\n                bytes memory notFoundError =\n                    abi.encodeWithSignature(\"CheatCodeError\", string(abi.encodePacked(\"invalid rpc url \", chainAlias)));\n                if (keccak256(notFoundError) != keccak256(err) || bytes(chain.rpcUrl).length == 0) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, err), mload(err))\n                    }\n                }\n            }\n        }\n        return chain;\n    }\n\n    function setFallbackToDefaultRpcUrls(bool useDefault) internal {\n        fallbackToDefaultRpcUrls = useDefault;\n    }\n\n    function initialize() private {\n        if (initialized) return;\n\n        initialized = true;\n\n        // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`\n        setChainWithDefaultRpcUrl(\"anvil\", ChainData(\"Anvil\", 31337, \"http://127.0.0.1:8545\"));\n        setChainWithDefaultRpcUrl(\n            \"mainnet\", ChainData(\"Mainnet\", 1, \"https://mainnet.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"goerli\", ChainData(\"Goerli\", 5, \"https://goerli.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"sepolia\", ChainData(\"Sepolia\", 11155111, \"https://sepolia.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b\")\n        );\n        setChainWithDefaultRpcUrl(\"optimism\", ChainData(\"Optimism\", 10, \"https://mainnet.optimism.io\"));\n        setChainWithDefaultRpcUrl(\"optimism_goerli\", ChainData(\"Optimism Goerli\", 420, \"https://goerli.optimism.io\"));\n        setChainWithDefaultRpcUrl(\"arbitrum_one\", ChainData(\"Arbitrum One\", 42161, \"https://arb1.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"arbitrum_one_goerli\", ChainData(\"Arbitrum One Goerli\", 421613, \"https://goerli-rollup.arbitrum.io/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\"arbitrum_nova\", ChainData(\"Arbitrum Nova\", 42170, \"https://nova.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\"polygon\", ChainData(\"Polygon\", 137, \"https://polygon-rpc.com\"));\n        setChainWithDefaultRpcUrl(\n            \"polygon_mumbai\", ChainData(\"Polygon Mumbai\", 80001, \"https://rpc-mumbai.maticvigil.com\")\n        );\n        setChainWithDefaultRpcUrl(\"avalanche\", ChainData(\"Avalanche\", 43114, \"https://api.avax.network/ext/bc/C/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"avalanche_fuji\", ChainData(\"Avalanche Fuji\", 43113, \"https://api.avax-test.network/ext/bc/C/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain\", ChainData(\"BNB Smart Chain\", 56, \"https://bsc-dataseed1.binance.org\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain_testnet\",\n            ChainData(\"BNB Smart Chain Testnet\", 97, \"https://rpc.ankr.com/bsc_testnet_chapel\")\n        );\n        setChainWithDefaultRpcUrl(\"gnosis_chain\", ChainData(\"Gnosis Chain\", 100, \"https://rpc.gnosischain.com\"));\n    }\n\n    // set chain info, with priority to chainAlias' rpc url in foundry.toml\n    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {\n        string memory rpcUrl = chain.rpcUrl;\n        defaultRpcUrls[chainAlias] = rpcUrl;\n        chain.rpcUrl = \"\";\n        setChain(chainAlias, chain);\n        chain.rpcUrl = rpcUrl; // restore argument\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdCheats.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {Vm} from \"./Vm.sol\";\n\nabstract contract StdCheatsSafe {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private gasMeteringOff;\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawTx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        // json value name = function\n        string functionSig;\n        bytes32 hash;\n        // json value name = tx\n        RawTx1559Detail txDetail;\n        // json value name = type\n        string opcode;\n    }\n\n    struct RawTx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        bytes gas;\n        bytes nonce;\n        address to;\n        bytes txType;\n        bytes value;\n    }\n\n    struct Tx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        bytes32 hash;\n        Tx1559Detail txDetail;\n        string opcode;\n    }\n\n    struct Tx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 nonce;\n        address to;\n        uint256 txType;\n        uint256 value;\n    }\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct TxLegacy {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        string hash;\n        string opcode;\n        TxDetailLegacy transaction;\n    }\n\n    struct TxDetailLegacy {\n        AccessList[] accessList;\n        uint256 chainId;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 gasPrice;\n        bytes32 hash;\n        uint256 nonce;\n        bytes1 opcode;\n        bytes32 r;\n        bytes32 s;\n        uint256 txType;\n        address to;\n        uint8 v;\n        uint256 value;\n    }\n\n    struct AccessList {\n        address accessAddress;\n        bytes32[] storageKeys;\n    }\n\n    // Data structures to parse Receipt objects from the broadcast artifact.\n    // The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawReceipt {\n        bytes32 blockHash;\n        bytes blockNumber;\n        address contractAddress;\n        bytes cumulativeGasUsed;\n        bytes effectiveGasPrice;\n        address from;\n        bytes gasUsed;\n        RawReceiptLog[] logs;\n        bytes logsBloom;\n        bytes status;\n        address to;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n    }\n\n    struct Receipt {\n        bytes32 blockHash;\n        uint256 blockNumber;\n        address contractAddress;\n        uint256 cumulativeGasUsed;\n        uint256 effectiveGasPrice;\n        address from;\n        uint256 gasUsed;\n        ReceiptLog[] logs;\n        bytes logsBloom;\n        uint256 status;\n        address to;\n        bytes32 transactionHash;\n        uint256 transactionIndex;\n    }\n\n    // Data structures to parse the entire broadcast artifact, assuming the\n    // transactions conform to EIP1559.\n\n    struct EIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        Receipt[] receipts;\n        uint256 timestamp;\n        Tx1559[] transactions;\n        TxReturn[] txReturns;\n    }\n\n    struct RawEIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        RawReceipt[] receipts;\n        TxReturn[] txReturns;\n        uint256 timestamp;\n        RawTx1559[] transactions;\n    }\n\n    struct RawReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        bytes blockNumber;\n        bytes data;\n        bytes logIndex;\n        bool removed;\n        bytes32[] topics;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n        bytes transactionLogIndex;\n    }\n\n    struct ReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        uint256 blockNumber;\n        bytes data;\n        uint256 logIndex;\n        bytes32[] topics;\n        uint256 transactionIndex;\n        uint256 transactionLogIndex;\n        bool removed;\n    }\n\n    struct TxReturn {\n        string internalType;\n        string value;\n    }\n\n    function assumeNoPrecompiles(address addr) internal virtual {\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        assumeNoPrecompiles(addr, chainId);\n    }\n\n    function assumeNoPrecompiles(address addr, uint256 chainId) internal pure virtual {\n        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific\n        // address), but the same rationale for excluding them applies so we include those too.\n\n        // These should be present on all EVM-compatible chains.\n        vm.assume(addr < address(0x1) || addr > address(0x9));\n\n        // forgefmt: disable-start\n        if (chainId == 10 || chainId == 420) {\n            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21\n            vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));\n        } else if (chainId == 42161 || chainId == 421613) {\n            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains\n            vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));\n        } else if (chainId == 43114 || chainId == 43113) {\n            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59\n            vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));\n            vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));\n            vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));\n        }\n        // forgefmt: disable-end\n    }\n\n    function readEIP1559ScriptArtifact(string memory path)\n        internal\n        view\n        virtual\n        returns (EIP1559ScriptArtifact memory)\n    {\n        string memory data = vm.readFile(path);\n        bytes memory parsedData = vm.parseJson(data);\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\n        EIP1559ScriptArtifact memory artifact;\n        artifact.libraries = rawArtifact.libraries;\n        artifact.path = rawArtifact.path;\n        artifact.timestamp = rawArtifact.timestamp;\n        artifact.pending = rawArtifact.pending;\n        artifact.txReturns = rawArtifact.txReturns;\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\n        return artifact;\n    }\n\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\n        for (uint256 i; i < rawTxs.length; i++) {\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\n        }\n        return txs;\n    }\n\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {\n        Tx1559 memory transaction;\n        transaction.arguments = rawTx.arguments;\n        transaction.contractName = rawTx.contractName;\n        transaction.functionSig = rawTx.functionSig;\n        transaction.hash = rawTx.hash;\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\n        transaction.opcode = rawTx.opcode;\n        return transaction;\n    }\n\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\n        internal\n        pure\n        virtual\n        returns (Tx1559Detail memory)\n    {\n        Tx1559Detail memory txDetail;\n        txDetail.data = rawDetail.data;\n        txDetail.from = rawDetail.from;\n        txDetail.to = rawDetail.to;\n        txDetail.nonce = _bytesToUint(rawDetail.nonce);\n        txDetail.txType = _bytesToUint(rawDetail.txType);\n        txDetail.value = _bytesToUint(rawDetail.value);\n        txDetail.gas = _bytesToUint(rawDetail.gas);\n        txDetail.accessList = rawDetail.accessList;\n        return txDetail;\n    }\n\n    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".transactions\");\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\n        return rawToConvertedEIPTx1559s(rawTxs);\n    }\n\n    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".transactions[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\n        return rawToConvertedEIPTx1559(rawTx);\n    }\n\n    // Analogous to readTransactions, but for receipts.\n    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".receipts\");\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\n        return rawToConvertedReceipts(rawReceipts);\n    }\n\n    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".receipts[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\n        return rawToConvertedReceipt(rawReceipt);\n    }\n\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\n        for (uint256 i; i < rawReceipts.length; i++) {\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\n        }\n        return receipts;\n    }\n\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {\n        Receipt memory receipt;\n        receipt.blockHash = rawReceipt.blockHash;\n        receipt.to = rawReceipt.to;\n        receipt.from = rawReceipt.from;\n        receipt.contractAddress = rawReceipt.contractAddress;\n        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);\n        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);\n        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);\n        receipt.status = _bytesToUint(rawReceipt.status);\n        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);\n        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\n        receipt.logsBloom = rawReceipt.logsBloom;\n        receipt.transactionHash = rawReceipt.transactionHash;\n        return receipt;\n    }\n\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\n        internal\n        pure\n        virtual\n        returns (ReceiptLog[] memory)\n    {\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\n        for (uint256 i; i < rawLogs.length; i++) {\n            logs[i].logAddress = rawLogs[i].logAddress;\n            logs[i].blockHash = rawLogs[i].blockHash;\n            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);\n            logs[i].data = rawLogs[i].data;\n            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);\n            logs[i].topics = rawLogs[i].topics;\n            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);\n            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);\n            logs[i].removed = rawLogs[i].removed;\n        }\n        return logs;\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes): Deployment failed.\");\n    }\n\n    function deployCode(string memory what) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string): Deployment failed.\");\n    }\n\n    /// @dev deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes,uint256): Deployment failed.\");\n    }\n\n    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,uint256): Deployment failed.\");\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal virtual returns (address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    function deriveRememberKey(string memory mnemonic, uint32 index)\n        internal\n        virtual\n        returns (address who, uint256 privateKey)\n    {\n        privateKey = vm.deriveKey(mnemonic, index);\n        who = vm.rememberKey(privateKey);\n    }\n\n    function _bytesToUint(bytes memory b) private pure returns (uint256) {\n        require(b.length <= 32, \"StdCheats _bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    function isFork() internal view virtual returns (bool status) {\n        try vm.activeFork() {\n            status = true;\n        } catch (bytes memory) {}\n    }\n\n    modifier skipWhenForking() {\n        if (!isFork()) {\n            _;\n        }\n    }\n\n    modifier skipWhenNotForking() {\n        if (isFork()) {\n            _;\n        }\n    }\n\n    modifier noGasMetering() {\n        vm.pauseGasMetering();\n        // To prevent turning gas monitoring back on with nested functions that use this modifier,\n        // we check if gasMetering started in the off position. If it did, we don't want to turn\n        // it back on until we exit the top level function that used the modifier\n        //\n        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.\n        // funcA will have `gasStartedOff` as false, funcB will have it as true,\n        // so we only turn metering back on at the end of the funcA\n        bool gasStartedOff = gasMeteringOff;\n        gasMeteringOff = true;\n\n        _;\n\n        // if gas metering was on when this modifier was called, turn it back on at the end\n        if (!gasStartedOff) {\n            gasMeteringOff = false;\n            vm.resumeGasMetering();\n        }\n    }\n\n    // a cheat for fuzzing addresses that are payable only\n    // see https://github.com/foundry-rs/foundry/issues/3631\n    function assumePayable(address addr) internal virtual {\n        (bool success,) = payable(addr).call{value: 0}(\"\");\n        vm.assume(success);\n    }\n}\n\n// Wrappers around cheatcodes to avoid footguns\nabstract contract StdCheats is StdCheatsSafe {\n    using stdStorage for StdStorage;\n\n    StdStorage private stdstore;\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal virtual {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) internal virtual {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender, origin);\n    }\n\n    function hoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender);\n    }\n\n    function startHoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function startHoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function changePrank(address msgSender) internal virtual {\n        vm.stopPrank();\n        vm.startPrank(msgSender);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal virtual {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal virtual {\n        deal(token, to, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);\n        }\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdError.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n}\n"
    },
    "node_modules/forge-std/src/StdInvariant.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\ncontract StdInvariant {\n    struct FuzzSelector {\n        address addr;\n        bytes4[] selectors;\n    }\n\n    address[] private _excludedContracts;\n    address[] private _excludedSenders;\n    address[] private _targetedContracts;\n    address[] private _targetedSenders;\n\n    string[] private _excludedArtifacts;\n    string[] private _targetedArtifacts;\n\n    FuzzSelector[] private _targetedArtifactSelectors;\n    FuzzSelector[] private _targetedSelectors;\n\n    // Functions for users:\n    // These are intended to be called in tests.\n\n    function excludeContract(address newExcludedContract_) internal {\n        _excludedContracts.push(newExcludedContract_);\n    }\n\n    function excludeSender(address newExcludedSender_) internal {\n        _excludedSenders.push(newExcludedSender_);\n    }\n\n    function excludeArtifact(string memory newExcludedArtifact_) internal {\n        _excludedArtifacts.push(newExcludedArtifact_);\n    }\n\n    function targetArtifact(string memory newTargetedArtifact_) internal {\n        _targetedArtifacts.push(newTargetedArtifact_);\n    }\n\n    function targetArtifactSelector(FuzzSelector memory newTargetedArtifactSelector_) internal {\n        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);\n    }\n\n    function targetContract(address newTargetedContract_) internal {\n        _targetedContracts.push(newTargetedContract_);\n    }\n\n    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {\n        _targetedSelectors.push(newTargetedSelector_);\n    }\n\n    function targetSender(address newTargetedSender_) internal {\n        _targetedSenders.push(newTargetedSender_);\n    }\n\n    // Functions for forge:\n    // These are called by forge to run invariant tests and don't need to be called in tests.\n\n    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {\n        excludedArtifacts_ = _excludedArtifacts;\n    }\n\n    function excludeContracts() public view returns (address[] memory excludedContracts_) {\n        excludedContracts_ = _excludedContracts;\n    }\n\n    function excludeSenders() public view returns (address[] memory excludedSenders_) {\n        excludedSenders_ = _excludedSenders;\n    }\n\n    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {\n        targetedArtifacts_ = _targetedArtifacts;\n    }\n\n    function targetArtifactSelectors() public view returns (FuzzSelector[] memory targetedArtifactSelectors_) {\n        targetedArtifactSelectors_ = _targetedArtifactSelectors;\n    }\n\n    function targetContracts() public view returns (address[] memory targetedContracts_) {\n        targetedContracts_ = _targetedContracts;\n    }\n\n    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {\n        targetedSelectors_ = _targetedSelectors;\n    }\n\n    function targetSenders() public view returns (address[] memory targetedSenders_) {\n        targetedSenders_ = _targetedSenders;\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdJson.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n// Helpers for parsing and writing JSON files\n// To parse:\n// ```\n// using stdJson for string;\n// string memory json = vm.readFile(\"some_peth\");\n// json.parseUint(\"<json_path>\");\n// ```\n// To write:\n// ```\n// using stdJson for string;\n// string memory json = \"deploymentArtifact\";\n// Contract contract = new Contract();\n// json.serialize(\"contractAddress\", address(contract));\n// json = json.serialize(\"deploymentTimes\", uint(1));\n// // store the stringified JSON to the 'json' variable we have been using as a key\n// // as we won't need it any longer\n// string memory json2 = \"finalArtifact\";\n// string memory final = json2.serialize(\"depArtifact\", json);\n// final.write(\"<some_path>\");\n// ```\n\nlibrary stdJson {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {\n        return vm.parseJson(json, key);\n    }\n\n    function readUint(string memory json, string memory key) internal returns (uint256) {\n        return vm.parseJsonUint(json, key);\n    }\n\n    function readUintArray(string memory json, string memory key) internal returns (uint256[] memory) {\n        return vm.parseJsonUintArray(json, key);\n    }\n\n    function readInt(string memory json, string memory key) internal returns (int256) {\n        return vm.parseJsonInt(json, key);\n    }\n\n    function readIntArray(string memory json, string memory key) internal returns (int256[] memory) {\n        return vm.parseJsonIntArray(json, key);\n    }\n\n    function readBytes32(string memory json, string memory key) internal returns (bytes32) {\n        return vm.parseJsonBytes32(json, key);\n    }\n\n    function readBytes32Array(string memory json, string memory key) internal returns (bytes32[] memory) {\n        return vm.parseJsonBytes32Array(json, key);\n    }\n\n    function readString(string memory json, string memory key) internal returns (string memory) {\n        return vm.parseJsonString(json, key);\n    }\n\n    function readStringArray(string memory json, string memory key) internal returns (string[] memory) {\n        return vm.parseJsonStringArray(json, key);\n    }\n\n    function readAddress(string memory json, string memory key) internal returns (address) {\n        return vm.parseJsonAddress(json, key);\n    }\n\n    function readAddressArray(string memory json, string memory key) internal returns (address[] memory) {\n        return vm.parseJsonAddressArray(json, key);\n    }\n\n    function readBool(string memory json, string memory key) internal returns (bool) {\n        return vm.parseJsonBool(json, key);\n    }\n\n    function readBoolArray(string memory json, string memory key) internal returns (bool[] memory) {\n        return vm.parseJsonBoolArray(json, key);\n    }\n\n    function readBytes(string memory json, string memory key) internal returns (bytes memory) {\n        return vm.parseJsonBytes(json, key);\n    }\n\n    function readBytesArray(string memory json, string memory key) internal returns (bytes[] memory) {\n        return vm.parseJsonBytesArray(json, key);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function write(string memory jsonKey, string memory path) internal {\n        vm.writeJson(jsonKey, path);\n    }\n\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\n        vm.writeJson(jsonKey, path, valueKey);\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN) {\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n        }\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nstruct StdStorage {\n    mapping(address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping(address => mapping(bytes4 => mapping(bytes32 => bool))) finds;\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\nlibrary stdStorageSafe {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);\n    event WARNING_UninitedSlot(address who, uint256 slot);\n\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(StdStorage storage self) internal returns (uint256) {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        vm.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\n        }\n\n        (bytes32[] memory reads,) = vm.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = vm.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(\n                    false,\n                    \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\"\n                );\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                // store\n                vm.store(who, reads[i], bytes32(hex\"1337\"));\n                bool success;\n                bytes memory rdat;\n                {\n                    (success, rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32 * field_depth);\n                }\n\n                if (success && fdat == bytes32(hex\"1337\")) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    vm.store(who, reads[i], prev);\n                    break;\n                }\n                vm.store(who, reads[i], prev);\n            }\n        } else {\n            revert(\"stdStorage find(StdStorage): No storage use detected for target.\");\n        }\n\n        require(\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],\n            \"stdStorage find(StdStorage): Slot(s) not found.\"\n        );\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        address t = self._target;\n        uint256 s = find(self);\n        return abi.encode(vm.load(t, bytes32(s)));\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n\nlibrary stdStorage {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return stdStorageSafe.sigs(sigStr);\n    }\n\n    function find(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.find(self);\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        return stdStorageSafe.target(self, _target);\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, who);\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, amt);\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, key);\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        return stdStorageSafe.depth(self, _depth);\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(StdStorage storage self, bytes32 set) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\n        }\n        bytes32 curr = vm.load(who, slot);\n\n        if (fdat != curr) {\n            require(\n                false,\n                \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\"\n            );\n        }\n        vm.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return stdStorageSafe.read_bytes32(self);\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        return stdStorageSafe.read_bool(self);\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return stdStorageSafe.read_address(self);\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.read_uint(self);\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return stdStorageSafe.read_int(self);\n    }\n\n    // Private function so needs to be copied over\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    // Private function so needs to be copied over\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {IMulticall3} from \"./interfaces/IMulticall3.sol\";\n// TODO Remove import.\nimport {VmSafe} from \"./Vm.sol\";\n\nabstract contract StdUtils {\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTANTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n    uint256 private constant INT256_MIN_ABS =\n        57896044618658097711785492504343953926634992332820282019728792003956564819968;\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\n        require(min <= max, \"StdUtils bound(uint256,uint256,uint256): Max is less than min.\");\n        // If x is between min and max, return x directly. This is to ensure that dictionary values\n        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188\n        if (x >= min && x <= max) return x;\n\n        uint256 size = max - min + 1;\n\n        // If the value is 0, 1, 2, 3, warp that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.\n        // This helps ensure coverage of the min/max values.\n        if (x <= 3 && size > x) return min + x;\n        if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);\n\n        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.\n        if (x > max) {\n            uint256 diff = x - max;\n            uint256 rem = diff % size;\n            if (rem == 0) return max;\n            result = min + rem - 1;\n        } else if (x < min) {\n            uint256 diff = min - x;\n            uint256 rem = diff % size;\n            if (rem == 0) return min;\n            result = max - rem + 1;\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal view virtual returns (uint256 result) {\n        result = _bound(x, min, max);\n        console2_log(\"Bound Result\", result);\n    }\n\n    function bound(int256 x, int256 min, int256 max) internal view virtual returns (int256 result) {\n        require(min <= max, \"StdUtils bound(int256,int256,int256): Max is less than min.\");\n\n        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:\n        // int256 : -(2**255) ~ (2**255 - 1)\n        // uint256:     0     ~ (2**256 - 1)\n        // So, add 2**255, INT256_MIN_ABS to the integer values.\n        //\n        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.\n        // So, use `~uint256(x) + 1` instead.\n        uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);\n        uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);\n        uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);\n\n        uint256 y = _bound(_x, _min, _max);\n\n        // To move it back to int256 value, subtract INT256_MIN_ABS at here.\n        result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);\n        console2_log(\"Bound result\", vm.toString(result));\n    }\n\n    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {\n        require(b.length <= 32, \"StdUtils bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\n    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {\n        // forgefmt: disable-start\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\n        // A one byte integer uses its own value as its length prefix, there is no additional \"0x80 + length\" prefix that comes before it.\n        if (nonce == 0x00)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));\n        if (nonce <= 0x7f)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));\n\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\n        if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));\n        if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));\n        if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));\n        // forgefmt: disable-end\n\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\n        return addressFromLast20Bytes(\n            keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce)))\n        );\n    }\n\n    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)\n        internal\n        pure\n        virtual\n        returns (address)\n    {\n        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initcodeHash)));\n    }\n\n    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {\n        return computeCreate2Address(salt, initCodeHash, CREATE2_FACTORY);\n    }\n\n    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {\n        return hashInitCode(creationCode, \"\");\n    }\n\n    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    /// @param args the ABI-encoded arguments to the constructor of C\n    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(creationCode, args));\n    }\n\n    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.\n    function getTokenBalances(address token, address[] memory addresses)\n        internal\n        virtual\n        returns (uint256[] memory balances)\n    {\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdUtils getTokenBalances(address,address[]): Token address is not a contract.\");\n\n        // ABI encode the aggregate call to Multicall3.\n        uint256 length = addresses.length;\n        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            // 0x70a08231 = bytes4(\"balanceOf(address)\"))\n            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});\n        }\n\n        // Make the aggregate call.\n        (, bytes[] memory returnData) = multicall.aggregate(calls);\n\n        // ABI decode the return data and return the balances.\n        balances = new uint256[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            balances[i] = abi.decode(returnData[i], (uint256));\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.\n\n    function console2_log(string memory p0, uint256 p1) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n        status;\n    }\n\n    function console2_log(string memory p0, string memory p1) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n        status;\n    }\n}\n"
    },
    "node_modules/forge-std/src/Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n// 💬 ABOUT\n// Standard Library's default Test\n\n// 🧩 MODULES\nimport {console} from \"./console.sol\";\nimport {console2} from \"./console2.sol\";\nimport {StdAssertions} from \"./StdAssertions.sol\";\nimport {StdChains} from \"./StdChains.sol\";\nimport {StdCheats} from \"./StdCheats.sol\";\nimport {stdError} from \"./StdError.sol\";\nimport {StdInvariant} from \"./StdInvariant.sol\";\nimport {stdJson} from \"./StdJson.sol\";\nimport {stdMath} from \"./StdMath.sol\";\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {StdUtils} from \"./StdUtils.sol\";\nimport {Vm} from \"./Vm.sol\";\n\n// 📦 BOILERPLATE\nimport {TestBase} from \"./Base.sol\";\nimport {DSTest} from \"ds-test/test.sol\";\n\n// ⭐️ TEST\nabstract contract Test is DSTest, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils, TestBase {\n// Note: IS_TEST() must return true.\n// Note: Must have failure system, https://github.com/dapphub/ds-test/blob/cd98eff28324bfac652e63a239a60632a761790b/src/test.sol#L39-L76.\n}\n"
    },
    "node_modules/forge-std/src/Vm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n// Cheatcodes are marked as view/pure/none using the following rules:\n// 0. A call's observable behaviour includes its return value, logs, reverts and state writes,\n// 1. If you can influence a later call's observable behaviour, you're neither `view` nor `pure (you are modifying some state be it the EVM, interpreter, filesystem, etc),\n// 2. Otherwise if you can be influenced by an earlier call, or if reading some state, you're `view`,\n// 3. Otherwise you're `pure`.\n\ninterface VmSafe {\n    struct Log {\n        bytes32[] topics;\n        bytes data;\n        address emitter;\n    }\n\n    struct Rpc {\n        string key;\n        string url;\n    }\n\n    struct FsMetadata {\n        bool isDir;\n        bool isSymlink;\n        uint256 length;\n        bool readOnly;\n        uint256 modified;\n        uint256 accessed;\n        uint256 created;\n    }\n\n    // Loads a storage slot from an address\n    function load(address target, bytes32 slot) external view returns (bytes32 data);\n    // Signs data\n    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n    // Gets the address for a given private key\n    function addr(uint256 privateKey) external pure returns (address keyAddr);\n    // Gets the nonce of an account\n    function getNonce(address account) external view returns (uint64 nonce);\n    // Performs a foreign function call via the terminal\n    function ffi(string[] calldata commandInput) external returns (bytes memory result);\n    // Sets environment variables\n    function setEnv(string calldata name, string calldata value) external;\n    // Reads environment variables, (name) => (value)\n    function envBool(string calldata name) external view returns (bool value);\n    function envUint(string calldata name) external view returns (uint256 value);\n    function envInt(string calldata name) external view returns (int256 value);\n    function envAddress(string calldata name) external view returns (address value);\n    function envBytes32(string calldata name) external view returns (bytes32 value);\n    function envString(string calldata name) external view returns (string memory value);\n    function envBytes(string calldata name) external view returns (bytes memory value);\n    // Reads environment variables as arrays\n    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);\n    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);\n    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);\n    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);\n    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);\n    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);\n    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);\n    // Read environment variables with default value\n    function envOr(string calldata name, bool defaultValue) external returns (bool value);\n    function envOr(string calldata name, uint256 defaultValue) external returns (uint256 value);\n    function envOr(string calldata name, int256 defaultValue) external returns (int256 value);\n    function envOr(string calldata name, address defaultValue) external returns (address value);\n    function envOr(string calldata name, bytes32 defaultValue) external returns (bytes32 value);\n    function envOr(string calldata name, string calldata defaultValue) external returns (string memory value);\n    function envOr(string calldata name, bytes calldata defaultValue) external returns (bytes memory value);\n    // Read environment variables as arrays with default value\n    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)\n        external\n        returns (bool[] memory value);\n    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)\n        external\n        returns (uint256[] memory value);\n    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)\n        external\n        returns (int256[] memory value);\n    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)\n        external\n        returns (address[] memory value);\n    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)\n        external\n        returns (bytes32[] memory value);\n    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)\n        external\n        returns (string[] memory value);\n    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)\n        external\n        returns (bytes[] memory value);\n    // Records all storage reads and writes\n    function record() external;\n    // Gets all accessed reads and write slot from a recording session, for a given address\n    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);\n    // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);\n    // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);\n    // Labels an address in call traces\n    function label(address account, string calldata newLabel) external;\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n    function broadcast() external;\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n    function broadcast(address signer) external;\n    // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain\n    function broadcast(uint256 privateKey) external;\n    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast() external;\n    // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain\n    function startBroadcast(address signer) external;\n    // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain\n    function startBroadcast(uint256 privateKey) external;\n    // Stops collecting onchain transactions\n    function stopBroadcast() external;\n    // Reads the entire content of file to string\n    function readFile(string calldata path) external view returns (string memory data);\n    // Reads the entire content of file as binary. Path is relative to the project root.\n    function readFileBinary(string calldata path) external view returns (bytes memory data);\n    // Get the path of the current project root\n    function projectRoot() external view returns (string memory path);\n    // Get the metadata for a file/directory\n    function fsMetadata(string calldata fileOrDir) external returns (FsMetadata memory metadata);\n    // Reads next line of file to string\n    function readLine(string calldata path) external view returns (string memory line);\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    function writeFile(string calldata path, string calldata data) external;\n    // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // Path is relative to the project root.\n    function writeFileBinary(string calldata path, bytes calldata data) external;\n    // Writes line to file, creating a file if it does not exist.\n    function writeLine(string calldata path, string calldata data) external;\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    function closeFile(string calldata path) external;\n    // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - Path points to a directory.\n    // - The file doesn't exist.\n    // - The user lacks permissions to remove the file.\n    function removeFile(string calldata path) external;\n    // Convert values to a string\n    function toString(address value) external pure returns (string memory stringifiedValue);\n    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);\n    function toString(bytes32 value) external pure returns (string memory stringifiedValue);\n    function toString(bool value) external pure returns (string memory stringifiedValue);\n    function toString(uint256 value) external pure returns (string memory stringifiedValue);\n    function toString(int256 value) external pure returns (string memory stringifiedValue);\n    // Convert values from a string\n    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);\n    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);\n    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);\n    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);\n    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);\n    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);\n    // Record all the transaction logs\n    function recordLogs() external;\n    // Gets all the recorded logs\n    function getRecordedLogs() external returns (Log[] memory logs);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at {derivationPath}{index}\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)\n        external\n        pure\n        returns (uint256 privateKey);\n    // Adds a private key to the local forge wallet and returns the address\n    function rememberKey(uint256 privateKey) external returns (address keyAddr);\n    //\n    // parseJson\n    //\n    // ----\n    // In case the returned value is a JSON object, it's encoded as a ABI-encoded tuple. As JSON objects\n    // don't have the notion of ordered, but tuples do, they JSON object is encoded with it's fields ordered in\n    // ALPHABETICAL order. That means that in order to successfully decode the tuple, we need to define a tuple that\n    // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded\n    // as tuples, with the attributes in the order in which they are defined.\n    // For example: json = { 'a': 1, 'b': 0xa4tb......3xs}\n    // a: uint256\n    // b: address\n    // To decode that json, we need to define a struct or a tuple as follows:\n    // struct json = { uint256 a; address b; }\n    // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to\n    // decode the tuple in that order, and thus fail.\n    // ----\n    // Given a string of JSON, return it as ABI-encoded\n    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);\n    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);\n\n    // The following parseJson cheatcodes will do type coercion, for the type that they indicate.\n    // For example, parseJsonUint will coerce all values to a uint256. That includes stringified numbers '12'\n    // and hex numbers '0xEF'.\n    // Type coercion works ONLY for discrete values or arrays. That means that the key must return a value or array, not\n    // a JSON object.\n    function parseJsonUint(string calldata, string calldata) external returns (uint256);\n    function parseJsonUintArray(string calldata, string calldata) external returns (uint256[] memory);\n    function parseJsonInt(string calldata, string calldata) external returns (int256);\n    function parseJsonIntArray(string calldata, string calldata) external returns (int256[] memory);\n    function parseJsonBool(string calldata, string calldata) external returns (bool);\n    function parseJsonBoolArray(string calldata, string calldata) external returns (bool[] memory);\n    function parseJsonAddress(string calldata, string calldata) external returns (address);\n    function parseJsonAddressArray(string calldata, string calldata) external returns (address[] memory);\n    function parseJsonString(string calldata, string calldata) external returns (string memory);\n    function parseJsonStringArray(string calldata, string calldata) external returns (string[] memory);\n    function parseJsonBytes(string calldata, string calldata) external returns (bytes memory);\n    function parseJsonBytesArray(string calldata, string calldata) external returns (bytes[] memory);\n    function parseJsonBytes32(string calldata, string calldata) external returns (bytes32);\n    function parseJsonBytes32Array(string calldata, string calldata) external returns (bytes32[] memory);\n\n    // Serialize a key and value to a JSON object stored in-memory that can be later written to a file\n    // It returns the stringified version of the specific JSON file up to that moment.\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)\n        external\n        returns (string memory json);\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)\n        external\n        returns (string memory json);\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)\n        external\n        returns (string memory json);\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)\n        external\n        returns (string memory json);\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)\n        external\n        returns (string memory json);\n    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)\n        external\n        returns (string memory json);\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)\n        external\n        returns (string memory json);\n\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)\n        external\n        returns (string memory json);\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)\n        external\n        returns (string memory json);\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)\n        external\n        returns (string memory json);\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)\n        external\n        returns (string memory json);\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)\n        external\n        returns (string memory json);\n    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)\n        external\n        returns (string memory json);\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)\n        external\n        returns (string memory json);\n\n    //\n    // writeJson\n    //\n    // ----\n    // Write a serialized JSON object to a file. If the file exists, it will be overwritten.\n    // Let's assume we want to write the following JSON to a file:\n    //\n    // { \"boolean\": true, \"number\": 342, \"object\": { \"title\": \"finally json serialization\" } }\n    //\n    // ```\n    //  string memory json1 = \"some key\";\n    //  vm.serializeBool(json1, \"boolean\", true);\n    //  vm.serializeBool(json1, \"number\", uint256(342));\n    //  json2 = \"some other key\";\n    //  string memory output = vm.serializeString(json2, \"title\", \"finally json serialization\");\n    //  string memory finalJson = vm.serialize(json1, \"object\", output);\n    //  vm.writeJson(finalJson, \"./output/example.json\");\n    // ```\n    // The critical insight is that every invocation of serialization will return the stringified version of the JSON\n    // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version\n    // to serialize them as values to another JSON object.\n    //\n    // json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)\n    // will find the object in-memory that is keyed by \"some key\".\n    function writeJson(string calldata json, string calldata path) external;\n    // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key>\n    // This is useful to replace a specific value of a JSON file, without having to parse the entire thing\n    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;\n    // Returns the RPC url for the given alias\n    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);\n    // Returns all rpc urls and their aliases `[alias, url][]`\n    function rpcUrls() external view returns (string[2][] memory urls);\n    // Returns all rpc urls and their aliases as structs.\n    function rpcUrlStructs() external view returns (Rpc[] memory urls);\n    // If the condition is false, discard this run's fuzz inputs and generate new ones.\n    function assume(bool condition) external pure;\n    // Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.\n    function pauseGasMetering() external;\n    // Resumes gas metering (i.e. gas usage is counted again). Noop if already on.\n    function resumeGasMetering() external;\n}\n\ninterface Vm is VmSafe {\n    // Sets block.timestamp\n    function warp(uint256 newTimestamp) external;\n    // Sets block.height\n    function roll(uint256 newHeight) external;\n    // Sets block.basefee\n    function fee(uint256 newBasefee) external;\n    // Sets block.difficulty\n    function difficulty(uint256 newDifficulty) external;\n    // Sets block.chainid\n    function chainId(uint256 newChainId) external;\n    // Stores a value to an address' storage slot.\n    function store(address target, bytes32 slot, bytes32 value) external;\n    // Sets the nonce of an account; must be higher than the current nonce of the account\n    function setNonce(address account, uint64 newNonce) external;\n    // Sets the *next* call's msg.sender to be the input address\n    function prank(address msgSender) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n    function startPrank(address msgSender) external;\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n    function prank(address msgSender, address txOrigin) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n    function startPrank(address msgSender, address txOrigin) external;\n    // Resets subsequent calls' msg.sender to be `address(this)`\n    function stopPrank() external;\n    // Sets an address' balance\n    function deal(address account, uint256 newBalance) external;\n    // Sets an address' code\n    function etch(address target, bytes calldata newRuntimeBytecode) external;\n    // Expects an error on next call\n    function expectRevert(bytes calldata revertData) external;\n    function expectRevert(bytes4 revertData) external;\n    function expectRevert() external;\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)\n        external;\n    // Mocks a call to an address, returning specified data.\n    // Calldata can either be strict or a partial match, e.g. if you only\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\n    // function will be mocked.\n    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;\n    // Mocks a call to an address with a specific msg.value, returning specified data.\n    // Calldata match takes precedence over msg.value in case of ambiguity.\n    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;\n    // Clears all mocked calls\n    function clearMockedCalls() external;\n    // Expects a call to an address with the specified calldata.\n    // Calldata can either be a strict or a partial match\n    function expectCall(address callee, bytes calldata data) external;\n    // Expects a call to an address with the specified msg.value and calldata\n    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;\n    // Expect a call to an address with the specified msg.value, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;\n    // Expect a call to an address with the specified msg.value and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;\n    // Sets block.coinbase\n    function coinbase(address newCoinbase) external;\n    // Snapshot the current state of the evm.\n    // Returns the id of the snapshot that was created.\n    // To revert a snapshot use `revertTo`\n    function snapshot() external returns (uint256 snapshotId);\n    // Revert the state of the EVM to a previous snapshot\n    // Takes the snapshot id to revert to.\n    // This deletes the snapshot and all snapshots taken after the given snapshot id.\n    function revertTo(uint256 snapshotId) external returns (bool success);\n    // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);\n    // Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction,\n    // and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n    // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before\n    // the transaction, returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);\n    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256 forkId) external;\n    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.\n    function activeFork() external view returns (uint256 forkId);\n    // Updates the currently active fork to given block number\n    // This is similar to `roll` but for the currently active fork\n    function rollFork(uint256 blockNumber) external;\n    // Updates the currently active fork to given transaction\n    // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block\n    function rollFork(bytes32 txHash) external;\n    // Updates the given fork to given block number\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n    // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block\n    function rollFork(uint256 forkId, bytes32 txHash) external;\n    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    // Meaning, changes made to the state of this account will be kept when switching forks\n    function makePersistent(address account) external;\n    function makePersistent(address account0, address account1) external;\n    function makePersistent(address account0, address account1, address account2) external;\n    function makePersistent(address[] calldata accounts) external;\n    // Revokes persistent status from the address, previously added via `makePersistent`\n    function revokePersistent(address account) external;\n    function revokePersistent(address[] calldata accounts) external;\n    // Returns true if the account is marked as persistent\n    function isPersistent(address account) external view returns (bool persistent);\n    // In forking mode, explicitly grant the given address cheatcode access\n    function allowCheatcodes(address account) external;\n    // Fetches the given transaction from the active fork and executes it on the current state\n    function transact(bytes32 txHash) external;\n    // Fetches the given transaction from the given fork and executes it on the current state\n    function transact(uint256 forkId, bytes32 txHash) external;\n}\n"
    },
    "node_modules/forge-std/src/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "node_modules/forge-std/src/console2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n/// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should\n/// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n/// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n/// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n/// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, int256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,int256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "node_modules/forge-std/src/interfaces/IMulticall3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\ninterface IMulticall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    function aggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes[] memory returnData);\n\n    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function blockAndAggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n\n    function getBasefee() external view returns (uint256 basefee);\n\n    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);\n\n    function getBlockNumber() external view returns (uint256 blockNumber);\n\n    function getChainId() external view returns (uint256 chainid);\n\n    function getCurrentBlockCoinbase() external view returns (address coinbase);\n\n    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);\n\n    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);\n\n    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);\n\n    function getEthBalance(address addr) external view returns (uint256 balance);\n\n    function getLastBlockHash() external view returns (bytes32 blockHash);\n\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (Result[] memory returnData);\n\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@openzeppelin/=node_modules/@openzeppelin/",
      "@openzeppelin/contracts-upgradeable/=node_modules/@openzeppelin/contracts-upgradeable/",
      "@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/",
      "@rari-capital/=node_modules/@rari-capital/",
      "@rari-capital/solmate/=node_modules/@rari-capital/solmate/",
      "ds-test/=node_modules/ds-test/src/",
      "forge-std/=node_modules/forge-std/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "metadata": {
      "bytecodeHash": "none"
    },
    "outputSelection": {
      "*": {
        "": [
          "ast"
        ],
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}
