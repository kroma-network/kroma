{
  "language": "Solidity",
  "sources": {
    "contracts/L1/AssetManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC721Receiver } from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport { Uint128Math } from \"../libraries/Uint128Math.sol\";\nimport { ISemver } from \"../universal/ISemver.sol\";\nimport { IAssetManager } from \"./interfaces/IAssetManager.sol\";\nimport { IValidatorManager } from \"./interfaces/IValidatorManager.sol\";\n\n/**\n * @title AssetManager\n * @notice AssetManager is a contract that handles (un)delegations of KRO and KGH, and the\n *         distribution of rewards to the delegators and the validator.\n */\ncontract AssetManager is ISemver, IERC721Receiver, IAssetManager {\n    using SafeERC20 for IERC20;\n    using Uint128Math for uint128;\n\n    /**\n     * @notice The numerator of the tax.\n     */\n    uint128 public constant TAX_NUMERATOR = 20;\n\n    /**\n     * @notice The denominator of the tax.\n     */\n    uint128 public constant TAX_DENOMINATOR = 100;\n\n    /**\n     * @notice Decimals offset for the KRO shares.\n     */\n    uint128 public constant DECIMAL_OFFSET = 10 ** 6;\n\n    /**\n     * @notice Address of the KRO token contract.\n     */\n    IERC20 public immutable ASSET_TOKEN;\n\n    /**\n     * @notice Address of the KGH token contract.\n     */\n    IERC721 public immutable KGH;\n\n    /**\n     * @notice The address of the SecurityCouncil contract. Can be updated via upgrade.\n     */\n    address public immutable SECURITY_COUNCIL;\n\n    /**\n     * @notice The address of Validator Reward Vault. Can be updated via upgrade.\n     */\n    address public immutable VALIDATOR_REWARD_VAULT;\n\n    /**\n     * @notice Address of ValidatorManager contract. Can be updated via upgrade.\n     */\n    IValidatorManager public immutable VALIDATOR_MANAGER;\n\n    /**\n     * @notice Minimum delegation period. Can be updated via upgrade.\n     */\n    uint128 public immutable MIN_DELEGATION_PERIOD;\n\n    /**\n     * @notice The amount to bond.\n     */\n    uint128 public immutable BOND_AMOUNT;\n\n    /**\n     * @notice A mapping of validator address to the vault.\n     */\n    mapping(address => Vault) internal _vaults;\n\n    /**\n     * @notice Modifier to check if the caller is the ValidatorManager contract.\n     */\n    modifier onlyValidatorManager() {\n        if (msg.sender != address(VALIDATOR_MANAGER)) revert NotAllowedCaller();\n        _;\n    }\n\n    /**\n     * @notice Modifier to check if the validator is registered and not in jail.\n     */\n    modifier isRegistered(address validator) {\n        if (\n            VALIDATOR_MANAGER.getStatus(validator) < IValidatorManager.ValidatorStatus.REGISTERED ||\n            VALIDATOR_MANAGER.inJail(validator)\n        ) revert ImproperValidatorStatus();\n        _;\n    }\n\n    /**\n     * @notice Modifier to check if the caller is the withdraw account of the validator.\n     */\n    modifier onlyWithdrawAccount(address validator) {\n        if (msg.sender != _vaults[validator].withdrawAccount) revert NotAllowedCaller();\n        _;\n    }\n\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.0.0\n     */\n    string public constant version = \"1.0.0\";\n\n    /**\n     * @notice Constructs the AssetManager contract.\n     *\n     * @param _assetToken           Address of the KRO token.\n     * @param _kgh                  Address of the KGH token.\n     * @param _securityCouncil      Address of the SecurityCouncil contract.\n     * @param _validatorRewardVault Address of the Validator Reward Vault.\n     * @param _validatorManager     Address of the ValidatorManager contract.\n     * @param _minDelegationPeriod  Minimum delegation period.\n     * @param _bondAmount           Amount to bond.\n     */\n    constructor(\n        IERC20 _assetToken,\n        IERC721 _kgh,\n        address _securityCouncil,\n        address _validatorRewardVault,\n        IValidatorManager _validatorManager,\n        uint128 _minDelegationPeriod,\n        uint128 _bondAmount\n    ) {\n        ASSET_TOKEN = _assetToken;\n        KGH = _kgh;\n        SECURITY_COUNCIL = _securityCouncil;\n        VALIDATOR_REWARD_VAULT = _validatorRewardVault;\n        VALIDATOR_MANAGER = _validatorManager;\n        MIN_DELEGATION_PERIOD = _minDelegationPeriod;\n        BOND_AMOUNT = _bondAmount;\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function getKroTotalShareBalance(\n        address validator,\n        address delegator\n    ) external view returns (uint128) {\n        return _vaults[validator].kroDelegators[delegator].shares;\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function getKroAssets(address validator, address delegator) external view returns (uint128) {\n        return _convertToKroAssets(validator, _vaults[validator].kroDelegators[delegator].shares);\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function getKghNum(address validator, address delegator) external view returns (uint128) {\n        return _vaults[validator].kghDelegators[delegator].kghNum;\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function previewDelegate(address validator, uint128 assets) external view returns (uint128) {\n        return _convertToKroShares(validator, assets);\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function previewUndelegate(address validator, uint128 shares) external view returns (uint128) {\n        return _convertToKroAssets(validator, shares);\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function canUndelegateKroAt(\n        address validator,\n        address delegator\n    ) public view returns (uint128) {\n        return _vaults[validator].kroDelegators[delegator].lastDelegatedAt + MIN_DELEGATION_PERIOD;\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function canUndelegateKghAt(\n        address validator,\n        address delegator,\n        uint256 tokenId\n    ) public view returns (uint128) {\n        return\n            _vaults[validator].kghDelegators[delegator].delegatedAt[tokenId] +\n            MIN_DELEGATION_PERIOD;\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function canWithdrawAt(address validator) public view returns (uint128) {\n        return _vaults[validator].lastDepositedAt + MIN_DELEGATION_PERIOD;\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function getKghReward(address validator, address delegator) external view returns (uint128) {\n        Vault storage vault = _vaults[validator];\n        KghDelegator storage kghDelegator = vault.kghDelegators[delegator];\n\n        uint128 rewardPerKghStored = vault.asset.rewardPerKghStored;\n        uint128 totalBoostedReward = kghDelegator.kghNum *\n            (rewardPerKghStored - kghDelegator.rewardPerKghPaid);\n\n        return totalBoostedReward;\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function getWithdrawAccount(address validator) external view returns (address) {\n        return _vaults[validator].withdrawAccount;\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function totalKroAssets(address validator) public view returns (uint128) {\n        return _vaults[validator].asset.totalKro;\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function totalKghNum(address validator) external view returns (uint128) {\n        return _vaults[validator].asset.totalKgh;\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function totalValidatorKro(address validator) external view returns (uint128) {\n        return _vaults[validator].asset.validatorKro;\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function totalValidatorKroBonded(address validator) external view returns (uint128) {\n        return _vaults[validator].asset.validatorKroBonded;\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function totalValidatorKroNotBonded(address validator) external view returns (uint128) {\n        return _vaults[validator].asset.validatorKro - _vaults[validator].asset.validatorKroBonded;\n    }\n\n    /**\n     * @notice Returns the reflective weight of given validator.\n     *\n     * @param validator Address of the validator.\n     *\n     * @return The reflective weight of given validator.\n     */\n    function reflectiveWeight(address validator) external view returns (uint128) {\n        return _vaults[validator].asset.totalKro + _vaults[validator].asset.validatorKro;\n    }\n\n    /**\n     * @notice Deposit KRO to register as a validator. This function is only called by the\n     *         ValidatorManager contract.\n     *\n     * @param validator       Address of the validator.\n     * @param assets          The amount of KRO to deposit.\n     * @param withdrawAccount An account where assets can be withdrawn to. Only this account can\n     *                        withdraw the assets.\n     */\n    function depositToRegister(\n        address validator,\n        uint128 assets,\n        address withdrawAccount\n    ) external onlyValidatorManager {\n        if (withdrawAccount == address(0)) revert ZeroAddress();\n\n        _vaults[validator].withdrawAccount = withdrawAccount;\n        _deposit(validator, assets, false);\n        emit Deposited(validator, assets);\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function deposit(uint128 assets) external {\n        if (assets == 0) revert NotAllowedZeroInput();\n        if (VALIDATOR_MANAGER.getStatus(msg.sender) == IValidatorManager.ValidatorStatus.NONE)\n            revert ImproperValidatorStatus();\n\n        _deposit(msg.sender, assets, true);\n        emit Deposited(msg.sender, assets);\n\n        VALIDATOR_MANAGER.tryActivateValidator(msg.sender);\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function withdraw(address validator, uint128 assets) external onlyWithdrawAccount(validator) {\n        if (assets == 0) revert NotAllowedZeroInput();\n        if (canWithdrawAt(validator) > block.timestamp) {\n            revert NotElapsedMinDelegationPeriod();\n        }\n        if (VALIDATOR_MANAGER.jailExpiresAt(validator) > block.timestamp)\n            revert ImproperValidatorStatus();\n\n        _withdraw(validator, assets);\n\n        VALIDATOR_MANAGER.updateValidatorTree(validator, true);\n\n        ASSET_TOKEN.safeTransfer(_vaults[validator].withdrawAccount, assets);\n\n        emit Withdrawn(validator, assets);\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function delegate(\n        address validator,\n        uint128 assets\n    ) external isRegistered(validator) returns (uint128) {\n        if (assets == 0) revert NotAllowedZeroInput();\n\n        ASSET_TOKEN.safeTransferFrom(msg.sender, address(this), assets);\n        uint128 shares = _convertToKroShares(validator, assets);\n        _delegate(validator, msg.sender, assets, shares);\n        VALIDATOR_MANAGER.updateValidatorTree(validator, false);\n\n        emit KroDelegated(validator, msg.sender, assets, shares);\n        return shares;\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function delegateKgh(address validator, uint256 tokenId) external isRegistered(validator) {\n        // claim boosted reward\n        uint128 boostedReward = _claimBoostedReward(validator, msg.sender);\n        if (boostedReward > 0) {\n            ASSET_TOKEN.safeTransfer(msg.sender, boostedReward);\n            emit KghRewardClaimed(validator, msg.sender, boostedReward);\n        }\n\n        KGH.safeTransferFrom(msg.sender, address(this), tokenId);\n        _delegateKgh(validator, msg.sender, tokenId);\n\n        emit KghDelegated(validator, msg.sender, tokenId);\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function delegateKghBatch(\n        address validator,\n        uint256[] calldata tokenIds\n    ) external isRegistered(validator) {\n        if (tokenIds.length == 0) revert NotAllowedZeroInput();\n\n        // claim boosted reward\n        uint128 boostedReward = _claimBoostedReward(validator, msg.sender);\n        if (boostedReward > 0) {\n            ASSET_TOKEN.safeTransfer(msg.sender, boostedReward);\n            emit KghRewardClaimed(validator, msg.sender, boostedReward);\n        }\n\n        KghDelegator storage kghDelegator = _vaults[validator].kghDelegators[msg.sender];\n        for (uint256 i = 0; i < tokenIds.length; ) {\n            KGH.safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n            kghDelegator.delegatedAt[tokenIds[i]] = uint128(block.timestamp);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        _delegateKghBatch(validator, msg.sender, uint128(tokenIds.length));\n\n        emit KghBatchDelegated(validator, msg.sender, tokenIds);\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function undelegate(address validator, uint128 assets) external {\n        if (assets == 0) revert NotAllowedZeroInput();\n\n        uint128 shares = _convertToKroShares(validator, assets);\n        if (shares == 0) revert InsufficientShare();\n        if (shares > _vaults[validator].kroDelegators[msg.sender].shares)\n            revert InsufficientShare();\n\n        if (canUndelegateKroAt(validator, msg.sender) > block.timestamp)\n            revert NotElapsedMinDelegationPeriod();\n\n        _undelegate(validator, msg.sender, assets, shares);\n        VALIDATOR_MANAGER.updateValidatorTree(validator, true);\n        ASSET_TOKEN.safeTransfer(msg.sender, assets);\n\n        emit KroUndelegated(validator, msg.sender, assets, shares);\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function undelegateKgh(address validator, uint256 tokenId) external {\n        KghDelegator storage kghDelegator = _vaults[validator].kghDelegators[msg.sender];\n\n        if (kghDelegator.delegatedAt[tokenId] == 0) revert InvalidTokenIdsInput();\n        if (canUndelegateKghAt(validator, msg.sender, tokenId) > block.timestamp)\n            revert NotElapsedMinDelegationPeriod();\n\n        // boosted reward of KGH\n        uint128 boostedReward = _claimBoostedReward(validator, msg.sender);\n\n        // update storage\n        _undelegateKgh(validator, msg.sender, tokenId);\n\n        // transfer KGH\n        KGH.safeTransferFrom(address(this), msg.sender, tokenId);\n\n        // transfer KRO\n        if (boostedReward > 0) {\n            ASSET_TOKEN.safeTransfer(msg.sender, boostedReward);\n        }\n\n        emit KghUndelegated(validator, msg.sender, tokenId, boostedReward);\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function undelegateKghBatch(address validator, uint256[] calldata tokenIds) external {\n        if (tokenIds.length == 0) revert NotAllowedZeroInput();\n\n        KghDelegator storage kghDelegator = _vaults[validator].kghDelegators[msg.sender];\n\n        for (uint256 i = 0; i < tokenIds.length; ) {\n            if (kghDelegator.delegatedAt[tokenIds[i]] == 0) revert InvalidTokenIdsInput();\n            if (canUndelegateKghAt(validator, msg.sender, tokenIds[i]) > block.timestamp)\n                revert NotElapsedMinDelegationPeriod();\n\n            delete kghDelegator.delegatedAt[tokenIds[i]];\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // boosted reward of KGHs\n        uint128 boostedReward = _claimBoostedReward(validator, msg.sender);\n\n        // update storage\n        _undelegateKghBatch(validator, msg.sender, uint128(tokenIds.length));\n\n        // transfer KGHs\n        for (uint256 i = 0; i < tokenIds.length; ) {\n            KGH.safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // transfer KRO\n        if (boostedReward > 0) {\n            ASSET_TOKEN.safeTransfer(msg.sender, boostedReward);\n        }\n\n        emit KghBatchUndelegated(validator, msg.sender, tokenIds, boostedReward);\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function claimKghReward(address validator) external {\n        uint128 boostedReward = _claimBoostedReward(validator, msg.sender);\n        if (boostedReward == 0) revert InsufficientAsset();\n\n        ASSET_TOKEN.safeTransfer(msg.sender, boostedReward);\n\n        emit KghRewardClaimed(validator, msg.sender, boostedReward);\n    }\n\n    /**\n     * @notice Bond KRO from validator KRO during output submission or challenge creation. This\n     *         function is only called by the ValidatorManager contract.\n     *\n     * @param validator Address of the validator.\n     */\n    function bondValidatorKro(address validator) external onlyValidatorManager {\n        Asset storage asset = _vaults[validator].asset;\n        uint128 remainder = asset.validatorKro - asset.validatorKroBonded;\n        if (remainder < BOND_AMOUNT) revert InsufficientAsset();\n\n        unchecked {\n            asset.validatorKroBonded += BOND_AMOUNT;\n        }\n\n        emit ValidatorKroBonded(validator, BOND_AMOUNT, remainder - BOND_AMOUNT);\n    }\n\n    /**\n     * @notice Unbond KRO from validator KRO during output finalization or challenge slashing. This\n     *         function is only called by the ValidatorManager contract.\n     *\n     * @param validator Address of the validator.\n     */\n    function unbondValidatorKro(address validator) external onlyValidatorManager {\n        Asset storage asset = _vaults[validator].asset;\n\n        unchecked {\n            asset.validatorKroBonded -= BOND_AMOUNT;\n        }\n\n        emit ValidatorKroUnbonded(\n            validator,\n            BOND_AMOUNT,\n            asset.validatorKro - asset.validatorKroBonded\n        );\n    }\n\n    /**\n     * @notice Update the vault of validator with the distributed reward. This function is only\n     *         called by the ValidatorManager contract.\n     *\n     * @param validator       Address of the validator.\n     * @param baseReward      The base reward to distribute.\n     * @param boostedReward   The boosted reward to distribute.\n     * @param validatorReward The validator reward to distribute.\n     */\n    function increaseBalanceWithReward(\n        address validator,\n        uint128 baseReward,\n        uint128 boostedReward,\n        uint128 validatorReward\n    ) external onlyValidatorManager {\n        // Distribute the reward from a designated vault to the AssetManager contract.\n        ASSET_TOKEN.safeTransferFrom(\n            VALIDATOR_REWARD_VAULT,\n            address(this),\n            baseReward + boostedReward + validatorReward\n        );\n\n        // If reward is distributed to SECURITY_COUNCIL, transfer it directly.\n        if (validator == SECURITY_COUNCIL) {\n            ASSET_TOKEN.safeTransfer(\n                SECURITY_COUNCIL,\n                baseReward + boostedReward + validatorReward\n            );\n        } else {\n            Asset storage asset = _vaults[validator].asset;\n            unchecked {\n                asset.totalKro += baseReward;\n                asset.validatorKro += validatorReward;\n                if (asset.totalKgh != 0) {\n                    asset.rewardPerKghStored += boostedReward / asset.totalKgh;\n                }\n                asset.validatorKroBonded -= BOND_AMOUNT;\n            }\n\n            emit ValidatorKroUnbonded(\n                validator,\n                BOND_AMOUNT,\n                asset.validatorKro - asset.validatorKroBonded\n            );\n        }\n    }\n\n    /**\n     * @notice Update the vault of challenge winner with the challenge reward. This function is only\n     *         called by the ValidatorManager contract.\n     *\n     * @param winner          Address of the challenge winner.\n     * @param challengeReward The challenge reward to be added to the winner's asset after excluding\n     *                        tax.\n     *\n     * @return The challenge reward added to winner's asset.\n     */\n    function increaseBalanceWithChallenge(\n        address winner,\n        uint128 challengeReward\n    ) external onlyValidatorManager returns (uint128) {\n        Asset storage asset = _vaults[winner].asset;\n\n        // If challenge reward is distributed to SECURITY_COUNCIL, transfer it directly.\n        if (winner == SECURITY_COUNCIL) {\n            ASSET_TOKEN.safeTransfer(SECURITY_COUNCIL, challengeReward);\n            return challengeReward;\n        }\n\n        uint128 tax = challengeReward.mulDiv(TAX_NUMERATOR, TAX_DENOMINATOR);\n        ASSET_TOKEN.safeTransfer(SECURITY_COUNCIL, tax);\n\n        unchecked {\n            challengeReward -= tax;\n            asset.validatorKro += challengeReward;\n        }\n\n        return challengeReward;\n    }\n\n    /**\n     * @notice Update the vault of challenge loser with the challenge reward. This function is only\n     *         called by the ValidatorManager contract.\n     *\n     * @param loser Address of the challenge loser.\n     *\n     * @return The challenge reward slashed from loser's asset.\n     */\n    function decreaseBalanceWithChallenge(\n        address loser\n    ) external onlyValidatorManager returns (uint128) {\n        Asset storage asset = _vaults[loser].asset;\n\n        unchecked {\n            asset.validatorKroBonded -= BOND_AMOUNT;\n            asset.validatorKro -= BOND_AMOUNT;\n        }\n\n        return BOND_AMOUNT;\n    }\n\n    /**\n     * @notice Revert the changes of decreaseBalanceWithChallenge. This function is only called by\n     *         the ValidatorManager contract.\n     *\n     * @param loser Address of the challenge original loser.\n     *\n     * @return The challenge reward refunded to loser's asset.\n     */\n    function revertDecreaseBalanceWithChallenge(\n        address loser\n    ) external onlyValidatorManager returns (uint128) {\n        Asset storage asset = _vaults[loser].asset;\n\n        unchecked {\n            asset.validatorKroBonded += BOND_AMOUNT;\n            asset.validatorKro += BOND_AMOUNT;\n        }\n\n        return BOND_AMOUNT;\n    }\n\n    /**\n     * @notice Returns the total amount of KRO shares held by the vault.\n     *\n     * @param validator Address of the validator.\n     *\n     * @return The total amount of shares held by the validator vault.\n     */\n    function _totalKroShares(address validator) internal view returns (uint128) {\n        return _vaults[validator].asset.totalKroShares;\n    }\n\n    /**\n     * @notice Internal conversion function for KRO (from assets to shares).\n     *\n     * @param validator Address of the validator.\n     * @param assets    The amount of assets to convert to shares.\n     */\n    function _convertToKroShares(\n        address validator,\n        uint128 assets\n    ) internal view returns (uint128) {\n        return\n            assets.mulDiv(\n                _totalKroShares(validator) + DECIMAL_OFFSET,\n                totalKroAssets(validator) + 1\n            );\n    }\n\n    /**\n     * @notice Internal conversion function for KRO (from shares to assets).\n     *\n     * @param validator Address of the validator.\n     * @param shares    The amount of shares to convert to assets.\n     */\n    function _convertToKroAssets(\n        address validator,\n        uint128 shares\n    ) internal view returns (uint128) {\n        return\n            shares.mulDiv(\n                totalKroAssets(validator) + 1,\n                _totalKroShares(validator) + DECIMAL_OFFSET\n            );\n    }\n\n    /**\n     * @notice Internal function to deposit KRO by the validator.\n     *\n     * @param validator  Address of the validator.\n     * @param assets     The amount of KRO to deposit.\n     * @param updateTree Flag to update the validator tree.\n     */\n    function _deposit(address validator, uint128 assets, bool updateTree) internal {\n        Vault storage vault = _vaults[validator];\n        ASSET_TOKEN.safeTransferFrom(validator, address(this), assets);\n\n        unchecked {\n            vault.asset.validatorKro += assets;\n            vault.lastDepositedAt = uint128(block.timestamp);\n        }\n\n        if (updateTree) {\n            VALIDATOR_MANAGER.updateValidatorTree(validator, false);\n        }\n    }\n\n    /**\n     * @notice Internal function to withdraw KRO by the validator.\n     *\n     * @param validator Address of the validator.\n     * @param assets    The amount of KRO to withdraw.\n     */\n    function _withdraw(address validator, uint128 assets) internal {\n        Asset storage asset = _vaults[validator].asset;\n        if (assets > asset.validatorKro - asset.validatorKroBonded) revert InsufficientAsset();\n\n        unchecked {\n            asset.validatorKro -= assets;\n        }\n    }\n\n    /**\n     * @notice Internal function to delegate KRO to the validator.\n     *\n     * @param validator Address of the validator.\n     * @param delegator Address of the delegator.\n     * @param assets    The amount of KRO to delegate.\n     * @param shares    The amount of shares to delegate.\n     */\n    function _delegate(\n        address validator,\n        address delegator,\n        uint128 assets,\n        uint128 shares\n    ) internal {\n        Vault storage vault = _vaults[validator];\n\n        unchecked {\n            vault.asset.totalKro += assets;\n            vault.asset.totalKroShares += shares;\n            vault.kroDelegators[delegator].shares += shares;\n            vault.kroDelegators[delegator].lastDelegatedAt = uint128(block.timestamp);\n        }\n    }\n\n    /**\n     * @notice Internal function to delegate KGH to the validator.\n     *\n     * @param validator Address of the validator.\n     * @param delegator Address of the delegator.\n     * @param tokenId   Token Id of the KGH.\n     */\n    function _delegateKgh(address validator, address delegator, uint256 tokenId) internal {\n        Vault storage vault = _vaults[validator];\n        KghDelegator storage kghDelegator = vault.kghDelegators[delegator];\n\n        unchecked {\n            vault.asset.totalKgh += 1;\n\n            ++kghDelegator.kghNum;\n            kghDelegator.delegatedAt[tokenId] = uint128(block.timestamp);\n        }\n    }\n\n    /**\n     * @notice Internal function to delegate KGHs to the validator.\n     *\n     * @param validator Address of the validator.\n     * @param delegator Address of the delegator.\n     * @param kghCount  The number of KGHs to delegate.\n     */\n    function _delegateKghBatch(address validator, address delegator, uint128 kghCount) internal {\n        Vault storage vault = _vaults[validator];\n\n        unchecked {\n            // asset\n            vault.asset.totalKgh += kghCount;\n\n            // delegator\n            vault.kghDelegators[delegator].kghNum += kghCount;\n        }\n    }\n\n    /**\n     * @notice Internal function to undelegate KRO from the validator.\n     *\n     * @param validator Address of the validator.\n     * @param delegator Address of the delegator.\n     * @param assets    The amount of KRO to undelegate.\n     * @param shares    The amount of shares to undelegate.\n     */\n    function _undelegate(\n        address validator,\n        address delegator,\n        uint128 assets,\n        uint128 shares\n    ) internal {\n        Vault storage vault = _vaults[validator];\n\n        unchecked {\n            vault.asset.totalKroShares -= shares;\n            vault.asset.totalKro -= assets;\n            vault.kroDelegators[delegator].shares -= shares;\n        }\n    }\n\n    /**\n     * @notice Internal function to undelegate KGH from the validator.\n     *\n     * @param validator Address of the validator.\n     * @param delegator Address of the delegator.\n     * @param tokenId   Token Id of the KGH.\n     */\n    function _undelegateKgh(address validator, address delegator, uint256 tokenId) internal {\n        Vault storage vault = _vaults[validator];\n        KghDelegator storage kghDelegator = vault.kghDelegators[delegator];\n\n        unchecked {\n            // asset\n            vault.asset.totalKgh -= 1;\n\n            // delegator\n            kghDelegator.kghNum -= 1;\n            delete kghDelegator.delegatedAt[tokenId];\n        }\n    }\n\n    /**\n     * @notice Internal function to undelegate KGHs from the validator.\n     *\n     * @param validator Address of the validator.\n     * @param delegator Address of the delegator.\n     * @param kghCount  The number of KGH token to undelegate.\n     */\n    function _undelegateKghBatch(address validator, address delegator, uint128 kghCount) internal {\n        Vault storage vault = _vaults[validator];\n\n        unchecked {\n            // asset\n            vault.asset.totalKgh -= kghCount;\n\n            // delegator\n            vault.kghDelegators[delegator].kghNum -= kghCount;\n        }\n    }\n\n    /**\n     * @notice Internal function to claim the boosted reward of the delegator.\n     *\n     * @param validator Address of the validator.\n     * @param delegator Address of the delegator.\n     *\n     * @return The amount of the claimed boosted reward.\n     */\n    function _claimBoostedReward(address validator, address delegator) internal returns (uint128) {\n        Vault storage vault = _vaults[validator];\n        KghDelegator storage kghDelegator = vault.kghDelegators[delegator];\n\n        uint128 rewardPerKghStored = vault.asset.rewardPerKghStored;\n        uint128 totalBoostedReward = kghDelegator.kghNum *\n            (rewardPerKghStored - kghDelegator.rewardPerKghPaid);\n\n        kghDelegator.rewardPerKghPaid = rewardPerKghStored;\n\n        return totalBoostedReward;\n    }\n\n    /**\n     * @inheritdoc IERC721Receiver\n     */\n    function onERC721Received(\n        address /* operator */,\n        address /* from */,\n        uint256 /* tokenId */,\n        bytes calldata /* data */\n    ) external pure returns (bytes4) {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/L1/Colosseum.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { ISemver } from \"../universal/ISemver.sol\";\nimport { IZKMerkleTrie } from \"./interfaces/IZKMerkleTrie.sol\";\nimport { L2OutputOracle } from \"./L2OutputOracle.sol\";\nimport { SecurityCouncil } from \"./SecurityCouncil.sol\";\nimport { ZKVerifier } from \"./ZKVerifier.sol\";\n\ncontract Colosseum is Initializable, ISemver {\n    /**\n     * @notice The constant value for the first turn.\n     */\n    uint8 internal constant TURN_INIT = 1;\n\n    /**\n     * @notice The constant value for the delete output root.\n     */\n    bytes32 internal constant DELETED_OUTPUT_ROOT = bytes32(0);\n\n    /**\n     * @notice Enum of the challenge status.\n     *\n     * See the https://specs.kroma.network/fault-proof/challenge.html#state-diagram\n     * for more details.\n     *\n     * Belows are possible state transitions at current implementation.\n     *\n     *  1) NONE               → createChallenge()                   → ASSERTER_TURN\n     *  2) ASSERTER_TURN      → bisect()                            → CHALLENGER_TURN\n     *  3) ASSERTER_TURN      → on bisection timeout                → ASSERTER_TIMEOUT\n     *  4) CHALLENGER_TURN    → bisect()                            → ASSERTER_TURN\n     *  5) CHALLENGER_TURN    → when isAbleToBisect() returns false → READY_TO_PROVE\n     *  6) CHALLENGER_TURN    → on bisection timeout                → CHALLENGER_TIMEOUT\n     *  7) ASSERTER_TIMEOUT   → when proveFault() succeeds          → NONE\n     *  8) ASSERTER_TIMEOUT   → on proving timeout                  → CHALLENGER_TIMEOUT\n     *  9) READY_TO_PROVE     → when proveFault() succeeds          → NONE\n     * 10) READY_TO_PROVE     → on proving timeout                  → CHALLENGER_TIMEOUT\n     * 11) CHALLENGER_TIMEOUT → challengerTimeout()                 → NONE\n     */\n    enum ChallengeStatus {\n        NONE,\n        CHALLENGER_TURN,\n        ASSERTER_TURN,\n        CHALLENGER_TIMEOUT,\n        ASSERTER_TIMEOUT,\n        READY_TO_PROVE\n    }\n\n    /**\n     * @notice Address of the L2OutputOracle.\n     */\n    L2OutputOracle public immutable L2_ORACLE;\n\n    /**\n     * @notice Address of the ZKVerifier.\n     */\n    ZKVerifier public immutable ZK_VERIFIER;\n\n    /**\n     * @notice The period seconds for which challenges can be created per each output.\n     */\n    uint256 public immutable CREATION_PERIOD_SECONDS;\n\n    /**\n     * @notice Timeout seconds for the bisection.\n     */\n    uint256 public immutable BISECTION_TIMEOUT;\n\n    /**\n     * @notice Timeout seconds for the proving.\n     */\n    uint256 public immutable PROVING_TIMEOUT;\n\n    /**\n     * @notice The interval in L2 blocks at which checkpoints must be\n     *         submitted on L2OutputOracle contract.\n     */\n    uint256 public immutable L2_ORACLE_SUBMISSION_INTERVAL;\n\n    /**\n     * @notice The dummy transaction hash. This is used to pad if the\n     *         number of transactions is less than MAX_TXS. This is same as:\n     *         unsignedTx = {\n     *           nonce: 0,\n     *           gasLimit: 0,\n     *           gasPrice: 0,\n     *           to: address(0),\n     *           value: 0,\n     *           data: '0x',\n     *           chainId: CHAIN_ID,\n     *         }\n     *         signature = sign(unsignedTx, 0x1)\n     *         dummyHash = keccak256(rlp({\n     *           ...unsignedTx,\n     *           signature,\n     *         }))\n     */\n    bytes32 public immutable DUMMY_HASH;\n\n    /**\n     * @notice The maximum number of transactions\n     */\n    uint256 public immutable MAX_TXS;\n\n    /**\n     * @notice Address that has the ability to approve the challenge.\n     */\n    address public immutable SECURITY_COUNCIL;\n\n    /**\n     * @notice Address that has the ability to verify the merkle proof.\n     */\n    address public immutable ZK_MERKLE_TRIE;\n\n    /**\n     * @notice Length of segment array for each turn.\n     */\n    mapping(uint256 => uint256) public segmentsLengths;\n\n    /**\n     * @notice A mapping of the challenge.\n     */\n    mapping(uint256 => mapping(address => Types.Challenge)) public challenges;\n\n    /**\n     * @notice A mapping indicating whether a public input is verified or not.\n     */\n    mapping(bytes32 => bool) public verifiedPublicInputs;\n\n    /**\n     * @notice A mapping of deleted output index to the deleted output.\n     */\n    mapping(uint256 => Types.CheckpointOutput) public deletedOutputs;\n\n    /**\n     * @notice Emitted when the challenge is created.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param asserter    Address of the asserter.\n     * @param challenger  Address of the challenger.\n     * @param timestamp   The timestamp when created.\n     */\n    event ChallengeCreated(\n        uint256 indexed outputIndex,\n        address indexed asserter,\n        address indexed challenger,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Emitted when segments are bisected.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param challenger  Address of the challenger.\n     * @param turn        The current turn.\n     * @param timestamp   The timestamp when bisected.\n     */\n    event Bisected(\n        uint256 indexed outputIndex,\n        address indexed challenger,\n        uint8 turn,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Emitted when it is ready to be proved.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param challenger  Address of the challenger.\n     */\n    event ReadyToProve(uint256 indexed outputIndex, address indexed challenger);\n\n    /**\n     * @notice Emitted when proven fault.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param challenger  Address of the challenger.\n     * @param timestamp   The timestamp when proven.\n     */\n    event Proven(uint256 indexed outputIndex, address indexed challenger, uint256 timestamp);\n\n    /**\n     * @notice Emitted when challenge is dismissed.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param challenger  Address of the challenger.\n     * @param timestamp   The timestamp when dismissed.\n     */\n    event ChallengeDismissed(\n        uint256 indexed outputIndex,\n        address indexed challenger,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Emitted when challenge is deleted forcefully.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param asseter     Address of the asseter.\n     * @param timestamp   The timestamp when output deleted.\n     */\n    event OutputForceDeleted(\n        uint256 indexed outputIndex,\n        address indexed asseter,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Emitted when challenge is canceled.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param challenger  Address of the challenger.\n     * @param timestamp   The timestamp when canceled.\n     */\n    event ChallengeCanceled(\n        uint256 indexed outputIndex,\n        address indexed challenger,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Emitted when challenger timed out.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param challenger  Address of the challenger.\n     * @param timestamp   The timestamp when deleted.\n     */\n    event ChallengerTimedOut(\n        uint256 indexed outputIndex,\n        address indexed challenger,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Reverts when caller is not allowed.\n     */\n    error NotAllowedCaller();\n\n    /**\n     * @notice Reverts when a non-challenger calls cancel challenge.\n     */\n    error OnlyChallengerCanCancel();\n\n    /**\n     * @notice Reverts when output is already finalized.\n     */\n    error OutputAlreadyFinalized();\n\n    /**\n     * @notice Reverts when output is already deleted.\n     */\n    error OutputAlreadyDeleted();\n\n    /**\n     * @notice Reverts when the status of validator is improper.\n     */\n    error ImproperValidatorStatus();\n\n    /**\n     * @notice Reverts when output is not deleted.\n     */\n    error OutputNotDeleted();\n\n    /**\n     * @notice Reverts when given output is invalid.\n     */\n    error InvalidOutputGiven();\n\n    /**\n     * @notice Reverts when given address is invalid.\n     */\n    error InvalidAddressGiven();\n\n    /**\n     * @notice Reverts when output is genesis output.\n     */\n    error NotAllowedGenesisOutput();\n\n    /**\n     * @notice Reverts when the status of challenge is improper.\n     */\n    error ImproperChallengeStatus();\n\n    /**\n     * @notice Reverts when the status of challenge is improper to cancel challenge.\n     */\n    error ImproperChallengeStatusToCancel();\n\n    /**\n     * @notice Reverts when the creation period is already passed.\n     */\n    error CreationPeriodPassed();\n\n    /**\n     * @notice Reverts when L1 is reorged.\n     */\n    error L1Reorged();\n\n    /**\n     * @notice Reverts when the public input is invalid.\n     */\n    error InvalidPublicInput();\n\n    /**\n     * @notice Reverts when the ZK proof is invalid.\n     */\n    error InvalidZKProof();\n\n    /**\n     * @notice Reverts when the inclusion proof is invalid.\n     */\n    error InvalidInclusionProof();\n\n    /**\n     * @notice Reverts when segments length is invalid.\n     */\n    error InvalidSegmentsLength();\n\n    /**\n     * @notice Reverts when the first segment is mismatched.\n     */\n    error FirstSegmentMismatched();\n\n    /**\n     * @notice Reverts when the last segment is matched.\n     */\n    error LastSegmentMatched();\n\n    /**\n     * @notice Reverts when the block hash is mismatched between source and destination output root\n     *         proof.\n     */\n    error BlockHashMismatchedBtwSrcAndDst();\n\n    /**\n     * @notice Reverts when the block hash is mismatched.\n     */\n    error BlockHashMismatched();\n\n    /**\n     * @notice Reverts when the state root is mismatched.\n     */\n    error StateRootMismatched();\n\n    /**\n     * @notice Reverts when turn is invalid.\n     */\n    error InvalidTurn();\n\n    /**\n     * @notice Reverts when challenge cannot be cancelled.\n     */\n    error CannotCancelChallenge();\n\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.1.0\n     */\n    string public constant version = \"1.1.0\";\n\n    /**\n     * @notice Constructs the Colosseum contract.\n     *\n     * @param _l2Oracle              Address of the L2OutputOracle contract.\n     * @param _zkVerifier            Address of the ZKVerifier contract.\n     * @param _submissionInterval    Interval in blocks at which checkpoints must be submitted.\n     * @param _creationPeriodSeconds Seconds The period seconds for which challenges can be created per each output.\n     * @param _bisectionTimeout      Timeout seconds for the bisection.\n     * @param _provingTimeout        Timeout seconds for the proving.\n     * @param _dummyHash             Dummy hash.\n     * @param _maxTxs                Number of max transactions per block.\n     * @param _segmentsLengths       Lengths of segments.\n     * @param _securityCouncil       Address of security council.\n     * @param _zkMerkleTrie          Address of zk merkle trie.\n     */\n    constructor(\n        L2OutputOracle _l2Oracle,\n        ZKVerifier _zkVerifier,\n        uint256 _submissionInterval,\n        uint256 _creationPeriodSeconds,\n        uint256 _bisectionTimeout,\n        uint256 _provingTimeout,\n        bytes32 _dummyHash,\n        uint256 _maxTxs,\n        uint256[] memory _segmentsLengths,\n        address _securityCouncil,\n        address _zkMerkleTrie\n    ) {\n        L2_ORACLE = _l2Oracle;\n        ZK_VERIFIER = _zkVerifier;\n        CREATION_PERIOD_SECONDS = _creationPeriodSeconds;\n        BISECTION_TIMEOUT = _bisectionTimeout;\n        PROVING_TIMEOUT = _provingTimeout;\n        L2_ORACLE_SUBMISSION_INTERVAL = _submissionInterval;\n        DUMMY_HASH = _dummyHash;\n        MAX_TXS = _maxTxs;\n        SECURITY_COUNCIL = _securityCouncil;\n        ZK_MERKLE_TRIE = _zkMerkleTrie;\n        initialize(_segmentsLengths);\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize(uint256[] memory _segmentsLengths) public initializer {\n        // _segmentsLengths length should be an even number in order to let challenger submit\n        // invalidity proof at the last turn.\n        if (_segmentsLengths.length % 2 != 0) revert InvalidSegmentsLength();\n\n        uint256 sum = 1;\n        for (uint256 i = 0; i < _segmentsLengths.length; ) {\n            segmentsLengths[i] = _segmentsLengths[i];\n            sum = sum * (_segmentsLengths[i] - 1);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (sum != L2_ORACLE_SUBMISSION_INTERVAL) revert InvalidSegmentsLength();\n    }\n\n    /**\n     * @notice Creates a challenge against an invalid output.\n     *\n     * @param _outputIndex   Index of the invalid L2 checkpoint output.\n     * @param _l1BlockHash   The block hash of L1 at the time the output L2 block was created.\n     * @param _l1BlockNumber The block number of L1 with the specified L1 block hash.\n     * @param _segments      Array of the segment. A segment is the first output root of a specific range.\n     */\n    function createChallenge(\n        uint256 _outputIndex,\n        bytes32 _l1BlockHash,\n        uint256 _l1BlockNumber,\n        bytes32[] calldata _segments\n    ) external {\n        if (_outputIndex == 0) revert NotAllowedGenesisOutput();\n\n        // Switch validator system after validator pool contract terminated.\n        if (L2_ORACLE.VALIDATOR_POOL().isTerminated(_outputIndex)) {\n            // Only the validators whose status is active can create challenge.\n            if (!L2_ORACLE.VALIDATOR_MANAGER().isActive(msg.sender))\n                revert ImproperValidatorStatus();\n        }\n\n        Types.Challenge storage challenge = challenges[_outputIndex][msg.sender];\n\n        if (challenge.turn >= TURN_INIT) {\n            if (_challengeStatus(challenge) != ChallengeStatus.CHALLENGER_TIMEOUT)\n                revert ImproperChallengeStatus();\n\n            _challengerTimeout(_outputIndex, msg.sender);\n        }\n\n        Types.CheckpointOutput memory targetOutput = L2_ORACLE.getL2Output(_outputIndex);\n\n        if (targetOutput.timestamp + CREATION_PERIOD_SECONDS < block.timestamp)\n            revert CreationPeriodPassed();\n\n        if (targetOutput.outputRoot == DELETED_OUTPUT_ROOT) revert OutputAlreadyDeleted();\n\n        if (msg.sender == targetOutput.submitter) revert NotAllowedCaller();\n\n        if (_l1BlockHash != bytes32(0) && blockhash(_l1BlockNumber) != bytes32(0)) {\n            // Like L2OutputOracle, it reverts transactions when L1 reorged.\n            if (blockhash(_l1BlockNumber) != _l1BlockHash) revert L1Reorged();\n        }\n\n        Types.CheckpointOutput memory prevOutput = L2_ORACLE.getL2Output(_outputIndex - 1);\n\n        // If the previous output has been deleted, the first segment will not be compared with the previous output.\n        if (prevOutput.outputRoot == DELETED_OUTPUT_ROOT) {\n            _validateSegments(TURN_INIT, _segments[0], targetOutput.outputRoot, _segments);\n        } else {\n            _validateSegments(TURN_INIT, prevOutput.outputRoot, targetOutput.outputRoot, _segments);\n        }\n\n        // Switch validator system after validator pool contract terminated.\n        if (L2_ORACLE.VALIDATOR_POOL().isTerminated(_outputIndex)) {\n            // Bond validator KRO to reserve slashing amount.\n            L2_ORACLE.VALIDATOR_MANAGER().bondValidatorKro(msg.sender);\n        } else {\n            L2_ORACLE.VALIDATOR_POOL().addPendingBond(_outputIndex, msg.sender);\n        }\n\n        _updateSegments(\n            challenge,\n            _segments,\n            targetOutput.l2BlockNumber - L2_ORACLE_SUBMISSION_INTERVAL,\n            L2_ORACLE_SUBMISSION_INTERVAL\n        );\n        challenge.turn = TURN_INIT;\n        challenge.asserter = targetOutput.submitter;\n        challenge.challenger = msg.sender;\n        _updateTimeout(challenge);\n\n        emit ChallengeCreated(_outputIndex, targetOutput.submitter, msg.sender, block.timestamp);\n    }\n\n    /**\n     * @notice Selects an invalid section and submit segments of that section.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _challenger  Address of the challenger.\n     * @param _pos         Position of the last valid segment.\n     * @param _segments    Array of the segment. A segment is the first output root of a specific range.\n     */\n    function bisect(\n        uint256 _outputIndex,\n        address _challenger,\n        uint256 _pos,\n        bytes32[] calldata _segments\n    ) external {\n        _checkOutputNotFinalized(_outputIndex);\n\n        Types.Challenge storage challenge = challenges[_outputIndex][_challenger];\n        ChallengeStatus status = _challengeStatus(challenge);\n\n        if (_cancelIfOutputDeleted(_outputIndex, challenge.challenger, status)) {\n            return;\n        }\n\n        address expectedSender;\n        if (status == ChallengeStatus.CHALLENGER_TURN) {\n            expectedSender = challenge.challenger;\n        } else if (status == ChallengeStatus.ASSERTER_TURN) {\n            expectedSender = challenge.asserter;\n        }\n        if (msg.sender != expectedSender) revert NotAllowedCaller();\n\n        uint8 newTurn = challenge.turn + 1;\n\n        _validateSegments(\n            newTurn,\n            challenge.segments[_pos],\n            challenge.segments[_pos + 1],\n            _segments\n        );\n\n        uint256 segSize = _nextSegSize(challenge);\n        _updateSegments(challenge, _segments, challenge.segStart + _pos * segSize, segSize);\n\n        challenge.turn = newTurn;\n        _updateTimeout(challenge);\n\n        emit Bisected(_outputIndex, _challenger, newTurn, block.timestamp);\n\n        if (!_isAbleToBisect(challenge)) {\n            emit ReadyToProve(_outputIndex, _challenger);\n        }\n    }\n\n    /**\n     * @notice Proves that a specific output is invalid using ZKP.\n     *         This function can only be called in the READY_TO_PROVE and ASSERTER_TIMEOUT states.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _pos         Position of the last valid segment.\n     * @param _proof       Proof for public input validation.\n     * @param _zkproof     Halo2 proofs composed of points and scalars.\n     *                     See https://zcash.github.io/halo2/design/implementation/proofs.html.\n     * @param _pair        Aggregated multi-opening proofs and public inputs. (Currently only 2 public inputs)\n     */\n    function proveFault(\n        uint256 _outputIndex,\n        uint256 _pos,\n        Types.PublicInputProof calldata _proof,\n        uint256[] calldata _zkproof,\n        uint256[] calldata _pair\n    ) external {\n        _checkOutputNotFinalized(_outputIndex);\n\n        Types.Challenge storage challenge = challenges[_outputIndex][msg.sender];\n        ChallengeStatus status = _challengeStatus(challenge);\n\n        if (_cancelIfOutputDeleted(_outputIndex, challenge.challenger, status)) {\n            return;\n        }\n\n        if (status != ChallengeStatus.READY_TO_PROVE && status != ChallengeStatus.ASSERTER_TIMEOUT)\n            revert ImproperChallengeStatus();\n\n        _validateOutputRootProof(\n            _pos,\n            challenge,\n            Hashing.hashOutputRootProof(_proof.srcOutputRootProof),\n            Hashing.hashOutputRootProof(_proof.dstOutputRootProof),\n            _proof.srcOutputRootProof,\n            _proof.dstOutputRootProof\n        );\n        _validatePublicInput(\n            _proof.srcOutputRootProof,\n            _proof.dstOutputRootProof,\n            _proof.publicInput,\n            _proof.rlps\n        );\n        _validateWithdrawalStorageRoot(\n            _proof.merkleProof,\n            _proof.l2ToL1MessagePasserBalance,\n            _proof.l2ToL1MessagePasserCodeHash,\n            _proof.dstOutputRootProof.messagePasserStorageRoot,\n            _proof.dstOutputRootProof.stateRoot\n        );\n\n        bytes32 publicInputHash = _hashPublicInput(\n            _proof.srcOutputRootProof.stateRoot,\n            _proof.publicInput\n        );\n\n        if (verifiedPublicInputs[publicInputHash]) revert InvalidPublicInput();\n\n        if (!ZK_VERIFIER.verify(_zkproof, _pair, publicInputHash)) revert InvalidZKProof();\n        emit Proven(_outputIndex, msg.sender, block.timestamp);\n\n        // Scope to call the security council, to avoid stack too deep.\n        {\n            Types.CheckpointOutput memory output = L2_ORACLE.getL2Output(_outputIndex);\n\n            bytes memory callbackData = abi.encodeWithSelector(\n                this.dismissChallenge.selector,\n                _outputIndex,\n                msg.sender,\n                challenge.asserter,\n                output.outputRoot,\n                publicInputHash\n            );\n\n            // Request outputRoot validation to security council\n            SecurityCouncil(SECURITY_COUNCIL).requestValidation(\n                output.outputRoot,\n                output.l2BlockNumber,\n                callbackData\n            );\n\n            deletedOutputs[_outputIndex] = output;\n        }\n\n        // Switch validator system after validator pool contract terminated.\n        if (L2_ORACLE.VALIDATOR_POOL().isTerminated(_outputIndex)) {\n            // Slash the asseter's asset and move it to pending challenge reward for the output.\n            L2_ORACLE.VALIDATOR_MANAGER().slash(_outputIndex, msg.sender, challenge.asserter);\n        } else {\n            // The challenger's bond is also included in the bond for that output.\n            L2_ORACLE.VALIDATOR_POOL().increaseBond(_outputIndex, msg.sender);\n        }\n\n        verifiedPublicInputs[publicInputHash] = true;\n        delete challenges[_outputIndex][msg.sender];\n\n        // Delete output root.\n        L2_ORACLE.replaceL2Output(_outputIndex, DELETED_OUTPUT_ROOT, msg.sender);\n    }\n\n    /**\n     * @notice Calls a private function that deletes the challenge because the challenger has timed out.\n     *         Reverts if the challenger hasn't timed out.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _challenger  Address of the challenger.\n     */\n    function challengerTimeout(uint256 _outputIndex, address _challenger) external {\n        if (\n            _challengeStatus(challenges[_outputIndex][_challenger]) !=\n            ChallengeStatus.CHALLENGER_TIMEOUT\n        ) revert ImproperChallengeStatus();\n\n        _challengerTimeout(_outputIndex, _challenger);\n    }\n\n    /**\n     * @notice Cancels the challenge.\n     *         Reverts if is not possible to cancel the sender's challenge for the given output index.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     */\n    function cancelChallenge(uint256 _outputIndex) external {\n        Types.Challenge storage challenge = challenges[_outputIndex][msg.sender];\n\n        if (\n            !_cancelIfOutputDeleted(_outputIndex, challenge.challenger, _challengeStatus(challenge))\n        ) revert CannotCancelChallenge();\n    }\n\n    /**\n     * @notice Dismisses the challenge and rollback l2 output.\n     *         This function can only be called by Security Council contract.\n     *\n     * @param _outputIndex      Index of the L2 checkpoint output.\n     * @param _challenger       Address of the challenger.\n     * @param _asserter         Address of the asserter.\n     * @param _outputRoot       The L2 output root to rollback.\n     * @param _publicInputHash  Hash of public input.\n     */\n    function dismissChallenge(\n        uint256 _outputIndex,\n        address _challenger,\n        address _asserter,\n        bytes32 _outputRoot,\n        bytes32 _publicInputHash\n    ) external {\n        _checkSecurityCouncil();\n        _checkOutputNotFinalized(_outputIndex);\n\n        if (L2_ORACLE.getL2Output(_outputIndex).outputRoot != DELETED_OUTPUT_ROOT)\n            revert OutputNotDeleted();\n        if (_outputRoot != deletedOutputs[_outputIndex].outputRoot) revert InvalidOutputGiven();\n        if (\n            _challenger != L2_ORACLE.getSubmitter(_outputIndex) ||\n            _asserter != deletedOutputs[_outputIndex].submitter\n        ) revert InvalidAddressGiven();\n        if (!verifiedPublicInputs[_publicInputHash]) revert InvalidPublicInput();\n\n        verifiedPublicInputs[_publicInputHash] = false;\n        delete deletedOutputs[_outputIndex];\n\n        // Rollback output root.\n        L2_ORACLE.replaceL2Output(_outputIndex, _outputRoot, _asserter);\n\n        // Switch validator system after validator pool contract terminated.\n        if (L2_ORACLE.VALIDATOR_POOL().isTerminated(_outputIndex)) {\n            // Revert slash asserter.\n            L2_ORACLE.VALIDATOR_MANAGER().revertSlash(_outputIndex, _asserter);\n            // Slash challenger.\n            L2_ORACLE.VALIDATOR_MANAGER().slash(_outputIndex, _asserter, _challenger);\n        }\n\n        emit ChallengeDismissed(_outputIndex, _challenger, block.timestamp);\n    }\n\n    /**\n     * @notice Deletes the L2 output root forcefully by the Security Council\n     *         when zk-proving is not possible due to an undeniable bug.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     */\n    function forceDeleteOutput(uint256 _outputIndex) external {\n        _checkSecurityCouncil();\n        _checkOutputNotFinalized(_outputIndex);\n\n        // Check if the output is deleted.\n        Types.CheckpointOutput memory output = L2_ORACLE.getL2Output(_outputIndex);\n        if (output.outputRoot == DELETED_OUTPUT_ROOT) revert OutputAlreadyDeleted();\n\n        // Delete output root.\n        L2_ORACLE.replaceL2Output(_outputIndex, DELETED_OUTPUT_ROOT, SECURITY_COUNCIL);\n\n        // Switch validator system after validator pool contract terminated.\n        if (L2_ORACLE.VALIDATOR_POOL().isTerminated(_outputIndex)) {\n            // Slash the asserter's asset and move it to pending challenge reward for the output.\n            L2_ORACLE.VALIDATOR_MANAGER().slash(_outputIndex, SECURITY_COUNCIL, output.submitter);\n        }\n\n        emit OutputForceDeleted(_outputIndex, output.submitter, block.timestamp);\n    }\n\n    /**\n     * @notice Reverts if the caller is not security council.\n     */\n    function _checkSecurityCouncil() internal view {\n        if (msg.sender != SECURITY_COUNCIL) revert NotAllowedCaller();\n    }\n\n    /**\n     * @notice Reverts if the output of given index is already finalized.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     */\n    function _checkOutputNotFinalized(uint256 _outputIndex) internal view {\n        if (L2_ORACLE.isFinalized(_outputIndex)) revert OutputAlreadyFinalized();\n    }\n\n    /**\n     * @notice Reverts if the given segments are invalid.\n     *\n     * @param _turn      The current turn.\n     * @param _prevFirst The first segment of previous turn.\n     * @param _prevLast  The last segment of previous turn.\n     * @param _segments  Array of the segment.\n     */\n    function _validateSegments(\n        uint8 _turn,\n        bytes32 _prevFirst,\n        bytes32 _prevLast,\n        bytes32[] memory _segments\n    ) internal view {\n        if (segmentsLengths[_turn - 1] != _segments.length) revert InvalidSegmentsLength();\n        if (_prevFirst != _segments[0]) revert FirstSegmentMismatched();\n        if (_prevLast == _segments[_segments.length - 1]) revert LastSegmentMatched();\n    }\n\n    /**\n     * @notice Updates the segment information for a given challenge.\n     *\n     * @param _challenge The challenge data.\n     * @param _segments  Array of the segment.\n     * @param _segStart  The L2 block number of the first segment.\n     * @param _segSize   The number of L2 blocks.\n     */\n    function _updateSegments(\n        Types.Challenge storage _challenge,\n        bytes32[] memory _segments,\n        uint256 _segStart,\n        uint256 _segSize\n    ) private {\n        _challenge.segments = _segments;\n        _challenge.segStart = _segStart;\n        _challenge.segSize = _segSize;\n    }\n\n    /**\n     * @notice Updates timestamp of the challenge timeout.\n     *\n     * @param _challenge The challenge data to update.\n     */\n    function _updateTimeout(Types.Challenge storage _challenge) private {\n        if (!_isAbleToBisect(_challenge)) {\n            _challenge.timeoutAt = uint64(block.timestamp + PROVING_TIMEOUT);\n        } else {\n            _challenge.timeoutAt = uint64(block.timestamp + BISECTION_TIMEOUT);\n        }\n    }\n\n    /**\n     * @notice Checks if the L2ToL1MesagePasser account is included in the given state root.\n     *\n     * @param _merkleProof                 Merkle proof of L2ToL1MessagePasser account against the state root.\n     * @param _l2ToL1MessagePasserBalance  Balance of the L2ToL1MessagePasser account.\n     * @param _l2ToL1MessagePasserCodeHash Codehash of the L2ToL1MessagePasser account.\n     * @param _messagePasserStorageRoot    Storage root of the L2ToL1MessagePasser account.\n     * @param _stateRoot                   State root.\n     */\n    function _validateWithdrawalStorageRoot(\n        bytes[] calldata _merkleProof,\n        bytes32 _l2ToL1MessagePasserBalance,\n        bytes32 _l2ToL1MessagePasserCodeHash,\n        bytes32 _messagePasserStorageRoot,\n        bytes32 _stateRoot\n    ) internal view {\n        // TODO(chokobole): Can we fix the codeHash?\n        bytes memory l2ToL1MessagePasserAccount = abi.encodePacked(\n            uint256(0), // nonce\n            _l2ToL1MessagePasserBalance, // balance,\n            _l2ToL1MessagePasserCodeHash, // codeHash,\n            _messagePasserStorageRoot // storage root\n        );\n\n        if (\n            !IZKMerkleTrie(ZK_MERKLE_TRIE).verifyInclusionProof(\n                bytes32(bytes20(Predeploys.L2_TO_L1_MESSAGE_PASSER)),\n                l2ToL1MessagePasserAccount,\n                _merkleProof,\n                _stateRoot\n            )\n        ) revert InvalidInclusionProof();\n    }\n\n    /**\n     * @notice Validates the output root proofs.\n     *\n     * @param _pos                Position of the last valid segment.\n     * @param _challenge          The challenge data.\n     * @param _srcOutputRoot      The source output root.\n     * @param _dstOutputRoot      The destination output root.\n     * @param _srcOutputRootProof Proof of the source output root.\n     * @param _dstOutputRootProof Proof of the destination output root.\n     */\n    function _validateOutputRootProof(\n        uint256 _pos,\n        Types.Challenge storage _challenge,\n        bytes32 _srcOutputRoot,\n        bytes32 _dstOutputRoot,\n        Types.OutputRootProof calldata _srcOutputRootProof,\n        Types.OutputRootProof calldata _dstOutputRootProof\n    ) internal view {\n        if (_challenge.segments[_pos] != _srcOutputRoot) revert FirstSegmentMismatched();\n\n        // If asserter timeout, the bisection of segments may not have ended.\n        // Therefore, segment validation only proceeds when bisection is not possible.\n        if (!_isAbleToBisect(_challenge)) {\n            if (_challenge.segments[_pos + 1] == _dstOutputRoot) revert LastSegmentMatched();\n        }\n\n        if (_srcOutputRootProof.nextBlockHash != _dstOutputRootProof.blockHash)\n            revert BlockHashMismatchedBtwSrcAndDst();\n    }\n\n    /**\n     * @notice Checks if the public input is valid.\n     *         Reverts if public input is invalid.\n     *\n     * @param _srcOutputRootProof Proof of the source output root.\n     * @param _dstOutputRootProof Proof of the destination output root.\n     * @param _publicInput        Ingredients to compute the public input used by ZK proof verification.\n     * @param _rlps               Pre-encoded RLPs to compute the next block hash of the source output root proof.\n     */\n    function _validatePublicInput(\n        Types.OutputRootProof calldata _srcOutputRootProof,\n        Types.OutputRootProof calldata _dstOutputRootProof,\n        Types.PublicInput calldata _publicInput,\n        Types.BlockHeaderRLP calldata _rlps\n    ) internal pure {\n        // TODO(chokobole): check withdrawal storage root of _dstOutputRootProof against state root of _dstOutputRootProof.\n        if (_publicInput.stateRoot != _dstOutputRootProof.stateRoot) revert StateRootMismatched();\n\n        // parentBeaconRoot is non-zero for Cancun block\n        bytes32 blockHash = _publicInput.parentBeaconRoot != bytes32(0)\n            ? Hashing.hashBlockHeaderCancun(_publicInput, _rlps)\n            : Hashing.hashBlockHeaderShanghai(_publicInput, _rlps);\n\n        if (_srcOutputRootProof.nextBlockHash != blockHash) revert BlockHashMismatched();\n    }\n\n    /**\n     * @notice Cancels the challenge if the output root to be challenged has already been deleted.\n     *         If the output root has been deleted, delete the challenge. Note that before validator\n     *         system upgrade, also refund the challenger's pending bond in validator pool.\n     *         Reverts when challenger is timed out or called by non-challenger.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _challenger  Address of the challenger.\n     * @param _status      Current status of the challenge.\n     *\n     * @return Whether the challenge was canceled.\n     */\n    function _cancelIfOutputDeleted(\n        uint256 _outputIndex,\n        address _challenger,\n        ChallengeStatus _status\n    ) private returns (bool) {\n        if (L2_ORACLE.getL2Output(_outputIndex).outputRoot != DELETED_OUTPUT_ROOT) {\n            return false;\n        }\n\n        // If the output is deleted, the asserter does not need to do anything further.\n        if (msg.sender != _challenger) revert OnlyChallengerCanCancel();\n\n        if (_status == ChallengeStatus.NONE || _status == ChallengeStatus.CHALLENGER_TIMEOUT)\n            revert ImproperChallengeStatusToCancel();\n\n        delete challenges[_outputIndex][msg.sender];\n        emit ChallengeCanceled(_outputIndex, msg.sender, block.timestamp);\n\n        // Switch validator system after validator pool contract terminated.\n        if (L2_ORACLE.VALIDATOR_POOL().isTerminated(_outputIndex)) {\n            L2_ORACLE.VALIDATOR_MANAGER().unbondValidatorKro(msg.sender);\n        } else {\n            L2_ORACLE.VALIDATOR_POOL().releasePendingBond(_outputIndex, msg.sender, msg.sender);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Deletes the challenge because the challenger timed out.\n     *         The winner is the asserter, and challenger loses their asset.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _challenger  Address of the challenger.\n     */\n    function _challengerTimeout(uint256 _outputIndex, address _challenger) private {\n        delete challenges[_outputIndex][_challenger];\n        emit ChallengerTimedOut(_outputIndex, _challenger, block.timestamp);\n\n        // Switch validator system after validator pool contract terminated.\n        if (L2_ORACLE.VALIDATOR_POOL().isTerminated(_outputIndex)) {\n            L2_ORACLE.VALIDATOR_MANAGER().slash(\n                _outputIndex,\n                L2_ORACLE.getSubmitter(_outputIndex),\n                _challenger\n            );\n            return;\n        }\n\n        // After output is finalized, the challenger's bond is included in the balance of output submitter.\n        if (L2_ORACLE.isFinalized(_outputIndex)) {\n            L2_ORACLE.VALIDATOR_POOL().releasePendingBond(\n                _outputIndex,\n                _challenger,\n                L2_ORACLE.getSubmitter(_outputIndex)\n            );\n        } else {\n            // Because the challenger lost, the challenger's bond is included in the bond for that output.\n            L2_ORACLE.VALIDATOR_POOL().increaseBond(_outputIndex, _challenger);\n        }\n    }\n\n    /**\n     * @notice Hashes the public input with padding dummy transactions.\n     *\n     * @param _prevStateRoot Previous state root.\n     * @param _publicInput   Ingredients to compute the public input used by ZK proof verification.\n     *\n     * @return Hash of public input.\n     */\n    function _hashPublicInput(\n        bytes32 _prevStateRoot,\n        Types.PublicInput calldata _publicInput\n    ) internal view returns (bytes32) {\n        bytes32[] memory dummyHashes;\n        if (_publicInput.txHashes.length < MAX_TXS) {\n            dummyHashes = Hashing.generateDummyHashes(\n                DUMMY_HASH,\n                MAX_TXS - _publicInput.txHashes.length\n            );\n        }\n\n        // NOTE(chokobole): We cannot calculate the Ethereum transaction root solely\n        // based on transaction hashes. It is necessary to have access to the original\n        // transactions. Considering the imposed constraints and the difficulty\n        // of providing a preimage that would generate the desired public input hash\n        // from an attacker's perspective, we have decided to omit the verification\n        // using the transaction root.\n        return Hashing.hashPublicInput(_prevStateRoot, _publicInput, dummyHashes);\n    }\n\n    /**\n     * @notice Returns the number of L2 blocks for the next turn.\n     *\n     * @param _challenge The current challenge data.\n     *\n     * @return The number of L2 blocks for the next turn.\n     */\n    function _nextSegSize(Types.Challenge storage _challenge) internal view returns (uint256) {\n        return _challenge.segSize / (segmentsLengths[_challenge.turn - 1] - 1);\n    }\n\n    /**\n     * @notice Determines if bisection is possible.\n     *\n     * @param _challenge The current challenge data.\n     *\n     * @return Whether bisection is possible.\n     */\n    function _isAbleToBisect(Types.Challenge storage _challenge) internal view returns (bool) {\n        return _nextSegSize(_challenge) > 1;\n    }\n\n    /**\n     * @notice Returns status of a given challenge.\n     *\n     * @param _challenge The challenge data.\n     *\n     * @return The status of the challenge.\n     */\n    function _challengeStatus(\n        Types.Challenge storage _challenge\n    ) internal view returns (ChallengeStatus) {\n        if (_challenge.turn < TURN_INIT) {\n            return ChallengeStatus.NONE;\n        }\n\n        // If the turn is even, it means that the asserter has completed its turn,\n        // so the next turn will be the challenger's turn.\n        bool isChallengerTurn = _challenge.turn % 2 == 0;\n\n        // Check if it's a timed out challenge.\n        if (block.timestamp > _challenge.timeoutAt) {\n            // timeout on challenger turn\n            if (isChallengerTurn) {\n                return ChallengeStatus.CHALLENGER_TIMEOUT;\n            }\n\n            // If the asserter times out and the challenger does not prove fault,\n            // the challenger is assumed to have timed out.\n            if (block.timestamp > _challenge.timeoutAt + PROVING_TIMEOUT) {\n                return ChallengeStatus.CHALLENGER_TIMEOUT;\n            }\n\n            // timeout on asserter turn\n            return ChallengeStatus.ASSERTER_TIMEOUT;\n        }\n\n        // If bisection is not possible, the Challenger must execute the fault proof.\n        if (!_isAbleToBisect(_challenge)) {\n            return ChallengeStatus.READY_TO_PROVE;\n        }\n\n        return isChallengerTurn ? ChallengeStatus.CHALLENGER_TURN : ChallengeStatus.ASSERTER_TURN;\n    }\n\n    /**\n     * @notice Returns the challenge segments corresponding to the given L2 output index and challenger.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _challenger  Address of the challenger.\n     *\n     * @return The challenge segments data.\n     */\n    function getSegments(\n        uint256 _outputIndex,\n        address _challenger\n    ) external view returns (bytes32[] memory) {\n        return challenges[_outputIndex][_challenger].segments;\n    }\n\n    /**\n     * @notice Returns the challenge status corresponding to the given L2 output index.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _challenger  Address of the challenger.\n     *\n     * @return The status of the challenge.\n     */\n    function getStatus(\n        uint256 _outputIndex,\n        address _challenger\n    ) external view returns (ChallengeStatus) {\n        return _challengeStatus(challenges[_outputIndex][_challenger]);\n    }\n\n    /**\n     * @notice Determines whether current timestamp is in challenge creation period corresponding to the given L2 output index.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     *\n     * @return Whether current timestamp is in challenge creation period.\n     */\n    function isInCreationPeriod(uint256 _outputIndex) external view returns (bool) {\n        return\n            L2_ORACLE.getL2Output(_outputIndex).timestamp + CREATION_PERIOD_SECONDS >=\n            block.timestamp;\n    }\n}\n"
    },
    "contracts/L1/KromaPortal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { ISemver } from \"../universal/ISemver.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { L2OutputOracle } from \"./L2OutputOracle.sol\";\nimport { ResourceMetering } from \"./ResourceMetering.sol\";\nimport { SystemConfig } from \"./SystemConfig.sol\";\nimport { ZKMerkleTrie } from \"./ZKMerkleTrie.sol\";\n\n/**\n * @custom:proxied\n * @title KromaPortal\n * @notice The KromaPortal is a low-level contract responsible for passing messages between L1\n *         and L2. Messages sent directly to the KromaPortal have no form of replayability.\n *         Users are encouraged to use the L1CrossDomainMessenger for a higher-level interface.\n */\ncontract KromaPortal is Initializable, ResourceMetering, ISemver {\n    /**\n     * @notice Represents a proven withdrawal.\n     *\n     * @custom:field outputRoot    Root of the L2 output this was proven against.\n     * @custom:field timestamp     Timestamp at whcih the withdrawal was proven.\n     * @custom:field l2OutputIndex Index of the output this was proven against.\n     */\n    struct ProvenWithdrawal {\n        bytes32 outputRoot;\n        uint128 timestamp;\n        uint128 l2OutputIndex;\n    }\n\n    /**\n     * @notice Version of the deposit event.\n     */\n    uint256 internal constant DEPOSIT_VERSION = 0;\n\n    /**\n     * @notice The L2 gas limit set when eth is deposited using the receive() function.\n     */\n    uint64 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;\n\n    /**\n     * @notice Address of the L2OutputOracle contract.\n     */\n    L2OutputOracle public immutable L2_ORACLE;\n\n    /**\n     * @notice Address of the ValidatorPool contract.\n     */\n    address public immutable VALIDATOR_POOL;\n\n    /**\n    /**\n     * @notice Address of the SystemConfig contract.\n     */\n    SystemConfig public immutable SYSTEM_CONFIG;\n\n    /**\n     * @notice MultiSig wallet address that has the ability to pause and unpause withdrawals.\n     */\n    address public immutable GUARDIAN;\n\n    /**\n     * @notice Address of the ZKMerkleTrie.\n     */\n    ZKMerkleTrie public immutable ZK_MERKLE_TRIE;\n\n    /**\n     * @notice Address of the L2 account which initiated a withdrawal in this transaction. If the\n     *         of this variable is the default L2 sender address, then we are NOT inside of a call\n     *         to finalizeWithdrawalTransaction.\n     */\n    address public l2Sender;\n\n    /**\n     * @notice A list of withdrawal hashes which have been successfully finalized.\n     */\n    mapping(bytes32 => bool) public finalizedWithdrawals;\n\n    /**\n     * @notice A mapping of withdrawal hashes to `ProvenWithdrawal` data.\n     */\n    mapping(bytes32 => ProvenWithdrawal) public provenWithdrawals;\n\n    /**\n     * @notice Determines if cross domain messaging is paused. When set to true,\n     *         withdrawals are paused. This may be removed in the future.\n     */\n    bool public paused;\n\n    /**\n     * @notice Emitted when a transaction is deposited from L1 to L2. The parameters of this event\n     *         are read by the rollup node and used to derive deposit transactions on L2.\n     *\n     * @param from       Address that triggered the deposit transaction.\n     * @param to         Address that the deposit transaction is directed to.\n     * @param version    Version of this deposit transaction event.\n     * @param opaqueData ABI encoded deposit data to be parsed off-chain.\n     */\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 indexed version,\n        bytes opaqueData\n    );\n\n    /**\n     * @notice Emitted when a withdrawal transaction is proven.\n     *\n     * @param withdrawalHash Hash of the withdrawal transaction.\n     */\n    event WithdrawalProven(\n        bytes32 indexed withdrawalHash,\n        address indexed from,\n        address indexed to\n    );\n\n    /**\n     * @notice Emitted when a withdrawal transaction is finalized.\n     *\n     * @param withdrawalHash Hash of the withdrawal transaction.\n     * @param success        Whether the withdrawal transaction was successful.\n     */\n    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);\n\n    /**\n     * @notice Emitted when the pause is triggered.\n     *\n     * @param account Address of the account triggering the pause.\n     */\n    event Paused(address account);\n\n    /**\n     * @notice Emitted when the pause is lifted.\n     *\n     * @param account Address of the account triggering the unpause.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @notice Reverts when paused.\n     */\n    modifier whenNotPaused() {\n        require(paused == false, \"KromaPortal: paused\");\n        _;\n    }\n\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.0.0\n     */\n    string public constant version = \"1.0.0\";\n\n    /**\n     * @notice Constructs the KromaPortal contract.\n     *\n     * @param _l2Oracle                  Address of the L2OutputOracle contract.\n     * @param _validatorPool             Address of the ValidatorPool contract.\n     * @param _guardian                  MultiSig wallet address that can pause deposits and withdrawals.\n     * @param _paused                    Sets the contract's pausability state.\n     * @param _config                    Address of the SystemConfig contract.\n     * @param _zkMerkleTrie              Address of the ZKMerkleTrie contract.\n     */\n    constructor(\n        L2OutputOracle _l2Oracle,\n        address _validatorPool,\n        address _guardian,\n        bool _paused,\n        SystemConfig _config,\n        ZKMerkleTrie _zkMerkleTrie\n    ) {\n        L2_ORACLE = _l2Oracle;\n        VALIDATOR_POOL = _validatorPool;\n        GUARDIAN = _guardian;\n        SYSTEM_CONFIG = _config;\n        ZK_MERKLE_TRIE = _zkMerkleTrie;\n        initialize(_paused);\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize(bool _paused) public initializer {\n        l2Sender = Constants.DEFAULT_L2_SENDER;\n        paused = _paused;\n        __ResourceMetering_init();\n    }\n\n    /**\n     * @notice Pause deposits and withdrawals.\n     */\n    function pause() external {\n        require(msg.sender == GUARDIAN, \"KromaPortal: only guardian can pause\");\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @notice Unpause deposits and withdrawals.\n     */\n    function unpause() external {\n        require(msg.sender == GUARDIAN, \"KromaPortal: only guardian can unpause\");\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    /**\n     * @notice Accepts value so that users can send ETH directly to this contract and have the\n     *         funds be deposited to their address on L2. This is intended as a convenience\n     *         function for EOAs. Contracts should call the depositTransaction() function directly\n     *         otherwise any deposited funds will be lost due to address aliasing.\n     */\n    // solhint-disable-next-line ordering\n    receive() external payable {\n        depositTransaction(msg.sender, msg.value, RECEIVE_DEFAULT_GAS_LIMIT, false, bytes(\"\"));\n    }\n\n    /**\n     * @notice Getter for the resource config. Used internally by the ResourceMetering\n     *         contract. The SystemConfig is the source of truth for the resource config.\n     *\n     * @return ResourceMetering.ResourceConfig\n     */\n    function _resourceConfig()\n        internal\n        view\n        override\n        returns (ResourceMetering.ResourceConfig memory)\n    {\n        return SYSTEM_CONFIG.resourceConfig();\n    }\n\n    /**\n     * @notice Proves a withdrawal transaction.\n     *\n     * @param _tx              Withdrawal transaction to finalize.\n     * @param _l2OutputIndex   L2 output index to prove against.\n     * @param _outputRootProof Inclusion proof of the L2ToL1MessagePasser contract's storage root.\n     * @param _withdrawalProof Inclusion proof of the withdrawal in L2ToL1MessagePasser contract.\n     */\n    function proveWithdrawalTransaction(\n        Types.WithdrawalTransaction memory _tx,\n        uint256 _l2OutputIndex,\n        Types.OutputRootProof calldata _outputRootProof,\n        bytes[] calldata _withdrawalProof\n    ) external whenNotPaused {\n        // Prevent users from creating a deposit transaction where this address is the message\n        // sender on L2. Because this is checked here, we do not need to check again in\n        // `finalizeWithdrawalTransaction`.\n        require(\n            _tx.target != address(this),\n            \"KromaPortal: you cannot send messages to the portal contract\"\n        );\n\n        // Get the output root and load onto the stack to prevent multiple mloads. This will\n        // revert if there is no output root for the given block number.\n        bytes32 outputRoot = L2_ORACLE.getL2Output(_l2OutputIndex).outputRoot;\n\n        // Verify that the output root can be generated with the elements in the proof.\n        require(\n            outputRoot == Hashing.hashOutputRootProof(_outputRootProof),\n            \"KromaPortal: invalid output root proof\"\n        );\n\n        // Load the ProvenWithdrawal into memory, using the withdrawal hash as a unique identifier.\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];\n\n        // We generally want to prevent users from proving the same withdrawal multiple times\n        // because each successive proof will update the timestamp. A malicious user can take\n        // advantage of this to prevent other users from finalizing their withdrawal. However,\n        // since withdrawals are proven before an output root is finalized, we need to allow users\n        // to re-prove their withdrawal only in the case that the output root for their specified\n        // output index has been updated.\n        require(\n            provenWithdrawal.timestamp == 0 ||\n                L2_ORACLE.getL2Output(provenWithdrawal.l2OutputIndex).outputRoot !=\n                provenWithdrawal.outputRoot,\n            \"KromaPortal: withdrawal hash has already been proven\"\n        );\n\n        // Compute the storage slot of the withdrawal hash in the L2ToL1MessagePasser contract.\n        // Refer to the Solidity documentation for more information on how storage layouts are\n        // computed for mappings.\n        bytes32 storageKey = keccak256(\n            abi.encode(\n                withdrawalHash,\n                uint256(0) // The withdrawals mapping is at the first slot in the layout.\n            )\n        );\n\n        // Verify that the hash of this withdrawal was stored in the L2toL1MessagePasser contract\n        // on L2. If this is true, under the assumption that the ZKMerkleTrie contract does not have\n        // bugs, then we know that this withdrawal was actually triggered on L2 and can therefore\n        // be relayed on L1.\n        require(\n            ZK_MERKLE_TRIE.verifyInclusionProof(\n                storageKey,\n                hex\"0000000000000000000000000000000000000000000000000000000000000001\",\n                _withdrawalProof,\n                _outputRootProof.messagePasserStorageRoot\n            ),\n            \"KromaPortal: invalid withdrawal inclusion proof\"\n        );\n\n        // Designate the withdrawalHash as proven by storing the `outputRoot`, `timestamp`, and\n        // `l2OutputIndex` in the `provenWithdrawals` mapping. A `withdrawalHash` can only be\n        // proven once unless it is submitted again with a different outputRoot.\n        provenWithdrawals[withdrawalHash] = ProvenWithdrawal({\n            outputRoot: outputRoot,\n            timestamp: uint128(block.timestamp),\n            l2OutputIndex: uint128(_l2OutputIndex)\n        });\n\n        // Emit a `WithdrawalProven` event.\n        emit WithdrawalProven(withdrawalHash, _tx.sender, _tx.target);\n    }\n\n    /**\n     * @notice Finalizes a withdrawal transaction.\n     *\n     * @param _tx Withdrawal transaction to finalize.\n     */\n    function finalizeWithdrawalTransaction(Types.WithdrawalTransaction memory _tx)\n        external\n        whenNotPaused\n    {\n        // Make sure that the l2Sender has not yet been set. The l2Sender is set to a value other\n        // than the default value when a withdrawal transaction is being finalized. This check is\n        // a defacto reentrancy guard.\n        require(\n            l2Sender == Constants.DEFAULT_L2_SENDER,\n            \"KromaPortal: can only trigger one withdrawal per transaction\"\n        );\n\n        // Grab the proven withdrawal from the `provenWithdrawals` map.\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];\n\n        // A withdrawal can only be finalized if it has been proven. We know that a withdrawal has\n        // been proven at least once when its timestamp is non-zero. Unproven withdrawals will have\n        // a timestamp of zero.\n        require(provenWithdrawal.timestamp != 0, \"KromaPortal: withdrawal has not been proven yet\");\n\n        // As a sanity check, we make sure that the proven withdrawal's timestamp is greater than\n        // starting timestamp inside the L2OutputOracle. Not strictly necessary but extra layer of\n        // safety against weird bugs in the proving step.\n        require(\n            provenWithdrawal.timestamp >= L2_ORACLE.startingTimestamp(),\n            \"KromaPortal: withdrawal timestamp less than L2 Oracle starting timestamp\"\n        );\n\n        // A proven withdrawal must wait at least the finalization period before it can be\n        // finalized. This waiting period can elapse in parallel with the waiting period for the\n        // output the withdrawal was proven against. In effect, this means that the minimum\n        // withdrawal time is l2 output submission time + finalization period.\n        require(\n            _isFinalizationPeriodElapsed(provenWithdrawal.timestamp),\n            \"KromaPortal: proven withdrawal finalization period has not elapsed\"\n        );\n\n        // Grab the CheckpointOutput from the L2OutputOracle, will revert if the output that\n        // corresponds to the given index has not been submitted yet.\n        Types.CheckpointOutput memory checkpointOutput = L2_ORACLE.getL2Output(\n            provenWithdrawal.l2OutputIndex\n        );\n\n        // Check that the output root that was used to prove the withdrawal is the same as the\n        // current output root for the given output index. An output root may change if it is\n        // deleted by the challenger address and then re-submitted.\n        require(\n            checkpointOutput.outputRoot == provenWithdrawal.outputRoot,\n            \"KromaPortal: output root proven is not the same as current output root\"\n        );\n\n        // Check that the checkpoint output has also been finalized.\n        require(\n            _isFinalizationPeriodElapsed(checkpointOutput.timestamp),\n            \"KromaPortal: checkpoint output finalization period has not elapsed\"\n        );\n\n        // Check that this withdrawal has not already been finalized, this is replay protection.\n        require(\n            finalizedWithdrawals[withdrawalHash] == false,\n            \"KromaPortal: withdrawal has already been finalized\"\n        );\n\n        // Mark the withdrawal as finalized so it can't be replayed.\n        finalizedWithdrawals[withdrawalHash] = true;\n\n        // Set the l2Sender so contracts know who triggered this withdrawal on L2.\n        l2Sender = _tx.sender;\n\n        // Trigger the call to the target contract. We use a custom low level method\n        // SafeCall.callWithMinGas to ensure two key properties\n        //   1. Target contracts cannot force this call to run out of gas by returning a very large\n        //      amount of data (and this is OK because we don't care about the returndata here).\n        //   2. The amount of gas provided to the execution context of the target is at least the\n        //      gas limit specified by the user. If there is not enough gas in the current context\n        //      to accomplish this, `callWithMinGas` will revert.\n        bool success = SafeCall.callWithMinGas(_tx.target, _tx.gasLimit, _tx.value, _tx.data);\n\n        // Reset the l2Sender back to the default value.\n        l2Sender = Constants.DEFAULT_L2_SENDER;\n\n        // All withdrawals are immediately finalized. Replayability can\n        // be achieved through contracts built on top of this contract\n        emit WithdrawalFinalized(withdrawalHash, success);\n\n        // Reverting here is useful for determining the exact gas cost to successfully execute the\n        // sub call to the target contract if the minimum gas limit specified by the user would not\n        // be sufficient to execute the sub call.\n        if (success == false && tx.origin == Constants.ESTIMATION_ADDRESS) {\n            revert(\"KromaPortal: withdrawal failed\");\n        }\n    }\n\n    /**\n     * @notice Accepts deposits of ETH and data, and emits a TransactionDeposited event for use in\n     *         deriving deposit transactions. Note that if a deposit is made by a contract, its\n     *         address will be aliased when retrieved using `tx.origin` or `msg.sender`. Consider\n     *         using the CrossDomainMessenger contracts for a simpler developer experience.\n     *\n     * @param _to         Target address on L2.\n     * @param _value      ETH value to send to the recipient.\n     * @param _gasLimit   Minimum L2 gas limit (can be greater than or equal to this value).\n     * @param _isCreation Whether or not the transaction is a contract creation.\n     * @param _data       Data to trigger the recipient with.\n     */\n    function depositTransaction(\n        address _to,\n        uint256 _value,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    ) public payable metered(_gasLimit) {\n        // Just to be safe, make sure that people specify address(0) as the target when doing\n        // contract creations.\n        if (_isCreation) {\n            require(\n                _to == address(0),\n                \"KromaPortal: must send to address(0) when creating a contract\"\n            );\n        }\n\n        // Prevent depositing transactions that have too small of a gas limit.\n        require(_gasLimit >= 21_000, \"KromaPortal: gas limit must cover instrinsic gas cost\");\n\n        // Transform the from-address to its alias if the caller is a contract.\n        address from = msg.sender;\n        if (msg.sender != tx.origin) {\n            from = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        // Compute the opaque data that will be emitted as part of the TransactionDeposited event.\n        // We use opaque data so that we can update the TransactionDeposited event in the future\n        // without breaking the current interface.\n        bytes memory opaqueData = abi.encodePacked(\n            msg.value,\n            _value,\n            _gasLimit,\n            _isCreation,\n            _data\n        );\n\n        // Emit a TransactionDeposited event so that the rollup node can derive a deposit\n        // transaction for this deposit.\n        emit TransactionDeposited(from, _to, DEPOSIT_VERSION, opaqueData);\n    }\n\n    /**\n     * @notice Accepts deposits of data from ValidatorPool contract, and emits a TransactionDeposited event for use in\n     *         deriving deposit transactions on L2.\n     *\n     * @param _to         Target address on L2.\n     * @param _gasLimit   Minimum L2 gas limit (can be greater than or equal to this value).\n     * @param _data       Data to trigger the recipient with.\n     */\n    function depositTransactionByValidatorPool(\n        address _to,\n        uint64 _gasLimit,\n        bytes memory _data\n    ) public {\n        require(\n            msg.sender == VALIDATOR_POOL,\n            \"KromaPortal: function can only be called from the ValidatorPool\"\n        );\n\n        // Transform the from-address to its alias.\n        address from = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n\n        // Compute the opaque data that will be emitted as part of the TransactionDeposited event.\n        bytes memory opaqueData = abi.encodePacked(uint256(0), uint256(0), _gasLimit, false, _data);\n\n        // Emit a TransactionDeposited event so that the rollup node can derive a deposit\n        // transaction for this deposit.\n        emit TransactionDeposited(from, _to, DEPOSIT_VERSION, opaqueData);\n    }\n\n    /**\n     * @notice Determines if the output at the given index is finalized. Reverts if the call to\n     *         L2_ORACLE.getL2Output reverts. Returns a boolean otherwise.\n     *\n     * @param _l2OutputIndex Index of the L2 output to check.\n     *\n     * @return Whether or not the output is finalized.\n     */\n    function isOutputFinalized(uint256 _l2OutputIndex) external view returns (bool) {\n        return _isFinalizationPeriodElapsed(L2_ORACLE.getL2Output(_l2OutputIndex).timestamp);\n    }\n\n    /**\n     * @notice Determines whether the finalization period has elapsed w/r/t a given timestamp.\n     *\n     * @param _timestamp Timestamp to check.\n     *\n     * @return Whether or not the finalization period has elapsed.\n     */\n    function _isFinalizationPeriodElapsed(uint256 _timestamp) internal view returns (bool) {\n        return block.timestamp > _timestamp + L2_ORACLE.FINALIZATION_PERIOD_SECONDS();\n    }\n}\n"
    },
    "contracts/L1/L1CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { ISemver } from \"../universal/ISemver.sol\";\nimport { KromaPortal } from \"./KromaPortal.sol\";\n\n/**\n * @custom:proxied\n * @title L1CrossDomainMessenger\n * @notice The L1CrossDomainMessenger is a message passing interface between L1 and L2 responsible\n *         for sending and receiving data on the L1 side. Users are encouraged to use this\n *         interface instead of interacting with lower-level contracts directly.\n */\ncontract L1CrossDomainMessenger is CrossDomainMessenger, ISemver {\n    /**\n     * @notice Address of the KromaPortal.\n     */\n    KromaPortal public immutable PORTAL;\n\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.0.0\n     */\n    string public constant version = \"1.0.0\";\n\n    /**\n     * @notice Constructs the L1CrossDomainMessenger contract.\n     *\n     * @param _portal Address of the KromaPortal contract on this network.\n     */\n    constructor(KromaPortal _portal) CrossDomainMessenger(Predeploys.L2_CROSS_DOMAIN_MESSENGER) {\n        PORTAL = _portal;\n        initialize();\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize() public initializer {\n        __CrossDomainMessenger_init();\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal override {\n        PORTAL.depositTransaction{ value: _value }(_to, _value, _gasLimit, false, _data);\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _isOtherMessenger() internal view override returns (bool) {\n        return msg.sender == address(PORTAL) && PORTAL.l2Sender() == OTHER_MESSENGER;\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _isUnsafeTarget(address _target) internal view override returns (bool) {\n        return _target == address(this) || _target == address(PORTAL);\n    }\n}\n"
    },
    "contracts/L1/L1ERC721Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport { L2ERC721Bridge } from \"../L2/L2ERC721Bridge.sol\";\nimport { ERC721Bridge } from \"../universal/ERC721Bridge.sol\";\nimport { ISemver } from \"../universal/ISemver.sol\";\n\n/**\n * @title L1ERC721Bridge\n * @notice The L1 ERC721 bridge is a contract which works together with the L2 ERC721 bridge to\n *         make it possible to transfer ERC721 tokens from Ethereum to Kroma. This contract\n *         acts as an escrow for ERC721 tokens deposited into L2.\n */\ncontract L1ERC721Bridge is ERC721Bridge, ISemver {\n    /**\n     * @notice Mapping of L1 token to L2 token to ID to boolean, indicating if the given L1 token\n     *         by ID was deposited for a given L2 token.\n     */\n    mapping(address => mapping(address => mapping(uint256 => bool))) public deposits;\n\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.0.0\n     */\n    string public constant version = \"1.0.0\";\n\n    /**\n     * @notice Constructs the L1ERC721Bridge contract.\n     *\n     * @param _messenger   Address of the CrossDomainMessenger on this network.\n     * @param _otherBridge Address of the ERC721 bridge on the other network.\n     */\n    constructor(address _messenger, address _otherBridge) ERC721Bridge(_messenger, _otherBridge) {}\n\n    /**\n     * @notice Completes an ERC721 bridge from the other domain and sends the ERC721 token to the\n     *         recipient on this domain.\n     *\n     * @param _localToken  Address of the ERC721 token on this domain.\n     * @param _remoteToken Address of the ERC721 token on the other domain.\n     * @param _from        Address that triggered the bridge on the other domain.\n     * @param _to          Address to receive the token on this domain.\n     * @param _tokenId     ID of the token being deposited.\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\n     *                     execute any code on L2 and is only emitted as extra data for the\n     *                     convenience of off-chain tooling.\n     */\n    function finalizeBridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes calldata _extraData\n    ) external onlyOtherBridge {\n        require(_localToken != address(this), \"L1ERC721Bridge: local token cannot be self\");\n\n        // Checks that the L1/L2 NFT pair has a token ID that is escrowed in the L1 Bridge.\n        require(\n            deposits[_localToken][_remoteToken][_tokenId] == true,\n            \"L1ERC721Bridge: Token ID is not escrowed in the L1 Bridge\"\n        );\n\n        // Mark that the token ID for this L1/L2 token pair is no longer escrowed in the L1\n        // Bridge.\n        deposits[_localToken][_remoteToken][_tokenId] = false;\n\n        // When a withdrawal is finalized on L1, the L1 Bridge transfers the NFT to the\n        // withdrawer.\n        IERC721(_localToken).safeTransferFrom(address(this), _to, _tokenId);\n\n        // slither-disable-next-line reentrancy-events\n        emit ERC721BridgeFinalized(_localToken, _remoteToken, _from, _to, _tokenId, _extraData);\n    }\n\n    /**\n     * @inheritdoc ERC721Bridge\n     */\n    function _initiateBridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) internal override {\n        require(_remoteToken != address(0), \"L1ERC721Bridge: remote token cannot be address(0)\");\n\n        // Construct calldata for _l2Token.finalizeBridgeERC721(_to, _tokenId)\n        bytes memory message = abi.encodeWithSelector(\n            L2ERC721Bridge.finalizeBridgeERC721.selector,\n            _remoteToken,\n            _localToken,\n            _from,\n            _to,\n            _tokenId,\n            _extraData\n        );\n\n        // Lock token into bridge\n        deposits[_localToken][_remoteToken][_tokenId] = true;\n        IERC721(_localToken).transferFrom(_from, address(this), _tokenId);\n\n        // Send calldata into L2\n        MESSENGER.sendMessage(OTHER_BRIDGE, message, _minGasLimit);\n        emit ERC721BridgeInitiated(_localToken, _remoteToken, _from, _to, _tokenId, _extraData);\n    }\n}\n"
    },
    "contracts/L1/L1StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { ISemver } from \"../universal/ISemver.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\n\n/**\n * @custom:proxied\n * @title L1StandardBridge\n * @notice The L1StandardBridge is responsible for transfering ETH and ERC20 tokens between L1 and\n *         L2. In the case that an ERC20 token is native to L1, it will be escrowed within this\n *         contract. If the ERC20 token is native to L2, it will be burnt. ETH is instead stored\n *         inside the KromaPortal contract.\n *         NOTE: this contract is not intended to support all variations of ERC20 tokens. Examples\n *         of some token types that may not be properly supported by this contract include, but are\n *         not limited to: tokens with transfer fees, rebasing tokens, and tokens with blocklists.\n */\ncontract L1StandardBridge is StandardBridge, ISemver {\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.0.0\n     */\n    string public constant version = \"1.0.0\";\n\n    /**\n     * @notice Constructs the L1StandardBridge contract.\n     *\n     * @param _messenger Address of the L1CrossDomainMessenger.\n     */\n    constructor(\n        address payable _messenger\n    ) StandardBridge(_messenger, payable(Predeploys.L2_STANDARD_BRIDGE)) {}\n\n    /**\n     * @notice Allows EOAs to bridge ETH by sending directly to the bridge.\n     */\n    receive() external payable override onlyEOA {\n        _initiateBridgeETH(msg.sender, msg.sender, msg.value, RECEIVE_DEFAULT_GAS_LIMIT, bytes(\"\"));\n    }\n}\n"
    },
    "contracts/L1/L2OutputOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { ISemver } from \"../universal/ISemver.sol\";\nimport { IValidatorManager } from \"./interfaces/IValidatorManager.sol\";\nimport { ValidatorPool } from \"./ValidatorPool.sol\";\n\n/**\n * @custom:proxied\n * @title L2OutputOracle\n * @notice The L2OutputOracle contains an array of L2 state outputs, where each output is a\n *         commitment to the state of the L2 chain. Other contracts like the KromaPortal use\n *         these outputs to verify information about the state of L2.\n */\ncontract L2OutputOracle is Initializable, ISemver {\n    /**\n     * @notice The address of the validator pool contract. Can be updated via upgrade.\n     */\n    ValidatorPool public immutable VALIDATOR_POOL;\n\n    /**\n     * @notice The address of the validator manager contract. Can be updated via upgrade.\n     */\n    IValidatorManager public immutable VALIDATOR_MANAGER;\n\n    /**\n     * @notice The address of the colosseum contract. Can be updated via upgrade.\n     */\n    address public immutable COLOSSEUM;\n\n    /**\n     * @notice The interval in L2 blocks at which checkpoints must be submitted. Although this is\n     *         immutable, it can be modified by upgrading the implementation contract.\n     *         Note that nodes that fetch and use this value need to restart when it is modified.\n     */\n    uint256 public immutable SUBMISSION_INTERVAL;\n\n    /**\n     * @notice The time between L2 blocks in seconds. Once set, this value MUST NOT be modified.\n     */\n    uint256 public immutable L2_BLOCK_TIME;\n\n    /**\n     * @notice Minimum time (in seconds) that must elapse before a withdrawal can be finalized.\n     */\n    uint256 public immutable FINALIZATION_PERIOD_SECONDS;\n\n    /**\n     * @notice The number of the first L2 block recorded in this contract.\n     */\n    uint256 public startingBlockNumber;\n\n    /**\n     * @notice The timestamp of the first L2 block recorded in this contract.\n     */\n    uint256 public startingTimestamp;\n\n    /**\n     * @notice Array of L2 checkpoint outputs.\n     */\n    Types.CheckpointOutput[] internal l2Outputs;\n\n    /**\n     * @notice The output index of the next finalization target output.\n     */\n    uint256 public nextFinalizeOutputIndex;\n\n    /**\n     * @notice Emitted when an output is submitted.\n     *\n     * @param outputRoot    The output root.\n     * @param l2OutputIndex The index of the output in the l2Outputs array.\n     * @param l2BlockNumber The L2 block number of the output root.\n     * @param l1Timestamp   The L1 timestamp when submitted.\n     */\n    event OutputSubmitted(\n        bytes32 indexed outputRoot,\n        uint256 indexed l2OutputIndex,\n        uint256 indexed l2BlockNumber,\n        uint256 l1Timestamp\n    );\n\n    /**\n     * @notice Emitted when an output is replaced.\n     *\n     * @param outputIndex   Replaced L2 output index.\n     * @param newSubmitter  Output submitter after replacement.\n     * @param newOutputRoot L2 output root after replacement.\n     */\n    event OutputReplaced(\n        uint256 indexed outputIndex,\n        address indexed newSubmitter,\n        bytes32 newOutputRoot\n    );\n\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.1.0\n     */\n    string public constant version = \"1.1.0\";\n\n    /**\n     * @notice Constructs the L2OutputOracle contract.\n     *\n     * @param _validatorPool             The address of the ValidatorPool contract.\n     * @param _validatorManager          The address of the ValidatorManager contract.\n     * @param _colosseum                 The address of the Colosseum contract.\n     * @param _submissionInterval        Interval in blocks at which checkpoints must be submitted.\n     * @param _l2BlockTime               The time per L2 block, in seconds.\n     * @param _startingBlockNumber       The number of the first L2 block.\n     * @param _startingTimestamp         The timestamp of the first L2 block.\n     * @param _finalizationPeriodSeconds Output finalization time in seconds.\n     */\n    constructor(\n        ValidatorPool _validatorPool,\n        IValidatorManager _validatorManager,\n        address _colosseum,\n        uint256 _submissionInterval,\n        uint256 _l2BlockTime,\n        uint256 _startingBlockNumber,\n        uint256 _startingTimestamp,\n        uint256 _finalizationPeriodSeconds\n    ) {\n        require(_l2BlockTime > 0, \"L2OutputOracle: L2 block time must be greater than 0\");\n        require(\n            _submissionInterval > 0,\n            \"L2OutputOracle: submission interval must be greater than 0\"\n        );\n\n        VALIDATOR_POOL = _validatorPool;\n        VALIDATOR_MANAGER = _validatorManager;\n        COLOSSEUM = _colosseum;\n        SUBMISSION_INTERVAL = _submissionInterval;\n        L2_BLOCK_TIME = _l2BlockTime;\n        FINALIZATION_PERIOD_SECONDS = _finalizationPeriodSeconds;\n\n        initialize(_startingBlockNumber, _startingTimestamp);\n    }\n\n    /**\n     * @notice Initializer.\n     *\n     * @param _startingBlockNumber Block number for the first recorded L2 block.\n     * @param _startingTimestamp   Timestamp for the first recorded L2 block.\n     */\n    function initialize(\n        uint256 _startingBlockNumber,\n        uint256 _startingTimestamp\n    ) public initializer {\n        require(\n            _startingTimestamp <= block.timestamp,\n            \"L2OutputOracle: starting L2 timestamp must be less than current time\"\n        );\n\n        startingTimestamp = _startingTimestamp;\n        startingBlockNumber = _startingBlockNumber;\n    }\n\n    /**\n     * @notice Replaces the output that corresponds to the given output index.\n     *         Only the Colosseum contract can replace an output.\n     *\n     * @param _l2OutputIndex Index of the L2 output to be replaced.\n     * @param _newOutputRoot The L2 output root to replace the existing one.\n     * @param _submitter     Address of the L2 output submitter.\n     */\n    function replaceL2Output(\n        uint256 _l2OutputIndex,\n        bytes32 _newOutputRoot,\n        address _submitter\n    ) external {\n        require(\n            msg.sender == COLOSSEUM,\n            \"L2OutputOracle: only the colosseum contract can replace an output\"\n        );\n\n        require(_submitter != address(0), \"L2OutputOracle: submitter address cannot be zero\");\n\n        // Make sure we're not *increasing* the length of the array.\n        require(\n            _l2OutputIndex < l2Outputs.length,\n            \"L2OutputOracle: cannot replace an output after the latest output index\"\n        );\n\n        Types.CheckpointOutput storage output = l2Outputs[_l2OutputIndex];\n        // Do not allow replacing any outputs that have already been finalized.\n        require(\n            block.timestamp - output.timestamp < FINALIZATION_PERIOD_SECONDS,\n            \"L2OutputOracle: cannot replace an output that has already been finalized\"\n        );\n\n        output.outputRoot = _newOutputRoot;\n        output.submitter = _submitter;\n\n        emit OutputReplaced(_l2OutputIndex, _submitter, _newOutputRoot);\n    }\n\n    /**\n     * @notice Accepts an outputRoot and the block number of the corresponding L2 block.\n     *         The block number must be equal to the current value returned by `nextBlockNumber()`\n     *         in order to be accepted. This function may only be called by the validator.\n     *\n     * @param _outputRoot    The L2 output of the checkpoint block.\n     * @param _l2BlockNumber The L2 block number that resulted in _outputRoot.\n     * @param _l1BlockHash   A block hash which must be included in the current chain.\n     * @param _l1BlockNumber The block number with the specified block hash.\n     */\n    function submitL2Output(\n        bytes32 _outputRoot,\n        uint256 _l2BlockNumber,\n        bytes32 _l1BlockHash,\n        uint256 _l1BlockNumber\n    ) external payable {\n        uint256 outputIndex = nextOutputIndex();\n\n        // Upgrade validator system after validator pool contract is terminated.\n        bool isValidatorPoolTerminated = VALIDATOR_POOL.isTerminated(outputIndex);\n        address nextValidator;\n        if (isValidatorPoolTerminated) {\n            VALIDATOR_MANAGER.checkSubmissionEligibility(msg.sender);\n        } else {\n            nextValidator = VALIDATOR_POOL.nextValidator();\n        }\n\n        // If it's not a public round, only selected validators can submit output.\n        if (\n            !isValidatorPoolTerminated && nextValidator != Constants.VALIDATOR_PUBLIC_ROUND_ADDRESS\n        ) {\n            require(\n                msg.sender == nextValidator,\n                \"L2OutputOracle: only the next selected validator can submit output\"\n            );\n        }\n\n        require(\n            _l2BlockNumber == nextBlockNumber(),\n            \"L2OutputOracle: block number must be equal to next expected block number\"\n        );\n\n        require(\n            nextOutputMinL2Timestamp() <= block.timestamp,\n            \"L2OutputOracle: cannot submit L2 output in the future\"\n        );\n\n        require(\n            _outputRoot != bytes32(0),\n            \"L2OutputOracle: L2 checkpoint output cannot be the zero hash\"\n        );\n\n        if (_l1BlockHash != bytes32(0) && blockhash(_l1BlockNumber) != bytes32(0)) {\n            // This check allows the validator to submit an output based on a given L1 block,\n            // without fear that it will be reorged out.\n            // It will be skipped if the blockheight provided is more than 256 blocks behind the\n            // chain tip (as the hash will return as zero).\n            require(\n                blockhash(_l1BlockNumber) == _l1BlockHash,\n                \"L2OutputOracle: block hash does not match the hash at the expected height\"\n            );\n        }\n\n        l2Outputs.push(\n            Types.CheckpointOutput({\n                submitter: msg.sender,\n                outputRoot: _outputRoot,\n                timestamp: uint128(block.timestamp),\n                l2BlockNumber: uint128(_l2BlockNumber)\n            })\n        );\n\n        emit OutputSubmitted(_outputRoot, outputIndex, _l2BlockNumber, block.timestamp);\n\n        if (isValidatorPoolTerminated) {\n            VALIDATOR_MANAGER.afterSubmitL2Output(outputIndex);\n        } else {\n            VALIDATOR_POOL.createBond(\n                outputIndex,\n                uint128(block.timestamp + FINALIZATION_PERIOD_SECONDS)\n            );\n        }\n    }\n\n    /**\n     * @notice Updates the next output index to be finalized. This function may only be called by\n     *         the validator pool contract before terminated, after that by the validator manager\n     *         contract.\n     *\n     * @param _outputIndex Index of the next output to be finalized.\n     */\n    function setNextFinalizeOutputIndex(uint256 _outputIndex) external {\n        if (VALIDATOR_POOL.isTerminated(_outputIndex - 1)) {\n            require(\n                msg.sender == address(VALIDATOR_MANAGER),\n                \"L2OutputOracle: only the validator manager contract can set next finalize output index\"\n            );\n        } else {\n            require(\n                msg.sender == address(VALIDATOR_POOL),\n                \"L2OutputOracle: only the validator pool contract can set next finalize output index\"\n            );\n        }\n\n        nextFinalizeOutputIndex = _outputIndex;\n    }\n\n    /**\n     * @notice Returns an output by index. Reverts if output is not found at the given index.\n     *\n     * @param _l2OutputIndex Index of the output to return.\n     *\n     * @return The output at the given index.\n     */\n    function getL2Output(\n        uint256 _l2OutputIndex\n    ) external view returns (Types.CheckpointOutput memory) {\n        return l2Outputs[_l2OutputIndex];\n    }\n\n    /**\n     * @notice Returns the index of the L2 output that checkpoints a given L2 block number. Uses a\n     *         binary search to find the first output greater than or equal to the given block.\n     *\n     * @param _l2BlockNumber L2 block number to find a checkpoint for.\n     *\n     * @return Index of the first checkpoint that commits to the given L2 block number.\n     */\n    function getL2OutputIndexAfter(uint256 _l2BlockNumber) public view returns (uint256) {\n        // Make sure an output for this block number has actually been submitted.\n        require(\n            _l2BlockNumber <= latestBlockNumber(),\n            \"L2OutputOracle: cannot get output for a block that has not been submitted\"\n        );\n\n        // Make sure there's at least one output submitted.\n        require(\n            l2Outputs.length > 0,\n            \"L2OutputOracle: cannot get output as no outputs have been submitted yet\"\n        );\n\n        // Find the output via binary search, guaranteed to exist.\n        uint256 lo = 0;\n        uint256 hi = l2Outputs.length;\n        while (lo < hi) {\n            uint256 mid = (lo + hi) / 2;\n            if (l2Outputs[mid].l2BlockNumber < _l2BlockNumber) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n\n        return lo;\n    }\n\n    /**\n     * @notice Returns the L2 checkpoint output that checkpoints a given L2 block number.\n     *\n     * @param _l2BlockNumber L2 block number to find a checkpoint for.\n     *\n     * @return First checkpoint that commits to the given L2 block number.\n     */\n    function getL2OutputAfter(\n        uint256 _l2BlockNumber\n    ) external view returns (Types.CheckpointOutput memory) {\n        return l2Outputs[getL2OutputIndexAfter(_l2BlockNumber)];\n    }\n\n    /**\n     * @notice Returns the index of the latest submitted output. Will revert if no outputs\n     *         have been submitted yet.\n     *\n     * @return The index of the latest submitted output.\n     */\n    function latestOutputIndex() external view returns (uint256) {\n        return l2Outputs.length - 1;\n    }\n\n    /**\n     * @notice Returns the index of the next output to be submitted.\n     *\n     * @return The index of the next output to be submitted.\n     */\n    function nextOutputIndex() public view returns (uint256) {\n        return l2Outputs.length;\n    }\n\n    /**\n     * @notice Returns the block number of the latest submitted L2 checkpoint output. If no outputs\n     *         have been submitted yet then this function will return the starting block number.\n     *\n     * @return Latest submitted L2 block number.\n     */\n    function latestBlockNumber() public view returns (uint256) {\n        return\n            l2Outputs.length == 0\n                ? startingBlockNumber\n                : l2Outputs[l2Outputs.length - 1].l2BlockNumber;\n    }\n\n    /**\n     * @notice Computes the block number of the next L2 block that needs to be checkpointed. If no\n     *         outputs have been submitted yet then this function will return the latest block\n     *         number, which is the starting block number.\n     *\n     * @return Next L2 block number.\n     */\n    function nextBlockNumber() public view returns (uint256) {\n        return\n            l2Outputs.length == 0 ? latestBlockNumber() : latestBlockNumber() + SUBMISSION_INTERVAL;\n    }\n\n    /**\n     * @notice Returns the L2 timestamp corresponding to a given L2 block number.\n     *\n     * @param _l2BlockNumber The L2 block number of the target block.\n     *\n     * @return L2 timestamp of the given block.\n     */\n    function computeL2Timestamp(uint256 _l2BlockNumber) public view returns (uint256) {\n        return startingTimestamp + ((_l2BlockNumber - startingBlockNumber) * L2_BLOCK_TIME);\n    }\n\n    /**\n     * @notice Returns the L2 timestamp corresponding to the right next block of the block that\n     *         needs to be checkpointed.\n     *         Note that the added one is because of the existence of next block hash in the output.\n     *\n     * @return L2 timestamp of the right next block of the block that needs to be checkpointed.\n     */\n    function nextOutputMinL2Timestamp() public view returns (uint256) {\n        return computeL2Timestamp(nextBlockNumber() + 1);\n    }\n\n    /**\n     * @notice Returns the address of the L2 output submitter.\n     *\n     * @param _outputIndex Index of an output.\n     *\n     * @return Address of the submitter.\n     */\n    function getSubmitter(uint256 _outputIndex) external view returns (address) {\n        return l2Outputs[_outputIndex].submitter;\n    }\n\n    /**\n     * @notice Returns if the output of given index is finalized.\n     *\n     * @param _outputIndex Index of an output.\n     *\n     * @return If the given output is finalized or not.\n     */\n    function isFinalized(uint256 _outputIndex) external view returns (bool) {\n        return finalizedAt(_outputIndex) <= block.timestamp;\n    }\n\n    /**\n     * @notice Returns the finalization time of given output index.\n     *\n     * @param _outputIndex Index of an output.\n     *\n     * @return The finalization time of given output index.\n     */\n    function finalizedAt(uint256 _outputIndex) public view returns (uint256) {\n        return l2Outputs[_outputIndex].timestamp + FINALIZATION_PERIOD_SECONDS;\n    }\n}\n"
    },
    "contracts/L1/ResourceMetering.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { Arithmetic } from \"../libraries/Arithmetic.sol\";\nimport { Burn } from \"../libraries/Burn.sol\";\n\n/**\n * @custom:upgradeable\n * @title ResourceMetering\n * @notice ResourceMetering implements an EIP-1559 style resource metering system where pricing\n *         updates automatically based on current demand.\n */\nabstract contract ResourceMetering is Initializable {\n    /**\n     * @notice Represents the various parameters that control the way in which resources are\n     *         metered. Corresponds to the EIP-1559 resource metering system.\n     *\n     * @custom:field prevBaseFee   Base fee from the previous block(s).\n     * @custom:field prevBoughtGas Amount of gas bought so far in the current block.\n     * @custom:field prevBlockNum  Last block number that the base fee was updated.\n     */\n    struct ResourceParams {\n        uint128 prevBaseFee;\n        uint64 prevBoughtGas;\n        uint64 prevBlockNum;\n    }\n\n    /**\n     * @notice Represents the configuration for the EIP-1559 based curve for the deposit gas\n     *         market. These values should be set with care as it is possible to set them in\n     *         a way that breaks the deposit gas market. The target resource limit is defined as\n     *         maxResourceLimit / elasticityMultiplier. This struct was designed to fit within a\n     *         single word. There is additional space for additions in the future.\n     *\n     * @custom:field maxResourceLimit             Represents the maximum amount of deposit gas that\n     *                                            can be purchased per block.\n     * @custom:field elasticityMultiplier         Determines the target resource limit along with\n     *                                            the resource limit.\n     * @custom:field baseFeeMaxChangeDenominator  Determines max change on fee per block.\n     * @custom:field minimumBaseFee               The min deposit base fee, it is clamped to this\n     *                                            value.\n     * @custom:field systemTxMaxGas               The amount of gas supplied to the system\n     *                                            transaction. This should be set to the same number\n     *                                            that the kroma-node sets as the gas limit for the\n     *                                            system transaction.\n     * @custom:field maximumBaseFee               The max deposit base fee, it is clamped to this\n     *                                            value.\n     */\n    struct ResourceConfig {\n        uint32 maxResourceLimit;\n        uint8 elasticityMultiplier;\n        uint8 baseFeeMaxChangeDenominator;\n        uint32 minimumBaseFee;\n        uint32 systemTxMaxGas;\n        uint128 maximumBaseFee;\n    }\n\n    /**\n     * @notice EIP-1559 style gas parameters.\n     */\n    ResourceParams public params;\n\n    /**\n     * @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\n     */\n    uint256[48] private __gap;\n\n    /**\n     * @notice Meters access to a function based an amount of a requested resource.\n     *\n     * @param _amount Amount of the resource requested.\n     */\n    modifier metered(uint64 _amount) {\n        // Record initial gas amount so we can refund for it later.\n        uint256 initialGas = gasleft();\n\n        // Run the underlying function.\n        _;\n\n        // Run the metering function.\n        _metered(_amount, initialGas);\n    }\n\n    /**\n     * @notice An internal function that holds all of the logic for metering a resource.\n     *\n     * @param _amount     Amount of the resource requested.\n     * @param _initialGas The amount of gas before any modifier execution.\n     */\n    function _metered(uint64 _amount, uint256 _initialGas) internal {\n        // Update block number and base fee if necessary.\n        uint256 blockDiff = block.number - params.prevBlockNum;\n\n        ResourceConfig memory config = _resourceConfig();\n        int256 targetResourceLimit = int256(uint256(config.maxResourceLimit)) /\n            int256(uint256(config.elasticityMultiplier));\n\n        if (blockDiff > 0) {\n            // Handle updating EIP-1559 style gas parameters. We use EIP-1559 to restrict the rate\n            // at which deposits can be created and therefore limit the potential for deposits to\n            // spam the L2 system. Fee scheme is very similar to EIP-1559 with minor changes.\n            int256 gasUsedDelta = int256(uint256(params.prevBoughtGas)) - targetResourceLimit;\n            int256 baseFeeDelta = (int256(uint256(params.prevBaseFee)) * gasUsedDelta) /\n                (targetResourceLimit * int256(uint256(config.baseFeeMaxChangeDenominator)));\n\n            // Update base fee by adding the base fee delta and clamp the resulting value between\n            // min and max.\n            int256 newBaseFee = Arithmetic.clamp({\n                _value: int256(uint256(params.prevBaseFee)) + baseFeeDelta,\n                _min: int256(uint256(config.minimumBaseFee)),\n                _max: int256(uint256(config.maximumBaseFee))\n            });\n\n            // If we skipped more than one block, we also need to account for every empty block.\n            // Empty block means there was no demand for deposits in that block, so we should\n            // reflect this lack of demand in the fee.\n            if (blockDiff > 1) {\n                // Update the base fee by repeatedly applying the exponent 1-(1/change_denominator)\n                // blockDiff - 1 times. Simulates multiple empty blocks. Clamp the resulting value\n                // between min and max.\n                newBaseFee = Arithmetic.clamp({\n                    _value: Arithmetic.cdexp({\n                        _coefficient: newBaseFee,\n                        _denominator: int256(uint256(config.baseFeeMaxChangeDenominator)),\n                        _exponent: int256(blockDiff - 1)\n                    }),\n                    _min: int256(uint256(config.minimumBaseFee)),\n                    _max: int256(uint256(config.maximumBaseFee))\n                });\n            }\n\n            // Update new base fee, reset bought gas, and update block number.\n            params.prevBaseFee = uint128(uint256(newBaseFee));\n            params.prevBoughtGas = 0;\n            params.prevBlockNum = uint64(block.number);\n        }\n\n        // Make sure we can actually buy the resource amount requested by the user.\n        params.prevBoughtGas += _amount;\n        require(\n            int256(uint256(params.prevBoughtGas)) <= int256(uint256(config.maxResourceLimit)),\n            \"ResourceMetering: cannot buy more gas than available gas limit\"\n        );\n\n        // Determine the amount of ETH to be paid.\n        uint256 resourceCost = uint256(_amount) * uint256(params.prevBaseFee);\n\n        // We currently charge for this ETH amount as an L1 gas burn, so we convert the ETH amount\n        // into gas by dividing by the L1 base fee. We assume a minimum base fee of 1 gwei to avoid\n        // division by zero for L1s that don't support 1559 or to avoid excessive gas burns during\n        // periods of extremely low L1 demand. One-day average gas fee hasn't dipped below 1 gwei\n        // during any 1 day period in the last 5 years, so should be fine.\n        uint256 gasCost = resourceCost / Math.max(block.basefee, 1 gwei);\n\n        // Give the user a refund based on the amount of gas they used to do all of the work up to\n        // this point. Since we're at the end of the modifier, this should be pretty accurate. Acts\n        // effectively like a dynamic stipend (with a minimum value).\n        uint256 usedGas = _initialGas - gasleft();\n        if (gasCost > usedGas) {\n            Burn.gas(gasCost - usedGas);\n        }\n    }\n\n    /**\n     * @notice Virtual function that returns the resource config. Contracts that inherit this\n     *         contract must implement this function.\n     *\n     * @return ResourceConfig\n     */\n    function _resourceConfig() internal virtual returns (ResourceConfig memory);\n\n    /**\n     * @notice Sets initial resource parameter values. This function must either be called by the\n     *         initializer function of an upgradeable child contract.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __ResourceMetering_init() internal onlyInitializing {\n        params = ResourceParams({\n            prevBaseFee: 1 gwei,\n            prevBoughtGas: 0,\n            prevBlockNum: uint64(block.number)\n        });\n    }\n}\n"
    },
    "contracts/L1/SecurityCouncil.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { TokenMultiSigWallet } from \"../universal/TokenMultiSigWallet.sol\";\nimport { ISemver } from \"../universal/ISemver.sol\";\nimport { Colosseum } from \"./Colosseum.sol\";\n\n/**\n * @custom:proxied\n * @title SecurityCouncil\n * @notice SecurityCouncil receives validation requests for specific output data,\n *         and allows security council parties to validate & agree on transactions before execution.\n */\ncontract SecurityCouncil is TokenMultiSigWallet, ISemver {\n    /**\n     * @notice The address of the colosseum contract. Can be updated via upgrade.\n     */\n    address public immutable COLOSSEUM;\n\n    /**\n     * @notice A mapping of outputs requested to be deleted.\n     */\n    mapping(uint256 => bool) public outputsDeleteRequested;\n\n    /**\n     * @notice Emitted when a validation request is submitted.\n     *\n     * @param transactionId Index of the submitted transaction.\n     * @param outputRoot    The L2 output of the checkpoint block to be validated.\n     * @param l2BlockNumber The L2 block number to be validated.\n     */\n    event ValidationRequested(\n        uint256 indexed transactionId,\n        bytes32 outputRoot,\n        uint256 l2BlockNumber\n    );\n\n    /**\n     * @notice Emitted when an output is requested to be deleted.\n     *\n     * @param transactionId Index of the requested transaction.\n     * @param outputIndex   Index of output to be deleted.\n     */\n    event DeletionRequested(uint256 indexed transactionId, uint256 indexed outputIndex);\n\n    /**\n     * @notice Disallow calls from anyone except Colosseum.\n     */\n    modifier onlyColosseum() {\n        require(\n            msg.sender == COLOSSEUM,\n            \"SecurityCouncil: only the colosseum contract can be a sender\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.1.0\n     */\n    string public constant version = \"1.1.0\";\n\n    /**\n     * @notice Constructs the SecurityCouncil contract.\n     *\n     * @param _colosseum Address of the Colosseum contract.\n     * @param _governor  Address of Governor contract.\n     */\n    constructor(address _colosseum, address payable _governor) TokenMultiSigWallet(_governor) {\n        COLOSSEUM = _colosseum;\n    }\n\n    /**\n     * @notice Allows the Colosseum to request for validate output data.\n     *\n     * @param _outputRoot    The L2 output of the checkpoint block to be validated.\n     * @param _l2BlockNumber The L2 block number to be validated.\n     * @param _data          Calldata for callback purpose.\n     */\n    function requestValidation(\n        bytes32 _outputRoot,\n        uint256 _l2BlockNumber,\n        bytes memory _data\n    ) public onlyColosseum {\n        uint256 transactionId = _submitTransaction(msg.sender, 0, _data);\n        emit ValidationRequested(transactionId, _outputRoot, _l2BlockNumber);\n    }\n\n    /**\n     * @notice Requests to delete an output to Colosseum forcefully.\n     *         This should only be called by one of the Security Council when undeniable bugs occur.\n     *\n     * @param _outputIndex Index of output to be deleted.\n     * @param _force       Option to forcibly make a request to delete the output.\n     */\n    function requestDeletion(uint256 _outputIndex, bool _force) public onlyTokenOwner(msg.sender) {\n        require(\n            !outputsDeleteRequested[_outputIndex] || _force,\n            \"SecurityCouncil: the output has already been requested to be deleted\"\n        );\n        bytes memory message = abi.encodeWithSelector(\n            Colosseum.forceDeleteOutput.selector,\n            _outputIndex\n        );\n        uint256 transactionId = submitTransaction(address(COLOSSEUM), 0, message);\n        // auto-confirmed by requester\n        confirmTransaction(transactionId);\n        outputsDeleteRequested[_outputIndex] = true;\n        emit DeletionRequested(transactionId, _outputIndex);\n    }\n}\n"
    },
    "contracts/L1/SystemConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { ISemver } from \"../universal/ISemver.sol\";\nimport { ResourceMetering } from \"./ResourceMetering.sol\";\n\n/**\n * @title SystemConfig\n * @notice The SystemConfig contract is used to manage configuration of a Kroma network. All\n *         configuration is stored on L1 and picked up by L2 as part of the derivation of the L2\n *         chain.\n */\ncontract SystemConfig is OwnableUpgradeable, ISemver {\n    /**\n     * @notice Enum representing different types of updates.\n     *\n     * @custom:value BATCHER                 Represents an update to the batcher hash.\n     * @custom:value GAS_CONFIG              Represents an update to txn fee config on L2.\n     * @custom:value GAS_LIMIT               Represents an update to gas limit on L2.\n     * @custom:value UNSAFE_BLOCK_SIGNER     Represents an update to the signer key for unsafe\n     *                                       block distribution.\n     * @custom:value VALIDATOR_REWARD_SCALAR Represents an update to validator reward scalar.\n     */\n    enum UpdateType {\n        BATCHER,\n        GAS_CONFIG,\n        GAS_LIMIT,\n        UNSAFE_BLOCK_SIGNER,\n        VALIDATOR_REWARD_SCALAR\n    }\n\n    /**\n     * @notice Version identifier, used for upgrades.\n     */\n    uint256 public constant VERSION = 0;\n\n    /**\n     * @notice Storage slot that the unsafe block signer is stored at. Storing it at this\n     *         deterministic storage slot allows for decoupling the storage layout from the way\n     *         that `solc` lays out storage. The `kroma-node` uses a storage proof to fetch this value.\n     */\n    bytes32 public constant UNSAFE_BLOCK_SIGNER_SLOT = keccak256(\"systemconfig.unsafeblocksigner\");\n\n    /**\n     * @notice Fixed L2 gas overhead. Used as part of the L2 fee calculation.\n     */\n    uint256 public overhead;\n\n    /**\n     * @notice Dynamic L2 gas overhead. Used as part of the L2 fee calculation.\n     */\n    uint256 public scalar;\n\n    /**\n     * @notice Identifier for the batcher. For version 1 of this configuration, this is represented\n     *         as an address left-padded with zeros to 32 bytes.\n     */\n    bytes32 public batcherHash;\n\n    /**\n     * @notice L2 block gas limit.\n     */\n    uint64 public gasLimit;\n\n    /**\n     * @notice The configuration for the deposit fee market. Used by the KromaPortal\n     *         to meter the cost of buying L2 gas on L1. Set as internal and wrapped with a getter\n     *         so that the struct is returned instead of a tuple.\n     */\n    ResourceMetering.ResourceConfig internal _resourceConfig;\n\n    /**\n     * @notice The scalar value to distribute transaction fees as validator reward.\n     *         The denominator is 10000, so the ratio is expressed in 4 decimal places.\n     */\n    uint256 public validatorRewardScalar;\n\n    /**\n     * @notice Emitted when configuration is updated\n     *\n     * @param version    SystemConfig version.\n     * @param updateType Type of update.\n     * @param data       Encoded update data.\n     */\n    event ConfigUpdate(uint256 indexed version, UpdateType indexed updateType, bytes data);\n\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.0.0\n     */\n    string public constant version = \"1.0.0\";\n\n    /**\n     * @notice Constructs the SystemConfig contract.\n     *\n     * @param _owner                 Initial owner of the contract.\n     * @param _overhead              Initial overhead value.\n     * @param _scalar                Initial scalar value.\n     * @param _batcherHash           Initial batcher hash.\n     * @param _gasLimit              Initial gas limit.\n     * @param _unsafeBlockSigner     Initial unsafe block signer address.\n     * @param _config                Initial resource config.\n     * @param _validatorRewardScalar Initial validator reward scalar.\n     */\n    constructor(\n        address _owner,\n        uint256 _overhead,\n        uint256 _scalar,\n        bytes32 _batcherHash,\n        uint64 _gasLimit,\n        address _unsafeBlockSigner,\n        ResourceMetering.ResourceConfig memory _config,\n        uint256 _validatorRewardScalar\n    ) {\n        initialize(\n            _owner,\n            _overhead,\n            _scalar,\n            _batcherHash,\n            _gasLimit,\n            _unsafeBlockSigner,\n            _config,\n            _validatorRewardScalar\n        );\n    }\n\n    /**\n     * @notice Initializer. The resource config must be set before the\n     *         require check.\n     *\n     * @param _owner                 Initial owner of the contract.\n     * @param _overhead              Initial overhead value.\n     * @param _scalar                Initial scalar value.\n     * @param _batcherHash           Initial batcher hash.\n     * @param _gasLimit              Initial gas limit.\n     * @param _unsafeBlockSigner     Initial unsafe block signer address.\n     * @param _config                Initial ResourceConfig.\n     * @param _validatorRewardScalar Initial validator reward scalar.\n     */\n    function initialize(\n        address _owner,\n        uint256 _overhead,\n        uint256 _scalar,\n        bytes32 _batcherHash,\n        uint64 _gasLimit,\n        address _unsafeBlockSigner,\n        ResourceMetering.ResourceConfig memory _config,\n        uint256 _validatorRewardScalar\n    ) public initializer {\n        __Ownable_init();\n        transferOwnership(_owner);\n        overhead = _overhead;\n        scalar = _scalar;\n        batcherHash = _batcherHash;\n        gasLimit = _gasLimit;\n        _setUnsafeBlockSigner(_unsafeBlockSigner);\n        _setResourceConfig(_config);\n        require(_gasLimit >= minimumGasLimit(), \"SystemConfig: gas limit too low\");\n        validatorRewardScalar = _validatorRewardScalar;\n    }\n\n    /**\n     * @notice Returns the minimum L2 gas limit that can be safely set for the system to\n     *         operate. The L2 gas limit must be larger than or equal to the amount of\n     *         gas that is allocated for deposits per block plus the amount of gas that\n     *         is allocated for the system transaction.\n     *         This function is used to determine if changes to parameters are safe.\n     *\n     * @return uint64\n     */\n    function minimumGasLimit() public view returns (uint64) {\n        return uint64(_resourceConfig.maxResourceLimit) + uint64(_resourceConfig.systemTxMaxGas);\n    }\n\n    /**\n     * @notice High level getter for the unsafe block signer address. Unsafe blocks can be\n     *         propagated across the p2p network if they are signed by the key corresponding to\n     *         this address.\n     *\n     * @return Address of the unsafe block signer.\n     */\n    // solhint-disable-next-line ordering\n    function unsafeBlockSigner() external view returns (address) {\n        address addr;\n        bytes32 slot = UNSAFE_BLOCK_SIGNER_SLOT;\n        assembly {\n            addr := sload(slot)\n        }\n        return addr;\n    }\n\n    /**\n     * @notice Updates the unsafe block signer address.\n     *\n     * @param _unsafeBlockSigner New unsafe block signer address.\n     */\n    function setUnsafeBlockSigner(address _unsafeBlockSigner) external onlyOwner {\n        _setUnsafeBlockSigner(_unsafeBlockSigner);\n\n        bytes memory data = abi.encode(_unsafeBlockSigner);\n        emit ConfigUpdate(VERSION, UpdateType.UNSAFE_BLOCK_SIGNER, data);\n    }\n\n    /**\n     * @notice Updates the batcher hash.\n     *\n     * @param _batcherHash New batcher hash.\n     */\n    function setBatcherHash(bytes32 _batcherHash) external onlyOwner {\n        batcherHash = _batcherHash;\n\n        bytes memory data = abi.encode(_batcherHash);\n        emit ConfigUpdate(VERSION, UpdateType.BATCHER, data);\n    }\n\n    /**\n     * @notice Updates gas config.\n     *\n     * @param _overhead New overhead value.\n     * @param _scalar   New scalar value.\n     */\n    function setGasConfig(uint256 _overhead, uint256 _scalar) external onlyOwner {\n        overhead = _overhead;\n        scalar = _scalar;\n\n        bytes memory data = abi.encode(_overhead, _scalar);\n        emit ConfigUpdate(VERSION, UpdateType.GAS_CONFIG, data);\n    }\n\n    /**\n     * @notice Updates the L2 gas limit.\n     *\n     * @param _gasLimit New gas limit.\n     */\n    function setGasLimit(uint64 _gasLimit) external onlyOwner {\n        require(_gasLimit >= minimumGasLimit(), \"SystemConfig: gas limit too low\");\n        gasLimit = _gasLimit;\n\n        bytes memory data = abi.encode(_gasLimit);\n        emit ConfigUpdate(VERSION, UpdateType.GAS_LIMIT, data);\n    }\n\n    /**\n     * @notice Low level setter for the unsafe block signer address. This function exists to\n     *         deduplicate code around storing the unsafeBlockSigner address in storage.\n     *\n     * @param _unsafeBlockSigner New unsafeBlockSigner value.\n     */\n    function _setUnsafeBlockSigner(address _unsafeBlockSigner) internal {\n        bytes32 slot = UNSAFE_BLOCK_SIGNER_SLOT;\n        assembly {\n            sstore(slot, _unsafeBlockSigner)\n        }\n    }\n\n    /**\n     * @notice A getter for the resource config. Ensures that the struct is\n     *         returned instead of a tuple.\n     *\n     * @return ResourceConfig\n     */\n    function resourceConfig() external view returns (ResourceMetering.ResourceConfig memory) {\n        return _resourceConfig;\n    }\n\n    /**\n     * @notice An external setter for the resource config. In the future, this\n     *         method may emit an event that the `kroma-node` picks up for when the\n     *         resource config is changed.\n     *\n     * @param _config The new resource config values.\n     */\n    function setResourceConfig(ResourceMetering.ResourceConfig memory _config) external onlyOwner {\n        _setResourceConfig(_config);\n    }\n\n    /**\n     * @notice An internal setter for the resource config. Ensures that the\n     *         config is sane before storing it by checking for invariants.\n     *\n     * @param _config The new resource config.\n     */\n    function _setResourceConfig(ResourceMetering.ResourceConfig memory _config) internal {\n        // Min base fee must be less than or equal to max base fee.\n        require(\n            _config.minimumBaseFee <= _config.maximumBaseFee,\n            \"SystemConfig: min base fee must be less than max base\"\n        );\n        // Base fee change denominator must be greater than 1.\n        require(\n            _config.baseFeeMaxChangeDenominator > 1,\n            \"SystemConfig: denominator must be larger than 1\"\n        );\n        // Max resource limit plus system tx gas must be less than or equal to the L2 gas limit.\n        // The gas limit must be increased before these values can be increased.\n        require(\n            _config.maxResourceLimit + _config.systemTxMaxGas <= gasLimit,\n            \"SystemConfig: gas limit too low\"\n        );\n        // Elasticity multiplier must be greater than 0.\n        require(\n            _config.elasticityMultiplier > 0,\n            \"SystemConfig: elasticity multiplier cannot be 0\"\n        );\n        // No precision loss when computing target resource limit.\n        require(\n            ((_config.maxResourceLimit / _config.elasticityMultiplier) *\n                _config.elasticityMultiplier) == _config.maxResourceLimit,\n            \"SystemConfig: precision loss with target resource limit\"\n        );\n\n        _resourceConfig = _config;\n    }\n\n    /**\n     * @notice Updates the validator reward scalar.\n     *\n     * @param _validatorRewardScalar New validator reward scalar.\n     */\n    function setValidatorRewardScalar(uint256 _validatorRewardScalar) external onlyOwner {\n        require(\n            _validatorRewardScalar <= Constants.VALIDATOR_REWARD_DENOMINATOR,\n            \"SystemConfig: the max value of validator reward scalar has been exceeded\"\n        );\n\n        validatorRewardScalar = _validatorRewardScalar;\n\n        bytes memory data = abi.encode(_validatorRewardScalar);\n        emit ConfigUpdate(VERSION, UpdateType.VALIDATOR_REWARD_SCALAR, data);\n    }\n}\n"
    },
    "contracts/L1/ValidatorManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { Atan2 } from \"../libraries/Atan2.sol\";\nimport { BalancedWeightTree } from \"../libraries/BalancedWeightTree.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Uint128Math } from \"../libraries/Uint128Math.sol\";\nimport { ISemver } from \"../universal/ISemver.sol\";\nimport { AssetManager } from \"./AssetManager.sol\";\nimport { IValidatorManager } from \"./interfaces/IValidatorManager.sol\";\nimport { L2OutputOracle } from \"./L2OutputOracle.sol\";\n\n/**\n * @custom:proxied\n * @title ValidatorManager\n * @notice The ValidatorManager manages validator set and determines the next validator who can\n *         submit the checkpoint output to L2OutputOracle.\n */\ncontract ValidatorManager is ISemver, IValidatorManager {\n    using BalancedWeightTree for BalancedWeightTree.Tree;\n    using Uint128Math for uint128;\n    using Math for uint256;\n\n    /**\n     * @notice The denominator for the commission rate.\n     */\n    uint128 public constant COMMISSION_RATE_DENOM = 100;\n\n    /**\n     * @notice The numerator for the boosted reward.\n     */\n    uint128 public constant BOOSTED_REWARD_NUMERATOR = 40;\n\n    /**\n     * @notice The denominator for the boosted reward.\n     */\n    uint128 public constant BOOSTED_REWARD_DENOM = 100;\n\n    /**\n     * @notice Address of the L2OutputOracle contract. Can be updated via upgrade.\n     */\n    L2OutputOracle public immutable L2_ORACLE;\n\n    /**\n     * @notice The address of AssetManager contract. Can be updated via upgrade.\n     */\n    AssetManager public immutable ASSET_MANAGER;\n\n    /**\n     * @notice The address of the trusted validator.\n     */\n    address public immutable TRUSTED_VALIDATOR;\n\n    /**\n     * @notice Minimum amount to register as a validator. It should be equal or more than\n     *         ASSET_MANAGER.BOND_AMOUNT.\n     */\n    uint128 public immutable MIN_REGISTER_AMOUNT;\n\n    /**\n     * @notice Minimum amount to activate a validator and add it to the validator tree.\n     *         Note that only the active validators can submit outputs.\n     */\n    uint128 public immutable MIN_ACTIVATE_AMOUNT;\n\n    /**\n     * @notice The delay to finalize the commission rate change of the validator (in seconds).\n     */\n    uint128 public immutable COMMISSION_CHANGE_DELAY_SECONDS;\n\n    /**\n     * @notice The duration of a submission round for one output (in seconds).\n     *         Note that there are two submission rounds for an output: PRIORITY ROUND and PUBLIC\n     *         ROUND.\n     */\n    uint128 public immutable ROUND_DURATION_SECONDS;\n\n    /**\n     * @notice The minimum duration to get out of jail in output non-submissions penalty (in seconds).\n     */\n    uint128 public immutable SOFT_JAIL_PERIOD_SECONDS;\n\n    /**\n     * @notice The maximum duration to get out of jail in slashing penalty (in seconds).\n     */\n    uint128 public immutable HARD_JAIL_PERIOD_SECONDS;\n\n    /**\n     * @notice Maximum allowed number of output non-submissions in priority round before the\n     *         validator goes to jail.\n     */\n    uint128 public immutable JAIL_THRESHOLD;\n\n    /**\n     * @notice The max number of outputs to be finalized at once when distributing rewards.\n     */\n    uint128 public immutable MAX_OUTPUT_FINALIZATIONS;\n\n    /**\n     * @notice Amount of base reward for the validator.\n     */\n    uint128 public immutable BASE_REWARD;\n\n    /**\n     * @notice Address of the next validator with priority for submitting output.\n     */\n    address internal _nextPriorityValidator;\n\n    /**\n     * @notice Weighted tree to store and calculate the probability to be selected as an output submitter.\n     */\n    BalancedWeightTree.Tree internal _validatorTree;\n\n    /**\n     * @notice A mapping of the validator to the validator information.\n     */\n    mapping(address => Validator) internal _validatorInfo;\n\n    /**\n     * @notice A mapping of the jailed validator to the jail expiration timestamp.\n     */\n    mapping(address => uint128) internal _jail;\n\n    /**\n     * @notice A mapping of output index challenged successfully to pending challenge rewards.\n     */\n    mapping(uint256 => uint128) internal _pendingChallengeReward;\n\n    /**\n     * @notice A modifier that only allows L2OutputOracle contract to call.\n     */\n    modifier onlyL2OutputOracle() {\n        if (msg.sender != address(L2_ORACLE)) revert NotAllowedCaller();\n        _;\n    }\n\n    /**\n     * @notice A modifier that only allows Colosseum contract to call.\n     */\n    modifier onlyColosseum() {\n        if (msg.sender != L2_ORACLE.COLOSSEUM()) revert NotAllowedCaller();\n        _;\n    }\n\n    /**\n     * @notice A modifier that only allows AssetManager contract to call.\n     */\n    modifier onlyAssetManager() {\n        if (msg.sender != address(ASSET_MANAGER)) revert NotAllowedCaller();\n        _;\n    }\n\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.0.0\n     */\n    string public constant version = \"1.0.0\";\n\n    /**\n     * @notice Constructs the ValidatorManager contract.\n     *\n     * @param _constructorParams The constructor parameters.\n     */\n    constructor(ConstructorParams memory _constructorParams) {\n        if (_constructorParams._minRegisterAmount > _constructorParams._minActivateAmount)\n            revert InvalidConstructorParams();\n\n        L2_ORACLE = _constructorParams._l2Oracle;\n        ASSET_MANAGER = _constructorParams._assetManager;\n        TRUSTED_VALIDATOR = _constructorParams._trustedValidator;\n        MIN_REGISTER_AMOUNT = _constructorParams._minRegisterAmount;\n        MIN_ACTIVATE_AMOUNT = _constructorParams._minActivateAmount;\n        COMMISSION_CHANGE_DELAY_SECONDS = _constructorParams._commissionChangeDelaySeconds;\n        // Note that this value MUST be (SUBMISSION_INTERVAL * L2_BLOCK_TIME) / 2.\n        ROUND_DURATION_SECONDS = _constructorParams._roundDurationSeconds;\n        SOFT_JAIL_PERIOD_SECONDS = _constructorParams._softJailPeriodSeconds;\n        HARD_JAIL_PERIOD_SECONDS = _constructorParams._hardJailPeriodSeconds;\n        JAIL_THRESHOLD = _constructorParams._jailThreshold;\n        MAX_OUTPUT_FINALIZATIONS = _constructorParams._maxOutputFinalizations;\n        BASE_REWARD = _constructorParams._baseReward;\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function registerValidator(\n        uint128 assets,\n        uint8 commissionRate,\n        address withdrawAccount\n    ) external {\n        if (msg.sender.code.length > 0 || msg.sender != tx.origin) revert NotAllowedCaller();\n        if (getStatus(msg.sender) != ValidatorStatus.NONE) revert ImproperValidatorStatus();\n        if (assets < MIN_REGISTER_AMOUNT) revert InsufficientAsset();\n        if (commissionRate > COMMISSION_RATE_DENOM) revert MaxCommissionRateExceeded();\n\n        Validator storage validatorInfo = _validatorInfo[msg.sender];\n        validatorInfo.isInitiated = true;\n        validatorInfo.commissionRate = commissionRate;\n\n        ASSET_MANAGER.depositToRegister(msg.sender, assets, withdrawAccount);\n\n        bool ready = assets >= MIN_ACTIVATE_AMOUNT;\n        if (ready) {\n            _activateValidator(msg.sender);\n        }\n\n        emit ValidatorRegistered(msg.sender, ready, commissionRate, assets);\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function activateValidator() external {\n        if (getStatus(msg.sender) != ValidatorStatus.READY || inJail(msg.sender))\n            revert ImproperValidatorStatus();\n\n        _activateValidator(msg.sender);\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function tryActivateValidator(address validator) external onlyAssetManager {\n        if (getStatus(validator) == ValidatorStatus.READY && !inJail(validator))\n            _activateValidator(validator);\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function afterSubmitL2Output(uint256 outputIndex) external onlyL2OutputOracle {\n        _distributeReward();\n\n        // Bond validator KRO to reserve slashing amount.\n        address submitter = L2_ORACLE.getSubmitter(outputIndex);\n        ASSET_MANAGER.bondValidatorKro(submitter);\n\n        if (submitter == _nextPriorityValidator) {\n            _resetNoSubmissionCount(submitter);\n        } else {\n            _tryJail();\n        }\n\n        // Select the next priority validator.\n        _updatePriorityValidator();\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function initCommissionChange(uint8 newCommissionRate) external {\n        if (getStatus(msg.sender) < ValidatorStatus.REGISTERED || inJail(msg.sender))\n            revert ImproperValidatorStatus();\n\n        if (newCommissionRate > COMMISSION_RATE_DENOM) revert MaxCommissionRateExceeded();\n\n        Validator storage validatorInfo = _validatorInfo[msg.sender];\n        uint8 oldCommissionRate = validatorInfo.commissionRate;\n        if (newCommissionRate == oldCommissionRate) revert SameCommissionRate();\n\n        validatorInfo.pendingCommissionRate = newCommissionRate;\n        validatorInfo.commissionChangeInitiatedAt = uint128(block.timestamp);\n\n        emit ValidatorCommissionChangeInitiated(msg.sender, oldCommissionRate, newCommissionRate);\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function finalizeCommissionChange() external {\n        if (getStatus(msg.sender) < ValidatorStatus.REGISTERED || inJail(msg.sender))\n            revert ImproperValidatorStatus();\n\n        uint128 canFinalizeAt = canFinalizeCommissionChangeAt(msg.sender);\n        if (canFinalizeAt == COMMISSION_CHANGE_DELAY_SECONDS) revert NotInitiatedCommissionChange();\n        if (block.timestamp < canFinalizeAt) revert NotElapsedCommissionChangeDelay();\n\n        Validator storage validatorInfo = _validatorInfo[msg.sender];\n        uint8 oldCommissionRate = validatorInfo.commissionRate;\n        uint8 newCommissionRate = validatorInfo.pendingCommissionRate;\n\n        validatorInfo.commissionRate = newCommissionRate;\n        validatorInfo.pendingCommissionRate = 0;\n        validatorInfo.commissionChangeInitiatedAt = 0;\n\n        emit ValidatorCommissionChangeFinalized(msg.sender, oldCommissionRate, newCommissionRate);\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function tryUnjail() external {\n        if (!inJail(msg.sender)) revert ImproperValidatorStatus();\n        if (_jail[msg.sender] > block.timestamp) revert NotElapsedJailPeriod();\n\n        _resetNoSubmissionCount(msg.sender);\n        delete _jail[msg.sender];\n\n        emit ValidatorUnjailed(msg.sender);\n\n        if (getStatus(msg.sender) == ValidatorStatus.READY) {\n            _activateValidator(msg.sender);\n        }\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function bondValidatorKro(address validator) external onlyColosseum {\n        ASSET_MANAGER.bondValidatorKro(validator);\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function unbondValidatorKro(address validator) external onlyColosseum {\n        ASSET_MANAGER.unbondValidatorKro(validator);\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function slash(uint256 outputIndex, address winner, address loser) external onlyColosseum {\n        uint128 challengeReward = ASSET_MANAGER.decreaseBalanceWithChallenge(loser);\n\n        emit Slashed(outputIndex, loser, challengeReward);\n\n        _sendToJail(loser, false);\n\n        if (L2_ORACLE.nextFinalizeOutputIndex() <= outputIndex) {\n            // If output is not rewarded yet, add slashing asset to the pending challenge reward.\n            unchecked {\n                _pendingChallengeReward[outputIndex] += challengeReward;\n            }\n        } else {\n            // If output is already rewarded, add slashing asset to the winner's asset directly.\n            challengeReward = ASSET_MANAGER.increaseBalanceWithChallenge(winner, challengeReward);\n            updateValidatorTree(winner, false);\n\n            emit ChallengeRewardDistributed(outputIndex, winner, challengeReward);\n        }\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function revertSlash(uint256 outputIndex, address loser) external onlyColosseum {\n        uint128 challengeReward = ASSET_MANAGER.revertDecreaseBalanceWithChallenge(loser);\n        unchecked {\n            _pendingChallengeReward[outputIndex] -= challengeReward;\n        }\n\n        emit SlashReverted(outputIndex, loser, challengeReward);\n\n        if (inJail(loser)) {\n            // Revert jail expiration timestamp of the original loser.\n            uint128 expiresAt = _jail[loser] - HARD_JAIL_PERIOD_SECONDS;\n            if (block.timestamp < expiresAt) {\n                _jail[loser] = expiresAt;\n\n                emit ValidatorJailed(loser, expiresAt);\n            } else {\n                delete _jail[loser];\n\n                emit ValidatorUnjailed(loser);\n\n                if (getStatus(loser) == ValidatorStatus.READY) {\n                    _activateValidator(loser);\n                }\n            }\n        }\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function checkSubmissionEligibility(address validator) external view onlyL2OutputOracle {\n        address _nextValidator = nextValidator();\n        if (\n            _nextValidator != Constants.VALIDATOR_PUBLIC_ROUND_ADDRESS &&\n            validator != _nextValidator\n        ) revert NotSelectedPriorityValidator();\n\n        if (!isActive(validator)) revert ImproperValidatorStatus();\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function getCommissionRate(address validator) external view returns (uint8) {\n        return _validatorInfo[validator].commissionRate;\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function getPendingCommissionRate(address validator) external view returns (uint8) {\n        return _validatorInfo[validator].pendingCommissionRate;\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function activatedValidatorCount() external view returns (uint32) {\n        return _validatorTree.counter - _validatorTree.removed;\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function getWeight(address validator) external view returns (uint120) {\n        return _validatorTree.nodes[_validatorTree.nodeMap[validator]].weight;\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function jailExpiresAt(address validator) external view returns (uint128) {\n        return _jail[validator];\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function updateValidatorTree(address validator, bool tryRemove) public {\n        ValidatorStatus status = getStatus(validator);\n        if (tryRemove && (status == ValidatorStatus.EXITED || status == ValidatorStatus.INACTIVE)) {\n            if (_validatorTree.remove(validator)) emit ValidatorStopped(validator, block.timestamp);\n        } else if (status >= ValidatorStatus.INACTIVE) {\n            _validatorTree.update(validator, uint120(ASSET_MANAGER.reflectiveWeight(validator)));\n        }\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function nextValidator() public view returns (address) {\n        if (_nextPriorityValidator != address(0)) {\n            uint256 l2Timestamp = L2_ORACLE.nextOutputMinL2Timestamp();\n            if (block.timestamp >= l2Timestamp) {\n                uint256 elapsed = block.timestamp - l2Timestamp;\n                // If the current time exceeds one round time, it is a public round.\n                if (elapsed > ROUND_DURATION_SECONDS) {\n                    return Constants.VALIDATOR_PUBLIC_ROUND_ADDRESS;\n                }\n            }\n\n            return _nextPriorityValidator;\n        } else {\n            return TRUSTED_VALIDATOR;\n        }\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function getStatus(address validator) public view returns (ValidatorStatus) {\n        if (!_validatorInfo[validator].isInitiated) {\n            return ValidatorStatus.NONE;\n        }\n\n        if (ASSET_MANAGER.totalValidatorKro(validator) < MIN_REGISTER_AMOUNT) {\n            return ValidatorStatus.EXITED;\n        }\n\n        bool activated = _validatorTree.nodeMap[validator] > 0;\n\n        if (ASSET_MANAGER.reflectiveWeight(validator) < MIN_ACTIVATE_AMOUNT) {\n            if (!activated) {\n                return ValidatorStatus.REGISTERED;\n            }\n            return ValidatorStatus.INACTIVE;\n        }\n\n        if (!activated) {\n            return ValidatorStatus.READY;\n        }\n        return ValidatorStatus.ACTIVE;\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function inJail(address validator) public view returns (bool) {\n        return _jail[validator] != 0;\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function isActive(address validator) public view returns (bool) {\n        if (getStatus(validator) == ValidatorStatus.ACTIVE) return true;\n        return false;\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function noSubmissionCount(address validator) public view returns (uint8) {\n        return _validatorInfo[validator].noSubmissionCount;\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function canFinalizeCommissionChangeAt(address validator) public view returns (uint128) {\n        return\n            _validatorInfo[validator].commissionChangeInitiatedAt + COMMISSION_CHANGE_DELAY_SECONDS;\n    }\n\n    /**\n     * @inheritdoc IValidatorManager\n     */\n    function activatedValidatorTotalWeight() public view returns (uint120) {\n        return _validatorTree.nodes[_validatorTree.root].weightSum;\n    }\n\n    /**\n     * @notice Private function to activate a validator and adds the validator to validator tree.\n     *\n     * @param validator Address of the validator.\n     */\n    function _activateValidator(address validator) private {\n        _validatorTree.insert(validator, uint120(ASSET_MANAGER.reflectiveWeight(validator)));\n\n        emit ValidatorActivated(validator, block.timestamp);\n    }\n\n    /**\n     * @notice Private function to add output submission rewards to the vaults of finalized output\n     *         submitters.\n     *\n     * @return Whether the reward distribution is done at least once or not.\n     */\n    function _distributeReward() private returns (bool) {\n        uint256 outputIndex = L2_ORACLE.nextFinalizeOutputIndex();\n        uint256 latestOutputIndex = L2_ORACLE.latestOutputIndex();\n\n        if (!L2_ORACLE.VALIDATOR_POOL().isTerminated(outputIndex)) {\n            return false;\n        }\n\n        uint128 finalizedOutputNum = 0;\n        address submitter;\n\n        while (finalizedOutputNum < MAX_OUTPUT_FINALIZATIONS && outputIndex <= latestOutputIndex) {\n            if (L2_ORACLE.isFinalized(outputIndex)) {\n                submitter = L2_ORACLE.getSubmitter(outputIndex);\n\n                (\n                    uint128 baseReward,\n                    uint128 boostedReward,\n                    uint128 validatorReward\n                ) = _calculateReward(submitter);\n\n                ASSET_MANAGER.increaseBalanceWithReward(\n                    submitter,\n                    baseReward,\n                    boostedReward,\n                    validatorReward\n                );\n\n                emit RewardDistributed(\n                    outputIndex,\n                    submitter,\n                    validatorReward,\n                    baseReward,\n                    boostedReward\n                );\n\n                uint128 challengeReward = _pendingChallengeReward[outputIndex];\n                if (challengeReward > 0) {\n                    challengeReward = ASSET_MANAGER.increaseBalanceWithChallenge(\n                        submitter,\n                        challengeReward\n                    );\n                    delete _pendingChallengeReward[outputIndex];\n\n                    emit ChallengeRewardDistributed(outputIndex, submitter, challengeReward);\n                }\n\n                updateValidatorTree(submitter, false);\n\n                unchecked {\n                    ++outputIndex;\n                    ++finalizedOutputNum;\n                }\n            } else {\n                break;\n            }\n        }\n\n        if (finalizedOutputNum > 0) {\n            L2_ORACLE.setNextFinalizeOutputIndex(outputIndex);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice Internal function to get the boosted reward with the number of KGH.\n     *\n     * @param validator Address of the validator.\n     *\n     * @return The boosted reward with the number of KGH.\n     */\n    function _getBoostedReward(address validator) internal view returns (uint128) {\n        uint128 numKgh = ASSET_MANAGER.totalKghNum(validator);\n        uint128 coefficient = BASE_REWARD.mulDiv(BOOSTED_REWARD_NUMERATOR, BOOSTED_REWARD_DENOM);\n        return uint128(Atan2.atan2(numKgh, 100).mulDiv(coefficient, 1 << 40));\n    }\n\n    /**\n     * @notice Internal function to calculate the reward of the validator when distributing reward.\n     *\n     * @param validator Address of the validator.\n     *\n     * @return The amount of base reward, excluding base reward for the validator.\n     * @return The amount of boosted reward.\n     * @return The amount of reward from commission and base reward for the validator.\n     */\n    function _calculateReward(address validator) internal view returns (uint128, uint128, uint128) {\n        if (validator == ASSET_MANAGER.SECURITY_COUNCIL()) {\n            return (0, 0, BASE_REWARD);\n        }\n\n        uint128 commissionRate = _validatorInfo[validator].commissionRate;\n        uint128 boostedReward = _getBoostedReward(validator);\n        uint128 baseReward;\n        uint128 validatorReward;\n\n        unchecked {\n            validatorReward = (BASE_REWARD + boostedReward).mulDiv(\n                commissionRate,\n                COMMISSION_RATE_DENOM\n            );\n            baseReward = BASE_REWARD.mulDiv(\n                COMMISSION_RATE_DENOM - commissionRate,\n                COMMISSION_RATE_DENOM\n            );\n            boostedReward = boostedReward.mulDiv(\n                COMMISSION_RATE_DENOM - commissionRate,\n                COMMISSION_RATE_DENOM\n            );\n\n            uint128 validatorKro = ASSET_MANAGER.totalValidatorKro(validator);\n            uint128 totalKro = ASSET_MANAGER.totalKroAssets(validator);\n            uint128 validatorBaseReward = baseReward.mulDiv(validatorKro, totalKro + validatorKro);\n            // Exclude the base reward for the validator from total base reward given to KRO delegators.\n            baseReward -= validatorBaseReward;\n            validatorReward += validatorBaseReward;\n        }\n\n        return (baseReward, boostedReward, validatorReward);\n    }\n\n    /**\n     * @notice Updates next priority validator address. Validators with more delegation tokens have\n     *         a higher probability of being selected. The random weight selection is based on the\n     *         last finalized output root.\n     */\n    function _updatePriorityValidator() private {\n        uint120 weightSum = activatedValidatorTotalWeight();\n        uint256 nextFinalizeOutputIndex = L2_ORACLE.nextFinalizeOutputIndex();\n\n        if (weightSum > 0 && nextFinalizeOutputIndex > 0) {\n            Types.CheckpointOutput memory output = L2_ORACLE.getL2Output(\n                nextFinalizeOutputIndex - 1\n            );\n\n            uint120 weight = uint120(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            output.outputRoot,\n                            block.number,\n                            block.coinbase,\n                            block.difficulty,\n                            blockhash(block.number - 1)\n                        )\n                    )\n                )\n            ) % weightSum;\n\n            _nextPriorityValidator = _validatorTree.select(weight);\n        } else {\n            _nextPriorityValidator = address(0);\n        }\n    }\n\n    /**\n     * @notice Attempts to jail a validator who was selected as a priority validator for this\n     *         submission round but did not submit the output. The period to get out of jail is\n     *         SOFT_JAIL_PERIOD_SECONDS.\n     */\n    function _tryJail() private {\n        if (_nextPriorityValidator == address(0)) return;\n\n        if (_validatorInfo[_nextPriorityValidator].noSubmissionCount >= JAIL_THRESHOLD) {\n            _sendToJail(_nextPriorityValidator, true);\n        } else {\n            unchecked {\n                _validatorInfo[_nextPriorityValidator].noSubmissionCount++;\n            }\n        }\n    }\n\n    /**\n     * @notice Send the given validator to the jail and remove from the validator tree.\n     *\n     * @param validator Address of the validator.\n     * @param isSoft    Whether the jail is soft or hard.\n     */\n    function _sendToJail(address validator, bool isSoft) private {\n        uint128 jailSeconds = isSoft ? SOFT_JAIL_PERIOD_SECONDS : HARD_JAIL_PERIOD_SECONDS;\n        uint128 expiresAt = _jail[validator].max(uint128(block.timestamp)) + jailSeconds;\n        _jail[validator] = expiresAt;\n\n        emit ValidatorJailed(validator, expiresAt);\n\n        if (_validatorTree.remove(validator)) emit ValidatorStopped(validator, block.timestamp);\n    }\n\n    /**\n     * @notice Attempts to reset non-submission count of a validator.\n     *\n     * @param validator Address of the validator.\n     */\n    function _resetNoSubmissionCount(address validator) private {\n        if (noSubmissionCount(validator) > 0) {\n            _validatorInfo[validator].noSubmissionCount = 0;\n        }\n    }\n}\n"
    },
    "contracts/L1/ValidatorPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    ReentrancyGuardUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { ISemver } from \"../universal/ISemver.sol\";\nimport { ValidatorRewardVault } from \"../L2/ValidatorRewardVault.sol\";\nimport { KromaPortal } from \"./KromaPortal.sol\";\nimport { L2OutputOracle } from \"./L2OutputOracle.sol\";\n\n/**\n * @custom:proxied\n * @title ValidatorPool\n * @notice The ValidatorPool determines whether the validator is present and manages the validator's deposit.\n */\ncontract ValidatorPool is ReentrancyGuardUpgradeable, ISemver {\n    /**\n     * @notice The gas limit to use when rewarding validator in the ValidatorRewardVault on L2.\n     *         This value is measured through simulation.\n     */\n    uint64 public constant VAULT_REWARD_GAS_LIMIT = 100000;\n\n    /**\n     * @notice The numerator of the tax.\n     */\n    uint128 public constant TAX_NUMERATOR = 20;\n\n    /**\n     * @notice The denominator of the tax.\n     */\n    uint128 public constant TAX_DENOMINATOR = 100;\n\n    /**\n     * @notice The address of the L2OutputOracle contract. Can be updated via upgrade.\n     */\n    L2OutputOracle public immutable L2_ORACLE;\n\n    /**\n     * @notice The address of the KromaPortal contract. Can be updated via upgrade.\n     */\n    KromaPortal public immutable PORTAL;\n\n    /**\n     * @notice The address of the SecurityCouncil contract. Can be updated via upgrade.\n     */\n    address public immutable SECURITY_COUNCIL;\n\n    /**\n     * @notice The address of the trusted validator. Can be updated via upgrade.\n     */\n    address public immutable TRUSTED_VALIDATOR;\n\n    /**\n     * @notice The required bond amount. Can be updated via upgrade.\n     */\n    uint128 public immutable REQUIRED_BOND_AMOUNT;\n\n    /**\n     * @notice The max number of unbonds when trying unbond.\n     */\n    uint256 public immutable MAX_UNBOND;\n\n    /**\n     * @notice The duration of a submission round for one output (in seconds).\n     *         Note that there are two submission rounds for an output: PRIORITY ROUND and PUBLIC ROUND.\n     */\n    uint256 public immutable ROUND_DURATION;\n\n    /**\n     * @notice The output index where ValidatorPool is terminated after. Validator system is\n     *         upgraded to ValidatorManager.\n     */\n    uint256 public immutable TERMINATE_OUTPUT_INDEX;\n\n    /**\n     * @notice A mapping of balances.\n     */\n    mapping(address => uint256) internal balances;\n\n    /**\n     * @notice The bond corresponding to a specific output index.\n     */\n    mapping(uint256 => Types.Bond) internal bonds;\n\n    /**\n     * @notice The output index to unbond next.\n     */\n    uint256 internal nextUnbondOutputIndex;\n\n    /**\n     * @notice An array of validator addresses.\n     */\n    address[] internal validators;\n\n    /**\n     * @notice The index of the specific address in the validator array.\n     */\n    mapping(address => uint256) internal validatorIndexes;\n\n    /**\n     * @notice Address of the next validator with priority for submitting output.\n     */\n    address internal nextPriorityValidator;\n\n    /**\n     * @notice A mapping of pending bonds that have not yet been included in a bond.\n     */\n    mapping(uint256 => mapping(address => uint128)) internal pendingBonds;\n\n    /**\n     * @notice Emitted when a validator bonds.\n     *\n     * @param submitter   Address of submitter.\n     * @param outputIndex Index of the L2 checkpoint output index.\n     * @param amount      Amount of bonded.\n     * @param expiresAt   The expiration timestamp of bond.\n     */\n    event Bonded(\n        address indexed submitter,\n        uint256 indexed outputIndex,\n        uint128 amount,\n        uint128 expiresAt\n    );\n\n    /**\n     * @notice Emitted when the pending bond is added.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param challenger  Address of the challenger.\n     * @param amount      Amount of bond added.\n     */\n    event PendingBondAdded(uint256 indexed outputIndex, address indexed challenger, uint128 amount);\n\n    /**\n     * @notice Emitted when the bond is increased.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param challenger  Address of the challenger.\n     * @param amount      Amount of bond increased.\n     */\n    event BondIncreased(uint256 indexed outputIndex, address indexed challenger, uint128 amount);\n\n    /**\n     * @notice Emitted when the pending bond is released(refunded).\n     *\n     * @param outputIndex  Index of the L2 checkpoint output.\n     * @param challenger   Address of the challenger.\n     * @param recipient    Address to receive amount from a pending bond.\n     * @param amount       Amount of bond released.\n     */\n    event PendingBondReleased(\n        uint256 indexed outputIndex,\n        address indexed challenger,\n        address indexed recipient,\n        uint128 amount\n    );\n\n    /**\n     * @notice Emitted when a validator unbonds.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param recipient   Address of the recipient.\n     * @param amount      Amount of unbonded.\n     */\n    event Unbonded(uint256 indexed outputIndex, address indexed recipient, uint128 amount);\n\n    /**\n     * @notice A modifier that only allows the Colosseum contract to call\n     */\n    modifier onlyColosseum() {\n        require(msg.sender == L2_ORACLE.COLOSSEUM(), \"ValidatorPool: sender is not Colosseum\");\n        _;\n    }\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.1.0\n     */\n    string public constant version = \"1.1.0\";\n\n    /**\n     * @notice Constructs the ValidatorPool contract.\n     *\n     * @param _l2OutputOracle       Address of the L2OutputOracle.\n     * @param _portal               Address of the KromaPortal.\n     * @param _securityCouncil      Address of the security council.\n     * @param _trustedValidator     Address of the trusted validator.\n     * @param _requiredBondAmount   The required bond amount.\n     * @param _maxUnbond            The max number of unbonds when trying unbond.\n     * @param _roundDuration        The duration of one submission round in seconds.\n     * @param _terminateOutputIndex The output index where ValidatorPool is terminated after.\n     */\n    constructor(\n        L2OutputOracle _l2OutputOracle,\n        KromaPortal _portal,\n        address _securityCouncil,\n        address _trustedValidator,\n        uint256 _requiredBondAmount,\n        uint256 _maxUnbond,\n        uint256 _roundDuration,\n        uint256 _terminateOutputIndex\n    ) {\n        L2_ORACLE = _l2OutputOracle;\n        PORTAL = _portal;\n        SECURITY_COUNCIL = _securityCouncil;\n        TRUSTED_VALIDATOR = _trustedValidator;\n        REQUIRED_BOND_AMOUNT = uint128(_requiredBondAmount);\n        MAX_UNBOND = _maxUnbond;\n        TERMINATE_OUTPUT_INDEX = _terminateOutputIndex;\n\n        // Note that this value MUST be (SUBMISSION_INTERVAL * L2_BLOCK_TIME) / 2.\n        ROUND_DURATION = _roundDuration;\n\n        initialize();\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize() public initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    /**\n     * @notice Deposit ETH to be used as bond. Note that deposit after termination is not allowed.\n     */\n    function deposit() external payable {\n        require(\n            L2_ORACLE.nextOutputIndex() < TERMINATE_OUTPUT_INDEX + 1,\n            \"ValidatorPool: only can deposit to ValidatorPool before terminated\"\n        );\n\n        _increaseBalance(msg.sender, msg.value);\n    }\n\n    /**\n     * @notice Withdraw a given amount.\n     *\n     * @param _amount Amount to withdraw.\n     */\n    function withdraw(uint256 _amount) external nonReentrant {\n        _decreaseBalance(msg.sender, _amount);\n\n        bool success = SafeCall.call(msg.sender, gasleft(), _amount, \"\");\n        require(success, \"ValidatorPool: ETH transfer failed\");\n    }\n\n    /**\n     * @notice Withdraw a given amount.\n     *\n     * @param _to     Address to withdraw asset to.\n     * @param _amount Amount to withdraw.\n     */\n    function withdrawTo(address _to, uint256 _amount) external nonReentrant {\n        require(_to != address(0), \"ValidatorPool: cannot withdraw to the zero address\");\n\n        _decreaseBalance(msg.sender, _amount);\n\n        bool success = SafeCall.call(_to, gasleft(), _amount, \"\");\n        require(success, \"ValidatorPool: ETH transfer failed\");\n    }\n\n    /**\n     * @notice Bond asset corresponding to the given output index.\n     *         This function is called when submitting output.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _expiresAt   The expiration timestamp of bond.\n     */\n    function createBond(uint256 _outputIndex, uint128 _expiresAt) external {\n        require(msg.sender == address(L2_ORACLE), \"ValidatorPool: sender is not L2OutputOracle\");\n\n        Types.Bond storage bond = bonds[_outputIndex];\n        require(\n            bond.expiresAt == 0,\n            \"ValidatorPool: bond of the given output index already exists\"\n        );\n\n        // Unbond the bond of nextUnbondOutputIndex if available.\n        _tryUnbond();\n\n        address submitter = L2_ORACLE.getSubmitter(_outputIndex);\n        _decreaseBalance(submitter, REQUIRED_BOND_AMOUNT);\n\n        bond.amount = REQUIRED_BOND_AMOUNT;\n        bond.expiresAt = _expiresAt;\n\n        emit Bonded(submitter, _outputIndex, REQUIRED_BOND_AMOUNT, _expiresAt);\n\n        // Select the next priority validator\n        _updatePriorityValidator();\n    }\n\n    /**\n     * @notice Adds a pending bond to the challenge corresponding to the given output index and challenger address.\n     *         The pending bond is added to the bond when the challenge is proven or challenger is timed out,\n     *         or refunded when the challenge is canceled.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _challenger  Address of the challenger.\n     */\n    function addPendingBond(uint256 _outputIndex, address _challenger) external onlyColosseum {\n        Types.Bond storage bond = bonds[_outputIndex];\n        require(\n            bond.expiresAt >= block.timestamp,\n            \"ValidatorPool: the output is already finalized\"\n        );\n\n        _decreaseBalance(_challenger, REQUIRED_BOND_AMOUNT);\n        pendingBonds[_outputIndex][_challenger] = REQUIRED_BOND_AMOUNT;\n\n        emit PendingBondAdded(_outputIndex, _challenger, REQUIRED_BOND_AMOUNT);\n    }\n\n    /**\n     * @notice Releases the corresponding pending bond to the given output index and challenger address\n     *         if a challenge is canceled.\n     *\n     * @param _outputIndex  Index of the L2 checkpoint output.\n     * @param _challenger   Address of the challenger.\n     * @param _recipient    Address to receive amount from a pending bond.\n     */\n    function releasePendingBond(\n        uint256 _outputIndex,\n        address _challenger,\n        address _recipient\n    ) external onlyColosseum {\n        uint128 bonded = pendingBonds[_outputIndex][_challenger];\n        require(bonded > 0, \"ValidatorPool: the pending bond does not exist\");\n        delete pendingBonds[_outputIndex][_challenger];\n\n        _increaseBalance(_recipient, bonded);\n        emit PendingBondReleased(_outputIndex, _challenger, _recipient, bonded);\n    }\n\n    /**\n     * @notice Increases the bond amount corresponding to the given output index by the pending bond amount.\n     *         This is when taxes are charged, and note that taxes are a means of preventing collusive attacks by\n     *         the asserter and challenger.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _challenger  Address of the challenger.\n     */\n    function increaseBond(uint256 _outputIndex, address _challenger) external onlyColosseum {\n        Types.Bond storage bond = bonds[_outputIndex];\n        require(\n            bond.expiresAt >= block.timestamp,\n            \"ValidatorPool: the output is already finalized\"\n        );\n\n        uint128 pendingBond = pendingBonds[_outputIndex][_challenger];\n        require(pendingBond > 0, \"ValidatorPool: the pending bond does not exist\");\n        uint128 tax = (pendingBond * TAX_NUMERATOR) / TAX_DENOMINATOR;\n        uint128 increased = pendingBond - tax;\n        delete pendingBonds[_outputIndex][_challenger];\n\n        unchecked {\n            bond.amount += increased;\n            balances[SECURITY_COUNCIL] += tax;\n        }\n\n        emit BondIncreased(_outputIndex, _challenger, increased);\n    }\n\n    /**\n     * @notice Attempt to unbond. Reverts if unbond is not possible.\n     */\n    function unbond() external {\n        bool released = _tryUnbond();\n        require(released, \"ValidatorPool: no bond that can be unbond\");\n    }\n\n    /**\n     * @notice Attempts to unbond starting from nextUnbondOutputIndex and returns whether at least\n     *         one unbond is executed. Tries unbond at most MAX_UNBOND number of bonds and sends\n     *         a reward message to L2 for each unbond.\n     *\n     * @return Whether at least one unbond is executed.\n     */\n    function _tryUnbond() private returns (bool) {\n        uint256 outputIndex = nextUnbondOutputIndex;\n        uint128 bondAmount;\n        Types.Bond storage bond;\n        Types.CheckpointOutput memory output;\n\n        uint256 unbondedNum = 0;\n        for (; unbondedNum < MAX_UNBOND; ) {\n            bond = bonds[outputIndex];\n            bondAmount = bond.amount;\n\n            if (block.timestamp >= bond.expiresAt && bondAmount > 0) {\n                delete bonds[outputIndex];\n                output = L2_ORACLE.getL2Output(outputIndex);\n                _increaseBalance(output.submitter, bondAmount);\n                emit Unbonded(outputIndex, output.submitter, bondAmount);\n\n                // Send reward message to L2 ValidatorRewardVault.\n                _sendRewardMessageToL2Vault(output);\n\n                unchecked {\n                    ++unbondedNum;\n                    ++outputIndex;\n                }\n            } else {\n                break;\n            }\n        }\n\n        if (unbondedNum > 0) {\n            unchecked {\n                nextUnbondOutputIndex = outputIndex;\n            }\n\n            // Set the next output index to be finalized in L2OutputOracle.\n            L2_ORACLE.setNextFinalizeOutputIndex(outputIndex);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice Updates next priority validator address.\n     */\n    function _updatePriorityValidator() private {\n        uint256 len = validators.length;\n        if (len > 0 && nextUnbondOutputIndex > 0) {\n            // TODO(pangssu): improve next validator selection\n            Types.CheckpointOutput memory output = L2_ORACLE.getL2Output(nextUnbondOutputIndex - 1);\n            uint256 validatorIndex = uint256(\n                keccak256(\n                    abi.encodePacked(\n                        output.outputRoot,\n                        block.number,\n                        block.coinbase,\n                        block.difficulty,\n                        blockhash(block.number - 1)\n                    )\n                )\n            ) % len;\n\n            nextPriorityValidator = validators[validatorIndex];\n        } else {\n            nextPriorityValidator = address(0);\n        }\n    }\n\n    /**\n     * @notice Sends reward message to ValidatorRewardVault contract on L2 using Portal.\n     *\n     * @param _output The finalized output.\n     */\n    function _sendRewardMessageToL2Vault(Types.CheckpointOutput memory _output) private {\n        // Pay out rewards via L2 Vault now that the output is finalized.\n        PORTAL.depositTransactionByValidatorPool(\n            Predeploys.VALIDATOR_REWARD_VAULT,\n            VAULT_REWARD_GAS_LIMIT,\n            abi.encodeWithSelector(\n                ValidatorRewardVault.reward.selector,\n                _output.submitter,\n                _output.l2BlockNumber\n            )\n        );\n    }\n\n    /**\n     * @notice Increases the balance of the given address. If the balance is greater than the required bond amount,\n     *         add the given address to the validator set.\n     *\n     * @param _validator Address to increase the balance.\n     * @param _amount    Amount of balance increased.\n     */\n    function _increaseBalance(address _validator, uint256 _amount) private {\n        uint256 balance = balances[_validator] + _amount;\n\n        if (balance >= REQUIRED_BOND_AMOUNT && !isValidator(_validator)) {\n            if (_validator != SECURITY_COUNCIL) {\n                validatorIndexes[_validator] = validators.length;\n                validators.push(_validator);\n            }\n        }\n\n        balances[_validator] = balance;\n    }\n\n    /**\n     * @notice Deceases the balance of the given address. If the balance is less than the required bond amount,\n     *         remove the given address from the validator set.\n     *\n     * @param _validator Address to decrease the balance.\n     * @param _amount    Amount of balance decreased.\n     */\n    function _decreaseBalance(address _validator, uint256 _amount) private {\n        uint256 balance = balances[_validator];\n        require(balance >= _amount, \"ValidatorPool: insufficient balances\");\n        balance = balance - _amount;\n\n        if (balance < REQUIRED_BOND_AMOUNT && isValidator(_validator)) {\n            uint256 lastValidatorIndex = validators.length - 1;\n            if (lastValidatorIndex > 0) {\n                uint256 validatorIndex = validatorIndexes[_validator];\n                address lastValidator = validators[lastValidatorIndex];\n\n                validators[validatorIndex] = lastValidator;\n                validatorIndexes[lastValidator] = validatorIndex;\n            }\n            delete validatorIndexes[_validator];\n            validators.pop();\n        }\n\n        balances[_validator] = balance;\n    }\n\n    /**\n     * @notice Returns the bond corresponding to the output index. Reverts if the bond does not exist.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     *\n     * @return The bond data.\n     */\n    function getBond(uint256 _outputIndex) external view returns (Types.Bond memory) {\n        Types.Bond storage bond = bonds[_outputIndex];\n        require(bond.amount > 0 && bond.expiresAt > 0, \"ValidatorPool: the bond does not exist\");\n        return bond;\n    }\n\n    /**\n     * @notice Returns the pending bond corresponding to the output index and challenger address.\n     *         Reverts if the pending bond does not exist.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     * @param _challenger  Address of the challenger.\n     *\n     * @return Amount of the pending bond.\n     */\n    function getPendingBond(\n        uint256 _outputIndex,\n        address _challenger\n    ) external view returns (uint128) {\n        uint128 pendingBond = pendingBonds[_outputIndex][_challenger];\n        require(pendingBond > 0, \"ValidatorPool: the pending bond does not exist\");\n        return pendingBond;\n    }\n\n    /**\n     * @notice Returns the balance of given address.\n     *\n     * @param _addr Address of validator.\n     *\n     * @return Balance of given address.\n     */\n    function balanceOf(address _addr) external view returns (uint256) {\n        return balances[_addr];\n    }\n\n    /**\n     * @notice Determines whether the given address is an active validator.\n     *\n     * @param _addr Address of validator.\n     *\n     * @return Whether the given address is an active validator.\n     */\n    function isValidator(address _addr) public view returns (bool) {\n        if (validators.length == 0) {\n            return false;\n        } else if (_addr == address(0)) {\n            return false;\n        }\n\n        uint256 index = validatorIndexes[_addr];\n        return validators[index] == _addr;\n    }\n\n    /**\n     * @notice Returns the number of validators.\n     *\n     * @return The number of validators.\n     */\n    function validatorCount() external view returns (uint256) {\n        return validators.length;\n    }\n\n    /**\n     * @notice Determines who can submit the L2 output next.\n     *\n     * @return The address of the validator.\n     */\n    function nextValidator() public view returns (address) {\n        if (nextPriorityValidator != address(0)) {\n            uint256 l2Timestamp = L2_ORACLE.nextOutputMinL2Timestamp();\n            if (block.timestamp >= l2Timestamp) {\n                uint256 elapsed = block.timestamp - l2Timestamp;\n                // If the current time exceeds one round time, it is a public round.\n                if (elapsed > ROUND_DURATION) {\n                    return Constants.VALIDATOR_PUBLIC_ROUND_ADDRESS;\n                }\n            }\n\n            return nextPriorityValidator;\n        } else {\n            return TRUSTED_VALIDATOR;\n        }\n    }\n\n    /**\n     * @notice Determines whether the given output index must not interact with ValidatorPool.\n     *\n     * @param _outputIndex Index of the L2 checkpoint output.\n     *\n     * @return Whether the given output index must not interact with ValidatorPool.\n     */\n    function isTerminated(uint256 _outputIndex) external view returns (bool) {\n        return _outputIndex > TERMINATE_OUTPUT_INDEX;\n    }\n}\n"
    },
    "contracts/L1/ZKMerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bytes } from \"../libraries/Bytes.sol\";\nimport { NodeReader } from \"../libraries/NodeReader.sol\";\nimport { IZKMerkleTrie } from \"./interfaces/IZKMerkleTrie.sol\";\nimport { ZKTrieHasher } from \"./ZKTrieHasher.sol\";\n\n/**\n * @custom:proxied\n * @title ZKMerkleTrie\n * @notice The ZKMerkleTrie is contract which can produce a hash according to ZKTrie.\n *         This owns an interface of Poseidon2 that is required to compute hash used by ZKTrie.\n */\ncontract ZKMerkleTrie is IZKMerkleTrie, ZKTrieHasher {\n    /**\n     * @notice Struct representing a node in the trie.\n     */\n    struct TrieNode {\n        bytes encoded;\n        NodeReader.Node decoded;\n    }\n\n    /**\n     * @notice Magic hash which indicates\n     *         See https://github.com/kroma-network/zktrie/blob/main/trie/zk_trie_proof.go.\n     */\n    bytes32 private constant MAGIC_SMT_BYTES_HASH =\n        keccak256(\n            hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\"\n        );\n\n    /**\n     * @param _poseidon2 The address of poseidon2 contract.\n     */\n    constructor(address _poseidon2) ZKTrieHasher(_poseidon2) {}\n\n    /**\n     * @notice Checks if a given bytes is MAGIC_SMT_BYTES_HASH.\n     *\n     * @param _value Bytes to be compared.\n     */\n    function isMagicSmtBytesHash(bytes memory _value) private pure returns (bool) {\n        return keccak256(_value) == MAGIC_SMT_BYTES_HASH;\n    }\n\n    /**\n     * @inheritdoc IZKMerkleTrie\n     */\n    function verifyInclusionProof(\n        bytes32 _key,\n        bytes memory _value,\n        bytes[] memory _proofs,\n        bytes32 _root\n    ) external view returns (bool) {\n        (bool exists, bytes memory value) = this.get(_key, _proofs, _root);\n        return (exists && Bytes.equal(_value, value));\n    }\n\n    /**\n     * @notice Retrieves the value associated with a given key.\n     *\n     * @param _key    Key to search for, as hex bytes.\n     * @param _proofs Merkle trie inclusion proof for the key.\n     * @param _root   Known root of the Merkle trie.\n     *\n     * @return Whether or not the key exists.\n     * @return Value of the key if it exists.\n     */\n    function get(\n        bytes32 _key,\n        bytes[] memory _proofs,\n        bytes32 _root\n    ) external view returns (bool, bytes memory) {\n        require(_proofs.length >= 2, \"ZKMerkleTrie: provided proof is too short\");\n        require(\n            isMagicSmtBytesHash(_proofs[_proofs.length - 1]),\n            \"ZKMerkleTrie: the last item is not magic hash\"\n        );\n        bytes32 key = _hashElem(_key);\n        TrieNode[] memory nodes = _parseProofs(_proofs);\n        NodeReader.Node memory currentNode;\n        bytes32 computedKey = bytes32(0);\n        bool exists = false;\n        bool empty = false;\n        bytes memory value = bytes(\"\");\n        for (uint256 i = nodes.length - 2; i >= 0; ) {\n            currentNode = nodes[i].decoded;\n            if (currentNode.nodeType == NodeReader.NodeType.MIDDLE) {\n                bool isLeft = _isLeft(key, i);\n                if (isLeft) {\n                    require(computedKey == currentNode.childL, \"ZKMerkleTrie: invalid key L\");\n                } else {\n                    require(computedKey == currentNode.childR, \"ZKMerkleTrie: invalid key R\");\n                }\n                computedKey = _hashFixed2Elems(currentNode.childL, currentNode.childR);\n            } else if (currentNode.nodeType == NodeReader.NodeType.LEAF) {\n                require(!exists && !empty, \"ZKMerkleTrie: duplicated terminal node\");\n                exists = currentNode.nodeKey == key;\n                if (!exists) {\n                    break;\n                }\n                computedKey = _hashFixed3Elems(\n                    bytes32(uint256(1)),\n                    currentNode.nodeKey,\n                    _valueHash(currentNode.compressedFlags, currentNode.valuePreimage)\n                );\n                bytes32[] memory valuePreimage = currentNode.valuePreimage;\n                uint256 len = valuePreimage.length;\n                assembly {\n                    value := valuePreimage\n                    mstore(value, mul(len, 32))\n                }\n                if (currentNode.keyPreimage != bytes32(0)) {\n                    // NOTE(chokobole): The comparison order is important, because in this setting,\n                    // first condition is mostly evaluted to be true. When we're sure about\n                    // database preimage, then we need to enable just one of check below!\n                    require(\n                        currentNode.keyPreimage == _key || currentNode.keyPreimage == key,\n                        \"ZKMerkleTrie: invalid key preimage\"\n                    );\n                }\n            } else if (currentNode.nodeType == NodeReader.NodeType.EMPTY) {\n                require(!exists && !empty, \"ZKMerkleTrie: duplicated terminal node\");\n                empty = true;\n            }\n            if (i == 0) {\n                require(computedKey == _root, \"ZKMerkeTrie: invalid root\");\n                break;\n            }\n            unchecked {\n                --i;\n            }\n        }\n        return (exists, value);\n    }\n\n    /**\n     * @notice Parses an array of proof elements into a new array that contains both the original\n     *         encoded element and the decoded element.\n     *\n     * @param _proofs Array of proof elements to parse.\n     *\n     * @return TrieNode parsed into easily accessible structs.\n     */\n    function _parseProofs(bytes[] memory _proofs) private pure returns (TrieNode[] memory) {\n        uint256 length = _proofs.length;\n        TrieNode[] memory nodes = new TrieNode[](length);\n        // NOTE(chokobole): Last proof is MAGIC_SMT_BYTES_HASH!\n        for (uint256 i = 0; i < length - 1; ) {\n            NodeReader.Node memory node = NodeReader.readNode(_proofs[i]);\n            nodes[i] = TrieNode({ encoded: _proofs[i], decoded: node });\n            unchecked {\n                ++i;\n            }\n        }\n        return nodes;\n    }\n\n    /**\n     * @notice Computes merkle path at index n based on a given keyPreimage.\n     *\n     * @param _keyPreimage Keypreimage.\n     * @param _n           Bit to mask.\n     *\n     * @return Whether merkle path is left or not.\n     */\n    function _isLeft(bytes32 _keyPreimage, uint256 _n) private pure returns (bool) {\n        require(_n < 256, \"ZKMerkleTrie: too long depth\");\n        return _keyPreimage & bytes32(1 << _n) == 0;\n    }\n}\n"
    },
    "contracts/L1/ZKTrieHasher.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { Bytes32 } from \"../libraries/Bytes32.sol\";\n\n/**\n * @title IPoseidon2\n */\ninterface IPoseidon2 {\n    function poseidon(bytes32[2] memory inputs) external pure returns (bytes32);\n}\n\n/**\n * @custom:proxied\n * @title ZKTrieHasher\n * @notice The ZKTrieHasher is contract which can produce a hash according to ZKTrie.\n *         This owns an interface of Poseidon2 that is required to compute hash used by ZKTrie.\n */\ncontract ZKTrieHasher {\n    /**\n     * @notice Poseidon2 contract generated by circomlibjs.\n     */\n    IPoseidon2 public immutable POSEIDON2;\n\n    /**\n     * @param _poseidon2 The address of poseidon2 contract.\n     */\n    constructor(address _poseidon2) {\n        POSEIDON2 = IPoseidon2(_poseidon2);\n    }\n\n    /**\n     * @notice Computes a hash of values.\n     *\n     * @param _compressedFlags Compressed flags.\n     * @param _values          Values.\n     *\n     * @return A hash of values.\n     */\n    function _valueHash(uint32 _compressedFlags, bytes32[] memory _values)\n        internal\n        view\n        returns (bytes32)\n    {\n        require(_values.length >= 1, \"ZKTrieHasher: too few values for _valueHash\");\n        bytes32[] memory ret = new bytes32[](_values.length);\n        for (uint256 i = 0; i < _values.length; ) {\n            if ((_compressedFlags & (1 << i)) != 0) {\n                ret[i] = _hashElem(_values[i]);\n            } else {\n                ret[i] = _values[i];\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        if (_values.length < 2) {\n            return ret[0];\n        }\n        return _hashElems(ret);\n    }\n\n    /**\n     * @notice Computes a hash of an element.\n     *\n     * @param _elem Bytes32 to be hashed.\n     *\n     * @return A hash of an element.\n     */\n    function _hashElem(bytes32 _elem) internal view returns (bytes32) {\n        (bytes32 high, bytes32 low) = Bytes32.split(_elem);\n        return POSEIDON2.poseidon([high, low]);\n    }\n\n    /**\n     * @notice Computes a root hash of elements tree.\n     *\n     * @param _elems Bytes32 array to be hashed.\n     *\n     * @return A hash of elements tree.\n     */\n    function _hashElems(bytes32[] memory _elems) internal view returns (bytes32) {\n        require(_elems.length >= 4, \"ZKTrieHasher: too few values for _hashElems\");\n        IPoseidon2 iposeidon = POSEIDON2;\n\n        uint256 idx;\n        uint256 adjacent_idx;\n\n        uint256 adjacent_offset = 1;\n        uint256 jump = 2;\n        uint256 length = _elems.length;\n        for (; adjacent_offset < length;) {\n            for (idx = 0; idx < length;) {\n                unchecked {\n                    adjacent_idx = idx + adjacent_offset;\n                }\n                if (adjacent_idx < length) {\n                    _elems[idx] = iposeidon.poseidon( [_elems[idx], _elems[adjacent_idx]] );\n                }\n                unchecked {\n                    idx += jump;\n                }\n            }\n            adjacent_offset = jump;\n            jump <<= 1;\n        }\n\n        return _elems[0];\n    }\n\n    /**\n     * @notice Computes a root hash of 2 elements.\n     *\n     * @param left_leaf  Bytes32 left leaf to be hashed.\n     * @param right_leaf Bytes32 right leaf to be hashed.\n     *\n     * @return A hash of 2 elements.\n     */\n    function _hashFixed2Elems(bytes32 left_leaf, bytes32 right_leaf) internal view returns (bytes32) {\n        return POSEIDON2.poseidon([left_leaf, right_leaf]);\n    }\n\n   /**\n     * @notice Computes a root hash of 3 elements.\n     *\n     * @param left_leaf  Bytes32 left leaf to be hashed.\n     * @param right_leaf Bytes32 right leaf to be hashed.\n     * @param up_leaf    Bytes32 up leaf to be hashed with left||right hash.\n     *\n     * @return A hash of 3 elements.\n     */\n    function _hashFixed3Elems(bytes32 left_leaf, bytes32 right_leaf, bytes32 up_leaf) internal view returns (bytes32) {\n        IPoseidon2 iposeidon = POSEIDON2;\n        left_leaf = iposeidon.poseidon([left_leaf, right_leaf]);\n        return iposeidon.poseidon([left_leaf, up_leaf]);\n    }\n}\n"
    },
    "contracts/L1/ZKVerifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\nimport { ISemver } from \"../universal/ISemver.sol\";\n\ncontract ZKVerifier is ISemver {\n    uint256 internal immutable HASH_SCALAR_VALUE;\n    uint256 internal immutable M_56_PX_VALUE;\n    uint256 internal immutable M_56_PY_VALUE;\n\n    /**\n     * @notice Semantic version.\n     * @custom:semver 0.1.5\n     */\n    string public constant version = \"0.1.5\";\n\n    constructor(uint256 _hashScalar, uint256 _m56Px, uint256 _m56Py) {\n        HASH_SCALAR_VALUE = _hashScalar;\n        M_56_PX_VALUE = _m56Px;\n        M_56_PY_VALUE = _m56Py;\n    }\n\n    function pairing(G1Point[] memory p1, G2Point[] memory p2) internal view returns (bool) {\n        uint256 length = p1.length * 6;\n        uint256[] memory input = new uint256[](length);\n        uint256[1] memory result;\n        bool ret;\n\n        require(p1.length == p2.length);\n\n        for (uint256 i = 0; i < p1.length; i++) {\n            input[0 + i * 6] = p1[i].x;\n            input[1 + i * 6] = p1[i].y;\n            input[2 + i * 6] = p2[i].x[0];\n            input[3 + i * 6] = p2[i].x[1];\n            input[4 + i * 6] = p2[i].y[0];\n            input[5 + i * 6] = p2[i].y[1];\n        }\n\n        assembly {\n            ret := staticcall(gas(), 8, add(input, 0x20), mul(length, 0x20), result, 0x20)\n        }\n        require(ret);\n        return result[0] != 0;\n    }\n\n    uint256 constant q_mod =\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    function fr_invert(uint256 a) internal view returns (uint256) {\n        return fr_pow(a, q_mod - 2);\n    }\n\n    function fr_pow(uint256 a, uint256 power) internal view returns (uint256) {\n        uint256[6] memory input;\n        uint256[1] memory result;\n        bool ret;\n\n        input[0] = 32;\n        input[1] = 32;\n        input[2] = 32;\n        input[3] = a;\n        input[4] = power;\n        input[5] = q_mod;\n\n        assembly {\n            ret := staticcall(gas(), 0x05, input, 0xc0, result, 0x20)\n        }\n        require(ret);\n\n        return result[0];\n    }\n\n    function fr_div(uint256 a, uint256 b) internal view returns (uint256) {\n        require(b != 0);\n        return mulmod(a, fr_invert(b), q_mod);\n    }\n\n    function fr_mul_add(uint256 a, uint256 b, uint256 c) internal pure returns (uint256) {\n        return addmod(mulmod(a, b, q_mod), c, q_mod);\n    }\n\n    function fr_mul_add_pm(\n        uint256[84] memory m,\n        uint256[] calldata proof,\n        uint256 opcode,\n        uint256 t\n    ) internal pure returns (uint256) {\n        for (uint256 i = 0; i < 32; i += 2) {\n            uint256 a = opcode & 0xff;\n            if (a != 0xff) {\n                opcode >>= 8;\n                uint256 b = opcode & 0xff;\n                opcode >>= 8;\n                t = addmod(mulmod(proof[a], m[b], q_mod), t, q_mod);\n            } else {\n                break;\n            }\n        }\n\n        return t;\n    }\n\n    function fr_mul_add_mt(\n        uint256[84] memory m,\n        uint256 base,\n        uint256 opcode,\n        uint256 t\n    ) internal pure returns (uint256) {\n        for (uint256 i = 0; i < 32; i += 1) {\n            uint256 a = opcode & 0xff;\n            if (a != 0xff) {\n                opcode >>= 8;\n                t = addmod(mulmod(base, t, q_mod), m[a], q_mod);\n            } else {\n                break;\n            }\n        }\n\n        return t;\n    }\n\n    function fr_reverse(uint256 input) internal pure returns (uint256 v) {\n        v = input;\n\n        // swap bytes\n        v =\n            ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8) |\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n\n        // swap 2-byte long pairs\n        v =\n            ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16) |\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n\n        // swap 4-byte long pairs\n        v =\n            ((v & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32) |\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n\n        // swap 8-byte long pairs\n        v =\n            ((v & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64) |\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n\n        // swap 16-byte long pairs\n        v = (v >> 128) | (v << 128);\n    }\n\n    uint256 constant p_mod =\n        21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    struct G1Point {\n        uint256 x;\n        uint256 y;\n    }\n\n    struct G2Point {\n        uint256[2] x;\n        uint256[2] y;\n    }\n\n    function ecc_from(uint256 x, uint256 y) internal pure returns (G1Point memory r) {\n        r.x = x;\n        r.y = y;\n    }\n\n    function ecc_add(\n        uint256 ax,\n        uint256 ay,\n        uint256 bx,\n        uint256 by\n    ) internal view returns (uint256, uint256) {\n        bool ret = false;\n        G1Point memory r;\n        uint256[4] memory input_points;\n\n        input_points[0] = ax;\n        input_points[1] = ay;\n        input_points[2] = bx;\n        input_points[3] = by;\n\n        assembly {\n            ret := staticcall(gas(), 6, input_points, 0x80, r, 0x40)\n        }\n        require(ret);\n\n        return (r.x, r.y);\n    }\n\n    function ecc_sub(\n        uint256 ax,\n        uint256 ay,\n        uint256 bx,\n        uint256 by\n    ) internal view returns (uint256, uint256) {\n        return ecc_add(ax, ay, bx, p_mod - by);\n    }\n\n    function ecc_mul(uint256 px, uint256 py, uint256 s) internal view returns (uint256, uint256) {\n        uint256[3] memory input;\n        bool ret = false;\n        G1Point memory r;\n\n        input[0] = px;\n        input[1] = py;\n        input[2] = s;\n\n        assembly {\n            ret := staticcall(gas(), 7, input, 0x60, r, 0x40)\n        }\n        require(ret);\n\n        return (r.x, r.y);\n    }\n\n    function _ecc_mul_add(uint256[5] memory input) internal view {\n        bool ret = false;\n\n        assembly {\n            ret := staticcall(gas(), 7, input, 0x60, add(input, 0x20), 0x40)\n        }\n        require(ret);\n\n        assembly {\n            ret := staticcall(gas(), 6, add(input, 0x20), 0x80, add(input, 0x60), 0x40)\n        }\n        require(ret);\n    }\n\n    function ecc_mul_add(\n        uint256 px,\n        uint256 py,\n        uint256 s,\n        uint256 qx,\n        uint256 qy\n    ) internal view returns (uint256, uint256) {\n        uint256[5] memory input;\n        input[0] = px;\n        input[1] = py;\n        input[2] = s;\n        input[3] = qx;\n        input[4] = qy;\n\n        _ecc_mul_add(input);\n\n        return (input[3], input[4]);\n    }\n\n    function ecc_mul_add_pm(\n        uint256[84] memory m,\n        uint256[] calldata proof,\n        uint256 opcode,\n        uint256 t0,\n        uint256 t1\n    ) internal view returns (uint256, uint256) {\n        uint256[5] memory input;\n        input[3] = t0;\n        input[4] = t1;\n        for (uint256 i = 0; i < 32; i += 2) {\n            uint256 a = opcode & 0xff;\n            if (a != 0xff) {\n                opcode >>= 8;\n                uint256 b = opcode & 0xff;\n                opcode >>= 8;\n                input[0] = proof[a];\n                input[1] = proof[a + 1];\n                input[2] = m[b];\n                _ecc_mul_add(input);\n            } else {\n                break;\n            }\n        }\n\n        return (input[3], input[4]);\n    }\n\n    function update_hash_scalar(\n        uint256 v,\n        uint256[144] memory absorbing,\n        uint256 pos\n    ) internal pure {\n        absorbing[pos++] = 0x02;\n        absorbing[pos++] = v;\n    }\n\n    function update_hash_point(\n        uint256 x,\n        uint256 y,\n        uint256[144] memory absorbing,\n        uint256 pos\n    ) internal pure {\n        absorbing[pos++] = 0x01;\n        absorbing[pos++] = x;\n        absorbing[pos++] = y;\n    }\n\n    function to_scalar(bytes32 r) private pure returns (uint256 v) {\n        uint256 tmp = uint256(r);\n        tmp = fr_reverse(tmp);\n        v = tmp % 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;\n    }\n\n    function hash(\n        uint256[144] memory absorbing,\n        uint256 length\n    ) private view returns (bytes32[1] memory v) {\n        bool success;\n        assembly {\n            success := staticcall(sub(gas(), 2000), 2, absorbing, length, v, 32)\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n        assert(success);\n    }\n\n    function squeeze_challenge(\n        uint256[144] memory absorbing,\n        uint32 length\n    ) internal view returns (uint256 v) {\n        absorbing[length] = 0;\n        bytes32 res = hash(absorbing, length * 32 + 1)[0];\n        v = to_scalar(res);\n        absorbing[0] = uint256(res);\n        length = 1;\n    }\n\n    function get_verify_circuit_g2_s() internal pure returns (G2Point memory s) {\n        s.x[0] = uint256(\n            11029560635643983818885738975758839003131865733814273016801144285524936684972\n        );\n        s.x[1] = uint256(\n            10665153487364924395451186075663597035495902496253353881119509267933768999122\n        );\n        s.y[0] = uint256(\n            18790173187318184075281544452912101572166071561689308149111466352378718492148\n        );\n        s.y[1] = uint256(\n            18755874088236213082062601512863221433227017725453112019151604716957419045549\n        );\n    }\n\n    function get_verify_circuit_g2_n() internal pure returns (G2Point memory n) {\n        n.x[0] = uint256(\n            11559732032986387107991004021392285783925812861821192530917403151452391805634\n        );\n        n.x[1] = uint256(\n            10857046999023057135944570762232829481370756359578518086990519993285655852781\n        );\n        n.y[0] = uint256(\n            17805874995975841540914202342111839520379459829704422454583296818431106115052\n        );\n        n.y[1] = uint256(\n            13392588948715843804641432497768002650278120570034223513918757245338268106653\n        );\n    }\n\n    function get_target_circuit_g2_s() internal pure returns (G2Point memory s) {\n        s.x[0] = uint256(\n            11029560635643983818885738975758839003131865733814273016801144285524936684972\n        );\n        s.x[1] = uint256(\n            10665153487364924395451186075663597035495902496253353881119509267933768999122\n        );\n        s.y[0] = uint256(\n            18790173187318184075281544452912101572166071561689308149111466352378718492148\n        );\n        s.y[1] = uint256(\n            18755874088236213082062601512863221433227017725453112019151604716957419045549\n        );\n    }\n\n    function get_target_circuit_g2_n() internal pure returns (G2Point memory n) {\n        n.x[0] = uint256(\n            11559732032986387107991004021392285783925812861821192530917403151452391805634\n        );\n        n.x[1] = uint256(\n            10857046999023057135944570762232829481370756359578518086990519993285655852781\n        );\n        n.y[0] = uint256(\n            17805874995975841540914202342111839520379459829704422454583296818431106115052\n        );\n        n.y[1] = uint256(\n            13392588948715843804641432497768002650278120570034223513918757245338268106653\n        );\n    }\n\n    function get_wx_wg(\n        uint256[] calldata proof,\n        uint256[6] memory instances\n    ) internal view returns (uint256, uint256, uint256, uint256) {\n        uint256[84] memory m;\n        uint256[144] memory absorbing;\n        uint256 t0 = 0;\n        uint256 t1 = 0;\n\n        (t0, t1) = (\n            ecc_mul(\n                17789833092049612098151701936050358897264906311798010005527050942756852717298,\n                10895600437035740537762783734736154159991587515994553016519128117735745182853,\n                instances[0]\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                10543918255196573445400399528935519333175023389167175628125725368018220699826,\n                12766487347162664556283708113947771881161039794532633041152166890738441603652,\n                instances[1],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                17008203783108743202559440655757700533653854901598142405028623347702668473277,\n                21814804208982435371780097106882418706885400711730256673026973858149650971299,\n                instances[2],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                16811698451652309858363601322080891018704447409836823044944128338389236089077,\n                18899539994854832158038246139972325143494193687503547200838261777721006548399,\n                instances[3],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                5494852631096636459288403096263717084869030781267238852252122493224146048270,\n                15370627062079108379015892130008397963684601860044622201721093508656326957966,\n                instances[4],\n                t0,\n                t1\n            )\n        );\n        (m[0], m[1]) = (\n            ecc_mul_add(\n                15605904389647533645433956766425544672547314322654580577432084020959766066522,\n                2981854610112145395053419471185791838523574193883358734299031423326998004318,\n                instances[5],\n                t0,\n                t1\n            )\n        );\n        update_hash_scalar(HASH_SCALAR_VALUE, absorbing, 0);\n        update_hash_point(m[0], m[1], absorbing, 2);\n        for (t0 = 0; t0 <= 4; t0++) {\n            update_hash_point(proof[0 + t0 * 2], proof[1 + t0 * 2], absorbing, 5 + t0 * 3);\n        }\n        m[2] = (squeeze_challenge(absorbing, 20));\n        for (t0 = 0; t0 <= 13; t0++) {\n            update_hash_point(proof[10 + t0 * 2], proof[11 + t0 * 2], absorbing, 1 + t0 * 3);\n        }\n        m[3] = (squeeze_challenge(absorbing, 43));\n        m[4] = (squeeze_challenge(absorbing, 1));\n        for (t0 = 0; t0 <= 9; t0++) {\n            update_hash_point(proof[38 + t0 * 2], proof[39 + t0 * 2], absorbing, 1 + t0 * 3);\n        }\n        m[5] = (squeeze_challenge(absorbing, 31));\n        for (t0 = 0; t0 <= 3; t0++) {\n            update_hash_point(proof[58 + t0 * 2], proof[59 + t0 * 2], absorbing, 1 + t0 * 3);\n        }\n        m[6] = (squeeze_challenge(absorbing, 13));\n        for (t0 = 0; t0 <= 70; t0++) {\n            update_hash_scalar(proof[66 + t0 * 1], absorbing, 1 + t0 * 2);\n        }\n        m[7] = (squeeze_challenge(absorbing, 143));\n        for (t0 = 0; t0 <= 3; t0++) {\n            update_hash_point(proof[137 + t0 * 2], proof[138 + t0 * 2], absorbing, 1 + t0 * 3);\n        }\n        m[8] = (squeeze_challenge(absorbing, 13));\n        m[9] = (\n            mulmod(\n                m[6],\n                13446667982376394161563610564587413125564757801019538732601045199901075958935,\n                q_mod\n            )\n        );\n        m[10] = (\n            mulmod(\n                m[6],\n                16569469942529664681363945218228869388192121720036659574609237682362097667612,\n                q_mod\n            )\n        );\n        m[11] = (\n            mulmod(\n                m[6],\n                14803907026430593724305438564799066516271154714737734572920456128449769927233,\n                q_mod\n            )\n        );\n        m[12] = (fr_pow(m[6], 67108864));\n        m[13] = (addmod(m[12], q_mod - 1, q_mod));\n        m[14] = (\n            mulmod(\n                21888242545679039938882419398440172875981108180010270949818755658014750055173,\n                m[13],\n                q_mod\n            )\n        );\n        t0 = (addmod(m[6], q_mod - 1, q_mod));\n        m[14] = (fr_div(m[14], t0));\n        m[15] = (\n            mulmod(\n                3495999257316610708652455694658595065970881061159015347599790211259094641512,\n                m[13],\n                q_mod\n            )\n        );\n        t0 = (\n            addmod(\n                m[6],\n                q_mod -\n                    14803907026430593724305438564799066516271154714737734572920456128449769927233,\n                q_mod\n            )\n        );\n        m[15] = (fr_div(m[15], t0));\n        m[16] = (\n            mulmod(\n                12851378806584061886934576302961450669946047974813165594039554733293326536714,\n                m[13],\n                q_mod\n            )\n        );\n        t0 = (\n            addmod(\n                m[6],\n                q_mod -\n                    11377606117859914088982205826922132024839443553408109299929510653283289974216,\n                q_mod\n            )\n        );\n        m[16] = (fr_div(m[16], t0));\n        m[17] = (\n            mulmod(\n                14638077285440018490948843142723135319134576188472316769433007423695824509066,\n                m[13],\n                q_mod\n            )\n        );\n        t0 = (\n            addmod(\n                m[6],\n                q_mod -\n                    3693565015985198455139889557180396682968596245011005461846595820698933079918,\n                q_mod\n            )\n        );\n        m[17] = (fr_div(m[17], t0));\n        m[18] = (\n            mulmod(\n                18027939092386982308810165776478549635922357517986691900813373197616541191289,\n                m[13],\n                q_mod\n            )\n        );\n        t0 = (\n            addmod(\n                m[6],\n                q_mod -\n                    17329448237240114492580865744088056414251735686965494637158808787419781175510,\n                q_mod\n            )\n        );\n        m[18] = (fr_div(m[18], t0));\n        m[19] = (\n            mulmod(\n                912591536032578604421866340844550116335029274442283291811906603256731601654,\n                m[13],\n                q_mod\n            )\n        );\n        t0 = (\n            addmod(\n                m[6],\n                q_mod -\n                    6047398202650739717314770882059679662647667807426525133977681644606291529311,\n                q_mod\n            )\n        );\n        m[19] = (fr_div(m[19], t0));\n        m[20] = (\n            mulmod(\n                17248638560015646562374089181598815896736916575459528793494921668169819478628,\n                m[13],\n                q_mod\n            )\n        );\n        t0 = (\n            addmod(\n                m[6],\n                q_mod -\n                    16569469942529664681363945218228869388192121720036659574609237682362097667612,\n                q_mod\n            )\n        );\n        m[20] = (fr_div(m[20], t0));\n        t0 = (addmod(m[15], m[16], q_mod));\n        t0 = (addmod(t0, m[17], q_mod));\n        t0 = (addmod(t0, m[18], q_mod));\n        m[15] = (addmod(t0, m[19], q_mod));\n        t0 = (fr_mul_add(proof[74], proof[72], proof[73]));\n        t0 = (fr_mul_add(proof[75], proof[67], t0));\n        t0 = (fr_mul_add(proof[76], proof[68], t0));\n        t0 = (fr_mul_add(proof[77], proof[69], t0));\n        t0 = (fr_mul_add(proof[78], proof[70], t0));\n        m[16] = (fr_mul_add(proof[79], proof[71], t0));\n        t0 = (mulmod(proof[67], proof[68], q_mod));\n        m[16] = (fr_mul_add(proof[80], t0, m[16]));\n        t0 = (mulmod(proof[69], proof[70], q_mod));\n        m[16] = (fr_mul_add(proof[81], t0, m[16]));\n        t0 = (addmod(1, q_mod - proof[97], q_mod));\n        m[17] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[100], proof[100], q_mod));\n        t0 = (addmod(t0, q_mod - proof[100], q_mod));\n        m[18] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(proof[100], q_mod - proof[99], q_mod));\n        m[19] = (mulmod(t0, m[14], q_mod));\n        m[21] = (mulmod(m[3], m[6], q_mod));\n        t0 = (addmod(m[20], m[15], q_mod));\n        m[15] = (addmod(1, q_mod - t0, q_mod));\n        m[22] = (addmod(proof[67], m[4], q_mod));\n        t0 = (fr_mul_add(proof[91], m[3], m[22]));\n        m[23] = (mulmod(t0, proof[98], q_mod));\n        t0 = (addmod(m[22], m[21], q_mod));\n        m[22] = (mulmod(t0, proof[97], q_mod));\n        m[24] = (\n            mulmod(\n                4131629893567559867359510883348571134090853742863529169391034518566172092834,\n                m[21],\n                q_mod\n            )\n        );\n        m[25] = (addmod(proof[68], m[4], q_mod));\n        t0 = (fr_mul_add(proof[92], m[3], m[25]));\n        m[23] = (mulmod(t0, m[23], q_mod));\n        t0 = (addmod(m[25], m[24], q_mod));\n        m[22] = (mulmod(t0, m[22], q_mod));\n        m[24] = (\n            mulmod(\n                4131629893567559867359510883348571134090853742863529169391034518566172092834,\n                m[24],\n                q_mod\n            )\n        );\n        m[25] = (addmod(proof[69], m[4], q_mod));\n        t0 = (fr_mul_add(proof[93], m[3], m[25]));\n        m[23] = (mulmod(t0, m[23], q_mod));\n        t0 = (addmod(m[25], m[24], q_mod));\n        m[22] = (mulmod(t0, m[22], q_mod));\n        m[24] = (\n            mulmod(\n                4131629893567559867359510883348571134090853742863529169391034518566172092834,\n                m[24],\n                q_mod\n            )\n        );\n        t0 = (addmod(m[23], q_mod - m[22], q_mod));\n        m[22] = (mulmod(t0, m[15], q_mod));\n        m[21] = (\n            mulmod(\n                m[21],\n                11166246659983828508719468090013646171463329086121580628794302409516816350802,\n                q_mod\n            )\n        );\n        m[23] = (addmod(proof[70], m[4], q_mod));\n        t0 = (fr_mul_add(proof[94], m[3], m[23]));\n        m[24] = (mulmod(t0, proof[101], q_mod));\n        t0 = (addmod(m[23], m[21], q_mod));\n        m[23] = (mulmod(t0, proof[100], q_mod));\n        m[21] = (\n            mulmod(\n                4131629893567559867359510883348571134090853742863529169391034518566172092834,\n                m[21],\n                q_mod\n            )\n        );\n        m[25] = (addmod(proof[71], m[4], q_mod));\n        t0 = (fr_mul_add(proof[95], m[3], m[25]));\n        m[24] = (mulmod(t0, m[24], q_mod));\n        t0 = (addmod(m[25], m[21], q_mod));\n        m[23] = (mulmod(t0, m[23], q_mod));\n        m[21] = (\n            mulmod(\n                4131629893567559867359510883348571134090853742863529169391034518566172092834,\n                m[21],\n                q_mod\n            )\n        );\n        m[25] = (addmod(proof[66], m[4], q_mod));\n        t0 = (fr_mul_add(proof[96], m[3], m[25]));\n        m[24] = (mulmod(t0, m[24], q_mod));\n        t0 = (addmod(m[25], m[21], q_mod));\n        m[23] = (mulmod(t0, m[23], q_mod));\n        m[21] = (\n            mulmod(\n                4131629893567559867359510883348571134090853742863529169391034518566172092834,\n                m[21],\n                q_mod\n            )\n        );\n        t0 = (addmod(m[24], q_mod - m[23], q_mod));\n        m[21] = (mulmod(t0, m[15], q_mod));\n        t0 = (addmod(proof[104], m[3], q_mod));\n        m[23] = (mulmod(proof[103], t0, q_mod));\n        t0 = (addmod(proof[106], m[4], q_mod));\n        m[23] = (mulmod(m[23], t0, q_mod));\n        m[24] = (mulmod(proof[67], proof[82], q_mod));\n        m[2] = (mulmod(0, m[2], q_mod));\n        m[24] = (addmod(m[2], m[24], q_mod));\n        m[25] = (addmod(m[2], proof[83], q_mod));\n        m[26] = (addmod(proof[104], q_mod - proof[106], q_mod));\n        t0 = (addmod(1, q_mod - proof[102], q_mod));\n        m[27] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[102], proof[102], q_mod));\n        t0 = (addmod(t0, q_mod - proof[102], q_mod));\n        m[28] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(m[24], m[3], q_mod));\n        m[24] = (mulmod(proof[102], t0, q_mod));\n        m[25] = (addmod(m[25], m[4], q_mod));\n        t0 = (mulmod(m[24], m[25], q_mod));\n        t0 = (addmod(m[23], q_mod - t0, q_mod));\n        m[23] = (mulmod(t0, m[15], q_mod));\n        m[24] = (mulmod(m[14], m[26], q_mod));\n        t0 = (addmod(proof[104], q_mod - proof[105], q_mod));\n        t0 = (mulmod(m[26], t0, q_mod));\n        m[26] = (mulmod(t0, m[15], q_mod));\n        t0 = (addmod(proof[109], m[3], q_mod));\n        m[29] = (mulmod(proof[108], t0, q_mod));\n        t0 = (addmod(proof[111], m[4], q_mod));\n        m[29] = (mulmod(m[29], t0, q_mod));\n        m[30] = (fr_mul_add(proof[82], proof[68], m[2]));\n        m[31] = (addmod(proof[109], q_mod - proof[111], q_mod));\n        t0 = (addmod(1, q_mod - proof[107], q_mod));\n        m[32] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[107], proof[107], q_mod));\n        t0 = (addmod(t0, q_mod - proof[107], q_mod));\n        m[33] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(m[30], m[3], q_mod));\n        t0 = (mulmod(proof[107], t0, q_mod));\n        t0 = (mulmod(t0, m[25], q_mod));\n        t0 = (addmod(m[29], q_mod - t0, q_mod));\n        m[29] = (mulmod(t0, m[15], q_mod));\n        m[30] = (mulmod(m[14], m[31], q_mod));\n        t0 = (addmod(proof[109], q_mod - proof[110], q_mod));\n        t0 = (mulmod(m[31], t0, q_mod));\n        m[31] = (mulmod(t0, m[15], q_mod));\n        t0 = (addmod(proof[114], m[3], q_mod));\n        m[34] = (mulmod(proof[113], t0, q_mod));\n        t0 = (addmod(proof[116], m[4], q_mod));\n        m[34] = (mulmod(m[34], t0, q_mod));\n        m[35] = (fr_mul_add(proof[82], proof[69], m[2]));\n        m[36] = (addmod(proof[114], q_mod - proof[116], q_mod));\n        t0 = (addmod(1, q_mod - proof[112], q_mod));\n        m[37] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[112], proof[112], q_mod));\n        t0 = (addmod(t0, q_mod - proof[112], q_mod));\n        m[38] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(m[35], m[3], q_mod));\n        t0 = (mulmod(proof[112], t0, q_mod));\n        t0 = (mulmod(t0, m[25], q_mod));\n        t0 = (addmod(m[34], q_mod - t0, q_mod));\n        m[34] = (mulmod(t0, m[15], q_mod));\n        m[35] = (mulmod(m[14], m[36], q_mod));\n        t0 = (addmod(proof[114], q_mod - proof[115], q_mod));\n        t0 = (mulmod(m[36], t0, q_mod));\n        m[36] = (mulmod(t0, m[15], q_mod));\n        t0 = (addmod(proof[119], m[3], q_mod));\n        m[39] = (mulmod(proof[118], t0, q_mod));\n        t0 = (addmod(proof[121], m[4], q_mod));\n        m[39] = (mulmod(m[39], t0, q_mod));\n        m[40] = (fr_mul_add(proof[82], proof[70], m[2]));\n        m[41] = (addmod(proof[119], q_mod - proof[121], q_mod));\n        t0 = (addmod(1, q_mod - proof[117], q_mod));\n        m[42] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[117], proof[117], q_mod));\n        t0 = (addmod(t0, q_mod - proof[117], q_mod));\n        m[43] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(m[40], m[3], q_mod));\n        t0 = (mulmod(proof[117], t0, q_mod));\n        t0 = (mulmod(t0, m[25], q_mod));\n        t0 = (addmod(m[39], q_mod - t0, q_mod));\n        m[25] = (mulmod(t0, m[15], q_mod));\n        m[39] = (mulmod(m[14], m[41], q_mod));\n        t0 = (addmod(proof[119], q_mod - proof[120], q_mod));\n        t0 = (mulmod(m[41], t0, q_mod));\n        m[40] = (mulmod(t0, m[15], q_mod));\n        t0 = (addmod(proof[124], m[3], q_mod));\n        m[41] = (mulmod(proof[123], t0, q_mod));\n        t0 = (addmod(proof[126], m[4], q_mod));\n        m[41] = (mulmod(m[41], t0, q_mod));\n        m[44] = (fr_mul_add(proof[84], proof[67], m[2]));\n        m[45] = (addmod(m[2], proof[85], q_mod));\n        m[46] = (addmod(proof[124], q_mod - proof[126], q_mod));\n        t0 = (addmod(1, q_mod - proof[122], q_mod));\n        m[47] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[122], proof[122], q_mod));\n        t0 = (addmod(t0, q_mod - proof[122], q_mod));\n        m[48] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(m[44], m[3], q_mod));\n        m[44] = (mulmod(proof[122], t0, q_mod));\n        t0 = (addmod(m[45], m[4], q_mod));\n        t0 = (mulmod(m[44], t0, q_mod));\n        t0 = (addmod(m[41], q_mod - t0, q_mod));\n        m[41] = (mulmod(t0, m[15], q_mod));\n        m[44] = (mulmod(m[14], m[46], q_mod));\n        t0 = (addmod(proof[124], q_mod - proof[125], q_mod));\n        t0 = (mulmod(m[46], t0, q_mod));\n        m[45] = (mulmod(t0, m[15], q_mod));\n        t0 = (addmod(proof[129], m[3], q_mod));\n        m[46] = (mulmod(proof[128], t0, q_mod));\n        t0 = (addmod(proof[131], m[4], q_mod));\n        m[46] = (mulmod(m[46], t0, q_mod));\n        m[49] = (fr_mul_add(proof[86], proof[67], m[2]));\n        m[50] = (addmod(m[2], proof[87], q_mod));\n        m[51] = (addmod(proof[129], q_mod - proof[131], q_mod));\n        t0 = (addmod(1, q_mod - proof[127], q_mod));\n        m[52] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[127], proof[127], q_mod));\n        t0 = (addmod(t0, q_mod - proof[127], q_mod));\n        m[53] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(m[49], m[3], q_mod));\n        m[49] = (mulmod(proof[127], t0, q_mod));\n        t0 = (addmod(m[50], m[4], q_mod));\n        t0 = (mulmod(m[49], t0, q_mod));\n        t0 = (addmod(m[46], q_mod - t0, q_mod));\n        m[46] = (mulmod(t0, m[15], q_mod));\n        m[49] = (mulmod(m[14], m[51], q_mod));\n        t0 = (addmod(proof[129], q_mod - proof[130], q_mod));\n        t0 = (mulmod(m[51], t0, q_mod));\n        m[50] = (mulmod(t0, m[15], q_mod));\n        t0 = (addmod(proof[134], m[3], q_mod));\n        m[51] = (mulmod(proof[133], t0, q_mod));\n        t0 = (addmod(proof[136], m[4], q_mod));\n        m[51] = (mulmod(m[51], t0, q_mod));\n        m[54] = (fr_mul_add(proof[88], proof[67], m[2]));\n        m[2] = (addmod(m[2], proof[89], q_mod));\n        m[55] = (addmod(proof[134], q_mod - proof[136], q_mod));\n        t0 = (addmod(1, q_mod - proof[132], q_mod));\n        m[56] = (mulmod(m[14], t0, q_mod));\n        t0 = (mulmod(proof[132], proof[132], q_mod));\n        t0 = (addmod(t0, q_mod - proof[132], q_mod));\n        m[20] = (mulmod(m[20], t0, q_mod));\n        t0 = (addmod(m[54], m[3], q_mod));\n        m[3] = (mulmod(proof[132], t0, q_mod));\n        t0 = (addmod(m[2], m[4], q_mod));\n        t0 = (mulmod(m[3], t0, q_mod));\n        t0 = (addmod(m[51], q_mod - t0, q_mod));\n        m[2] = (mulmod(t0, m[15], q_mod));\n        m[3] = (mulmod(m[14], m[55], q_mod));\n        t0 = (addmod(proof[134], q_mod - proof[135], q_mod));\n        t0 = (mulmod(m[55], t0, q_mod));\n        m[4] = (mulmod(t0, m[15], q_mod));\n        t0 = (fr_mul_add(m[5], 0, m[16]));\n        t0 = (\n            fr_mul_add_mt(\n                m,\n                m[5],\n                24064768791442479290152634096194013545513974547709823832001394403118888981009,\n                t0\n            )\n        );\n        t0 = (fr_mul_add_mt(m, m[5], 4704208815882882920750, t0));\n        m[2] = (fr_div(t0, m[13]));\n        m[3] = (mulmod(m[8], m[8], q_mod));\n        m[4] = (mulmod(m[3], m[8], q_mod));\n        (t0, t1) = (ecc_mul(proof[143], proof[144], m[4]));\n        (t0, t1) = (ecc_mul_add_pm(m, proof, 281470825071501, t0, t1));\n        (m[14], m[15]) = (ecc_add(t0, t1, proof[137], proof[138]));\n        m[5] = (mulmod(m[4], m[11], q_mod));\n        m[11] = (mulmod(m[4], m[7], q_mod));\n        m[13] = (mulmod(m[11], m[7], q_mod));\n        m[16] = (mulmod(m[13], m[7], q_mod));\n        m[17] = (mulmod(m[16], m[7], q_mod));\n        m[18] = (mulmod(m[17], m[7], q_mod));\n        m[19] = (mulmod(m[18], m[7], q_mod));\n        t0 = (mulmod(m[19], proof[135], q_mod));\n        t0 = (fr_mul_add_pm(m, proof, 79227007564587019091207590530, t0));\n        m[20] = (fr_mul_add(proof[105], m[4], t0));\n        m[10] = (mulmod(m[3], m[10], q_mod));\n        m[20] = (fr_mul_add(proof[99], m[3], m[20]));\n        m[9] = (mulmod(m[8], m[9], q_mod));\n        m[21] = (mulmod(m[8], m[7], q_mod));\n        for (t0 = 0; t0 < 8; t0++) {\n            m[22 + t0 * 1] = (mulmod(m[21 + t0 * 1], m[7 + t0 * 0], q_mod));\n        }\n        t0 = (mulmod(m[29], proof[133], q_mod));\n        t0 = (fr_mul_add_pm(m, proof, 1461480058012745347196003969984389955172320353408, t0));\n        m[20] = (addmod(m[20], t0, q_mod));\n        m[3] = (addmod(m[3], m[21], q_mod));\n        m[21] = (mulmod(m[7], m[7], q_mod));\n        m[30] = (mulmod(m[21], m[7], q_mod));\n        for (t0 = 0; t0 < 50; t0++) {\n            m[31 + t0 * 1] = (mulmod(m[30 + t0 * 1], m[7 + t0 * 0], q_mod));\n        }\n        m[81] = (mulmod(m[80], proof[90], q_mod));\n        m[82] = (mulmod(m[79], m[12], q_mod));\n        m[83] = (mulmod(m[82], m[12], q_mod));\n        m[12] = (mulmod(m[83], m[12], q_mod));\n        t0 = (fr_mul_add(m[79], m[2], m[81]));\n        t0 = (\n            fr_mul_add_pm(\n                m,\n                proof,\n                28637501128329066231612878461967933875285131620580756137874852300330784214624,\n                t0\n            )\n        );\n        t0 = (\n            fr_mul_add_pm(\n                m,\n                proof,\n                21474593857386732646168474467085622855647258609351047587832868301163767676495,\n                t0\n            )\n        );\n        t0 = (\n            fr_mul_add_pm(\n                m,\n                proof,\n                14145600374170319983429588659751245017860232382696106927048396310641433325177,\n                t0\n            )\n        );\n        t0 = (fr_mul_add_pm(m, proof, 18446470583433829957, t0));\n        t0 = (addmod(t0, proof[66], q_mod));\n        m[2] = (addmod(m[20], t0, q_mod));\n        m[19] = (addmod(m[19], m[54], q_mod));\n        m[20] = (addmod(m[29], m[53], q_mod));\n        m[18] = (addmod(m[18], m[51], q_mod));\n        m[28] = (addmod(m[28], m[50], q_mod));\n        m[17] = (addmod(m[17], m[48], q_mod));\n        m[27] = (addmod(m[27], m[47], q_mod));\n        m[16] = (addmod(m[16], m[45], q_mod));\n        m[26] = (addmod(m[26], m[44], q_mod));\n        m[13] = (addmod(m[13], m[42], q_mod));\n        m[25] = (addmod(m[25], m[41], q_mod));\n        m[11] = (addmod(m[11], m[39], q_mod));\n        m[24] = (addmod(m[24], m[38], q_mod));\n        m[4] = (addmod(m[4], m[36], q_mod));\n        m[23] = (addmod(m[23], m[35], q_mod));\n        m[22] = (addmod(m[22], m[34], q_mod));\n        m[3] = (addmod(m[3], m[33], q_mod));\n        m[8] = (addmod(m[8], m[32], q_mod));\n        (t0, t1) = (ecc_mul(proof[143], proof[144], m[5]));\n        (t0, t1) = (\n            ecc_mul_add_pm(\n                m,\n                proof,\n                10933423423422768024429730621579321771439401845242250760130969989159573132066,\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add_pm(m, proof, 1461486238301980199876269201563775120819706402602, t0, t1)\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                15738646021458965415875359585850781728243543812280308548595326491476474302955,\n                11051787057691458774492360569996861082650504993138626819003221898493178050035,\n                m[78],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                1475696300049442917028467159105389721116357718795651750519726871994775216295,\n                8164600896470502362564790171132408561435532006283737733288998283496711243676,\n                m[77],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                20037340314091442687430628478276133171639671164499869262269052470554953532798,\n                8617374172579535083448320238697316576863116103559910108651404828163902641209,\n                m[76],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                2590328984608469713687780064619512676013076673646564572496583030882285919986,\n                638589679743187931075527957989835488430425780368511997293885082437553073995,\n                m[75],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                12146901029446786042585650348552207198317726707649479980494243975966168586800,\n                21004224368627752160019614542278109958896643390087793101726552507600837692403,\n                m[74],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                12484898247528969713369796601188723761879994746350513864107241452597517714843,\n                20710920799110457828705640996188165458350589749232606705712996851057245387342,\n                m[73],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                19886509832083393598366465489701294384803664485460545523068306491024326504725,\n                3485984208124097149766319408505384162933092797198027169851040569744728509599,\n                m[72],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                16404659647391097455159976273992692920152024451288249273063848656492758204389,\n                21408247695101639349153277734734938504956965085851869757712649884779075439039,\n                m[71],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                17108853774466418779129374196319580280286578385405087585516556746536875115907,\n                19908760740801913322265695807368645417588084579607860033571444712857010186774,\n                m[70],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                21629254704290212852937802382494716478889797428965842728144220543246322859554,\n                21658265822014679146185833630076754140073759884763957789271421091032211025157,\n                m[69],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                19886509832083393598366465489701294384803664485460545523068306491024326504725,\n                3485984208124097149766319408505384162933092797198027169851040569744728509599,\n                m[68],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                11494485494412314036912556883437307149797432820383623637519035656794042012095,\n                2410489863957456775707779378033814786966154706946761951908809676618278443068,\n                m[67],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                21627166622184628562834675422084345034193467320009306763329316593023720936150,\n                2103102746100002335801212537254725041663108226492711350135413308275232360031,\n                m[66],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                5833003470394876828918971407337456408257193352118920119145576292426638346769,\n                21517803666035190572447529780797402738873790305626876614632047398304071926756,\n                m[65],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                15660369869316007654180594416910060098683972168851332428191944238046914461816,\n                619475474362397505663248548997199145354664366559823796718165155533015020663,\n                m[64],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                14357122501752010758022868212927876311895459359009009733271861104226260045594,\n                16126281904050270224623042280467621555101638794226278850100489095734549617918,\n                m[63],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                16761622113591657736617505151691036744631771696590303134292673377873890818119,\n                6686562932890286592033158402117293865477246854478945021606806487507223075395,\n                m[62],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                17229942418385200082062914700911519717772513320730624793493549643743556744576,\n                5621800961668224347956111291579888905398405975749251495793956267512617886424,\n                m[61],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                16719044151302115613031649349289232028937886588938900980773255912070590283284,\n                8996560925096856479601278542730270549020210858287011041285301443498627852162,\n                m[60],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                456517166543705985184166475990427022518096989415429862512544596075628104766,\n                4584298690582989400824123720778697263357419965108679590688166449396561305804,\n                m[59],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                8841671929736409341755876439864603183349976850407514895007839042769729845276,\n                19908694064427411410925537740321794844212081049969432136633191256148570974369,\n                m[58],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                2104154327908680857716247273517715744719141711240749880794301438788948027686,\n                7499686005093585017307496107151445622144347868958974916146393505438758744367,\n                m[57],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (ecc_mul_add(M_56_PX_VALUE, M_56_PY_VALUE, m[56], t0, t1));\n        (t0, t1) = (\n            ecc_mul_add_pm(\n                m,\n                proof,\n                6277008573546246765208814532330797927747086570010716419876,\n                t0,\n                t1\n            )\n        );\n        (m[0], m[1]) = (ecc_add(t0, t1, m[0], m[1]));\n        (t0, t1) = (ecc_mul(1, 2, m[2]));\n        (m[0], m[1]) = (ecc_sub(m[0], m[1], t0, t1));\n        return (m[14], m[15], m[0], m[1]);\n    }\n\n    function verify(\n        uint256[] calldata proof,\n        uint256[] calldata target_circuit_final_pair,\n        bytes32 publicInputHash\n    ) public view returns (bool) {\n        uint256[6] memory instances;\n        instances[0] = target_circuit_final_pair[0] & ((1 << 136) - 1);\n        instances[1] =\n            (target_circuit_final_pair[0] >> 136) +\n            ((target_circuit_final_pair[1] & 1) << 136);\n        instances[2] = target_circuit_final_pair[2] & ((1 << 136) - 1);\n        instances[3] =\n            (target_circuit_final_pair[2] >> 136) +\n            ((target_circuit_final_pair[3] & 1) << 136);\n\n        instances[4] = uint256(publicInputHash) >> (8 * 16);\n        instances[5] = uint256(publicInputHash) & uint256(2 ** 128 - 1);\n\n        uint256 x0 = 0;\n        uint256 x1 = 0;\n        uint256 y0 = 0;\n        uint256 y1 = 0;\n\n        G1Point[] memory g1_points = new G1Point[](2);\n        G2Point[] memory g2_points = new G2Point[](2);\n\n        (x0, y0, x1, y1) = get_wx_wg(proof, instances);\n        g1_points[0].x = x0;\n        g1_points[0].y = y0;\n        g1_points[1].x = x1;\n        g1_points[1].y = y1;\n        g2_points[0] = get_verify_circuit_g2_s();\n        g2_points[1] = get_verify_circuit_g2_n();\n\n        if (!pairing(g1_points, g2_points)) {\n            return false;\n        }\n\n        g1_points[0].x = target_circuit_final_pair[0];\n        g1_points[0].y = target_circuit_final_pair[1];\n        g1_points[1].x = target_circuit_final_pair[2];\n        g1_points[1].y = target_circuit_final_pair[3];\n        g2_points[0] = get_target_circuit_g2_s();\n        g2_points[1] = get_target_circuit_g2_n();\n\n        if (!pairing(g1_points, g2_points)) {\n            return false;\n        }\n\n        return true;\n    }\n}\n"
    },
    "contracts/L1/interfaces/IAssetManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title IAssetManager\n * @notice Interface for AssetManager contract.\n */\ninterface IAssetManager {\n    /**\n     * @notice Represents the asset information of the vault of a validator.\n     *\n     * @custom:field validatorKro       Total amount of KRO that deposited by the validator and\n     *                                  accumulated as validator reward (including validatorKroBonded).\n     * @custom:field validatorKroBonded Total amount of validator KRO that bonded during output\n     *                                  submission or challenge creation.\n     * @custom:field totalKro           Total amount of KRO that delegated by the delegators and\n     *                                  accumulated as KRO delegation reward.\n     * @custom:field totalKroShares     Total shares for KRO delegation in the vault.\n     * @custom:field totalKgh           Total number of KGH in the vault.\n     * @custom:field rewardPerKghStored Accumulated boosted reward per 1 KGH.\n     */\n    struct Asset {\n        uint128 validatorKro;\n        uint128 validatorKroBonded;\n        uint128 totalKro;\n        uint128 totalKroShares;\n        uint128 totalKgh;\n        uint128 rewardPerKghStored;\n    }\n\n    /**\n     * @notice Constructs the delegator of KRO in the vault of a validator.\n     *\n     * @custom:field shares          Amount of shares for KRO delegation.\n     * @custom:field lastDelegatedAt Last timestamp when the delegator delegated. The delegator can\n     *                               undelegate after MIN_DELEGATION_PERIOD elapsed.\n     */\n    struct KroDelegator {\n        uint128 shares;\n        uint128 lastDelegatedAt;\n    }\n\n    /**\n     * @notice Constructs the delegator of KGH in the vault of a validator.\n     *\n     * @custom:field rewardPerKghPaid Accumulated paid boosted reward per 1 KGH.\n     * @custom:field kghNum           Total number of KGH delegated.\n     * @custom:field delegatedAt      A mapping of tokenId to the delegation timestamp. The\n     *                                delegator can undelegate after MIN_DELEGATION_PERIOD\n     *                                elapsed from each delegation timestamp.\n     */\n    struct KghDelegator {\n        uint128 rewardPerKghPaid;\n        uint128 kghNum;\n        mapping(uint256 => uint128) delegatedAt;\n    }\n\n    /**\n     * @notice Constructs the vault of a validator.\n     *\n     * @custom:field withdrawAccount An account where assets can be withdrawn to. Only this account\n     *                               can withdraw the assets.\n     * @custom:field lastDepositedAt Last timestamp when the validator deposited. The validator can\n     *                               withdraw after MIN_DELEGATION_PERIOD elapsed.\n     * @custom:field asset           Asset information of the vault.\n     * @custom:field kroDelegators   A mapping of validator address to KRO delegator struct.\n     * @custom:field kghDelegators   A mapping of validator address to KGH delegator struct.\n     */\n    struct Vault {\n        address withdrawAccount;\n        uint128 lastDepositedAt;\n        Asset asset;\n        mapping(address => KroDelegator) kroDelegators;\n        mapping(address => KghDelegator) kghDelegators;\n    }\n\n    /**\n     * @notice Emitted when validator deposited KROs.\n     *\n     * @param validator Address of the validator.\n     * @param amount    The amount of KRO deposited.\n     */\n    event Deposited(address indexed validator, uint128 amount);\n\n    /**\n     * @notice Emitted when KROs are delegated.\n     *\n     * @param validator Address of the validator.\n     * @param delegator Address of the delegator.\n     * @param amount    The amount of KRO delegated.\n     * @param shares    The amount of shares received.\n     */\n    event KroDelegated(\n        address indexed validator,\n        address indexed delegator,\n        uint128 amount,\n        uint128 shares\n    );\n\n    /**\n     * @notice Emitted when a KGH is delegated.\n     *\n     * @param validator Address of the validator.\n     * @param delegator Address of the delegator.\n     * @param tokenId   Token id of the KGH.\n     */\n    event KghDelegated(address indexed validator, address indexed delegator, uint256 tokenId);\n\n    /**\n     * @notice Emitted when KGHs are delegated in batch.\n     *\n     * @param validator Address of the validator.\n     * @param delegator Address of the delegator.\n     * @param tokenIds  Array of token ids of the KGHs.\n     */\n    event KghBatchDelegated(\n        address indexed validator,\n        address indexed delegator,\n        uint256[] tokenIds\n    );\n\n    /**\n     * @notice Emitted when validator withdrew KRO.\n     *\n     * @param validator Address of the validator.\n     * @param amount    The amount of KRO the validator withdrew.\n     */\n    event Withdrawn(address indexed validator, uint128 amount);\n\n    /**\n     * @notice Emitted when KRO is undelegated.\n     *\n     * @param validator Address of the validator.\n     * @param delegator Address of the delegator.\n     * @param amount    The amount of KRO to undelegate.\n     * @param shares    The amount of shares to be burnt.\n     */\n    event KroUndelegated(\n        address indexed validator,\n        address indexed delegator,\n        uint128 amount,\n        uint128 shares\n    );\n\n    /**\n     * @notice Emitted when KGH is undelegated.\n     *\n     * @param validator Address of the validator.\n     * @param delegator Address of the delegator.\n     * @param tokenId   Token id of the KGH.\n     * @param amount    The amount of KRO claimed as boosted reward.\n     */\n    event KghUndelegated(\n        address indexed validator,\n        address indexed delegator,\n        uint256 tokenId,\n        uint128 amount\n    );\n\n    /**\n     * @notice Emitted when KGHs are undelegated in batch.\n     *\n     * @param validator Address of the validator.\n     * @param delegator Address of the delegator.\n     * @param tokenIds  Array of token ids of the KGHs.\n     * @param amount    The amount of KRO claimed as boosted reward.\n     */\n    event KghBatchUndelegated(\n        address indexed validator,\n        address indexed delegator,\n        uint256[] tokenIds,\n        uint128 amount\n    );\n\n    /**\n     * @notice Emitted when accumulated rewards of KGH delegation are claimed.\n     *\n     * @param validator Address of the validator.\n     * @param delegator Address of the delegator.\n     * @param amount    The amount of KRO claimed as boosted reward.\n     */\n    event KghRewardClaimed(address indexed validator, address indexed delegator, uint128 amount);\n\n    /**\n     * @notice Emitted when validator KRO is bonded during output submission or challenge creation.\n     *\n     * @param validator Address of the validator.\n     * @param amount    The amount of KRO bonded.\n     * @param remainder The remaining amount of validator KRO excluding bonded KRO.\n     */\n    event ValidatorKroBonded(address indexed validator, uint128 amount, uint128 remainder);\n\n    /**\n     * @notice Emitted when validator KRO is unbonded during output finalization or slashing.\n     *\n     * @param validator Address of the validator.\n     * @param amount    The amount of KRO unbonded.\n     * @param remainder The remaining amount of validator KRO excluding bonded KRO.\n     */\n    event ValidatorKroUnbonded(address indexed validator, uint128 amount, uint128 remainder);\n\n    /**\n     * @notice Reverts when caller is not allowed.\n     */\n    error NotAllowedCaller();\n\n    /**\n     * @notice Reverts when the status of validator is improper.\n     */\n    error ImproperValidatorStatus();\n\n    /**\n     * @notice Reverts when try to input zero.\n     */\n    error NotAllowedZeroInput();\n\n    /**\n     * @notice Reverts when the address is zero address.\n     */\n    error ZeroAddress();\n\n    /**\n     * @notice Reverts when the asset is insufficient.\n     */\n    error InsufficientAsset();\n\n    /**\n     * @notice Reverts when the share is insufficient.\n     */\n    error InsufficientShare();\n\n    /**\n     * @notice Reverts when the minimum delegation period is not elapsed.\n     */\n    error NotElapsedMinDelegationPeriod();\n\n    /**\n     * @notice Reverts when the given token ids are invalid.\n     */\n    error InvalidTokenIdsInput();\n\n    /**\n     * @notice Returns the address of withdraw account of given validator.\n     *\n     * @param validator Address of the validator.\n     *\n     * @return The address of withdraw account of given validator.\n     */\n    function getWithdrawAccount(address validator) external view returns (address);\n\n    /**\n     * @notice Returns when the validator can withdraw KRO. The validator can withdraw after\n     *         MIN_DELEGATION_PERIOD elapsed from lastDepositedAt.\n     *\n     * @param validator Address of the validator.\n     *\n     * @return When the validator can withdraw KRO.\n     */\n    function canWithdrawAt(address validator) external view returns (uint128);\n\n    /**\n     * @notice Returns the total amount of KRO a validator has deposited and been rewarded.\n     *\n     * @param validator Address of the validator.\n     *\n     * @return The total amount of KRO a validator has deposited and been rewarded.\n     */\n    function totalValidatorKro(address validator) external view returns (uint128);\n\n    /**\n     * @notice Returns the total amount of validator KRO that bonded during output submission or\n     *         challenge creation.\n     *\n     * @param validator Address of the validator.\n     *\n     * @return The total amount of validator KRO bonded.\n     */\n    function totalValidatorKroBonded(address validator) external view returns (uint128);\n\n    /**\n     * @notice Returns the total amount of validator balance excluding the bond amount.\n     *\n     * @param validator Address of the validator.\n     *\n     * @return The total amount of validator balance excluding the bond amount.\n     */\n    function totalValidatorKroNotBonded(address validator) external view returns (uint128);\n\n    /**\n     * @notice Returns the total amount of KRO that delegated by the delegators and accumulated as\n     *         KRO delegation reward.\n     *\n     * @param validator Address of the validator.\n     *\n     * @return The total amount of KRO that delegated by the delegators and accumulated as KRO\n     *         delegation reward.\n     */\n    function totalKroAssets(address validator) external view returns (uint128);\n\n    /**\n     * @notice Returns the total number of KGHs held by the vault.\n     *\n     * @param validator Address of the validator.\n     *\n     * @return The total number of KGHs held by the vault.\n     */\n    function totalKghNum(address validator) external view returns (uint128);\n\n    /**\n     * @notice Returns the amount of KRO shares that the KRO delegator has.\n     *\n     * @param validator Address of the validator.\n     * @param delegator Address of the delegator.\n     *\n     * @return The amount of KRO shares that the KRO delegator has.\n     */\n    function getKroTotalShareBalance(\n        address validator,\n        address delegator\n    ) external view returns (uint128);\n\n    /**\n     * @notice Returns the amount of KRO assets delegated to the given validator by the delegator.\n     *\n     * @param validator Address of the validator.\n     * @param delegator Address of the delegator.\n     *\n     * @return The amount of KRO assets that the delegator delegated to the validator.\n     */\n    function getKroAssets(address validator, address delegator) external view returns (uint128);\n\n    /**\n     * @notice Returns when the KRO delegators can undelegate KRO. The delegators can undelegate\n     *         after MIN_DELEGATION_PERIOD elapsed from lastDelegatedAt.\n     *\n     * @param validator Address of the validator.\n     * @param delegator Address of the KRO delegator.\n     *\n     * @return When the KRO delegators can undelegate KRO.\n     */\n    function canUndelegateKroAt(\n        address validator,\n        address delegator\n    ) external view returns (uint128);\n\n    /**\n     * @notice Returns the number of KGH delegated by the given delegator.\n     *\n     * @param validator Address of the validator.\n     * @param delegator Address of the delegator.\n     *\n     * @return The number of KGH delegated by the given delegator.\n     */\n    function getKghNum(address validator, address delegator) external view returns (uint128);\n\n    /**\n     * @notice Returns when the KGH delegators can undelegate KGH. The delegators can undelegate KGH\n     *         for the given token id after MIN_DELEGATION_PERIOD elapsed from delegation\n     *         timestamp.\n     *\n     * @param validator Address of the validator.\n     * @param delegator Address of the KGH delegator.\n     * @param tokenId   The token id of KGH to undelegate.\n     *\n     * @return When the KGH delegators can undelegate KGH for the given token id.\n     */\n    function canUndelegateKghAt(\n        address validator,\n        address delegator,\n        uint256 tokenId\n    ) external view returns (uint128);\n\n    /**\n     * @notice Allows an on-chain or off-chain user to simulate the effects of their KRO delegation\n     *         at the current block.\n     *\n     * @param validator Address of the validator.\n     * @param assets    The amount of assets to delegate.\n     *\n     * @return The amount of shares that the Vault would exchange for the amount of assets provided.\n     */\n    function previewDelegate(address validator, uint128 assets) external view returns (uint128);\n\n    /**\n     * @notice Allows an on-chain or off-chain user to simulate the effects of their KRO\n     *         undelegation at the current block.\n     *\n     * @param validator The address of the validator.\n     * @param shares    The amount of shares to undelegate.\n     *\n     * @return The amount of assets that the Vault would exchange for the amount of shares provided.\n     */\n    function previewUndelegate(address validator, uint128 shares) external view returns (uint128);\n\n    /**\n     * @notice Returns the claimable reward of KGH delegation.\n     *\n     * @param validator The address of the validator.\n     * @param delegator The address of the delegator.\n     *\n     * @return The amount of claimable reward of KGH delegation.\n     */\n    function getKghReward(address validator, address delegator) external view returns (uint128);\n\n    /**\n     * @notice Deposit KRO. To deposit KRO, the validator should be initiated.\n     *\n     * @param assets The amount of KRO to deposit.\n     */\n    function deposit(uint128 assets) external;\n\n    /**\n     * @notice Withdraw KRO. To withdraw KRO, the validator should be initiated and MIN_DELEGATION_PERIOD\n     *         should be passed after the last deposit time. Only withdrawAccount of the validator can call\n     *         this function.\n     *\n     * @param validator Address of the validator.\n     * @param assets    The amount of KRO to withdraw.\n     */\n    function withdraw(address validator, uint128 assets) external;\n\n    /**\n     * @notice Delegate KRO to the validator and returns the amount of shares that the vault would\n     *         exchange.\n     *\n     * @param validator Address of the validator.\n     * @param assets    The amount of KRO to delegate.\n     *\n     * @return The amount of shares that the Vault would exchange for the amount of assets provided.\n     */\n    function delegate(address validator, uint128 assets) external returns (uint128);\n\n    /**\n     * @notice Delegate KGH to the validator.\n     *\n     * @param validator Address of the validator.\n     * @param tokenId   The token id of KGH to delegate.\n     */\n    function delegateKgh(address validator, uint256 tokenId) external;\n\n    /**\n     * @notice Delegate KGHs to the validator.\n     *\n     * @param validator Address of the validator.\n     * @param tokenIds  The token ids of KGHs to delegate.\n     */\n    function delegateKghBatch(address validator, uint256[] calldata tokenIds) external;\n\n    /**\n     * @notice Undelegate the KRO of given assets for the given validator.\n     *\n     * @param validator Address of the validator.\n     * @param assets    The amount of assets to undelegate.\n     */\n    function undelegate(address validator, uint128 assets) external;\n\n    /**\n     * @notice Undelegate KGH for given validator and tokenId.\n     *\n     * @param validator Address of the validator.\n     * @param tokenId   Token id of KGH to undelegate.\n     */\n    function undelegateKgh(address validator, uint256 tokenId) external;\n\n    /**\n     * @notice Undelegate KGHs for given validator and token ids.\n     *\n     * @param validator Address of the validator.\n     * @param tokenIds  Array of token ids of KGHs to undelegate.\n     */\n    function undelegateKghBatch(address validator, uint256[] calldata tokenIds) external;\n\n    /**\n     * @notice Claim the boosted reward of the KGH delegator from the given validator vault.\n     *\n     * @param validator Address of the validator.\n     */\n    function claimKghReward(address validator) external;\n}\n"
    },
    "contracts/L1/interfaces/IValidatorManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { AssetManager } from \"../AssetManager.sol\";\nimport { L2OutputOracle } from \"../L2OutputOracle.sol\";\n\n/**\n * @title IValidatorManager\n * @notice Interface for ValidatorManager contract.\n */\ninterface IValidatorManager {\n    /**\n     * @notice Enum of the status of a validator.\n     *\n     * Below is the possible conditions of each status. \"initiated\" means the validator has been\n     * initiated at least once, \"activated\" means the validator has been activated and added to the\n     * validator tree. \"MIN_REGISTER_AMOUNT\" means the total assets of the validator exceeds\n     * MIN_REGISTER_AMOUNT, \"MIN_ACTIVATE_AMOUNT\" means the same.\n     *\n     * +------------+-----------+-----------+---------------------+---------------------+\n     * | Status     | initiated | activated | MIN_REGISTER_AMOUNT | MIN_ACTIVATE_AMOUNT |\n     * +------------+-----------+-----------+---------------------+---------------------+\n     * | NONE       | X         | X         | X                   | X                   |\n     * | EXITED     | O         | O/X       | X                   | O/X                 |\n     * | REGISTERED | O         | X         | O                   | X                   |\n     * | READY      | O         | X         | O                   | O                   |\n     * | INACTIVE   | O         | O         | O                   | X                   |\n     * | ACTIVE     | O         | O         | O                   | O                   |\n     * +------------+-----------+-----------+---------------------+---------------------+\n     */\n    enum ValidatorStatus {\n        NONE,\n        EXITED,\n        REGISTERED,\n        READY,\n        INACTIVE,\n        ACTIVE\n    }\n\n    /**\n     * @notice Constructs the constructor parameters of ValidatorManager contract.\n     *\n     * @custom:field _l2Oracle                     Address of the L2OutputOracle contract.\n     * @custom:field _assetManager                 Address of the AssetManager contract.\n     * @custom:field _trustedValidator             Address of the trusted validator.\n     * @custom:field _commissionChangeDelaySeconds The delay to finalize the commission rate change\n     *                                             in seconds.\n     * @custom:field _roundDurationSeconds         The duration of one submission round in seconds.\n     * @custom:field _softJailPeriodSeconds        The minimum duration to get out of jail in\n     *                                             seconds in output non-submissions penalty.\n     * @custom:field _hardJailPeriodSeconds        The minimum duration to get out of jail in\n     *                                             seconds in slashing penalty.\n     * @custom:field _jailThreshold                The maximum allowed number of output\n     *                                             non-submissions before jailed.\n     * @custom:field _maxOutputFinalizations       Max number of finalized outputs.\n     * @custom:field _baseReward                   Base reward for the validator.\n     * @custom:field _minRegisterAmount            Minimum amount to register as a validator.\n     * @custom:field _minActivateAmount            Minimum amount to activate a validator.\n     */\n    struct ConstructorParams {\n        L2OutputOracle _l2Oracle;\n        AssetManager _assetManager;\n        address _trustedValidator;\n        uint128 _commissionChangeDelaySeconds;\n        uint128 _roundDurationSeconds;\n        uint128 _softJailPeriodSeconds;\n        uint128 _hardJailPeriodSeconds;\n        uint128 _jailThreshold;\n        uint128 _maxOutputFinalizations;\n        uint128 _baseReward;\n        uint128 _minRegisterAmount;\n        uint128 _minActivateAmount;\n    }\n\n    /**\n     * @notice Constructs the information of a validator.\n     *\n     * @custom:field isInitiated                 Whether the validator is initiated.\n     * @custom:field noSubmissionCount           Number of counts that the validator did not submit\n     *                                           the output in priority round.\n     * @custom:field commissionRate              Commission rate of validator.\n     * @custom:field pendingCommissionRate       Pending commission rate of validator.\n     * @custom:field commissionChangeInitiatedAt Timestamp of commission change initialization.\n     */\n    struct Validator {\n        bool isInitiated;\n        uint8 noSubmissionCount;\n        uint8 commissionRate;\n        uint8 pendingCommissionRate;\n        uint128 commissionChangeInitiatedAt;\n    }\n\n    /**\n     * @notice Emitted when registers as a validator.\n     *\n     * @param validator      Address of the validator.\n     * @param activated      If the validator is activated or not.\n     * @param commissionRate The commission rate the validator sets.\n     * @param assets         The number of assets the validator deposits.\n     */\n    event ValidatorRegistered(\n        address indexed validator,\n        bool activated,\n        uint8 commissionRate,\n        uint128 assets\n    );\n\n    /**\n     * @notice Emitted when a validator activated, which means added to the validator tree.\n     *\n     * @param validator   Address of the validator.\n     * @param activatedAt The timestamp when the validator activated.\n     */\n    event ValidatorActivated(address indexed validator, uint256 activatedAt);\n\n    /**\n     * @notice Emitted when a validator stops, which means removed from the validator tree.\n     *\n     * @param validator Address of the validator.\n     * @param stopsAt   The timestamp when the validator stops.\n     */\n    event ValidatorStopped(address indexed validator, uint256 stopsAt);\n\n    /**\n     * @notice Emitted when a validator initiated commission rate change.\n     *\n     * @param validator         Address of the validator.\n     * @param oldCommissionRate The old commission rate.\n     * @param newCommissionRate The new commission rate.\n     */\n    event ValidatorCommissionChangeInitiated(\n        address indexed validator,\n        uint8 oldCommissionRate,\n        uint8 newCommissionRate\n    );\n\n    /**\n     * @notice Emitted when a validator finalized commission rate change.\n     *\n     * @param validator         Address of the validator.\n     * @param oldCommissionRate The old commission rate.\n     * @param newCommissionRate The new commission rate.\n     */\n    event ValidatorCommissionChangeFinalized(\n        address indexed validator,\n        uint8 oldCommissionRate,\n        uint8 newCommissionRate\n    );\n\n    /**\n     * @notice Emitted when a validator is jailed.\n     *\n     * @param validator Address of the validator.\n     * @param expiresAt The expiration timestamp of the jail.\n     */\n    event ValidatorJailed(address indexed validator, uint128 expiresAt);\n\n    /**\n     * @notice Emitted when a validator is unjailed.\n     *\n     * @param validator Address of the validator.\n     */\n    event ValidatorUnjailed(address indexed validator);\n\n    /**\n     * @notice Emitted when the output reward is distributed.\n     *\n     * @param outputIndex     Index of the L2 checkpoint output.\n     * @param validator       Address of the validator whose vault is rewarded.\n     * @param validatorReward The amount of validator reward.\n     * @param baseReward      The amount of base reward for KRO delegators.\n     * @param boostedReward   The amount of boosted reward for KGH delegators.\n     */\n    event RewardDistributed(\n        uint256 indexed outputIndex,\n        address indexed validator,\n        uint128 validatorReward,\n        uint128 baseReward,\n        uint128 boostedReward\n    );\n\n    /**\n     * @notice Emitted when challenge reward for challenge winner is distributed.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param recipient   Address of the reward recipient.\n     * @param amount      The amount of challenge reward.\n     */\n    event ChallengeRewardDistributed(\n        uint256 indexed outputIndex,\n        address indexed recipient,\n        uint128 amount\n    );\n\n    /**\n     * @notice Emitted when the validator is slashed.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param loser       Address of the challenge loser.\n     * @param amount      The amount of KRO slashed.\n     */\n    event Slashed(uint256 indexed outputIndex, address indexed loser, uint128 amount);\n\n    /**\n     * @notice Emitted when the slash is reverted.\n     *\n     * @param outputIndex Index of the L2 checkpoint output.\n     * @param loser       Address of the challenge original loser.\n     * @param amount      The amount of KRO refunded to the loser.\n     */\n    event SlashReverted(uint256 indexed outputIndex, address indexed loser, uint128 amount);\n\n    /**\n     * @notice Reverts when caller is not allowed.\n     */\n    error NotAllowedCaller();\n\n    /**\n     * @notice Reverts when constructor parameters are invalid.\n     */\n    error InvalidConstructorParams();\n\n    /**\n     * @notice Reverts when the status of validator is improper.\n     */\n    error ImproperValidatorStatus();\n\n    /**\n     * @notice Reverts when the asset is insufficient.\n     */\n    error InsufficientAsset();\n\n    /**\n     * @notice Reverts when the commission rate exceeds the max value.\n     */\n    error MaxCommissionRateExceeded();\n\n    /**\n     * @notice Reverts when try to change commission rate with same value as previous.\n     */\n    error SameCommissionRate();\n\n    /**\n     * @notice Reverts when the commission rate change has not been initiated.\n     */\n    error NotInitiatedCommissionChange();\n\n    /**\n     * @notice Reverts when the delay of commission rate change finalization has not elapsed.\n     */\n    error NotElapsedCommissionChangeDelay();\n\n    /**\n     * @notice Reverts when try to unjail before jail period elapsed.\n     */\n    error NotElapsedJailPeriod();\n\n    /**\n     * @notice Reverts if the validator is not selected priority validator.\n     */\n    error NotSelectedPriorityValidator();\n\n    /**\n     * @notice Registers as a validator with assets at least MIN_REGISTER_AMOUNT. The validator with\n     *         assets more than MIN_ACTIVATE_AMOUNT can be activated at the same time.\n     *\n     * @param assets          The amount of assets to deposit.\n     * @param commissionRate  The commission rate the validator sets.\n     * @param withdrawAccount An account where assets can be withdrawn to. Only this account can\n     *                        withdraw the assets.\n     */\n    function registerValidator(\n        uint128 assets,\n        uint8 commissionRate,\n        address withdrawAccount\n    ) external;\n\n    /**\n     * @notice Activates a validator and adds the validator to validator tree. To submit outputs,\n     *         the validator should be activated.\n     */\n    function activateValidator() external;\n\n    /**\n     * @notice Tries to activate a validator and adds the validator to validator tree. To submit\n     *         outputs, the validator should be activated. This function can only be called by\n     *         AssetManager.\n     *\n     * @param validator Address of the validator.\n     */\n    function tryActivateValidator(address validator) external;\n\n    /**\n     * @notice Handles some essential actions such as reward distribution, jail handling, next\n     *         priority validator selection after output submission. This function can only be\n     *         called by L2OutputOracle.\n     *\n     * @param outputIndex Index of the L2 checkpoint output submitted.\n     */\n    function afterSubmitL2Output(uint256 outputIndex) external;\n\n    /**\n     * @notice Initiates the commission rate change of a validator. An exited or jailed validator\n     *         cannot initiate it.\n     *\n     * @param newCommissionRate The new commission rate to apply.\n     */\n    function initCommissionChange(uint8 newCommissionRate) external;\n\n    /**\n     * @notice Finalizes the commission rate change of a validator. An exited or jailed validator\n     *         cannot finalize it, and a validator can finalize it after\n     *         COMMISION_CHANGE_DELAY_SECONDS elapsed since the initialization of commission change.\n     */\n    function finalizeCommissionChange() external;\n\n    /**\n     * @notice Attempts to unjail a validator. Only the validator who wants to unjail can call\n     *         itself.\n     */\n    function tryUnjail() external;\n\n    /**\n     * @notice Call ASSET_MANAGER.bondValidatorKro(). This function is only called by the Colosseum\n     *         contract.\n     *\n     * @param validator Address of the validator.\n     */\n    function bondValidatorKro(address validator) external;\n\n    /**\n     * @notice Call ASSET_MANAGER.unbondValidatorKro(). This function is only called by the\n     *         Colosseum contract.\n     *\n     * @param validator Address of the validator.\n     */\n    function unbondValidatorKro(address validator) external;\n\n    /**\n     * @notice Slash KRO from the vault of the challenge loser and move the slashing asset to\n     *         pending challenge reward before output rewarded, after directly to winner's asset.\n     *         Since the behavior could threaten the security of the chain, the loser is sent to\n     *         jail for HARD_JAIL_PERIOD_SECONDS. This function is only called by the Colosseum\n     *         contract.\n     *\n     * @param outputIndex The index of output challenged.\n     * @param winner      Address of the challenge winner.\n     * @param loser       Address of the challenge loser.\n     */\n    function slash(uint256 outputIndex, address winner, address loser) external;\n\n    /**\n     * @notice Revert slash. This function is only called by the Colosseum contract.\n     *\n     * @param outputIndex The index of output challenged.\n     * @param loser       Address of the challenge loser.\n     */\n    function revertSlash(uint256 outputIndex, address loser) external;\n\n    /**\n     * @notice Updates the validator tree.\n     *\n     * @param validator Address of the validator.\n     * @param tryRemove Flag to try remove the validator from validator tree.\n     */\n    function updateValidatorTree(address validator, bool tryRemove) external;\n\n    /**\n     * @notice Returns the no submission count of given validator.\n     *\n     * @param validator Address of the validator.\n     *\n     * @return The no submission count of given validator.\n     */\n    function noSubmissionCount(address validator) external view returns (uint8);\n\n    /**\n     * @notice Returns the commission rate of given validator.\n     *\n     * @param validator Address of the validator.\n     *\n     * @return The commission rate of given validator.\n     */\n    function getCommissionRate(address validator) external view returns (uint8);\n\n    /**\n     * @notice Returns the pending commission rate of given validator.\n     *\n     * @param validator Address of the validator.\n     *\n     * @return The pending commission rate of given validator.\n     */\n    function getPendingCommissionRate(address validator) external view returns (uint8);\n\n    /**\n     * @notice Returns when commission change of given validator can be finalized.\n     *\n     * @param validator Address of the validator.\n     *\n     * @return When commission change of given validator can be finalized.\n     */\n    function canFinalizeCommissionChangeAt(address validator) external view returns (uint128);\n\n    /**\n     * @notice Checks the eligibility to submit L2 checkpoint output during output submission.\n     *         Note that only the validator whose status is ACTIVE can submit output. This function\n     *         can only be called by L2OutputOracle during output submission.\n     *\n     * @param validator Address of the output submitter.\n     */\n    function checkSubmissionEligibility(address validator) external view;\n\n    /**\n     * @notice Determines who can submit the L2 checkpoint output for the current round.\n     *\n     * @return Address of the validator who can submit the L2 checkpoint output for the current\n     *         round.\n     */\n    function nextValidator() external view returns (address);\n\n    /**\n     * @notice Returns the status of the validator corresponding to the given address.\n     *\n     * @param validator Address of the validator.\n     *\n     * @return The status of the validator corresponding to the given address.\n     */\n    function getStatus(address validator) external view returns (ValidatorStatus);\n\n    /**\n     * @notice Returns if the given validator is in jail or not.\n     *\n     * @param validator Address of the validator.\n     *\n     * @return If the given validator is in jail or not.\n     */\n    function inJail(address validator) external view returns (bool);\n\n    /**\n     * @notice Returns the jail expiration timestamp of given validator.\n     *\n     * @param validator Address of the jailed validator.\n     *\n     * @return The jail expiration timestamp of given validator.\n     */\n    function jailExpiresAt(address validator) external view returns (uint128);\n\n    /**\n     * @notice Returns if the status of the given validator is active.\n     *\n     * @param validator Address of the validator.\n     *\n     * @return If the status of the given validator is active.\n     */\n    function isActive(address validator) external view returns (bool);\n\n    /**\n     * @notice Returns the weight of given validator. It not activated, returns 0.\n     *         Note that `weight / activatedValidatorTotalWeight()` is the probability that the\n     *         validator is selected as a priority validator.\n     *\n     * @param validator Address of the validator.\n     *\n     * @return The weight of given validator.\n     */\n    function getWeight(address validator) external view returns (uint120);\n\n    /**\n     * @notice Returns the number of activated validators.\n     *\n     * @return The number of activated validators.\n     */\n    function activatedValidatorCount() external view returns (uint32);\n\n    /**\n     * @notice Returns the total weight of activated validators.\n     *\n     * @return The total weight of activated validators.\n     */\n    function activatedValidatorTotalWeight() external view returns (uint120);\n}\n"
    },
    "contracts/L1/interfaces/IZKMerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title IZKMerkleTrie\n */\ninterface IZKMerkleTrie {\n    /**\n     * @notice Verifies a proof that a given key/value pair is present in the trie.\n     *\n     * @param _key    Key of the node to search for, as a hex string.\n     * @param _value  Value of the node to search for, as a hex string.\n     * @param _proofs Merkle trie inclusion proof for the desired node.\n     * @param _root   Known root of the Merkle trie. Used to verify that the included proof is\n     *                correctly constructed.\n     *\n     * @return Whether or not the proof is valid.\n     */\n    function verifyInclusionProof(\n        bytes32 _key,\n        bytes memory _value,\n        bytes[] memory _proofs,\n        bytes32 _root\n    ) external view returns (bool);\n}\n"
    },
    "contracts/L2/CrossDomainOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\n\n/**\n * @title CrossDomainOwnable\n * @notice This contract extends the OpenZeppelin `Ownable` contract for L2 contracts to be owned\n *         by contracts on L1. Note that this contract is only safe to be used if the\n *         CrossDomainMessenger system is bypassed and the caller on L1 is calling the\n *         KromaPortal directly.\n */\nabstract contract CrossDomainOwnable is Ownable {\n    /**\n     * @notice Overrides the implementation of the `onlyOwner` modifier to check that the unaliased\n     *         `msg.sender` is the owner of the contract.\n     */\n    function _checkOwner() internal view override {\n        require(\n            owner() == AddressAliasHelper.undoL1ToL2Alias(msg.sender),\n            \"CrossDomainOwnable: caller is not the owner\"\n        );\n    }\n}\n"
    },
    "contracts/L2/CrossDomainOwnable2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { L2CrossDomainMessenger } from \"./L2CrossDomainMessenger.sol\";\n\n/**\n * @title CrossDomainOwnable2\n * @notice This contract extends the OpenZeppelin `Ownable` contract for L2 contracts to be owned\n *         by contracts on L1. Note that this contract is meant to be used with systems that use\n *         the CrossDomainMessenger system. It will not work if the KromaPortal is used\n *         directly.\n */\nabstract contract CrossDomainOwnable2 is Ownable {\n    /**\n     * @notice Overrides the implementation of the `onlyOwner` modifier to check that the unaliased\n     *         `xDomainMessageSender` is the owner of the contract. This value is set to the caller\n     *         of the L1CrossDomainMessenger.\n     */\n    function _checkOwner() internal view override {\n        L2CrossDomainMessenger messenger = L2CrossDomainMessenger(\n            Predeploys.L2_CROSS_DOMAIN_MESSENGER\n        );\n\n        require(\n            msg.sender == address(messenger),\n            \"CrossDomainOwnable2: caller is not the messenger\"\n        );\n\n        require(\n            owner() == messenger.xDomainMessageSender(),\n            \"CrossDomainOwnable2: caller is not the owner\"\n        );\n    }\n}\n"
    },
    "contracts/L2/CrossDomainOwnable3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { L2CrossDomainMessenger } from \"./L2CrossDomainMessenger.sol\";\n\n/**\n * @title CrossDomainOwnable3\n * @notice This contract extends the OpenZeppelin `Ownable` contract for L2 contracts to be owned\n *         by contracts on either L1 or L2. Note that this contract is meant to be used with systems\n *         that use the CrossDomainMessenger system. It will not work if the KromaPortal is\n *         used directly.\n */\nabstract contract CrossDomainOwnable3 is Ownable {\n    /**\n     * @notice If true, the contract uses the cross domain _checkOwner function override. If false\n     *         it uses the standard Ownable _checkOwner function.\n     */\n    bool public isLocal = true;\n\n    /**\n     * @notice Emits when ownership of the contract is transferred. Includes the\n     *         isLocal field in addition to the standard `Ownable` OwnershipTransferred event.\n     */\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner,\n        bool isLocal\n    );\n\n    /**\n     * @notice Allows for ownership to be transferred with specifying the locality.\n     * @param _owner   The new owner of the contract.\n     * @param _isLocal Configures the locality of the ownership.\n     */\n    function transferOwnership(address _owner, bool _isLocal) external onlyOwner {\n        require(_owner != address(0), \"CrossDomainOwnable3: new owner is the zero address\");\n\n        address oldOwner = owner();\n        _transferOwnership(_owner);\n        isLocal = _isLocal;\n\n        emit OwnershipTransferred(oldOwner, _owner, _isLocal);\n    }\n\n    /**\n     * @notice Overrides the implementation of the `onlyOwner` modifier to check that the unaliased\n     *         `xDomainMessageSender` is the owner of the contract. This value is set to the caller\n     *         of the L1CrossDomainMessenger.\n     */\n    function _checkOwner() internal view override {\n        if (isLocal) {\n            require(owner() == msg.sender, \"CrossDomainOwnable3: caller is not the owner\");\n        } else {\n            L2CrossDomainMessenger messenger = L2CrossDomainMessenger(\n                Predeploys.L2_CROSS_DOMAIN_MESSENGER\n            );\n\n            require(\n                msg.sender == address(messenger),\n                \"CrossDomainOwnable3: caller is not the messenger\"\n            );\n\n            require(\n                owner() == messenger.xDomainMessageSender(),\n                \"CrossDomainOwnable3: caller is not the owner\"\n            );\n        }\n    }\n}\n"
    },
    "contracts/L2/GasPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { L1Block } from \"../L2/L1Block.sol\";\nimport { ISemver } from \"../universal/ISemver.sol\";\n\n/// @custom:proxied\n/// @custom:predeploy 0x4200000000000000000000000000000000000005\n/// @title GasPriceOracle\n/// @notice This contract maintains the variables responsible for computing the L1 portion of the\n///         total fee charged on L2. Before Bedrock, this contract held variables in state that were\n///         read during the state transition function to compute the L1 portion of the transaction\n///         fee. After Bedrock, this contract now simply proxies the L1Block contract, which has\n///         the values used to compute the L1 portion of the fee in its state.\n///\n///         The contract exposes an API that is useful for knowing how large the L1 portion of the\n///         transaction fee will be. The following events were deprecated with Bedrock:\n///         - event OverheadUpdated(uint256 overhead);\n///         - event ScalarUpdated(uint256 scalar);\n///         - event DecimalsUpdated(uint256 decimals);\ncontract GasPriceOracle is ISemver {\n    /// @notice Number of decimals used in the scalar.\n    uint256 public constant DECIMALS = 6;\n\n    /// @notice Semantic version.\n    /// @custom:semver 1.1.0\n    string public constant version = \"1.1.0\";\n\n    /// @notice Indicates whether the network has gone through the Ecotone upgrade.\n    bool public isEcotone;\n\n    /// @notice Computes the L1 portion of the fee based on the size of the rlp encoded input\n    ///         transaction, the current L1 base fee, and the various dynamic parameters.\n    /// @param _data Unsigned fully RLP-encoded transaction to get the L1 fee for.\n    /// @return L1 fee that should be paid for the tx\n    function getL1Fee(bytes memory _data) external view returns (uint256) {\n        if (isEcotone) {\n            return _getL1FeeEcotone(_data);\n        }\n        return _getL1FeeBedrock(_data);\n    }\n\n    /// @notice Set chain to be Ecotone chain (callable by depositor account)\n    function setEcotone() external {\n        require(\n            msg.sender == L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).DEPOSITOR_ACCOUNT(),\n            \"GasPriceOracle: only the depositor account can set isEcotone flag\"\n        );\n        require(isEcotone == false, \"GasPriceOracle: Ecotone already active\");\n        isEcotone = true;\n    }\n\n    /// @notice Retrieves the current gas price (base fee).\n    /// @return Current L2 gas price (base fee).\n    function gasPrice() public view returns (uint256) {\n        return block.basefee;\n    }\n\n    /// @notice Retrieves the current base fee.\n    /// @return Current L2 base fee.\n    function baseFee() public view returns (uint256) {\n        return block.basefee;\n    }\n\n    /// @custom:legacy\n    /// @notice Retrieves the current fee overhead.\n    /// @return Current fee overhead.\n    function overhead() public view returns (uint256) {\n        require(!isEcotone, \"GasPriceOracle: overhead() is deprecated\");\n        return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).l1FeeOverhead();\n    }\n\n    /// @custom:legacy\n    /// @notice Retrieves the current fee scalar.\n    /// @return Current fee scalar.\n    function scalar() public view returns (uint256) {\n        require(!isEcotone, \"GasPriceOracle: scalar() is deprecated\");\n        return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).l1FeeScalar();\n    }\n\n    /// @notice Retrieves the latest known L1 base fee.\n    /// @return Latest known L1 base fee.\n    function l1BaseFee() public view returns (uint256) {\n        return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).basefee();\n    }\n\n    /// @notice Retrieves the current blob base fee.\n    /// @return Current blob base fee.\n    function blobBaseFee() public view returns (uint256) {\n        return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).blobBaseFee();\n    }\n\n    /// @notice Retrieves the current base fee scalar.\n    /// @return Current base fee scalar.\n    function baseFeeScalar() public view returns (uint32) {\n        return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).baseFeeScalar();\n    }\n\n    /// @notice Retrieves the current blob base fee scalar.\n    /// @return Current blob base fee scalar.\n    function blobBaseFeeScalar() public view returns (uint32) {\n        return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).blobBaseFeeScalar();\n    }\n\n    /// @custom:legacy\n    /// @notice Retrieves the number of decimals used in the scalar.\n    /// @return Number of decimals used in the scalar.\n    function decimals() public pure returns (uint256) {\n        return DECIMALS;\n    }\n\n    /// @notice Computes the amount of L1 gas used for a transaction. Adds 68 bytes\n    ///         of padding to account for the fact that the input does not have a signature.\n    /// @param _data Unsigned fully RLP-encoded transaction to get the L1 gas for.\n    /// @return Amount of L1 gas used to publish the transaction.\n    function getL1GasUsed(bytes memory _data) public view returns (uint256) {\n        uint256 l1GasUsed = _getCalldataGas(_data);\n        if (isEcotone) {\n            return l1GasUsed;\n        }\n        return l1GasUsed + L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).l1FeeOverhead();\n    }\n\n    /// @notice Computation of the L1 portion of the fee for Bedrock.\n    /// @param _data Unsigned fully RLP-encoded transaction to get the L1 fee for.\n    /// @return L1 fee that should be paid for the tx\n    function _getL1FeeBedrock(bytes memory _data) internal view returns (uint256) {\n        uint256 l1GasUsed = _getCalldataGas(_data);\n        uint256 fee = (l1GasUsed + L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).l1FeeOverhead()) * l1BaseFee()\n            * L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).l1FeeScalar();\n        return fee / (10 ** DECIMALS);\n    }\n\n    /// @notice L1 portion of the fee after Ecotone.\n    /// @param _data Unsigned fully RLP-encoded transaction to get the L1 fee for.\n    /// @return L1 fee that should be paid for the tx\n    function _getL1FeeEcotone(bytes memory _data) internal view returns (uint256) {\n        uint256 l1GasUsed = _getCalldataGas(_data);\n        uint256 scaledBaseFee = baseFeeScalar() * 16 * l1BaseFee();\n        uint256 scaledBlobBaseFee = blobBaseFeeScalar() * blobBaseFee();\n        uint256 fee = l1GasUsed * (scaledBaseFee + scaledBlobBaseFee);\n        return fee / (16 * 10 ** DECIMALS);\n    }\n\n    /// @notice L1 gas estimation calculation.\n    /// @param _data Unsigned fully RLP-encoded transaction to get the L1 gas for.\n    /// @return Amount of L1 gas used to publish the transaction.\n    function _getCalldataGas(bytes memory _data) internal pure returns (uint256) {\n        uint256 total = 0;\n        uint256 length = _data.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (_data[i] == 0) {\n                total += 4;\n            } else {\n                total += 16;\n            }\n        }\n        return total + (68 * 16);\n    }\n}\n"
    },
    "contracts/L2/L1Block.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { ISemver } from \"../universal/ISemver.sol\";\n\n/// @custom:proxied\n/// @custom:predeploy 0x4200000000000000000000000000000000000002\n/// @title L1Block\n/// @notice The L1Block predeploy gives users access to information about the last known L1 block.\n///         Values within this contract are updated once per epoch (every L1 block) and can only be\n///         set by the \"depositor\" account, a special system address. Depositor account transactions\n///         are created by the protocol whenever we move to a new epoch.\ncontract L1Block is ISemver {\n    /// @notice Address of the special depositor account.\n    address public constant DEPOSITOR_ACCOUNT = 0xDeaDDEaDDeAdDeAdDEAdDEaddeAddEAdDEAd0001;\n\n    /// @notice The latest L1 block number known by the L2 system.\n    uint64 public number;\n\n    /// @notice The latest L1 timestamp known by the L2 system.\n    uint64 public timestamp;\n\n    /// @notice The latest L1 base fee.\n    uint256 public basefee;\n\n    /// @notice The latest L1 blockhash.\n    bytes32 public hash;\n\n    /// @notice The number of L2 blocks in the same epoch.\n    uint64 public sequenceNumber;\n\n    /// @notice The scalar value applied to the L1 blob base fee portion of the blob-capable L1 cost func.\n    uint32 public blobBaseFeeScalar;\n\n    /// @notice The scalar value applied to the L1 base fee portion of the blob-capable L1 cost func.\n    uint32 public baseFeeScalar;\n\n    /// @notice The versioned hash to authenticate the batcher by.\n    bytes32 public batcherHash;\n\n    /// @notice The overhead value applied to the L1 portion of the transaction fee.\n    /// @custom:legacy\n    uint256 public l1FeeOverhead;\n\n    /// @notice The scalar value applied to the L1 portion of the transaction fee.\n    /// @custom:legacy\n    uint256 public l1FeeScalar;\n\n    /// @notice The scalar value to distribute transaction fees as validator reward.\n    ///         The denominator is 10000, so the ratio is expressed in 4 decimal places.\n    /// @custom:legacy\n    uint256 public validatorRewardScalar;\n\n    /// @notice The latest L1 blob base fee.\n    uint256 public blobBaseFee;\n\n    /// @custom:semver 1.1.0\n    string public constant version = \"1.1.0\";\n\n    /// @custom:legacy\n    /// @notice Updates the L1 block values.\n    /// @param _number                L1 blocknumber.\n    /// @param _timestamp             L1 timestamp.\n    /// @param _basefee               L1 basefee.\n    /// @param _hash                  L1 blockhash.\n    /// @param _sequenceNumber        Number of L2 blocks since epoch start.\n    /// @param _batcherHash           Versioned hash to authenticate batcher by.\n    /// @param _l1FeeOverhead         L1 fee overhead.\n    /// @param _l1FeeScalar           L1 fee scalar.\n    /// @param _validatorRewardScalar Validator reward scalar.\n    function setL1BlockValues(\n        uint64 _number,\n        uint64 _timestamp,\n        uint256 _basefee,\n        bytes32 _hash,\n        uint64 _sequenceNumber,\n        bytes32 _batcherHash,\n        uint256 _l1FeeOverhead,\n        uint256 _l1FeeScalar,\n        uint256 _validatorRewardScalar\n    )\n    external\n    {\n        require(msg.sender == DEPOSITOR_ACCOUNT, \"L1Block: only the depositor account can set L1 block values\");\n\n        require(\n            _validatorRewardScalar <= Constants.VALIDATOR_REWARD_DENOMINATOR,\n            \"L1Block: the max value of validator reward scalar has been exceeded\"\n        );\n\n        number = _number;\n        timestamp = _timestamp;\n        basefee = _basefee;\n        hash = _hash;\n        sequenceNumber = _sequenceNumber;\n        batcherHash = _batcherHash;\n        l1FeeOverhead = _l1FeeOverhead;\n        l1FeeScalar = _l1FeeScalar;\n        validatorRewardScalar = _validatorRewardScalar;\n    }\n\n    /// @notice Updates the L1 block values for an Ecotone upgraded chain.\n    /// Params are packed and passed in as raw msg.data instead of ABI to reduce calldata size.\n    /// Params are expected to be in the following order:\n    ///   1. _baseFeeScalar         L1 base fee scalar\n    ///   2. _blobBaseFeeScalar     L1 blob base fee scalar\n    ///   3. _sequenceNumber        Number of L2 blocks since epoch start.\n    ///   4. _timestamp             L1 timestamp.\n    ///   5. _number                L1 blocknumber.\n    ///   6. _basefee               L1 base fee.\n    ///   7. _blobBaseFee           L1 blob base fee.\n    ///   8. _hash                  L1 blockhash.\n    ///   9. _batcherHash           Versioned hash to authenticate batcher by.\n    ///   10. _validatorRewardScalar Validator reward scalar.\n    function setL1BlockValuesEcotone() external {\n        assembly {\n        // Revert if the caller is not the depositor account.\n            if xor(caller(), DEPOSITOR_ACCOUNT) {\n                mstore(0x00, 0x3cc50b45) // 0x3cc50b45 is the 4-byte selector of \"NotDepositor()\"\n                revert(0x1C, 0x04) // returns the stored 4-byte selector from above\n            }\n            let data := calldataload(4)\n        // sequencenum (uint64), blobBaseFeeScalar (uint32), baseFeeScalar (uint32)\n            sstore(sequenceNumber.slot, shr(128, calldataload(4)))\n        // number (uint64) and timestamp (uint64)\n            sstore(number.slot, shr(128, calldataload(20)))\n            sstore(basefee.slot, calldataload(36)) // uint256\n            sstore(blobBaseFee.slot, calldataload(68)) // uint256\n            sstore(hash.slot, calldataload(100)) // bytes32\n            sstore(batcherHash.slot, calldataload(132)) // bytes32\n            sstore(validatorRewardScalar.slot, calldataload(164)) // uint256\n        }\n    }\n}\n"
    },
    "contracts/L2/L1FeeVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { FeeVault } from \"../universal/FeeVault.sol\";\nimport { ISemver } from \"../universal/ISemver.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000007\n * @title L1FeeVault\n * @notice The L1FeeVault accumulates the L1 portion of the transaction fees.\n */\ncontract L1FeeVault is FeeVault, ISemver {\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.0.2\n     */\n    string public constant version = \"1.0.2\";\n\n    /**\n     * @notice Constructs the L1FeeVault contract.\n     *\n     * @param _recipient Address that will receive the accumulated fees.\n     */\n    constructor(address _recipient) FeeVault(_recipient, 0) {}\n}\n"
    },
    "contracts/L2/L2CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { ISemver } from \"../universal/ISemver.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { L2ToL1MessagePasser } from \"./L2ToL1MessagePasser.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000004\n * @title L2CrossDomainMessenger\n * @notice The L2CrossDomainMessenger is a high-level interface for message passing between L1 and\n *         L2 on the L2 side. Users are generally encouraged to use this contract instead of lower\n *         level message passing contracts.\n */\ncontract L2CrossDomainMessenger is CrossDomainMessenger, ISemver {\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.0.0\n     */\n    string public constant version = \"1.0.0\";\n\n    /**\n     * @notice Constructs the L2CrossDomainMessenger contract.\n     *\n     * @param _l1CrossDomainMessenger Address of the L1CrossDomainMessenger contract.\n     */\n    constructor(address _l1CrossDomainMessenger) CrossDomainMessenger(_l1CrossDomainMessenger) {\n        initialize();\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize() public initializer {\n        __CrossDomainMessenger_init();\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal override {\n        L2ToL1MessagePasser(payable(Predeploys.L2_TO_L1_MESSAGE_PASSER)).initiateWithdrawal{\n            value: _value\n        }(_to, _gasLimit, _data);\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _isOtherMessenger() internal view override returns (bool) {\n        return AddressAliasHelper.undoL1ToL2Alias(msg.sender) == OTHER_MESSENGER;\n    }\n\n    /**\n     * @inheritdoc CrossDomainMessenger\n     */\n    function _isUnsafeTarget(address _target) internal view override returns (bool) {\n        return _target == address(this) || _target == address(Predeploys.L2_TO_L1_MESSAGE_PASSER);\n    }\n}\n"
    },
    "contracts/L2/L2ERC721Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport { L1ERC721Bridge } from \"../L1/L1ERC721Bridge.sol\";\nimport { ERC721Bridge } from \"../universal/ERC721Bridge.sol\";\nimport { IKromaMintableERC721 } from \"../universal/IKromaMintableERC721.sol\";\nimport { ISemver } from \"../universal/ISemver.sol\";\n\n/**\n * @title L2ERC721Bridge\n * @notice The L2 ERC721 bridge is a contract which works together with the L1 ERC721 bridge to\n *         make it possible to transfer ERC721 tokens from Ethereum to Kroma. This contract\n *         acts as a minter for new tokens when it hears about deposits into the L1 ERC721 bridge.\n *         This contract also acts as a burner for tokens being withdrawn.\n *         **WARNING**: Do not bridge an ERC721 that was originally deployed on Kroma. This\n *         bridge ONLY supports ERC721s originally deployed on Ethereum. Users will need to\n *         wait for the one-week challenge period to elapse before their Kroma-native NFT\n *         can be refunded on L2.\n */\ncontract L2ERC721Bridge is ERC721Bridge, ISemver {\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.0.0\n     */\n    string public constant version = \"1.0.0\";\n\n    /**\n     * @notice Constructs the L2ERC721Bridge contract.\n     *\n     * @param _messenger   Address of the CrossDomainMessenger on this network.\n     * @param _otherBridge Address of the ERC721 bridge on the other network.\n     */\n    constructor(address _messenger, address _otherBridge) ERC721Bridge(_messenger, _otherBridge) {}\n\n    /**\n     * @notice Completes an ERC721 bridge from the other domain and sends the ERC721 token to the\n     *         recipient on this domain.\n     *\n     * @param _localToken  Address of the ERC721 token on this domain.\n     * @param _remoteToken Address of the ERC721 token on the other domain.\n     * @param _from        Address that triggered the bridge on the other domain.\n     * @param _to          Address to receive the token on this domain.\n     * @param _tokenId     ID of the token being deposited.\n     * @param _extraData   Optional data to forward to L1. Data supplied here will not be used to\n     *                     execute any code on L1 and is only emitted as extra data for the\n     *                     convenience of off-chain tooling.\n     */\n    function finalizeBridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes calldata _extraData\n    ) external onlyOtherBridge {\n        require(_localToken != address(this), \"L2ERC721Bridge: local token cannot be self\");\n\n        // Note that supportsInterface makes a callback to the _localToken address which is user\n        // provided.\n        require(\n            ERC165Checker.supportsInterface(_localToken, type(IKromaMintableERC721).interfaceId),\n            \"L2ERC721Bridge: local token interface is not compliant\"\n        );\n\n        require(\n            _remoteToken == IKromaMintableERC721(_localToken).REMOTE_TOKEN(),\n            \"L2ERC721Bridge: wrong remote token for Kroma Mintable ERC721 local token\"\n        );\n\n        // When a deposit is finalized, we give the NFT with the same tokenId to the account\n        // on L2. Note that safeMint makes a callback to the _to address which is user provided.\n        IKromaMintableERC721(_localToken).safeMint(_to, _tokenId);\n\n        // slither-disable-next-line reentrancy-events\n        emit ERC721BridgeFinalized(_localToken, _remoteToken, _from, _to, _tokenId, _extraData);\n    }\n\n    /**\n     * @inheritdoc ERC721Bridge\n     */\n    function _initiateBridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) internal override {\n        require(_remoteToken != address(0), \"L2ERC721Bridge: remote token cannot be address(0)\");\n\n        // Check that the withdrawal is being initiated by the NFT owner\n        require(\n            _from == IKromaMintableERC721(_localToken).ownerOf(_tokenId),\n            \"L2ERC721Bridge: Withdrawal is not being initiated by NFT owner\"\n        );\n\n        // Construct calldata for l1ERC721Bridge.finalizeBridgeERC721(_to, _tokenId)\n        // slither-disable-next-line reentrancy-events\n        address remoteToken = IKromaMintableERC721(_localToken).REMOTE_TOKEN();\n        require(\n            remoteToken == _remoteToken,\n            \"L2ERC721Bridge: remote token does not match given value\"\n        );\n\n        // When a withdrawal is initiated, we burn the withdrawer's NFT to prevent subsequent L2\n        // usage\n        // slither-disable-next-line reentrancy-events\n        IKromaMintableERC721(_localToken).burn(_from, _tokenId);\n\n        bytes memory message = abi.encodeWithSelector(\n            L1ERC721Bridge.finalizeBridgeERC721.selector,\n            remoteToken,\n            _localToken,\n            _from,\n            _to,\n            _tokenId,\n            _extraData\n        );\n\n        // Send message to L1 bridge\n        // slither-disable-next-line reentrancy-events\n        MESSENGER.sendMessage(OTHER_BRIDGE, message, _minGasLimit);\n\n        // slither-disable-next-line reentrancy-events\n        emit ERC721BridgeInitiated(_localToken, remoteToken, _from, _to, _tokenId, _extraData);\n    }\n}\n"
    },
    "contracts/L2/L2StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { ISemver } from \"../universal/ISemver.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000009\n * @title L2StandardBridge\n * @notice The L2StandardBridge is responsible for transfering ETH and ERC20 tokens between L1 and\n *         L2. In the case that an ERC20 token is native to L2, it will be escrowed within this\n *         contract. If the ERC20 token is native to L1, it will be burnt.\n *         NOTE: this contract is not intended to support all variations of ERC20 tokens. Examples\n *         of some token types that may not be properly supported by this contract include, but are\n *         not limited to: tokens with transfer fees, rebasing tokens, and tokens with blocklists.\n */\ncontract L2StandardBridge is StandardBridge, ISemver {\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.0.0\n     */\n    string public constant version = \"1.0.0\";\n\n    /**\n     * @notice Constructs the L2StandardBridge contract.\n     *\n     * @param _otherBridge Address of the L1StandardBridge.\n     */\n    constructor(\n        address payable _otherBridge\n    ) StandardBridge(payable(Predeploys.L2_CROSS_DOMAIN_MESSENGER), _otherBridge) {}\n\n    /**\n     * @notice Allows EOAs to bridge ETH by sending directly to the bridge.\n     */\n    receive() external payable override onlyEOA {\n        _initiateBridgeETH(\n            msg.sender,\n            msg.sender,\n            msg.value,\n            RECEIVE_DEFAULT_GAS_LIMIT,\n            bytes(\"\")\n        );\n    }\n}\n"
    },
    "contracts/L2/L2ToL1MessagePasser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Burn } from \"../libraries/Burn.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { ISemver } from \"../universal/ISemver.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000003\n * @title L2ToL1MessagePasser\n * @notice The L2ToL1MessagePasser is a dedicated contract where messages that are being sent from\n *         L2 to L1 can be stored. The storage root of this contract is pulled up to the top level\n *         of the L2 output to reduce the cost of proving the existence of sent messages.\n */\ncontract L2ToL1MessagePasser is ISemver {\n    /**\n     * @notice The L1 gas limit set when eth is withdrawn using the receive() function.\n     */\n    uint256 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;\n\n    /**\n     * @notice Current message version identifier.\n     */\n    uint16 public constant MESSAGE_VERSION = 0;\n\n    /**\n     * @notice Includes the message hashes for all withdrawals\n     */\n    mapping(bytes32 => bool) public sentMessages;\n\n    /**\n     * @notice A unique value hashed with each withdrawal.\n     */\n    uint240 internal msgNonce;\n\n    /**\n     * @notice Emitted any time a withdrawal is initiated.\n     *\n     * @param nonce          Unique value corresponding to each withdrawal.\n     * @param sender         The L2 account address which initiated the withdrawal.\n     * @param target         The L1 account address the call will be send to.\n     * @param value          The ETH value submitted for withdrawal, to be forwarded to the target.\n     * @param gasLimit       The minimum amount of gas that must be provided when withdrawing.\n     * @param data           The data to be forwarded to the target on L1.\n     * @param withdrawalHash The hash of the withdrawal.\n     */\n    event MessagePassed(\n        uint256 indexed nonce,\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes data,\n        bytes32 withdrawalHash\n    );\n\n    /**\n     * @notice Emitted when the balance of this contract is burned.\n     *\n     * @param amount Amount of ETh that was burned.\n     */\n    event WithdrawerBalanceBurnt(uint256 indexed amount);\n\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.0.0\n     */\n    string public constant version = \"1.0.0\";\n\n    /**\n     * @notice Allows users to withdraw ETH by sending directly to this contract.\n     */\n    receive() external payable {\n        initiateWithdrawal(msg.sender, RECEIVE_DEFAULT_GAS_LIMIT, bytes(\"\"));\n    }\n\n    /**\n     * @notice Removes all ETH held by this contract from the state. Used to prevent the amount of\n     *         ETH on L2 inflating when ETH is withdrawn. Anyone can call this function. Not\n     *         incentivized since this function is very cheap.\n     */\n    function burn() external {\n        uint256 balance = address(this).balance;\n        Burn.eth(balance);\n        emit WithdrawerBalanceBurnt(balance);\n    }\n\n    /**\n     * @notice Sends a message from L2 to L1.\n     *\n     * @param _target   Address to call on L1 execution.\n     * @param _gasLimit Minimum gas limit for executing the message on L1.\n     * @param _data     Data to forward to L1 target.\n     */\n    function initiateWithdrawal(\n        address _target,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) public payable {\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction({\n                nonce: messageNonce(),\n                sender: msg.sender,\n                target: _target,\n                value: msg.value,\n                gasLimit: _gasLimit,\n                data: _data\n            })\n        );\n\n        sentMessages[withdrawalHash] = true;\n\n        emit MessagePassed(\n            messageNonce(),\n            msg.sender,\n            _target,\n            msg.value,\n            _gasLimit,\n            _data,\n            withdrawalHash\n        );\n\n        unchecked {\n            ++msgNonce;\n        }\n    }\n\n    /**\n     * @notice Retrieves the next message nonce. Message version will be added to the upper two\n     *         bytes of the message nonce. Message version allows us to treat messages as having\n     *         different structures.\n     *\n     * @return Nonce of the next message to be sent, with added message version.\n     */\n    function messageNonce() public view returns (uint256) {\n        return Encoding.encodeVersionedNonce(msgNonce, MESSAGE_VERSION);\n    }\n}\n"
    },
    "contracts/L2/ProtocolVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { FeeVault } from \"../universal/FeeVault.sol\";\nimport { ISemver } from \"../universal/ISemver.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000006\n * @title ProtocolVault\n * @notice The ProtocolVault accumulates transaction fees to fund network operation.\n */\ncontract ProtocolVault is FeeVault, ISemver {\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.0.1\n     */\n    string public constant version = \"1.0.1\";\n\n    /**\n     * @notice Constructs the ProtocolVault contract.\n     *\n     * @param _recipient Address that will receive the accumulated fees.\n     */\n    constructor(address _recipient) FeeVault(_recipient, 0) {}\n}\n"
    },
    "contracts/L2/ValidatorRewardVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { L2StandardBridge } from \"../L2/L2StandardBridge.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { FeeVault } from \"../universal/FeeVault.sol\";\nimport { ISemver } from \"../universal/ISemver.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000008\n * @title ValidatorRewardVault\n * @notice The ValidatorRewardVault accumulates transaction fees and pays rewards to validators.\n */\ncontract ValidatorRewardVault is FeeVault, ISemver {\n    /**\n     * @notice Address of the ValidatorPool contract on L1.\n     */\n    address public immutable VALIDATOR_POOL;\n\n    /**\n     * @notice A value to divide the vault balance by when determining the reward amount.\n     */\n    uint256 public immutable REWARD_DIVIDER;\n\n    /**\n     * @notice The reward balance that the validator is eligible to receive.\n     */\n    mapping(address => uint256) internal rewards;\n\n    /**\n     * @notice A mapping of whether the reward corresponding to the L2 block number has been paid.\n     */\n    mapping(uint256 => bool) internal isPaid;\n\n    /**\n     * @notice The amount of determined as rewards.\n     */\n    uint256 public totalReserved;\n\n    /**\n     * @notice Emitted when the balance of a validator has increased.\n     *\n     * @param validator     Address of the validator.\n     * @param l2BlockNumber The L2 block number of the output root.\n     * @param amount        Amount of the reward.\n     */\n    event Rewarded(address indexed validator, uint256 indexed l2BlockNumber, uint256 amount);\n\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.0.1\n     */\n    string public constant version = \"1.0.1\";\n\n    /**\n     * @notice Constructs the ValidatorRewardVault contract.\n     *\n     * @param _validatorPool Address of the ValidatorPool contract on L1.\n     * @param _rewardDivider A value to divide the vault balance by when determining the reward amount.\n     */\n    constructor(address _validatorPool, uint256 _rewardDivider) FeeVault(address(0), 0) {\n        VALIDATOR_POOL = _validatorPool;\n        REWARD_DIVIDER = _rewardDivider;\n    }\n\n    /**\n     * @notice Rewards the validator for submitting the output.\n     *         ValidatorPool contract on L1 calls this function over the portal when output is finalized.\n     *\n     * @param _validator     Address of the validator.\n     * @param _l2BlockNumber The L2 block number of the output root.\n     */\n    function reward(address _validator, uint256 _l2BlockNumber) external {\n        require(\n            AddressAliasHelper.undoL1ToL2Alias(msg.sender) == VALIDATOR_POOL,\n            \"ValidatorRewardVault: function can only be called from the ValidatorPool\"\n        );\n\n        require(_validator != address(0), \"ValidatorRewardVault: validator address cannot be 0\");\n\n        require(\n            !isPaid[_l2BlockNumber],\n            \"ValidatorRewardVault: the reward has already been paid for the L2 block number\"\n        );\n\n        uint256 amount = _determineRewardAmount();\n\n        unchecked {\n            totalReserved += amount;\n            rewards[_validator] += amount;\n        }\n\n        isPaid[_l2BlockNumber] = true;\n\n        emit Rewarded(_validator, _l2BlockNumber, amount);\n    }\n\n    /**\n     * @notice Checks if the withdrawal is possible, and returns the withdrawal amount.\n     *         When a withdrawal is available, it resets the balance and updates the total processed amount.\n     */\n    function _processWithdrawal() internal override returns (uint256) {\n        uint256 amount = rewards[msg.sender];\n        require(\n            amount >= MIN_WITHDRAWAL_AMOUNT,\n            \"ValidatorRewardVault: withdrawal amount must be greater than minimum withdrawal amount\"\n        );\n\n        rewards[msg.sender] = 0;\n        unchecked {\n            totalReserved -= amount;\n            totalProcessed += amount;\n        }\n\n        emit Withdrawal(amount, msg.sender, msg.sender);\n        return amount;\n    }\n\n    /**\n     * @notice Withdraws all of the sender's balance.\n     *         Reverts if the balance is less than the minimum withdrawal amount.\n     */\n    function withdraw() external override {\n        uint256 amount = _processWithdrawal();\n\n        L2StandardBridge(payable(Predeploys.L2_STANDARD_BRIDGE)).bridgeETHTo{ value: amount }(\n            msg.sender,\n            WITHDRAWAL_MIN_GAS,\n            bytes(\"\")\n        );\n    }\n\n    /**\n     * @notice Withdraws all of the sender's balance to L2.\n     *         Reverts if the balance is less than the minimum withdrawal amount.\n     */\n    function withdrawToL2() external override {\n        uint256 amount = _processWithdrawal();\n\n        bool success = SafeCall.call(msg.sender, gasleft(), amount, bytes(\"\"));\n        require(success, \"ValidatorRewardVault: ETH transfer failed\");\n    }\n\n    /**\n     * @notice Withdraws all remaining contract balance excluding reserved amount to ProtocolVault.\n     *         Reverts if the available withdraw amount is 0.\n     *         Note that this function is added not to use this contract anymore.\n     */\n    function withdrawToProtocolVault() external {\n        uint256 amount = address(this).balance - totalReserved;\n        require(amount > 0, \"ValidatorRewardVault: withdrawal amount must be greater than zero\");\n\n        unchecked {\n            totalProcessed += amount;\n        }\n\n        emit Withdrawal(amount, Predeploys.PROTOCOL_VAULT, msg.sender);\n\n        bool success = SafeCall.call(Predeploys.PROTOCOL_VAULT, gasleft(), amount, bytes(\"\"));\n        require(success, \"ValidatorRewardVault: ETH transfer failed\");\n    }\n\n    /**\n     * @notice Determines the reward amount.\n     *\n     * @return Amount of the reward.\n     */\n    function _determineRewardAmount() internal view returns (uint256) {\n        return (address(this).balance - totalReserved) / REWARD_DIVIDER;\n    }\n\n    /**\n     * @notice Returns the reward balance of the given address.\n     *\n     * @param _addr Address to lookup.\n     *\n     * @return The reward balance of the given address.\n     */\n    function balanceOf(address _addr) external view returns (uint256) {\n        return rewards[_addr];\n    }\n}\n"
    },
    "contracts/echidna/FuzzAddressAliasing.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\n\ncontract EchidnaFuzzAddressAliasing {\n    bool internal failedRoundtrip;\n\n    /**\n     * @notice Takes an address to be aliased with AddressAliasHelper and then unaliased\n     *         and updates the test contract's state indicating if the round trip encoding\n     *         failed.\n     */\n    function testRoundTrip(address addr) public {\n        // Alias our address\n        address aliasedAddr = AddressAliasHelper.applyL1ToL2Alias(addr);\n\n        // Unalias our address\n        address undoneAliasAddr = AddressAliasHelper.undoL1ToL2Alias(aliasedAddr);\n\n        // If our round trip aliasing did not return the original result, set our state.\n        if (addr != undoneAliasAddr) {\n            failedRoundtrip = true;\n        }\n    }\n\n    /**\n     * @custom:invariant Address aliases are always able to be undone.\n     *\n     * Asserts that an address that has been aliased with `applyL1ToL2Alias` can always\n     * be unaliased with `undoL1ToL2Alias`.\n     */\n    function echidna_round_trip_aliasing() public view returns (bool) {\n        // ASSERTION: The round trip aliasing done in testRoundTrip(...) should never fail.\n        return !failedRoundtrip;\n    }\n}\n"
    },
    "contracts/echidna/FuzzBurn.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { StdUtils } from \"forge-std/Test.sol\";\n\nimport { Burn } from \"../libraries/Burn.sol\";\n\ncontract EchidnaFuzzBurnEth is StdUtils {\n    bool internal failedEthBurn;\n\n    /**\n     * @notice Takes an integer amount of eth to burn through the Burn library and\n     * updates the contract state if an incorrect amount of eth moved from the contract\n     */\n    function testBurn(uint256 _value) public {\n        // cache the contract's eth balance\n        uint256 preBurnBalance = address(this).balance;\n        uint256 value = bound(_value, 0, preBurnBalance);\n\n        // execute a burn of _value eth\n        Burn.eth(value);\n\n        // check that exactly value eth was transfered from the contract\n        unchecked {\n            if (address(this).balance != preBurnBalance - value) {\n                failedEthBurn = true;\n            }\n        }\n    }\n\n    /**\n     * @custom:invariant `eth(uint256)` always burns the exact amount of eth passed.\n     *\n     * Asserts that when `Burn.eth(uint256)` is called, it always burns the exact amount\n     * of ETH passed to the function.\n     */\n    function echidna_burn_eth() public view returns (bool) {\n        // ASSERTION: The amount burned should always match the amount passed exactly\n        return !failedEthBurn;\n    }\n}\n\ncontract EchidnaFuzzBurnGas is StdUtils {\n    bool internal failedGasBurn;\n\n    /**\n     * @notice Takes an integer amount of gas to burn through the Burn library and\n     * updates the contract state if at least that amount of gas was not burned\n     * by the library\n     */\n    function testGas(uint256 _value) public {\n        // cap the value to the max resource limit\n        uint256 MAX_RESOURCE_LIMIT = 8_000_000;\n        uint256 value = bound(_value, 0, MAX_RESOURCE_LIMIT);\n\n        // cache the contract's current remaining gas\n        uint256 preBurnGas = gasleft();\n\n        // execute the gas burn\n        Burn.gas(value);\n\n        // cache the remaining gas post burn\n        uint256 postBurnGas = gasleft();\n\n        // check that at least value gas was burnt (and that there was no underflow)\n        unchecked {\n            if (postBurnGas - preBurnGas > value || preBurnGas - value > preBurnGas) {\n                failedGasBurn = true;\n            }\n        }\n    }\n\n    /**\n     * @custom:invariant `gas(uint256)` always burns at least the amount of gas passed.\n     *\n     * Asserts that when `Burn.gas(uint256)` is called, it always burns at least the amount\n     * of gas passed to the function.\n     */\n    function echidna_burn_gas() public view returns (bool) {\n        // ASSERTION: The amount of gas burned should be strictly greater than the\n        // the amount passed as _value (minimum _value + whatever minor overhead to\n        // the value after the call)\n        return !failedGasBurn;\n    }\n}\n"
    },
    "contracts/echidna/FuzzEncoding.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Encoding } from \"../libraries/Encoding.sol\";\n\ncontract EchidnaFuzzEncoding {\n    bool internal failedRoundtripAToB;\n    bool internal failedRoundtripBToA;\n\n    /**\n     * @notice Takes a pair of integers to be encoded into a versioned nonce with the\n     *         Encoding library and then decoded and updates the test contract's state\n     *         indicating if the round trip encoding failed.\n     */\n    function testRoundTripAToB(uint240 _nonce, uint16 _version) public {\n        // Encode the nonce and version\n        uint256 encodedVersionedNonce = Encoding.encodeVersionedNonce(_nonce, _version);\n\n        // Decode the nonce and version\n        uint240 decodedNonce;\n        uint16 decodedVersion;\n\n        (decodedNonce, decodedVersion) = Encoding.decodeVersionedNonce(encodedVersionedNonce);\n\n        // If our round trip encoding did not return the original result, set our state.\n        if ((decodedNonce != _nonce) || (decodedVersion != _version)) {\n            failedRoundtripAToB = true;\n        }\n    }\n\n    /**\n     * @notice Takes an integer representing a packed version and nonce and attempts\n     *         to decode them using the Encoding library before re-encoding and updates\n     *         the test contract's state indicating if the round trip encoding failed.\n     */\n    function testRoundTripBToA(uint256 _versionedNonce) public {\n        // Decode the nonce and version\n        uint240 decodedNonce;\n        uint16 decodedVersion;\n\n        (decodedNonce, decodedVersion) = Encoding.decodeVersionedNonce(_versionedNonce);\n\n        // Encode the nonce and version\n        uint256 encodedVersionedNonce = Encoding.encodeVersionedNonce(decodedNonce, decodedVersion);\n\n        // If our round trip encoding did not return the original result, set our state.\n        if (encodedVersionedNonce != _versionedNonce) {\n            failedRoundtripBToA = true;\n        }\n    }\n\n    /**\n     * @custom:invariant `testRoundTripAToB` never fails.\n     *\n     * Asserts that a raw versioned nonce can be encoded / decoded to reach the same raw value.\n     */\n    function echidna_round_trip_encoding_AToB() public view returns (bool) {\n        // ASSERTION: The round trip encoding done in testRoundTripAToB(...)\n        return !failedRoundtripAToB;\n    }\n\n    /**\n     * @custom:invariant `testRoundTripBToA` never fails.\n     *\n     * Asserts that an encoded versioned nonce can always be decoded / re-encoded to reach\n     * the same encoded value.\n     */\n    function echidna_round_trip_encoding_BToA() public view returns (bool) {\n        // ASSERTION: The round trip encoding done in testRoundTripBToA should never\n        // fail.\n        return !failedRoundtripBToA;\n    }\n}\n"
    },
    "contracts/echidna/FuzzHashing.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\n\ncontract EchidnaFuzzHashing {\n    bool internal failedCrossDomainHashHighVersion;\n    bool internal failedCrossDomainHashV0;\n\n    /**\n     * @notice Takes the necessary parameters to perform a cross domain hash with a randomly\n     * generated version. Only schema version 0 is supported and all others should revert.\n     */\n    function testHashCrossDomainMessageHighVersion(\n        uint16 _version,\n        uint240 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) public {\n        // generate the versioned nonce\n        uint256 encodedNonce = Encoding.encodeVersionedNonce(_nonce, _version);\n\n        // hash the cross domain message. we don't need to store the result since the function\n        // validates and should revert if an invalid version (>0) is encoded\n        Hashing.hashCrossDomainMessage(encodedNonce, _sender, _target, _value, _gasLimit, _data);\n\n        // check that execution never makes it this far for an invalid version\n        if (_version > 0) {\n            failedCrossDomainHashHighVersion = true;\n        }\n    }\n\n    /**\n     * @notice Takes the necessary parameters to perform a cross domain hash using the v0 schema\n     * and compares the output of a call to the unversioned function to the v0 function directly\n     */\n    function testHashCrossDomainMessageV0(\n        uint240 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) public {\n        // generate the versioned nonce with the version set to 0\n        uint256 encodedNonce = Encoding.encodeVersionedNonce(_nonce, 0);\n\n        // hash the cross domain message using the unversioned and versioned functions for\n        // comparison\n        bytes32 sampleHash1 = Hashing.hashCrossDomainMessage(\n            encodedNonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n        bytes32 sampleHash2 = Hashing.hashCrossDomainMessageV0(\n            encodedNonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n\n        // check that the output of both functions matches\n        if (sampleHash1 != sampleHash2) {\n            failedCrossDomainHashV0 = true;\n        }\n    }\n\n    /**\n     * @custom:invariant `hashCrossDomainMessage` reverts if `version` is > `0`.\n     *\n     * The `hashCrossDomainMessage` function should always revert if the `version` passed is > `0`.\n     */\n    function echidna_hash_xdomain_msg_high_version() public view returns (bool) {\n        // ASSERTION: A call to hashCrossDomainMessage will never succeed for a version > 1\n        return !failedCrossDomainHashHighVersion;\n    }\n\n    /**\n     * @custom:invariant `version` = `0`: `hashCrossDomainMessage` and `hashCrossDomainMessageV0`\n     * are equivalent.\n     *\n     * If the version passed is 0, `hashCrossDomainMessage` and `hashCrossDomainMessageV0` should be\n     * equivalent.\n     */\n    function echidna_hash_xdomain_msg_0() public view returns (bool) {\n        // ASSERTION: A call to hashCrossDomainMessage and hashCrossDomainMessageV0\n        // should always match when the version passed is 0\n        return !failedCrossDomainHashV0;\n    }\n}\n"
    },
    "contracts/echidna/FuzzKromaPortal.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { KromaPortal } from \"../L1/KromaPortal.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { SystemConfig } from \"../L1/SystemConfig.sol\";\nimport { ZKMerkleTrie } from \"../L1/ZKMerkleTrie.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\n\ncontract EchidnaFuzzKromaPortal {\n    KromaPortal internal portal;\n    bool internal failedToComplete;\n\n    constructor() {\n        ResourceMetering.ResourceConfig memory rcfg = Constants.DEFAULT_RESOURCE_CONFIG();\n\n        SystemConfig systemConfig = new SystemConfig({\n            _owner: address(1),\n            _overhead: 0,\n            _scalar: 10000,\n            _batcherHash: bytes32(0),\n            _gasLimit: 30_000_000,\n            _unsafeBlockSigner: address(0),\n            _config: rcfg,\n            _validatorRewardScalar: 5000\n        });\n        portal = new KromaPortal({\n            _l2Oracle: L2OutputOracle(address(0)),\n            _validatorPool: address(0),\n            _guardian: address(0),\n            _paused: false,\n            _config: systemConfig,\n            _zkMerkleTrie: ZKMerkleTrie(address(0))\n        });\n    }\n\n    // A test intended to identify any unexpected halting conditions\n    function testDepositTransactionCompletes(\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    ) public payable {\n        failedToComplete = true;\n        require(!_isCreation || _to == address(0), \"EchidnaFuzzKromaPortal: invalid test case.\");\n        portal.depositTransaction{ value: _mint }(_to, _value, _gasLimit, _isCreation, _data);\n        failedToComplete = false;\n    }\n\n    /**\n     * @custom:invariant Deposits of any value should always succeed unless\n     * `_to` = `address(0)` or `_isCreation` = `true`.\n     *\n     * All deposits, barring creation transactions and transactions sent to `address(0)`,\n     * should always succeed.\n     */\n    function echidna_deposit_completes() public view returns (bool) {\n        return !failedToComplete;\n    }\n}\n"
    },
    "contracts/echidna/FuzzResourceMetering.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { StdUtils } from \"forge-std/Test.sol\";\n\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { Arithmetic } from \"../libraries/Arithmetic.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\n\ncontract EchidnaFuzzResourceMetering is ResourceMetering, StdUtils {\n    bool internal failedMaxGasPerBlock;\n    bool internal failedRaiseBaseFee;\n    bool internal failedLowerBaseFee;\n    bool internal failedNeverBelowMinBaseFee;\n    bool internal failedMaxRaiseBaseFeePerBlock;\n    bool internal failedMaxLowerBaseFeePerBlock;\n\n    // Used as a special flag for the purpose of identifying unchecked math errors specifically\n    // in the test contracts, not the target contracts themselves.\n    bool internal underflow;\n\n    constructor() {\n        initialize();\n    }\n\n    function initialize() internal initializer {\n        __ResourceMetering_init();\n    }\n\n    function resourceConfig() public pure returns (ResourceMetering.ResourceConfig memory) {\n        return _resourceConfig();\n    }\n\n    function _resourceConfig()\n        internal\n        pure\n        override\n        returns (ResourceMetering.ResourceConfig memory)\n    {\n        ResourceMetering.ResourceConfig memory rcfg = Constants.DEFAULT_RESOURCE_CONFIG();\n        return rcfg;\n    }\n\n    /**\n     * @notice Takes the necessary parameters to allow us to burn arbitrary amounts of gas to test\n     *         the underlying resource metering/gas market logic\n     */\n    function testBurn(uint256 _gasToBurn, bool _raiseBaseFee) public {\n        // Part 1: we cache the current param values and do some basic checks on them.\n        uint256 cachedPrevBaseFee = uint256(params.prevBaseFee);\n        uint256 cachedPrevBoughtGas = uint256(params.prevBoughtGas);\n        uint256 cachedPrevBlockNum = uint256(params.prevBlockNum);\n\n        ResourceMetering.ResourceConfig memory rcfg = resourceConfig();\n        uint256 targetResourceLimit = uint256(rcfg.maxResourceLimit) /\n            uint256(rcfg.elasticityMultiplier);\n\n        // check that the last block's base fee hasn't dropped below the minimum\n        if (cachedPrevBaseFee < uint256(rcfg.minimumBaseFee)) {\n            failedNeverBelowMinBaseFee = true;\n        }\n        // check that the last block didn't consume more than the max amount of gas\n        if (cachedPrevBoughtGas > uint256(rcfg.maxResourceLimit)) {\n            failedMaxGasPerBlock = true;\n        }\n\n        // Part2: we perform the gas burn\n\n        // force the gasToBurn into the correct range based on whether we intend to\n        // raise or lower the baseFee after this block, respectively\n        uint256 gasToBurn;\n        if (_raiseBaseFee) {\n            gasToBurn = bound(\n                _gasToBurn,\n                uint256(targetResourceLimit),\n                uint256(rcfg.maxResourceLimit)\n            );\n        } else {\n            gasToBurn = bound(_gasToBurn, 0, targetResourceLimit);\n        }\n\n        _burnInternal(uint64(gasToBurn));\n\n        // Part 3: we run checks and modify our invariant flags based on the updated params values\n\n        // Calculate the maximum allowed baseFee change (per block)\n        uint256 maxBaseFeeChange = cachedPrevBaseFee / uint256(rcfg.baseFeeMaxChangeDenominator);\n\n        // If the last block used more than the target amount of gas (and there were no\n        // empty blocks in between), ensure this block's baseFee increased, but not by\n        // more than the max amount per block\n        if (\n            (cachedPrevBoughtGas > uint256(targetResourceLimit)) &&\n            (uint256(params.prevBlockNum) - cachedPrevBlockNum == 1)\n        ) {\n            failedRaiseBaseFee = failedRaiseBaseFee || (params.prevBaseFee <= cachedPrevBaseFee);\n            failedMaxRaiseBaseFeePerBlock =\n                failedMaxRaiseBaseFeePerBlock ||\n                ((uint256(params.prevBaseFee) - cachedPrevBaseFee) < maxBaseFeeChange);\n        }\n\n        // If the last block used less than the target amount of gas, (or was empty),\n        // ensure that: this block's baseFee was decreased, but not by more than the max amount\n        if (\n            (cachedPrevBoughtGas < uint256(targetResourceLimit)) ||\n            (uint256(params.prevBlockNum) - cachedPrevBlockNum > 1)\n        ) {\n            // Invariant: baseFee should decrease\n            failedLowerBaseFee =\n                failedLowerBaseFee ||\n                (uint256(params.prevBaseFee) > cachedPrevBaseFee);\n\n            if (params.prevBlockNum - cachedPrevBlockNum == 1) {\n                // No empty blocks\n                // Invariant: baseFee should not have decreased by more than the maximum amount\n                failedMaxLowerBaseFeePerBlock =\n                    failedMaxLowerBaseFeePerBlock ||\n                    ((cachedPrevBaseFee - uint256(params.prevBaseFee)) <= maxBaseFeeChange);\n            } else if (params.prevBlockNum - cachedPrevBlockNum > 1) {\n                // We have at least one empty block\n                // Update the maxBaseFeeChange to account for multiple blocks having passed\n                unchecked {\n                    maxBaseFeeChange = uint256(\n                        int256(cachedPrevBaseFee) -\n                            Arithmetic.clamp(\n                                Arithmetic.cdexp(\n                                    int256(cachedPrevBaseFee),\n                                    int256(uint256(rcfg.baseFeeMaxChangeDenominator)),\n                                    int256(uint256(params.prevBlockNum) - cachedPrevBlockNum)\n                                ),\n                                int256(uint256(rcfg.minimumBaseFee)),\n                                int256(uint256(rcfg.maximumBaseFee))\n                            )\n                    );\n                }\n\n                // Detect an underflow in the previous calculation.\n                // Without using unchecked above, and detecting the underflow here, echidna would\n                // otherwise ignore the revert.\n                underflow = underflow || maxBaseFeeChange > cachedPrevBaseFee;\n\n                // Invariant: baseFee should not have decreased by more than the maximum amount\n                failedMaxLowerBaseFeePerBlock =\n                    failedMaxLowerBaseFeePerBlock ||\n                    ((cachedPrevBaseFee - uint256(params.prevBaseFee)) <= maxBaseFeeChange);\n            }\n        }\n    }\n\n    function _burnInternal(uint64 _gasToBurn) private metered(_gasToBurn) {}\n\n    /**\n     * @custom:invariant The base fee should increase if the last block used more\n     * than the target amount of gas\n     *\n     * If the last block used more than the target amount of gas (and there were no\n     * empty blocks in between), ensure this block's baseFee increased, but not by\n     * more than the max amount per block.\n     */\n    function echidna_high_usage_raise_baseFee() public view returns (bool) {\n        return !failedRaiseBaseFee;\n    }\n\n    /**\n     * @custom:invariant The base fee should decrease if the last block used less\n     * than the target amount of gas\n     *\n     * If the previous block used less than the target amount of gas, the base fee should decrease,\n     * but not more than the max amount.\n     */\n    function echidna_low_usage_lower_baseFee() public view returns (bool) {\n        return !failedLowerBaseFee;\n    }\n\n    /**\n     * @custom:invariant A block's base fee should never be below `MINIMUM_BASE_FEE`\n     *\n     * This test asserts that a block's base fee can never drop below the\n     * `MINIMUM_BASE_FEE` threshold.\n     */\n    function echidna_never_below_min_baseFee() public view returns (bool) {\n        return !failedNeverBelowMinBaseFee;\n    }\n\n    /**\n     * @custom:invariant A block can never consume more than `MAX_RESOURCE_LIMIT` gas.\n     *\n     * This test asserts that a block can never consume more than the `MAX_RESOURCE_LIMIT`\n     * gas threshold.\n     */\n    function echidna_never_above_max_gas_limit() public view returns (bool) {\n        return !failedMaxGasPerBlock;\n    }\n\n    /**\n     * @custom:invariant The base fee can never be raised more than the max base fee change.\n     *\n     * After a block consumes more gas than the target gas, the base fee cannot be raised\n     * more than the maximum amount allowed. The max base fee change (per-block) is derived\n     * as follows: `prevBaseFee / BASE_FEE_MAX_CHANGE_DENOMINATOR`\n     */\n    function echidna_never_exceed_max_increase() public view returns (bool) {\n        return !failedMaxRaiseBaseFeePerBlock;\n    }\n\n    /**\n     * @custom:invariant The base fee can never be lowered more than the max base fee change.\n     *\n     * After a block consumes less than the target gas, the base fee cannot be lowered more\n     * than the maximum amount allowed. The max base fee change (per-block) is derived as\n     *follows: `prevBaseFee / BASE_FEE_MAX_CHANGE_DENOMINATOR`\n     */\n    function echidna_never_exceed_max_decrease() public view returns (bool) {\n        return !failedMaxLowerBaseFeePerBlock;\n    }\n\n    /**\n     * @custom:invariant The `maxBaseFeeChange` calculation over multiple blocks can never\n     * underflow.\n     *\n     * When calculating the `maxBaseFeeChange` after multiple empty blocks, the calculation\n     * should never be allowed to underflow.\n     */\n    function echidna_underflow() public view returns (bool) {\n        return !underflow;\n    }\n}\n"
    },
    "contracts/governance/GovernanceToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\nimport { KromaMintableERC20 } from \"../universal/KromaMintableERC20.sol\";\n\n/**\n * @custom:proxied\n * @title GovernanceToken\n * @notice The KRO token used in governance, supporting voting and delegation. Implements\n *         EIP 2612 allowing signed approvals. `mint` function is only allowed to the owner or\n *         `Bridge`, and the total supply amount is minted at once (TGE). `Bridge` has the\n *         permission to `mint` and `burn`, for the purpose of bridging KRO to the remote chain.\n */\ncontract GovernanceToken is KromaMintableERC20, ERC20Votes, Ownable2StepUpgradeable {\n    /**\n     * @notice Constructs the GovernanceToken contract.\n     *\n     * @param _bridge      Address of the StandardBridge contract on this network.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     */\n    constructor(\n        address _bridge,\n        address _remoteToken\n    ) KromaMintableERC20(_bridge, _remoteToken, \"\", \"\") ERC20Permit(\"Kroma\") {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializer.\n     *\n     * @param _owner The owner of this contract.\n     */\n    function initialize(address _owner) public initializer {\n        __Ownable2Step_init();\n        transferOwnership(_owner);\n    }\n\n    /**\n     * @notice Allows StandardBridge or the owner to mint tokens.\n     *\n     * @param _to     Address to mint tokens to.\n     * @param _amount Amount of tokens to mint.\n     */\n    function mint(address _to, uint256 _amount) external override {\n        require(\n            msg.sender == BRIDGE || msg.sender == owner(),\n            \"GovernanceToken: only bridge or owner can mint\"\n        );\n\n        _mint(_to, _amount);\n    }\n\n    /**\n     * @inheritdoc KromaMintableERC20\n     */\n    function burn(address _from, uint256 _amount) external override onlyBridge {\n        _burn(_from, _amount);\n    }\n\n    /**\n     * @inheritdoc ERC20\n     */\n    function name() public pure override returns (string memory) {\n        return \"Kroma\";\n    }\n\n    /**\n     * @inheritdoc ERC20\n     */\n    function symbol() public pure override returns (string memory) {\n        return \"KRO\";\n    }\n\n    /**\n     * @notice Callback called after a token transfer.\n     *\n     * @param from   The account sending tokens.\n     * @param to     The account receiving tokens.\n     * @param amount The amount of tokens being transferred.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20, ERC20Votes) {\n        super._afterTokenTransfer(from, to, amount);\n    }\n\n    /**\n     * @notice Internal mint function.\n     *\n     * @param account The account receiving minted tokens.\n     * @param amount  The amount of tokens to mint.\n     */\n    function _mint(address account, uint256 amount) internal override(ERC20, ERC20Votes) {\n        super._mint(account, amount);\n        emit Mint(account, amount);\n    }\n\n    /**\n     * @notice Internal burn function.\n     *\n     * @param account The account that tokens will be burned from.\n     * @param amount  The amount of tokens that will be burned.\n     */\n    function _burn(address account, uint256 amount) internal override(ERC20, ERC20Votes) {\n        super._burn(account, amount);\n        emit Burn(account, amount);\n    }\n\n    /**\n     * @notice Override function.\n     */\n    function _msgSender() internal view override(Context, ContextUpgradeable) returns (address) {\n        return super._msgSender();\n    }\n\n    /**\n     * @notice Override function.\n     */\n    function _msgData()\n        internal\n        view\n        override(Context, ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return super._msgData();\n    }\n}\n"
    },
    "contracts/governance/MintManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\nimport { GovernanceToken } from \"./GovernanceToken.sol\";\n\n/**\n * @title MintManager\n * @notice MintManager issues mint cap amount of GovernanceToken at once (TGE) and distributes the\n *         tokens to specified recipients.\n */\ncontract MintManager is Ownable2Step {\n    /**\n     * @notice The amount of tokens that can be minted.\n     */\n    uint256 public constant MINT_CAP = 1_000_000_000;\n\n    /**\n     * @notice The denominator of each recipient's share.\n     */\n    uint256 public constant SHARE_DENOMINATOR = 10 ** 5;\n\n    /**\n     * @notice The GovernanceToken that the MintManager can mint.\n     */\n    GovernanceToken public immutable GOVERNANCE_TOKEN;\n\n    /**\n     * @notice True when already minted on this chain. MintManager can mint only once on each chain.\n     */\n    bool public minted;\n\n    /**\n     * @notice A list of recipient addresses that will receive tokens to be distributed.\n     */\n    address[] public recipients;\n\n    /**\n     * @notice A mapping of the recipient's address to share.\n     */\n    mapping(address => uint256) public shareOf;\n\n    /**\n     * @notice Constructs the MintManager contract.\n     *\n     * @param _governanceToken The GovernanceToken this contract can mint tokens of.\n     * @param _owner           The owner of this contract.\n     * @param _recipients      List of the recipients.\n     * @param _shares          List of token distribution ratios for each recipient.\n     */\n    constructor(\n        address _governanceToken,\n        address _owner,\n        address[] memory _recipients,\n        uint256[] memory _shares\n    ) {\n        GOVERNANCE_TOKEN = GovernanceToken(_governanceToken);\n\n        transferOwnership(_owner);\n\n        require(_recipients.length == _shares.length, \"MintManager: invalid length of array\");\n\n        uint256 totalShares = 0;\n        for (uint256 i = 0; i < _recipients.length; i++) {\n            address recipient = _recipients[i];\n            require(recipient != address(0), \"MintManager: recipient address cannot be 0\");\n\n            uint256 share = _shares[i];\n            require(share != 0, \"MintManager: share cannot be 0\");\n\n            if (shareOf[recipient] == 0) {\n                recipients.push(recipient);\n            }\n            shareOf[recipient] += share;\n            totalShares += share;\n        }\n\n        require(\n            totalShares <= SHARE_DENOMINATOR,\n            \"MintManager: max total share is equal or less than SHARE_DENOMINATOR\"\n        );\n    }\n\n    /**\n     * @notice Only the owner is allowed to mint mint cap amount of the GovernanceToken at once.\n     */\n    function mint() external onlyOwner {\n        require(!minted, \"MintManager: already minted on this chain\");\n\n        uint256 mintCap = MINT_CAP * 10 ** GOVERNANCE_TOKEN.decimals();\n\n        uint256 totalAmount;\n        for (uint256 i = 0; i < recipients.length; i++) {\n            address recipient = recipients[i];\n            uint256 share = shareOf[recipient];\n            uint256 amount = (mintCap * share) / SHARE_DENOMINATOR;\n            totalAmount += amount;\n        }\n\n        GOVERNANCE_TOKEN.mint(address(this), totalAmount);\n\n        minted = true;\n    }\n\n    /**\n     * @notice Only the owner is allowed to distribute the GovernanceToken to specified recipients.\n     */\n    function distribute() external onlyOwner {\n        uint256 mintCap = MINT_CAP * 10 ** GOVERNANCE_TOKEN.decimals();\n\n        for (uint256 i = 0; i < recipients.length; i++) {\n            address recipient = recipients[i];\n            uint256 share = shareOf[recipient];\n            uint256 amount = (mintCap * share) / SHARE_DENOMINATOR;\n            GOVERNANCE_TOKEN.transfer(recipient, amount);\n        }\n    }\n\n    /**\n     * @notice Only the owner is allowed to renounce the ownership of the GovernanceToken.\n     */\n    function renounceOwnershipOfToken() external onlyOwner {\n        require(minted, \"MintManager: not minted before renounce ownership\");\n\n        GOVERNANCE_TOKEN.renounceOwnership();\n    }\n\n    /**\n     * @notice Only the owner is allowed to transfer the ownership of the GovernanceToken.\n     *\n     * @param newMintManager The new MintManager to own the GovernanceToken.\n     */\n    function transferOwnershipOfToken(address newMintManager) external onlyOwner {\n        GOVERNANCE_TOKEN.transferOwnership(newMintManager);\n    }\n\n    /**\n     * @notice Only the owner is allowed to accept the ownership of the GovernanceToken.\n     */\n    function acceptOwnershipOfToken() external onlyOwner {\n        GOVERNANCE_TOKEN.acceptOwnership();\n    }\n}\n"
    },
    "contracts/governance/SecurityCouncilToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport { ISemver } from \"../universal/ISemver.sol\";\nimport \"../universal/KromaSoulBoundERC721.sol\";\n\n/**\n * @custom:proxied\n * @title SecurityCouncilToken\n * @notice The SecurityCouncilToken is a basic token based on KromaSoulBoundERC721.\n */\ncontract SecurityCouncilToken is KromaSoulBoundERC721, ISemver {\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.0.1\n     */\n    string public constant version = \"1.0.1\";\n\n    /**\n     * @notice Initializer.\n     *\n     * @param _owner Owner of this token contract.\n     */\n    function initialize(address _owner) public initializer {\n        __KromaSoulBoundERC721_init(\"KromaSecurityCouncil\", \"KSC\", _owner);\n    }\n\n    function _baseURI() internal pure override returns (string memory) {\n        return \"https://nft.kroma.network/sc/\";\n    }\n}\n"
    },
    "contracts/governance/TimeLock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport { ISemver } from \"../universal/ISemver.sol\";\n\n/**\n * @custom:proxied\n * @title TimeLock\n * @notice The TimeLock is a timelock controller based on OpenZeppelin TimelockController.\n */\ncontract TimeLock is Initializable, TimelockControllerUpgradeable, ISemver {\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.0.0\n     */\n    string public constant version = \"1.0.0\";\n\n    /**\n     * @notice Initializer.\n     *\n     * @param _minDelay  Initial minimum delay for operations.\n     * @param _proposers Accounts to be granted proposer and canceller roles.\n     * @param _executors Accounts to be granted executor role.\n     * @param _admin     Optional account to be granted admin role; disable with zero address.\n     */\n    function initialize(\n        uint256 _minDelay,\n        address[] memory _proposers,\n        address[] memory _executors,\n        address _admin\n    ) public initializer {\n        __TimelockController_init(_minDelay, _proposers, _executors, _admin);\n    }\n}\n"
    },
    "contracts/governance/UpgradeGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorCountingSimpleUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport { ISemver } from \"../universal/ISemver.sol\";\n\n/**\n * @custom:proxied\n * @title UpgradeGovernor\n * @notice The UpgradeGovernor is a basic ERC20, ERC721 based DAO using OpenZeppelin Governor.\n */\ncontract UpgradeGovernor is\n    Initializable,\n    GovernorUpgradeable,\n    GovernorSettingsUpgradeable,\n    GovernorCountingSimpleUpgradeable,\n    GovernorVotesUpgradeable,\n    GovernorVotesQuorumFractionUpgradeable,\n    GovernorTimelockControlUpgradeable,\n    ISemver\n{\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.0.0\n     */\n    string private constant _version = \"1.0.0\";\n\n    /**\n     * @notice Constructs the UpgradeGovernor contract.\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializer.\n     *\n     * @param _token                    Address of the token(ERC20 or ERC721).\n     * @param _timelock                 Address of the timelock controller.\n     * @param _initialVotingDelay       Voting delay.(unit: 1 block = 12 seconds on L1)\n     * @param _initialVotingPeriod      Voting period.(unit: 1 block = 12 seconds on L1)\n     * @param _initialProposalThreshold Proposal threshold.\n     * @param _votesQuorumFraction      Quorum as a fraction of the token's total supply.\n     */\n    function initialize(\n        address _token,\n        address payable _timelock,\n        uint256 _initialVotingDelay,\n        uint256 _initialVotingPeriod,\n        uint256 _initialProposalThreshold,\n        uint256 _votesQuorumFraction\n    ) public initializer {\n        __Governor_init(\"UpgradeGovernor\");\n        __GovernorSettings_init(\n            _initialVotingDelay,\n            _initialVotingPeriod,\n            _initialProposalThreshold\n        );\n        __GovernorCountingSimple_init();\n        __GovernorVotes_init(IVotesUpgradeable(_token));\n        __GovernorVotesQuorumFraction_init(_votesQuorumFraction);\n        __GovernorTimelockControl_init(TimelockControllerUpgradeable(_timelock));\n    }\n\n    // The following functions are overridden cause required by Solidity.\n\n    function votingDelay()\n        public\n        view\n        override(IGovernorUpgradeable, GovernorSettingsUpgradeable)\n        returns (uint256)\n    {\n        return super.votingDelay();\n    }\n\n    function votingPeriod()\n        public\n        view\n        override(IGovernorUpgradeable, GovernorSettingsUpgradeable)\n        returns (uint256)\n    {\n        return super.votingPeriod();\n    }\n\n    function quorum(uint256 blockNumber)\n        public\n        view\n        override(IGovernorUpgradeable, GovernorVotesQuorumFractionUpgradeable)\n        returns (uint256)\n    {\n        return super.quorum(blockNumber);\n    }\n\n    function state(uint256 proposalId)\n        public\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (ProposalState)\n    {\n        return super.state(proposalId);\n    }\n\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public override(GovernorUpgradeable, IGovernorUpgradeable) returns (uint256) {\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    function proposalThreshold()\n        public\n        view\n        override(GovernorUpgradeable, GovernorSettingsUpgradeable)\n        returns (uint256)\n    {\n        return super.proposalThreshold();\n    }\n\n    /**\n     * @notice Returns the full contract version.\n     *\n     * @return contract version as a string.\n     */\n    function version()\n        public\n        pure\n        override(IGovernorUpgradeable, GovernorUpgradeable, ISemver)\n        returns (string memory)\n    {\n        return _version;\n    }\n\n    function _execute(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) {\n        super._execute(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (uint256) {\n        return super._cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    function _executor()\n        internal\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (address)\n    {\n        return super._executor();\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/libraries/Arithmetic.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SignedMath } from \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport { FixedPointMathLib } from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\n\n/**\n * @title Arithmetic\n * @notice Even more math than before.\n */\nlibrary Arithmetic {\n    /**\n     * @notice Clamps a value between a minimum and maximum.\n     *\n     * @param _value The value to clamp.\n     * @param _min   The minimum value.\n     * @param _max   The maximum value.\n     *\n     * @return The clamped value.\n     */\n    function clamp(\n        int256 _value,\n        int256 _min,\n        int256 _max\n    ) internal pure returns (int256) {\n        return SignedMath.min(SignedMath.max(_value, _min), _max);\n    }\n\n    /**\n     * @notice Clamps a value between a minimum and maximum.\n     *\n     * @param _value The value to clamp.\n     * @param _min   The minimum value.\n     * @param _max   The maximum value.\n     *\n     * @return The clamped value.\n     */\n    function clamp(\n        uint256 _value,\n        uint256 _min,\n        uint256 _max\n    ) internal pure returns (uint256) {\n        return Math.min(Math.max(_value, _min), _max);\n    }\n\n    /**\n     * @notice (c)oefficient (d)enominator (exp)onentiation function.\n     *         Returns the result of: c * (1 - 1/d)^exp.\n     *\n     * @param _coefficient Coefficient of the function.\n     * @param _denominator Fractional denominator.\n     * @param _exponent    Power function exponent.\n     *\n     * @return Result of c * (1 - 1/d)^exp.\n     */\n    function cdexp(\n        int256 _coefficient,\n        int256 _denominator,\n        int256 _exponent\n    ) internal pure returns (int256) {\n        return\n            (_coefficient *\n                (FixedPointMathLib.powWad(1e18 - (1e18 / _denominator), _exponent * 1e18))) / 1e18;\n    }\n}\n"
    },
    "contracts/libraries/Atan2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title Atan2\n * @notice A library for calculating the arctangent of a fraction y / x. Based on fixed-point\n *         math library, it provides 1E-12 precision with 40 fractional bits.\n *         Originally from https://github.com/NovakDistributed/macroverse.\n */\nlibrary Atan2 {\n    /**\n     * @notice The value of pi/2 in radians, represented as a fixed-point number.\n     */\n    uint256 internal constant REAL_HALF_PI = 1727108826179;\n\n    /**\n     * @notice Calculate atan(y / x).\n     * @dev Uses the Chebyshev polynomial approach to approximate arctan(x) where x is [0, 1].\n     * @dev 0.999974x-0.332568x^3+0.193235x^5-0.115729x^7+0.0519505x^9-0.0114658x^11\n     *\n     * @param real_y The numerator of the fraction y / x.\n     * @param real_x The denominator of the fraction y / x.\n     *\n     * @return result The angle in radians of the fraction y / x.\n     */\n    function atan2(uint256 real_y, uint256 real_x) internal pure returns (uint256 result) {\n        assembly {\n            let frac\n\n            switch lt(real_x, real_y)\n            case 0 {\n                frac := div(mul(real_y, shl(40, 1)), real_x)\n            }\n            case 1 {\n                frac := div(mul(real_x, shl(40, 1)), real_y)\n            }\n\n            // Initialize variables to be used in the polynomial.\n            let frac_squared := shr(40, mul(frac, frac))\n            let frac_cubed := shr(40, mul(frac_squared, frac))\n            let frac_five_squared := shr(40, mul(frac_squared, frac_cubed))\n            let frac_seven_squared := shr(40, mul(frac_squared, frac_five_squared))\n            let frac_nine_squared := shr(40, mul(frac_squared, frac_seven_squared))\n            let frac_eleven_squared := shr(40, mul(frac_squared, frac_nine_squared))\n\n            // Calculate the polynomial using unsigned integers.\n            // Start with the x^1 term, and then subtract or add the other terms based on the coefficient signs.\n            result := shr(40, mul(1099483040474, frac)) // x^1 term\n\n            // x^5 term\n            result := add(result, shr(40, mul(212464129393, frac_five_squared)))\n\n            // x^9 term\n            result := add(result, shr(40, mul(57120178819, frac_nine_squared)))\n\n            // x^3 term, subtract because original coefficient is negative\n            result := sub(result, shr(40, mul(365662383026, frac_cubed)))\n\n            // x^7 term, subtract because original coefficient is negative\n            result := sub(result, shr(40, mul(127245381171, frac_seven_squared)))\n\n            // x^11 term, subtract because original coefficient is negative\n            result := sub(result, shr(40, mul(12606780422, frac_eleven_squared)))\n\n            if gt(real_y, real_x) {\n                result := sub(REAL_HALF_PI, result)\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/BalancedWeightTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title BalancedWeightTree\n * @notice A self-balancing tree (balancing the weights) holds the keys and their weights and the\n *         weight sum of each child. A random integer smaller than the weight sum is taken and the\n *         tree is traversed to find the matching key.\n *         See https://github.com/yasharpm/Solidity-Weighted-Random-List.\n */\nlibrary BalancedWeightTree {\n    /**\n     * @notice Struct representing a node that constructs the tree.\n     *\n     * @custom:field addr        The address that owns the node.\n     * @custom:field parent      The index of parent node.\n     * @custom:field leftChild   The index of left child node.\n     * @custom:field rightChild  The index of right child node.\n     * @custom:field isLeftChild If the node is left child node of its parent node.\n     * @custom:field weight      The weight of the node.\n     * @custom:field weightSum   The weight sum of the node and its child nodes.\n     */\n    struct Node {\n        address addr;\n        uint32 parent;\n        uint32 leftChild;\n        uint32 rightChild;\n        bool isLeftChild;\n        uint120 weight;\n        uint120 weightSum;\n    }\n\n    /**\n     * @notice Struct representing a tree.\n     *\n     * @custom:field counter A counter used to assign a unique index to each node. The node index\n     *                       starts with 1 and counter only increments.\n     * @custom:field removed The cumulative number of removed nodes.\n     * @custom:field root    The index of root node.\n     * @custom:field nodes   A mapping of node index to node struct.\n     * @custom:field nodeMap A mapping of owner address to node index.\n     */\n    struct Tree {\n        uint32 counter;\n        uint32 removed;\n        uint32 root;\n        mapping(uint32 => Node) nodes;\n        mapping(address => uint32) nodeMap;\n    }\n\n    /**\n     * @notice Inserts new node with the specified address and weight inside the tree.\n     *\n     * @param _tree   The tree to insert the new node.\n     * @param _addr   The address that owns the new node.\n     * @param _weight The weight of the new node.\n     */\n    function insert(Tree storage _tree, address _addr, uint120 _weight) internal {\n        require(_addr != address(0), \"BalancedWeightTree: zero address not allowed\");\n        require(_tree.nodeMap[_addr] == 0, \"BalancedWeightTree: node already existing\");\n\n        Node memory newNode = Node({\n            addr: _addr,\n            weight: _weight,\n            weightSum: _weight,\n            parent: 0,\n            leftChild: 0,\n            rightChild: 0,\n            isLeftChild: true\n        });\n\n        unchecked {\n            _tree.counter++;\n        }\n\n        uint32 newNodeIndex = _tree.counter;\n        _tree.nodes[newNodeIndex] = newNode;\n        _tree.nodeMap[_addr] = newNodeIndex;\n\n        if (_tree.root == 0) {\n            _tree.root = newNodeIndex;\n            return;\n        }\n\n        uint32 index = _tree.root;\n        while (true) {\n            Node storage node = _tree.nodes[index];\n\n            unchecked {\n                node.weightSum += _weight;\n            }\n\n            if (node.leftChild == 0) {\n                _tree.nodes[newNodeIndex].parent = index;\n                node.leftChild = newNodeIndex;\n\n                _promote(_tree, newNodeIndex);\n\n                return;\n            } else if (node.rightChild == 0) {\n                _tree.nodes[newNodeIndex].parent = index;\n                _tree.nodes[newNodeIndex].isLeftChild = false;\n                node.rightChild = newNodeIndex;\n\n                _promote(_tree, newNodeIndex);\n\n                return;\n            } else if (\n                _tree.nodes[node.leftChild].weightSum > _tree.nodes[node.rightChild].weightSum\n            ) {\n                index = node.rightChild;\n            } else {\n                index = node.leftChild;\n            }\n        }\n    }\n\n    /**\n     * @notice Updates the weight of the node with the specified address. Returns true if the weight\n     *         is updated, false if the node with specified address doesn't exist.\n     *\n     * @param _tree   The tree that includes the node to update.\n     * @param _addr   The address that owns the node to update.\n     * @param _weight The new weight to be assigned.\n     *\n     * @return If the weight is updated.\n     */\n    function update(Tree storage _tree, address _addr, uint120 _weight) internal returns (bool) {\n        uint32 index = _tree.nodeMap[_addr];\n\n        if (index == 0) {\n            return false;\n        }\n\n        uint120 oldWeight = _tree.nodes[index].weight;\n        _tree.nodes[index].weight = _weight;\n\n        uint32 parentIndex = _tree.nodes[index].parent;\n        if (_weight > oldWeight) {\n            unchecked {\n                uint120 weightDiff = _weight - oldWeight;\n                _tree.nodes[index].weightSum += weightDiff;\n\n                while (parentIndex != 0) {\n                    _tree.nodes[parentIndex].weightSum += weightDiff;\n                    parentIndex = _tree.nodes[parentIndex].parent;\n                }\n            }\n\n            _promote(_tree, index);\n        } else {\n            unchecked {\n                uint120 weightDiff = oldWeight - _weight;\n                _tree.nodes[index].weightSum -= weightDiff;\n\n                while (parentIndex != 0) {\n                    _tree.nodes[parentIndex].weightSum -= weightDiff;\n                    parentIndex = _tree.nodes[parentIndex].parent;\n                }\n            }\n\n            _demote(_tree, index);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Removes the node with specified address from the tree. Returns true is the node is\n     *         removed, false if it doesn't exist in the tree.\n     *\n     * @param _tree The tree that includes the node to remove.\n     * @param _addr The address that owns the node to remove.\n     *\n     * @return If the node is removed.\n     */\n    function remove(Tree storage _tree, address _addr) internal returns (bool) {\n        uint32 index = _tree.nodeMap[_addr];\n\n        if (index == 0) {\n            return false;\n        }\n\n        delete _tree.nodeMap[_addr];\n\n        uint32 parentIndex = _tree.nodes[index].parent;\n        uint120 weight = _tree.nodes[index].weight;\n        while (parentIndex != 0) {\n            unchecked {\n                _tree.nodes[parentIndex].weightSum -= weight;\n            }\n            parentIndex = _tree.nodes[parentIndex].parent;\n        }\n\n        _pullUp(_tree, index);\n\n        unchecked {\n            ++_tree.removed;\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Performs a weighted selection among the stored nodes. Returns the address of the\n     *         selected node. If _weight is equal or greater than the weight sum of the tree, it\n     *         returns zero address.\n     *\n     * @param _tree   The tree that includes the nodes to select.\n     * @param _weight The random weight to be used for selection.\n     *\n     * @return The address of the selected node.\n     */\n    function select(Tree storage _tree, uint120 _weight) internal view returns (address) {\n        uint32 index = _tree.root;\n        while (true) {\n            if (_tree.nodes[_tree.nodes[index].leftChild].weightSum > _weight) {\n                index = _tree.nodes[index].leftChild;\n                continue;\n            }\n\n            unchecked {\n                _weight -= _tree.nodes[_tree.nodes[index].leftChild].weightSum;\n            }\n\n            if (_tree.nodes[index].weight > _weight) {\n                return _tree.nodes[index].addr;\n            }\n\n            unchecked {\n                _weight -= _tree.nodes[index].weight;\n            }\n\n            if (_tree.nodes[_tree.nodes[index].rightChild].weightSum > _weight) {\n                index = _tree.nodes[index].rightChild;\n            } else {\n                return address(0);\n            }\n        }\n\n        return address(0);\n    }\n\n    /**\n     * @notice Promotes the node with higher weight to higher level of the tree. It is because to\n     *         reduce the average number of traverses required since these nodes are more likely to\n     *         be randomly selected.\n     *\n     * @param _tree  The tree that includes the node to promote.\n     * @param _index The initial index of the target node to promote.\n     */\n    function _promote(Tree storage _tree, uint32 _index) private {\n        Node storage node = _tree.nodes[_index];\n        Node storage parentNode = _tree.nodes[node.parent];\n\n        while (node.parent != 0 && node.weight > parentNode.weight) {\n            address nodeAddr = node.addr;\n            node.addr = parentNode.addr;\n            parentNode.addr = nodeAddr;\n\n            uint120 nodeWeight = node.weight;\n            uint120 parentWeight = parentNode.weight;\n            node.weight = parentWeight;\n            parentNode.weight = nodeWeight;\n\n            unchecked {\n                node.weightSum -= nodeWeight - parentWeight;\n            }\n\n            _tree.nodeMap[node.addr] = _index;\n            _tree.nodeMap[parentNode.addr] = node.parent;\n\n            _index = node.parent;\n            node = _tree.nodes[_index];\n            parentNode = _tree.nodes[node.parent];\n        }\n    }\n\n    /**\n     * @notice Demotes the node with lower weight to lower level of the tree. It is because to\n     *         reduce the average number of traverses required since these nodes are less likely to\n     *         be randomly selected.\n     *\n     * @param _tree  The tree that includes the node to demote.\n     * @param _index The initial index of the target node to demote.\n     */\n    function _demote(Tree storage _tree, uint32 _index) private {\n        while (true) {\n            Node storage node = _tree.nodes[_index];\n\n            if (_tree.nodes[node.leftChild].weight > _tree.nodes[node.rightChild].weight) {\n                if (_tree.nodes[node.leftChild].weight > node.weight) {\n                    address nodeAddr = node.addr;\n                    node.addr = _tree.nodes[node.leftChild].addr;\n                    _tree.nodes[node.leftChild].addr = nodeAddr;\n\n                    uint120 nodeWeight = node.weight;\n                    uint120 leftChildWeight = _tree.nodes[node.leftChild].weight;\n                    node.weight = leftChildWeight;\n                    _tree.nodes[node.leftChild].weight = nodeWeight;\n\n                    unchecked {\n                        _tree.nodes[node.leftChild].weightSum -= leftChildWeight - nodeWeight;\n                    }\n\n                    _tree.nodeMap[node.addr] = _index;\n                    _tree.nodeMap[_tree.nodes[node.leftChild].addr] = node.leftChild;\n\n                    _index = node.leftChild;\n\n                    continue;\n                }\n\n                return;\n            } else if (_tree.nodes[node.rightChild].weight > node.weight) {\n                address nodeAddr = node.addr;\n                node.addr = _tree.nodes[node.rightChild].addr;\n                _tree.nodes[node.rightChild].addr = nodeAddr;\n\n                uint120 nodeWeight = node.weight;\n                uint120 rightChildWeight = _tree.nodes[node.rightChild].weight;\n                node.weight = rightChildWeight;\n                _tree.nodes[node.rightChild].weight = nodeWeight;\n\n                unchecked {\n                    _tree.nodes[node.rightChild].weightSum -= rightChildWeight - nodeWeight;\n                }\n\n                _tree.nodeMap[node.addr] = _index;\n                _tree.nodeMap[_tree.nodes[node.rightChild].addr] = node.rightChild;\n\n                _index = node.rightChild;\n\n                continue;\n            }\n\n            return;\n        }\n    }\n\n    /**\n     * @notice When removing a node, pulls up the remaining nodes with higher weight to higher level\n     *         of the tree.\n     *\n     * @param _tree  The tree that includes the node to remove.\n     * @param _index The initial index of the target node to remove.\n     */\n    function _pullUp(Tree storage _tree, uint32 _index) private {\n        while (true) {\n            Node storage node = _tree.nodes[_index];\n            require(node.addr != address(0), \"BalancedWeightTree: node not exists\");\n\n            if (node.leftChild == 0) {\n                if (node.rightChild == 0) {\n                    if (node.parent == 0) {\n                        _tree.root = 0;\n                    } else if (node.isLeftChild) {\n                        _tree.nodes[node.parent].leftChild = 0;\n                    } else {\n                        _tree.nodes[node.parent].rightChild = 0;\n                    }\n\n                    delete _tree.nodes[_index];\n\n                    return;\n                } else {\n                    node.addr = _tree.nodes[node.rightChild].addr;\n                    node.weight = _tree.nodes[node.rightChild].weight;\n                    node.weightSum = _tree.nodes[node.rightChild].weightSum;\n\n                    _tree.nodeMap[_tree.nodes[node.rightChild].addr] = _index;\n\n                    _index = node.rightChild;\n                }\n            } else if (node.rightChild == 0) {\n                node.addr = _tree.nodes[node.leftChild].addr;\n                node.weight = _tree.nodes[node.leftChild].weight;\n                node.weightSum = _tree.nodes[node.leftChild].weightSum;\n\n                _tree.nodeMap[_tree.nodes[node.leftChild].addr] = _index;\n\n                _index = node.leftChild;\n            } else if (_tree.nodes[node.leftChild].weight > _tree.nodes[node.rightChild].weight) {\n                node.addr = _tree.nodes[node.leftChild].addr;\n                node.weight = _tree.nodes[node.leftChild].weight;\n                unchecked {\n                    node.weightSum =\n                        _tree.nodes[node.leftChild].weightSum +\n                        _tree.nodes[node.rightChild].weightSum;\n                }\n\n                _tree.nodeMap[_tree.nodes[node.leftChild].addr] = _index;\n\n                _index = node.leftChild;\n            } else {\n                node.addr = _tree.nodes[node.rightChild].addr;\n                node.weight = _tree.nodes[node.rightChild].weight;\n                unchecked {\n                    node.weightSum =\n                        _tree.nodes[node.leftChild].weightSum +\n                        _tree.nodes[node.rightChild].weightSum;\n                }\n\n                _tree.nodeMap[_tree.nodes[node.rightChild].addr] = _index;\n\n                _index = node.rightChild;\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/Burn.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { SafeCall } from \"./SafeCall.sol\";\n\n/**\n * @title Burn\n * @notice Utilities for burning stuff.\n */\nlibrary Burn {\n    /**\n     * Burns a given amount of ETH.\n     * Note that execution engine of Kroma does not support SELFDESTRUCT opcode, so it sends ETH to zero address.\n     *\n     * @param _amount Amount of ETH to burn.\n     */\n    function eth(uint256 _amount) internal {\n        SafeCall.call(address(0), gasleft(), _amount, \"\");\n    }\n\n    /**\n     * Burns a given amount of gas.\n     *\n     * @param _amount Amount of gas to burn.\n     */\n    function gas(uint256 _amount) internal view {\n        uint256 i = 0;\n        uint256 initialGas = gasleft();\n        while (initialGas - gasleft() < _amount) {\n            ++i;\n        }\n    }\n}\n"
    },
    "contracts/libraries/Bytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Bytes\n * @notice Bytes is a library for manipulating byte arrays.\n */\nlibrary Bytes {\n    /**\n     * @notice Compares two byte arrays by comparing their keccak256 hashes.\n     *\n     * @param _bytes First byte array to compare.\n     * @param _other Second byte array to compare.\n     *\n     * @return True if the two byte arrays are equal, false otherwise.\n     */\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\n        return keccak256(_bytes) == keccak256(_other);\n    }\n}\n"
    },
    "contracts/libraries/Bytes32.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Bytes32\n * @notice Bytes32 is a library for manipulating byte32.\n */\nlibrary Bytes32 {\n    /**\n     * @notice Splits bytes32 to high and low parts.\n     *\n     * @param _bytes Bytes32 to split.\n     *\n     * @return High part of bytes32.\n     * @return Low part of bytes32.\n     */\n    function split(bytes32 _bytes) internal pure returns (bytes32, bytes32) {\n        bytes16 high = bytes16(_bytes);\n        bytes16 low = bytes16(uint128(uint256(_bytes)));\n        return (fromBytes16(high), fromBytes16(low));\n    }\n\n    /**\n     * @notice Converts bytes16 to bytes32.\n     *\n     * @param _bytes Bytes to constrcut to bytes32.\n     *\n     * @return Bytes32 constructed from bytes16.\n     */\n    function fromBytes16(bytes16 _bytes) internal pure returns (bytes32) {\n        return bytes32(uint256(uint128(_bytes)));\n    }\n}\n"
    },
    "contracts/libraries/CodeDeployer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title CodeDeployer\n * @notice CodeDeployer is a library to deploy bytecode.\n */\nlibrary CodeDeployer {\n    function deployCode(bytes memory _code) internal returns (address deployedAddress) {\n        assembly {\n            deployedAddress := create(0, add(_code, 0x20), mload(_code))\n        }\n    }\n}\n"
    },
    "contracts/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\n\n/**\n * @title Constants\n * @notice Constants is a library for storing constants. Simple! Don't put everything in here, just\n *         the stuff used in multiple contracts. Constants that only apply to a single contract\n *         should be defined in that contract instead.\n */\nlibrary Constants {\n    /**\n     * @notice Special address to be used as the tx origin for gas estimation calls in the\n     *         KromaPortal and CrossDomainMessenger calls. You only need to use this address if\n     *         the minimum gas limit specified by the user is not actually enough to execute the\n     *         given message and you're attempting to estimate the actual necessary gas limit. We\n     *         use address(1) because it's the ecrecover precompile and therefore guaranteed to\n     *         never have any code on any EVM chain.\n     */\n    address internal constant ESTIMATION_ADDRESS = address(1);\n\n    /**\n     * @notice Value used for the L2 sender storage slot in both the KromaPortal and the\n     *         CrossDomainMessenger contracts before an actual sender is set. This value is\n     *         non-zero to reduce the gas cost of message passing transactions.\n     */\n    address internal constant DEFAULT_L2_SENDER = 0x000000000000000000000000000000000000dEaD;\n\n    /**\n     * @notice Returns the default values for the ResourceConfig. These are the recommended values\n     *         for a production network.\n     */\n    function DEFAULT_RESOURCE_CONFIG()\n        internal\n        pure\n        returns (ResourceMetering.ResourceConfig memory)\n    {\n        ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({\n            maxResourceLimit: 20_000_000,\n            elasticityMultiplier: 10,\n            baseFeeMaxChangeDenominator: 8,\n            minimumBaseFee: 1 gwei,\n            systemTxMaxGas: 1_000_000,\n            maximumBaseFee: type(uint128).max\n        });\n        return config;\n    }\n\n    /**\n     * @notice The denominator of the validator reward.\n     *         DO NOT change this value if the L2 chain is already operational.\n     */\n    uint256 internal constant VALIDATOR_REWARD_DENOMINATOR = 10000;\n\n    /**\n     * @notice An address that identifies that current submission round is a public round.\n     */\n    address internal constant VALIDATOR_PUBLIC_ROUND_ADDRESS = address(type(uint160).max);\n}\n"
    },
    "contracts/libraries/Encoding.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Hashing } from \"./Hashing.sol\";\nimport { Types } from \"./Types.sol\";\nimport { RLPWriter } from \"./rlp/RLPWriter.sol\";\n\n/// @title Encoding\n/// @notice Encoding handles Kroma's various different encoding schemes.\nlibrary Encoding {\n    /// @notice RLP encodes the L2 transaction that would be generated when a given deposit is sent\n    ///         to the L2 system. Useful for searching for a deposit in the L2 system. The\n    ///         transaction is prefixed with 0x7e to identify its EIP-2718 type.\n    /// @param _tx User deposit transaction to encode.\n    /// @return RLP encoded L2 deposit transaction.\n    function encodeDepositTransaction(Types.UserDepositTransaction memory _tx) internal pure returns (bytes memory) {\n        bytes32 source = Hashing.hashDepositSource(_tx.l1BlockHash, _tx.logIndex);\n        bytes[] memory raw = new bytes[](7);\n        raw[0] = RLPWriter.writeBytes(abi.encodePacked(source));\n        raw[1] = RLPWriter.writeAddress(_tx.from);\n        raw[2] = _tx.isCreation ? RLPWriter.writeBytes(\"\") : RLPWriter.writeAddress(_tx.to);\n        raw[3] = RLPWriter.writeUint(_tx.mint);\n        raw[4] = RLPWriter.writeUint(_tx.value);\n        raw[5] = RLPWriter.writeUint(uint256(_tx.gasLimit));\n        raw[6] = RLPWriter.writeBytes(_tx.data);\n        return abi.encodePacked(uint8(0x7e), RLPWriter.writeList(raw));\n    }\n\n    /// @notice Encodes the cross domain message based on the version that is encoded into the\n    ///         message nonce.\n    /// @param _nonce    Message nonce with version encoded into the first two bytes.\n    /// @param _sender   Address of the sender of the message.\n    /// @param _target   Address of the target of the message.\n    /// @param _value    ETH value to send to the target.\n    /// @param _gasLimit Gas limit to use for the message.\n    /// @param _data     Data to send with the message.\n    /// @return Encoded cross domain message.\n    function encodeCrossDomainMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        (, uint16 version) = decodeVersionedNonce(_nonce);\n        if (version == 0) {\n            return encodeCrossDomainMessageV0(_nonce, _sender, _target, _value, _gasLimit, _data);\n        } else {\n            revert(\"Encoding: unknown cross domain message version\");\n        }\n    }\n\n    /// @notice Encodes a cross domain message based on the V0 (current) encoding.\n    /// @param _nonce    Message nonce.\n    /// @param _sender   Address of the sender of the message.\n    /// @param _target   Address of the target of the message.\n    /// @param _value    ETH value to send to the target.\n    /// @param _gasLimit Gas limit to use for the message.\n    /// @param _data     Data to send with the message.\n    /// @return Encoded cross domain message.\n    function encodeCrossDomainMessageV0(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSignature(\n            \"relayMessage(uint256,address,address,uint256,uint256,bytes)\",\n            _nonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n    }\n\n    /// @notice Adds a version number into the first two bytes of a message nonce.\n    /// @param _nonce   Message nonce to encode into.\n    /// @param _version Version number to encode into the message nonce.\n    /// @return Message nonce with version encoded into the first two bytes.\n    function encodeVersionedNonce(uint240 _nonce, uint16 _version) internal pure returns (uint256) {\n        uint256 nonce;\n        assembly {\n            nonce := or(shl(240, _version), _nonce)\n        }\n        return nonce;\n    }\n\n    /// @notice Pulls the version out of a version-encoded nonce.\n    /// @param _nonce Message nonce with version encoded into the first two bytes.\n    /// @return Nonce without encoded version.\n    /// @return Version of the message.\n    function decodeVersionedNonce(uint256 _nonce) internal pure returns (uint240, uint16) {\n        uint240 nonce;\n        uint16 version;\n        assembly {\n            nonce := and(_nonce, 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            version := shr(240, _nonce)\n        }\n        return (nonce, version);\n    }\n\n    /// @notice Returns an appropriately encoded call to L1Block.setL1BlockValuesEcotone\n    /// @param baseFeeScalar         L1 base fee Scalar\n    /// @param blobBaseFeeScalar     L1 blob base fee Scalar\n    /// @param sequenceNumber        Number of L2 blocks since epoch start.\n    /// @param timestamp             L1 timestamp.\n    /// @param number                L1 blocknumber.\n    /// @param baseFee               L1 base fee.\n    /// @param blobBaseFee           L1 blob base fee.\n    /// @param hash                  L1 blockhash.\n    /// @param batcherHash           Versioned hash to authenticate batcher by.\n    /// @param validatorRewardScalar Validator reward scalar.\n    function encodeSetL1BlockValuesEcotone(\n        uint32 baseFeeScalar,\n        uint32 blobBaseFeeScalar,\n        uint64 sequenceNumber,\n        uint64 timestamp,\n        uint64 number,\n        uint256 baseFee,\n        uint256 blobBaseFee,\n        bytes32 hash,\n        bytes32 batcherHash,\n        uint256 validatorRewardScalar\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes4 functionSignature = bytes4(keccak256(\"setL1BlockValuesEcotone()\"));\n        return abi.encodePacked(\n            functionSignature,\n            baseFeeScalar,\n            blobBaseFeeScalar,\n            sequenceNumber,\n            timestamp,\n            number,\n            baseFee,\n            blobBaseFee,\n            hash,\n            batcherHash,\n            validatorRewardScalar\n        );\n    }\n}\n"
    },
    "contracts/libraries/Hashing.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Encoding } from \"./Encoding.sol\";\nimport { RLPWriter } from \"./rlp/RLPWriter.sol\";\nimport { Types } from \"./Types.sol\";\n\n/**\n * @title Hashing\n * @notice Hashing handles Kroma's various different hashing schemes.\n */\nlibrary Hashing {\n    /**\n     * @notice Computes the hash of the RLP encoded L2 transaction that would be generated when a\n     *         given deposit is sent to the L2 system. Useful for searching for a deposit in the L2\n     *         system.\n     *\n     * @param _tx User deposit transaction to hash.\n     *\n     * @return Hash of the RLP encoded L2 deposit transaction.\n     */\n    function hashDepositTransaction(\n        Types.UserDepositTransaction memory _tx\n    ) internal pure returns (bytes32) {\n        return keccak256(Encoding.encodeDepositTransaction(_tx));\n    }\n\n    /**\n     * @notice Computes the deposit transaction's \"source hash\", a value that guarantees the hash\n     *         of the L2 transaction that corresponds to a deposit is unique and is\n     *         deterministically generated from L1 transaction data.\n     *\n     * @param _l1BlockHash Hash of the L1 block where the deposit was included.\n     * @param _logIndex    The index of the log that created the deposit transaction.\n     *\n     * @return Hash of the deposit transaction's \"source hash\".\n     */\n    function hashDepositSource(\n        bytes32 _l1BlockHash,\n        uint64 _logIndex\n    ) internal pure returns (bytes32) {\n        bytes32 depositId = keccak256(abi.encode(_l1BlockHash, _logIndex));\n        return keccak256(abi.encode(bytes32(0), depositId));\n    }\n\n    /**\n     * @notice Hashes the cross domain message based on the version that is encoded into the\n     *         message nonce.\n     *\n     * @param _nonce    Message nonce with version encoded into the first two bytes.\n     * @param _sender   Address of the sender of the message.\n     * @param _target   Address of the target of the message.\n     * @param _value    ETH value to send to the target.\n     * @param _gasLimit Gas limit to use for the message.\n     * @param _data     Data to send with the message.\n     *\n     * @return Hashed cross domain message.\n     */\n    function hashCrossDomainMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes32) {\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\n        if (version == 0) {\n            return hashCrossDomainMessageV0(_nonce, _sender, _target, _value, _gasLimit, _data);\n        } else {\n            revert(\"Hashing: unknown cross domain message version\");\n        }\n    }\n\n    /**\n     * @notice Hashes a cross domain message based on the V0 (current) encoding.\n     *\n     * @param _nonce    Message nonce.\n     * @param _sender   Address of the sender of the message.\n     * @param _target   Address of the target of the message.\n     * @param _value    ETH value to send to the target.\n     * @param _gasLimit Gas limit to use for the message.\n     * @param _data     Data to send with the message.\n     *\n     * @return Hashed cross domain message.\n     */\n    function hashCrossDomainMessageV0(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                Encoding.encodeCrossDomainMessageV0(\n                    _nonce,\n                    _sender,\n                    _target,\n                    _value,\n                    _gasLimit,\n                    _data\n                )\n            );\n    }\n\n    /**\n     * @notice Derives the withdrawal hash according to the encoding in the L2 Withdrawer contract\n     *\n     * @param _tx Withdrawal transaction to hash.\n     *\n     * @return Hashed withdrawal transaction.\n     */\n    function hashWithdrawal(\n        Types.WithdrawalTransaction memory _tx\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(_tx.nonce, _tx.sender, _tx.target, _tx.value, _tx.gasLimit, _tx.data)\n            );\n    }\n\n    /**\n     * @notice Hashes the various elements of an output root proof into an output root hash which\n     *         can be used to check if the proof is valid.\n     *\n     * @param _outputRootProof Output root proof which should be hashed to an output root.\n     *\n     * @return Hashed output root proof.\n     */\n    function hashOutputRootProof(\n        Types.OutputRootProof memory _outputRootProof\n    ) internal pure returns (bytes32) {\n        if (_outputRootProof.version == bytes32(uint256(0))) {\n            return hashOutputRootProofV0(_outputRootProof);\n        } else {\n            revert(\"Hashing: unknown output root proof version\");\n        }\n    }\n\n    /**\n     * @notice Hashes the various elements of an output root proof into an output root hash which\n     *         can be used to check if the proof is valid. (version 0)\n     *\n     * @param _outputRootProof Output root proof which should be hashed to an output root.\n     *\n     * @return Hashed output root proof.\n     */\n    function hashOutputRootProofV0(\n        Types.OutputRootProof memory _outputRootProof\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    _outputRootProof.version,\n                    _outputRootProof.stateRoot,\n                    _outputRootProof.messagePasserStorageRoot,\n                    _outputRootProof.blockHash,\n                    _outputRootProof.nextBlockHash\n                )\n            );\n    }\n\n    /**\n     * @notice Fills the values of the block hash fields to a given bytes.\n     *\n     * @param _publicInput Public input which should be hashed to a block hash.\n     * @param _rlps        Pre-RLP encoded data which should be hashed to a block hash.\n     * @param _raw         An array of bytes to be populated.\n     */\n    function _fillBlockHashFieldsToBytes(\n        Types.PublicInput memory _publicInput,\n        Types.BlockHeaderRLP memory _rlps,\n        bytes[] memory _raw\n    ) private pure {\n        _raw[0] = RLPWriter.writeBytes(abi.encodePacked(_publicInput.parentHash));\n        _raw[1] = _rlps.uncleHash;\n        _raw[2] = _rlps.coinbase;\n        _raw[3] = RLPWriter.writeBytes(abi.encodePacked(_publicInput.stateRoot));\n        _raw[4] = RLPWriter.writeBytes(abi.encodePacked(_publicInput.transactionsRoot));\n        _raw[5] = _rlps.receiptsRoot;\n        _raw[6] = _rlps.logsBloom;\n        _raw[7] = _rlps.difficulty;\n        _raw[8] = RLPWriter.writeUint(_publicInput.number);\n        _raw[9] = RLPWriter.writeUint(_publicInput.gasLimit);\n        _raw[10] = _rlps.gasUsed;\n        _raw[11] = RLPWriter.writeUint(_publicInput.timestamp);\n        _raw[12] = _rlps.extraData;\n        _raw[13] = _rlps.mixHash;\n        _raw[14] = _rlps.nonce;\n        _raw[15] = RLPWriter.writeUint(_publicInput.baseFee);\n    }\n\n    /**\n     * @notice Hashes the various elements of a block header into a block hash(before shanghai).\n     *\n     * @param _publicInput Public input which should be hashed to a block hash.\n     * @param _rlps        Pre-RLP encoded data which should be hashed to a block hash.\n     *\n     * @return Hashed block header.\n     */\n    function hashBlockHeader(\n        Types.PublicInput memory _publicInput,\n        Types.BlockHeaderRLP memory _rlps\n    ) internal pure returns (bytes32) {\n        bytes[] memory raw = new bytes[](16);\n        _fillBlockHashFieldsToBytes(_publicInput, _rlps, raw);\n        return keccak256(RLPWriter.writeList(raw));\n    }\n\n    /**\n     * @notice Hashes the various elements of a block header into a block hash(after shanghai).\n     *\n     * @param _publicInput Public input which should be hashed to a block hash.\n     * @param _rlps        Pre-RLP encoded data which should be hashed to a block hash.\n     *\n     * @return Hashed block header.\n     */\n    function hashBlockHeaderShanghai(\n        Types.PublicInput memory _publicInput,\n        Types.BlockHeaderRLP memory _rlps\n    ) internal pure returns (bytes32) {\n        bytes[] memory raw = new bytes[](17);\n        _fillBlockHashFieldsToBytes(_publicInput, _rlps, raw);\n        raw[16] = RLPWriter.writeBytes(abi.encodePacked(_publicInput.withdrawalsRoot));\n        return keccak256(RLPWriter.writeList(raw));\n    }\n\n    /**\n     * @notice Hashes the various elements of a block header into a block hash(after Cancun).\n     *\n     * @param _publicInput Public input which should be hashed to a block hash.\n     * @param _rlps        Pre-RLP encoded data which should be hashed to a block hash.\n     *\n     * @return Hashed block header.\n     */\n    function hashBlockHeaderCancun(\n        Types.PublicInput memory _publicInput,\n        Types.BlockHeaderRLP memory _rlps\n    ) internal pure returns (bytes32) {\n        bytes[] memory raw = new bytes[](20);\n        _fillBlockHashFieldsToBytes(_publicInput, _rlps, raw);\n        raw[16] = RLPWriter.writeBytes(abi.encodePacked(_publicInput.withdrawalsRoot));\n        raw[17] = RLPWriter.writeUint(_publicInput.blobGasUsed);\n        raw[18] = RLPWriter.writeUint(_publicInput.excessBlobGas);\n        raw[19] = RLPWriter.writeBytes(abi.encodePacked(_publicInput.parentBeaconRoot));\n        return keccak256(RLPWriter.writeList(raw));\n    }\n\n    /**\n     * @notice Hashes the various elements of a public input into a public input hash.\n     *\n     * @param _prevStateRoot Previous state root.\n     * @param _publicInput   Public input which should be hashed to a public input hash.\n     * @param _dummyHashes   Dummy hashes returned from generateDummyHashes().\n     *\n     * @return Hashed block header.\n     */\n    function hashPublicInput(\n        bytes32 _prevStateRoot,\n        Types.PublicInput memory _publicInput,\n        bytes32[] memory _dummyHashes\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    _prevStateRoot,\n                    _publicInput.stateRoot,\n                    // NOTE(0xHansLee): the withdrawalsRoot is not used in Scroll's zkEVM circuit, so it is filled by zero\n                    bytes32(0),\n                    _publicInput.blockHash,\n                    _publicInput.parentHash,\n                    _publicInput.number,\n                    _publicInput.timestamp,\n                    _publicInput.baseFee,\n                    _publicInput.gasLimit,\n                    uint16(_publicInput.txHashes.length),\n                    _publicInput.txHashes,\n                    _dummyHashes\n                )\n            );\n    }\n\n    /**\n     * @notice Generates a bytes32 array filled with a dummy hash for the given length.\n     *\n     * @param _dummyHashes Dummy hash.\n     * @param _length      A length of the array.\n     *\n     * @return Bytes32 array filled with dummy hash.\n     */\n    function generateDummyHashes(\n        bytes32 _dummyHashes,\n        uint256 _length\n    ) internal pure returns (bytes32[] memory) {\n        bytes32[] memory hashes = new bytes32[](_length);\n        for (uint256 i = 0; i < _length; i++) {\n            hashes[i] = _dummyHashes;\n        }\n        return hashes;\n    }\n}\n"
    },
    "contracts/libraries/NodeReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title NodeReader\n * @notice NodeReader is a library for reading ZKTrie Node.\n */\nlibrary NodeReader {\n    /**\n     * @notice Node types.\n     *         See https://github.com/kroma-network/zktrie/blob/main/types/README.md.\n     *\n     * @custom:value MIDDLE Represents a middle node.\n     * @custom:value LEAF   Represents a leaf node.\n     * @custom:value EMPTY  Represents a empty node.\n     * @custom:value ROOT   Represents a root node.\n     */\n    enum NodeType {\n        MIDDLE,\n        LEAF,\n        EMPTY,\n        ROOT\n    }\n\n    /**\n     * @notice Struct representing a Node.\n     *         See https://github.com/kroma-network/zktrie/blob/main/types/README.md.\n     */\n    struct Node {\n        NodeType nodeType;\n        bytes32 childL;\n        bytes32 childR;\n        bytes32 nodeKey;\n        bytes32[] valuePreimage;\n        uint32 compressedFlags;\n        bytes32 valueHash;\n        bytes32 keyPreimage;\n    }\n\n    /**\n     * @notice Struct representing an Item.\n     */\n    struct Item {\n        bytes ptr;\n        uint256 len;\n    }\n\n    /**\n     * @notice Converts bytes to Item.\n     *\n     * @param _bytes bytes to convert.\n     *\n     * @return Item referencing _bytes.\n     */\n    function toItem(bytes memory _bytes) internal pure returns (Item memory) {\n        bytes memory ptr;\n        assembly {\n            ptr := add(_bytes, 32)\n        }\n        return Item({ ptr: ptr, len: _bytes.length });\n    }\n\n    /**\n     * @notice Reads an Item into an uint8.\n     *         Internal ptr and length is updated automatically.\n     *\n     * @param _item Item to read.\n     *\n     * @return An uint8 value.\n     */\n    function readUint8(Item memory _item) internal pure returns (uint8) {\n        require(_item.len >= 1, \"NodeReader: too short for uint8\");\n        bytes memory newPtr;\n        bytes memory ptr = _item.ptr;\n        uint8 ret;\n        assembly {\n            ret := shr(248, mload(ptr))\n            newPtr := add(ptr, 1)\n        }\n        _item.ptr = newPtr;\n        _item.len -= 1;\n        return ret;\n    }\n\n    /**\n     * @notice Reads an Item into compressed flags and length of values.\n     *         Internal ptr and length is updated automatically.\n     *\n     * @param _item Item to read.\n     *\n     * @return Compressed flags.\n     * @return Length of values.\n     */\n    function readCompressedFlags(Item memory _item) internal pure returns (uint32, uint8) {\n        require(_item.len >= 4, \"NodeReader: too short for uint32\");\n        bytes memory newPtr;\n        bytes memory ptr = _item.ptr;\n        uint32 temp;\n        uint8 flag;\n        uint8 len;\n        assembly {\n            temp := mload(ptr)\n            len := shr(248, temp)\n            flag := shr(240, temp)\n            newPtr := add(ptr, 4)\n        }\n        _item.ptr = newPtr;\n        _item.len -= 4;\n        return (flag, len);\n    }\n\n    /**\n     * @notice Reads an Item into a bytes32.\n     *         Internal ptr and length is updated automatically.\n     *\n     * @param _item Item to read.\n     *\n     * @return A bytes32 value.\n     */\n    function readBytes32(Item memory _item) internal pure returns (bytes32) {\n        require(_item.len >= 32, \"NodeReader: too short for bytes32\");\n        bytes memory newPtr;\n        bytes memory ptr = _item.ptr;\n        bytes32 ret;\n        assembly {\n            ret := mload(ptr)\n            newPtr := add(ptr, 32)\n        }\n        _item.ptr = newPtr;\n        _item.len -= 32;\n        return ret;\n    }\n\n    /**\n     * @notice Reads an Item by n bytes into a bytes32.\n     *         Internal ptr and length is updated automatically.\n     *\n     * @param _item Item to read.\n     *\n     * @return A bytes32 value.\n     */\n    function readBytesN(Item memory _item, uint256 _length) internal pure returns (bytes32) {\n        require(_item.len >= _length, \"NodeReader: too short for n bytes\");\n        bytes memory newPtr;\n        bytes memory ptr = _item.ptr;\n        bytes32 ret;\n        uint256 to = 256 - _length * 8;\n        assembly {\n            newPtr := add(ptr, _length)\n            ret := shr(to, mload(ptr))\n        }\n        _item.ptr = newPtr;\n        _item.len -= _length;\n        return ret;\n    }\n\n    /**\n     * @notice Reads bytes into a Node.\n     *\n     * @param _proof Bytes to read.\n     *\n     * @return A decoded Node.\n     */\n    function readNode(bytes memory _proof) internal pure returns (Node memory) {\n        Node memory node;\n        Item memory item = toItem(_proof);\n        uint256 nodeType = readUint8(item);\n        if (nodeType == uint256(NodeType.MIDDLE)) {\n            // TODO(chokobole): Do the length check as much as possible at once and read the bytes.\n            node.childL = readBytes32(item);\n            node.childR = readBytes32(item);\n        } else if (nodeType == uint256(NodeType.LEAF)) {\n            // TODO(chokobole): Do the length check as much as possible at once and read the bytes.\n            node.nodeKey = readBytes32(item);\n            (uint32 compressedFlags, uint256 valuePreimageLen) = readCompressedFlags(item);\n            require((compressedFlags == 1 && valuePreimageLen == 1) || (compressedFlags == 4 && valuePreimageLen == 4), \"NodeReader: invalid compressedFlags\");\n            node.compressedFlags = compressedFlags;\n            node.valuePreimage = new bytes32[](valuePreimageLen);\n            for (uint256 i = 0; i < valuePreimageLen; ) {\n                node.valuePreimage[i] = readBytes32(item);\n                unchecked {\n                    ++i;\n                }\n            }\n            uint256 keyPreimageLen = readUint8(item);\n            if (keyPreimageLen > 0) {\n                node.keyPreimage = readBytesN(item, keyPreimageLen);\n            }\n        } else if (nodeType == uint256(NodeType.EMPTY)) {\n            // Do nothing.\n        } else if (nodeType == uint256(NodeType.ROOT)) {\n            revert(\"NodeReader: unexpected root node type\");\n        } else {\n            revert(\"NodeReader: invalid node type\");\n        }\n        node.nodeType = NodeType(nodeType);\n        return node;\n    }\n}\n"
    },
    "contracts/libraries/Predeploys.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Predeploys\n * @notice Contains constant addresses for contracts that are pre-deployed to the L2 system.\n */\nlibrary Predeploys {\n    /**\n     * @notice Address of the ProxyAdmin predeploy.\n     */\n    address internal constant PROXY_ADMIN = 0x4200000000000000000000000000000000000000;\n\n    /**\n     * @notice Address of the L1Block predeploy.\n     */\n    address internal constant L1_BLOCK_ATTRIBUTES = 0x4200000000000000000000000000000000000002;\n\n    /**\n     * @notice Address of the L2ToL1MessagePasser predeploy.\n     */\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000003;\n\n    /**\n     * @notice Address of the L2CrossDomainMessenger predeploy.\n     */\n    address internal constant L2_CROSS_DOMAIN_MESSENGER =\n        0x4200000000000000000000000000000000000004;\n\n    /**\n     * @notice Address of the GasPriceOracle predeploy. Includes fee information\n     *         and helpers for computing the L1 portion of the transaction fee.\n     */\n    address internal constant GAS_PRICE_ORACLE = 0x4200000000000000000000000000000000000005;\n\n    /**\n     * @notice Address of the ProtocolVault predeploy.\n     */\n    address internal constant PROTOCOL_VAULT = 0x4200000000000000000000000000000000000006;\n\n    /**\n     * @notice Address of the L1FeeVault predeploy.\n     */\n    address internal constant L1_FEE_VAULT = 0x4200000000000000000000000000000000000007;\n\n    /**\n     * @notice Address of the ValidatorRewardVault predeploy.\n     */\n    address internal constant VALIDATOR_REWARD_VAULT = 0x4200000000000000000000000000000000000008;\n\n    /**\n     * @notice Address of the L2StandardBridge predeploy.\n     */\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000009;\n\n    /**\n     * @notice Address of the L2ERC721Bridge predeploy.\n     */\n    address internal constant L2_ERC721_BRIDGE = 0x420000000000000000000000000000000000000A;\n\n    /**\n     * @notice Address of the KromaMintableERC20Factory predeploy.\n     */\n    address internal constant KROMA_MINTABLE_ERC20_FACTORY =\n        0x420000000000000000000000000000000000000B;\n\n    /**\n     * @notice Address of the KromaMintableERC721Factory predeploy.\n     */\n    address internal constant KROMA_MINTABLE_ERC721_FACTORY =\n        0x420000000000000000000000000000000000000c;\n}\n"
    },
    "contracts/libraries/SafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title SafeCall\n * @notice Perform low level safe calls\n */\nlibrary SafeCall {\n    /**\n     * @notice Perform a low level call without copying any returndata\n     *\n     * @param _target   Address to call\n     * @param _gas      Amount of gas to pass to the call\n     * @param _value    Amount of value to pass to the call\n     * @param _calldata Calldata to pass to the call\n     */\n    function call(\n        address _target,\n        uint256 _gas,\n        uint256 _value,\n        bytes memory _calldata\n    ) internal returns (bool) {\n        bool _success;\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 32), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n        }\n        return _success;\n    }\n\n    /**\n     * @notice Helper function to determine if there is sufficient gas remaining within the context\n     *         to guarantee that the minimum gas requirement for a call will be met as well as\n     *         optionally reserving a specified amount of gas for after the call has concluded.\n     *\n     * @param _minGas      The minimum amount of gas that may be passed to the target context.\n     * @param _reservedGas Optional amount of gas to reserve for the caller after the execution\n     *                     of the target context.\n     *\n     * @return `true` if there is enough gas remaining to safely supply `_minGas` to the target\n     *         context as well as reserve `_reservedGas` for the caller after the execution of\n     *         the target context.\n     *\n     * @dev !!!!! FOOTGUN ALERT !!!!!\n     *      1.) The 40_000 base buffer is to account for the worst case of the dynamic cost of the\n     *          `CALL` opcode's `address_access_cost`, `positive_value_cost`, and\n     *          `value_to_empty_account_cost` factors with an added buffer of 5,700 gas. It is\n     *          still possible to self-rekt by initiating a withdrawal with a minimum gas limit\n     *          that does not account for the `memory_expansion_cost` & `code_execution_cost`\n     *          factors of the dynamic cost of the `CALL` opcode.\n     *      2.) This function should *directly* precede the external call if possible. There is an\n     *          added buffer to account for gas consumed between this check and the call, but it\n     *          is only 5,700 gas.\n     *      3.) Because EIP-150 ensures that a maximum of 63/64ths of the remaining gas in the call\n     *          frame may be passed to a subcontext, we need to ensure that the gas will not be\n     *          truncated.\n     *      4.) Use wisely. This function is not a silver bullet.\n     */\n    function hasMinGas(uint256 _minGas, uint256 _reservedGas) internal view returns (bool) {\n        bool _hasMinGas;\n        assembly {\n            // Equation: gas × 63 ≥ minGas × 64 + 63(40_000 + reservedGas)\n            _hasMinGas := iszero(\n                lt(mul(gas(), 63), add(mul(_minGas, 64), mul(add(40000, _reservedGas), 63)))\n            )\n        }\n        return _hasMinGas;\n    }\n\n    /**\n     * @notice Perform a low level call without copying any returndata. This function\n     *         will revert if the call cannot be performed with the specified minimum\n     *         gas.\n     *\n     * @param _target   Address to call\n     * @param _minGas   The minimum amount of gas that may be passed to the call\n     * @param _value    Amount of value to pass to the call\n     * @param _calldata Calldata to pass to the call\n     */\n    function callWithMinGas(\n        address _target,\n        uint256 _minGas,\n        uint256 _value,\n        bytes memory _calldata\n    ) internal returns (bool) {\n        bool _success;\n        bool _hasMinGas = hasMinGas(_minGas, 0);\n        assembly {\n            // Assertion: gasleft() >= (_minGas * 64) / 63 + 40_000\n            if iszero(_hasMinGas) {\n                // Store the \"Error(string)\" selector in scratch space.\n                mstore(0, 0x08c379a0)\n                // Store the pointer to the string length in scratch space.\n                mstore(32, 32)\n                // Store the string.\n                //\n                // SAFETY:\n                // - We pad the beginning of the string with two zero bytes as well as the\n                // length (24) to ensure that we override the free memory pointer at offset\n                // 0x40. This is necessary because the free memory pointer is likely to\n                // be greater than 1 byte when this function is called, but it is incredibly\n                // unlikely that it will be greater than 3 bytes. As for the data within\n                // 0x60, it is ensured that it is 0 due to 0x60 being the zero offset.\n                // - It's fine to clobber the free memory pointer, we're reverting.\n                mstore(88, 0x0000185361666543616c6c3a204e6f7420656e6f75676820676173)\n\n                // Revert with 'Error(\"SafeCall: Not enough gas\")'\n                revert(28, 100)\n            }\n\n            // The call will be supplied at least ((_minGas * 64) / 63 + 40_000 - 49) gas due to the\n            // above assertion. This ensures that, in all circumstances (except for when the\n            // `_minGas` does not account for the `memory_expansion_cost` and `code_execution_cost`\n            // factors of the dynamic cost of the `CALL` opcode), the call will receive at least\n            // the minimum amount of gas specified.\n            _success := call(\n                gas(), // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 32), // inloc\n                mload(_calldata), // inlen\n                0x00, // outloc\n                0x00 // outlen\n            )\n        }\n        return _success;\n    }\n}\n"
    },
    "contracts/libraries/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Types\n * @notice Contains various types used throughout the Kroma contract system.\n */\nlibrary Types {\n    /**\n     * @notice CheckpointOutput represents a commitment to the state of L2 checkpoint. The timestamp\n     *         is the L1 timestamp that the output root is posted. This timestamp is used to verify\n     *         that the finalization period has passed since the output root was submitted.\n     *\n     * @custom:field submitter     Address of the output submitter.\n     * @custom:field outputRoot    Hash of the L2 output.\n     * @custom:field timestamp     Timestamp of the L1 block that the output root was submitted in.\n     * @custom:field l2BlockNumber L2 block number that the output corresponds to.\n     */\n    struct CheckpointOutput {\n        address submitter;\n        bytes32 outputRoot;\n        uint128 timestamp;\n        uint128 l2BlockNumber;\n    }\n\n    /**\n     * @notice Struct representing the elements that are hashed together to generate an output root\n     *         which itself represents a snapshot of the L2 state.\n     *\n     * @custom:field version                  Version of the output root.\n     * @custom:field stateRoot                Root of the state trie at the block of this output.\n     * @custom:field messagePasserStorageRoot Root of the message passer storage trie.\n     * @custom:field blockHash                Hash of the block this output was generated from.\n     * @custom:field nextBlockHash            Hash of the next block.\n     */\n    struct OutputRootProof {\n        bytes32 version;\n        bytes32 stateRoot;\n        bytes32 messagePasserStorageRoot;\n        bytes32 blockHash;\n        bytes32 nextBlockHash;\n    }\n\n    /**\n     * @notice Struct representing the elements that are hashed together to generate a public input.\n     *\n     * @custom:field blockHash        The hash of the block.\n     * @custom:field parentHash       The hash of the previous block.\n     * @custom:field timestamp        The block time.\n     * @custom:field number           The block number.\n     * @custom:field gasLimit         Maximum gas allowed.\n     * @custom:field baseFee          The base fee per gas.\n     * @custom:field transactionsRoot Root hash of the transactions.\n     * @custom:field stateRoot        Root hash of the state trie.\n     * @custom:field withdrawalsRoot  Root hash of the withdrawals.\n     * @custom:field txHashes         Array of hash of the transaction.\n     * @custom:field blobGasUsed      The total amount of blob gas consumed by the transactions within the block.\n     * @custom:field excessBlobGas    A total of blob gas consumed in excess of the target, prior to the block.\n     * @custom:field parentBeaconRoot Root hash of the parent beacon block.\n     */\n    struct PublicInput {\n        bytes32 blockHash;\n        bytes32 parentHash;\n        uint64 timestamp;\n        uint64 number;\n        uint64 gasLimit;\n        uint256 baseFee;\n        bytes32 transactionsRoot;\n        bytes32 stateRoot;\n        bytes32 withdrawalsRoot;\n        bytes32[] txHashes;\n        uint64 blobGasUsed;\n        uint64 excessBlobGas;\n        bytes32 parentBeaconRoot;\n    }\n\n    /**\n     * @notice Struct representing the elements that are hashed together to generate a block hash.\n     *         Some of fields that are contained in PublicInput are omitted.\n     *\n     * @custom:field uncleHash    RLP encoded uncle hash.\n     * @custom:field coinbase     RLP encoded coinbase.\n     * @custom:field receiptsRoot RLP encoded receipts root.\n     * @custom:field logsBloom    RLP encoded logs bloom.\n     * @custom:field difficulty   RLP encoded difficulty.\n     * @custom:field gasUsed      RLP encoded gas used.\n     * @custom:field extraData    RLP encoded extra data.\n     * @custom:field mixHash      RLP encoded mix hash.\n     * @custom:field nonce        RLP encoded nonce.\n     */\n    struct BlockHeaderRLP {\n        bytes uncleHash;\n        bytes coinbase;\n        bytes receiptsRoot;\n        bytes logsBloom;\n        bytes difficulty;\n        bytes gasUsed;\n        bytes extraData;\n        bytes mixHash;\n        bytes nonce;\n    }\n\n    /**\n     * @notice Struct representing a deposit transaction (L1 => L2 transaction) created by an end\n     *         user (as opposed to a system deposit transaction generated by the system).\n     *\n     * @custom:field from        Address of the sender of the transaction.\n     * @custom:field to          Address of the recipient of the transaction.\n     * @custom:field isCreation  True if the transaction is a contract creation.\n     * @custom:field value       Value to send to the recipient.\n     * @custom:field mint        Amount of ETH to mint.\n     * @custom:field gasLimit    Gas limit of the transaction.\n     * @custom:field data        Data of the transaction.\n     * @custom:field l1BlockHash Hash of the block the transaction was submitted in.\n     * @custom:field logIndex    Index of the log in the block the transaction was submitted in.\n     */\n    struct UserDepositTransaction {\n        address from;\n        address to;\n        bool isCreation;\n        uint256 value;\n        uint256 mint;\n        uint64 gasLimit;\n        bytes data;\n        bytes32 l1BlockHash;\n        uint64 logIndex;\n    }\n\n    /**\n     * @notice Struct representing a withdrawal transaction.\n     *\n     * @custom:field nonce    Nonce of the withdrawal transaction\n     * @custom:field sender   Address of the sender of the transaction.\n     * @custom:field target   Address of the recipient of the transaction.\n     * @custom:field value    Value to send to the recipient.\n     * @custom:field gasLimit Gas limit of the transaction.\n     * @custom:field data     Data of the transaction.\n     */\n    struct WithdrawalTransaction {\n        uint256 nonce;\n        address sender;\n        address target;\n        uint256 value;\n        uint256 gasLimit;\n        bytes data;\n    }\n\n    /**\n     * @notice Struct representing a challenge.\n     *\n     * @custom:field turn       The current turn.\n     * @custom:field timeoutAt  Timeout timestamp of the next turn.\n     * @custom:field asserter   Address of the asserter.\n     * @custom:field challenger Address of the challenger.\n     * @custom:field segments   Array of the segment.\n     * @custom:field segStart   The L2 block number of the first segment.\n     * @custom:field segSize    The number of L2 blocks.\n     */\n    struct Challenge {\n        uint8 turn;\n        uint64 timeoutAt;\n        address asserter;\n        address challenger;\n        bytes32[] segments;\n        uint256 segSize;\n        uint256 segStart;\n    }\n\n    /**\n     * @notice Struct representing a validator's bond.\n     *\n     * @custom:field amount    Amount of the lock.\n     * @custom:field expiresAt The expiration timestamp of bond.\n     */\n    struct Bond {\n        uint128 amount;\n        uint128 expiresAt;\n    }\n\n    /**\n     * @notice Struct representing multisig transaction data.\n     *\n     * @custom:field target   The destination address to run the transaction.\n     * @custom:field executed Record whether a transaction was executed or not.\n     * @custom:field value    The value passed in while executing the transaction.\n     * @custom:field data     Calldata for transaction.\n     */\n    struct MultiSigTransaction {\n        address target;\n        bool executed;\n        uint256 value;\n        bytes data;\n    }\n\n    /**\n     * @notice Struct representing multisig confirmation data.\n     *\n     * @custom:field confirmationCount The sum of confirmations.\n     * @custom:field confirmedBy       Map data that stores whether confirmation is performed by account.\n     */\n    struct MultiSigConfirmation {\n        uint256 confirmationCount;\n        mapping(address => bool) confirmedBy;\n    }\n\n    /**\n     * @notice Struct representing the data for verifying the public input.\n     *\n     * @custom:field srcOutputRootProof          Proof of the source output root.\n     * @custom:field dstOutputRootProof          Proof of the destination output root.\n     * @custom:field publicInput                 Ingredients to compute the public input used by ZK proof verification.\n     * @custom:field rlps                        Pre-encoded RLPs to compute the next block hash\n     *                                           of the source output root proof.\n     * @custom:field l2ToL1MessagePasserBalance  Balance of the L2ToL1MessagePasser account.\n     * @custom:field l2ToL1MessagePasserCodeHash Codehash of the L2ToL1MessagePasser account.\n     * @custom:field merkleProof                 Merkle proof of L2ToL1MessagePasser account against the state root.\n     */\n    struct PublicInputProof {\n        OutputRootProof srcOutputRootProof;\n        OutputRootProof dstOutputRootProof;\n        PublicInput publicInput;\n        BlockHeaderRLP rlps;\n        bytes32 l2ToL1MessagePasserBalance;\n        bytes32 l2ToL1MessagePasserCodeHash;\n        bytes[] merkleProof;\n    }\n}\n"
    },
    "contracts/libraries/Uint128Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title Uint128Math\n * @notice A library for handling overflow-safe math on uint128, especially for mulDiv operations.\n *         This library is motivated from the open-source Openzeppelin's Math library.\n */\nlibrary Uint128Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint128 a, uint128 b) internal pure returns (uint128) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint128 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs and Openzeppelin also under MIT license.\n     */\n    function mulDiv(\n        uint128 x,\n        uint128 y,\n        uint128 denominator\n    ) internal pure returns (uint128 result) {\n        unchecked {\n            uint256 prod;\n            assembly {\n                prod := mul(x, y)\n            }\n\n            // Make sure the result is less than 2^128.\n            require(denominator > (prod >> 128), \"Uint128Math: mulDiv overflow\");\n\n            // Direct division as fallback since we can't guarantee not exceeding 128 bits without further checks.\n            result = uint128(prod / uint256(denominator));\n            return result;\n        }\n    }\n}\n"
    },
    "contracts/libraries/rlp/RLPWriter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @custom:attribution https://github.com/bakaoh/solidity-rlp-encode\n * @title RLPWriter\n * @author RLPWriter is a library for encoding Solidity types to RLP bytes. Adapted from Bakaoh's\n *         RLPEncode library (https://github.com/bakaoh/solidity-rlp-encode) with minor\n *         modifications to improve legibility.\n */\nlibrary RLPWriter {\n    /**\n     * @notice RLP encodes a byte string.\n     *\n     * @param _in The byte string to encode.\n     *\n     * @return The RLP encoded string in bytes.\n     */\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\n            encoded = _in;\n        } else {\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\n        }\n\n        return encoded;\n    }\n\n    /**\n     * @notice RLP encodes a list of RLP encoded byte byte strings.\n     *\n     * @param _in The list of RLP encoded byte strings.\n     *\n     * @return The RLP encoded list of items in bytes.\n     */\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\n        bytes memory list = _flatten(_in);\n        return abi.encodePacked(_writeLength(list.length, 192), list);\n    }\n\n    /**\n     * @notice RLP encodes a string.\n     *\n     * @param _in The string to encode.\n     *\n     * @return The RLP encoded string in bytes.\n     */\n    function writeString(string memory _in) internal pure returns (bytes memory) {\n        return writeBytes(bytes(_in));\n    }\n\n    /**\n     * @notice RLP encodes an address.\n     *\n     * @param _in The address to encode.\n     *\n     * @return The RLP encoded address in bytes.\n     */\n    function writeAddress(address _in) internal pure returns (bytes memory) {\n        return writeBytes(abi.encodePacked(_in));\n    }\n\n    /**\n     * @notice RLP encodes a uint.\n     *\n     * @param _in The uint256 to encode.\n     *\n     * @return The RLP encoded uint256 in bytes.\n     */\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\n        return writeBytes(_toBinary(_in));\n    }\n\n    /**\n     * @notice RLP encodes a bool.\n     *\n     * @param _in The bool to encode.\n     *\n     * @return The RLP encoded bool in bytes.\n     */\n    function writeBool(bool _in) internal pure returns (bytes memory) {\n        bytes memory encoded = new bytes(1);\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\n        return encoded;\n    }\n\n    /**\n     * @notice Encode the first byte and then the `len` in binary form if `length` is more than 55.\n     *\n     * @param _len    The length of the string or the payload.\n     * @param _offset 128 if item is string, 192 if item is list.\n     *\n     * @return RLP encoded bytes.\n     */\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\n        } else {\n            uint256 lenLen;\n            uint256 i = 1;\n            while (_len / i != 0) {\n                lenLen++;\n                i *= 256;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\n            for (i = 1; i <= lenLen; i++) {\n                encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));\n            }\n        }\n\n        return encoded;\n    }\n\n    /**\n     * @notice Encode integer in big endian binary form with no leading zeroes.\n     *\n     * @param _x The integer to encode.\n     *\n     * @return RLP encoded bytes.\n     */\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\n        bytes memory b = abi.encodePacked(_x);\n\n        uint256 i = 0;\n        for (; i < 32; i++) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n\n        bytes memory res = new bytes(32 - i);\n        for (uint256 j = 0; j < res.length; j++) {\n            res[j] = b[i++];\n        }\n\n        return res;\n    }\n\n    /**\n     * @custom:attribution https://github.com/Arachnid/solidity-stringutils\n     * @notice Copies a piece of memory to another location.\n     *\n     * @param _dest Destination location.\n     * @param _src  Source location.\n     * @param _len  Length of memory to copy.\n     */\n    function _memcpy(\n        uint256 _dest,\n        uint256 _src,\n        uint256 _len\n    ) private pure {\n        uint256 dest = _dest;\n        uint256 src = _src;\n        uint256 len = _len;\n\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        uint256 mask;\n        unchecked {\n            mask = 256**(32 - len) - 1;\n        }\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * @custom:attribution https://github.com/sammayo/solidity-rlp-encoder\n     * @notice Flattens a list of byte strings into one byte string.\n     *\n     * @param _list List of byte strings to flatten.\n     *\n     * @return The flattened byte string.\n     */\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint256 len;\n        uint256 i = 0;\n        for (; i < _list.length; i++) {\n            len += _list[i].length;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint256 flattenedPtr;\n        assembly {\n            flattenedPtr := add(flattened, 0x20)\n        }\n\n        for (i = 0; i < _list.length; i++) {\n            bytes memory item = _list[i];\n\n            uint256 listPtr;\n            assembly {\n                listPtr := add(item, 0x20)\n            }\n\n            _memcpy(flattenedPtr, listPtr, item.length);\n            flattenedPtr += _list[i].length;\n        }\n\n        return flattened;\n    }\n}\n"
    },
    "contracts/test/AddressAliasHelper.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\n\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\n\ncontract AddressAliasHelper_applyAndUndo_Test is Test {\n    /**\n     * @notice Tests that applying and then undoing an alias results in the original address.\n     */\n    function testFuzz_applyAndUndo_succeeds(address _address) external {\n        address aliased = AddressAliasHelper.applyL1ToL2Alias(_address);\n        address unaliased = AddressAliasHelper.undoL1ToL2Alias(aliased);\n        assertEq(_address, unaliased);\n    }\n}\n"
    },
    "contracts/test/AssetManager.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport { AssetManager } from \"../L1/AssetManager.sol\";\nimport { ValidatorManager } from \"../L1/ValidatorManager.sol\";\nimport { IAssetManager } from \"../L1/interfaces/IAssetManager.sol\";\nimport { IValidatorManager } from \"../L1/interfaces/IValidatorManager.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { ValidatorSystemUpgrade_Initializer } from \"./CommonTest.t.sol\";\nimport { MockL2OutputOracle } from \"./ValidatorManager.t.sol\";\n\ncontract MockAssetManager is AssetManager {\n    constructor(\n        IERC20 _assetToken,\n        IERC721 _kgh,\n        address _securityCouncil,\n        address _validatorRewardVault,\n        IValidatorManager _validatorManager,\n        uint128 _minDelegationPeriod,\n        uint128 _bondAmount\n    )\n        AssetManager(\n            _assetToken,\n            _kgh,\n            _securityCouncil,\n            _validatorRewardVault,\n            _validatorManager,\n            _minDelegationPeriod,\n            _bondAmount\n        )\n    {}\n\n    function increaseRewardPerKgh(address validator, uint128 amount) external {\n        _vaults[validator].asset.rewardPerKghStored += amount;\n    }\n\n    function increaseBaseReward(address validator, uint128 amount) external {\n        _vaults[validator].asset.totalKro += amount;\n    }\n}\n\ncontract MockValidatorManager is ValidatorManager {\n    constructor(ConstructorParams memory _constructorParams) ValidatorManager(_constructorParams) {}\n\n    function sendToJail(address validator) external {\n        _jail[validator] = uint128(block.timestamp) + HARD_JAIL_PERIOD_SECONDS;\n    }\n\n    function calculateBoostedReward(address validator) external view returns (uint128) {\n        return _getBoostedReward(validator);\n    }\n}\n\n// Tests the implementations of the AssetManager\ncontract AssetManagerTest is ValidatorSystemUpgrade_Initializer {\n    MockAssetManager public mockAssetMgr;\n    MockValidatorManager public mockValMgr;\n    MockL2OutputOracle public mockOracle;\n    address public validator = trusted;\n\n    function setUp() public override {\n        super.setUp();\n\n        MockL2OutputOracle mockOracleImpl = new MockL2OutputOracle(\n            pool,\n            valMgr,\n            address(colosseum),\n            submissionInterval,\n            l2BlockTime,\n            startingBlockNumber,\n            startingTimestamp,\n            finalizationPeriodSeconds\n        );\n        vm.prank(multisig);\n        Proxy(payable(address(oracle))).upgradeTo(address(mockOracleImpl));\n        mockOracle = MockL2OutputOracle(address(oracle));\n\n        MockAssetManager assetManagerImpl = new MockAssetManager(\n            IERC20(assetToken),\n            IERC721(kgh),\n            guardian,\n            validatorRewardVault,\n            valMgr,\n            minDelegationPeriod,\n            bondAmount\n        );\n        vm.prank(multisig);\n        Proxy(payable(address(assetMgr))).upgradeTo(address(assetManagerImpl));\n        mockAssetMgr = MockAssetManager(address(assetMgr));\n\n        MockValidatorManager mockValMgrImpl = new MockValidatorManager(constructorParams);\n        vm.prank(multisig);\n        Proxy(payable(address(valMgr))).upgradeTo(address(mockValMgrImpl));\n        mockValMgr = MockValidatorManager(address(valMgr));\n\n        // Submit until terminateOutputIndex and set next output index to be finalized after it\n        for (uint256 i = oracle.nextOutputIndex(); i <= terminateOutputIndex; i++) {\n            _submitOutputRoot(pool.nextValidator());\n        }\n        vm.warp(oracle.finalizedAt(terminateOutputIndex));\n        mockOracle.mockSetNextFinalizeOutputIndex(terminateOutputIndex + 1);\n    }\n\n    function _submitOutputRoot(address _validator) internal {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime();\n        vm.prank(_validator);\n        mockOracle.addOutput(nextBlockNumber);\n    }\n\n    function _registerValidator(uint128 amount) internal {\n        vm.startPrank(validator, validator);\n        assetToken.approve(address(assetMgr), amount);\n        valMgr.registerValidator(amount, 0, withdrawAcc);\n        vm.stopPrank();\n    }\n\n    function _delegate(address _delegator, uint128 amount) internal {\n        vm.startPrank(_delegator);\n        assetToken.approve(address(assetMgr), amount);\n        assetMgr.delegate(validator, amount);\n        vm.stopPrank();\n    }\n\n    function _delegateKgh(address _delegator, uint256 tokenId) internal {\n        kgh.mint(_delegator, tokenId);\n        vm.startPrank(_delegator);\n        kgh.approve(address(assetMgr), tokenId);\n        assetMgr.delegateKgh(validator, tokenId);\n        vm.stopPrank();\n    }\n\n    function _delegateKghBatch(uint256 kghCount) internal {\n        uint256[] memory tokenIds = new uint256[](kghCount);\n        for (uint256 i = 1; i < kghCount + 1; i++) {\n            kgh.mint(delegator, i);\n            vm.prank(delegator);\n            kgh.approve(address(assetMgr), i);\n            tokenIds[i - 1] = i;\n        }\n\n        vm.prank(delegator);\n        assetMgr.delegateKghBatch(validator, tokenIds);\n    }\n\n    function _undelegate(address _delegator) internal returns (uint128) {\n        uint128 delegatorKro = assetMgr.getKroAssets(validator, _delegator);\n        vm.warp(assetMgr.canUndelegateKroAt(validator, _delegator));\n        vm.prank(_delegator);\n        assetMgr.undelegate(validator, delegatorKro);\n\n        return delegatorKro;\n    }\n\n    function _undelegateKgh(address _delegator, uint256 tokenId) internal {\n        vm.warp(assetMgr.canUndelegateKghAt(validator, _delegator, tokenId));\n        vm.prank(_delegator);\n        assetMgr.undelegateKgh(validator, tokenId);\n    }\n\n    function _undelegateKghBatch(uint256 kghCount) internal {\n        uint256[] memory tokenIds = new uint256[](kghCount);\n        for (uint256 i = 1; i < kghCount + 1; i++) {\n            tokenIds[i - 1] = i;\n        }\n\n        vm.warp(assetMgr.canUndelegateKghAt(validator, delegator, tokenIds[0]));\n        vm.prank(delegator);\n        assetMgr.undelegateKghBatch(validator, tokenIds);\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(address(assetMgr.ASSET_TOKEN()), address(assetToken));\n        assertEq(address(assetMgr.KGH()), address(kgh));\n        assertEq(assetMgr.SECURITY_COUNCIL(), guardian);\n        assertEq(address(assetMgr.VALIDATOR_REWARD_VAULT()), validatorRewardVault);\n        assertEq(address(assetMgr.VALIDATOR_MANAGER()), address(valMgr));\n        assertEq(assetMgr.MIN_DELEGATION_PERIOD(), minDelegationPeriod);\n        assertEq(assetMgr.BOND_AMOUNT(), bondAmount);\n    }\n\n    function test_depositToRegister_succeeds() external {\n        uint256 beforeBalance = assetToken.balanceOf(validator);\n\n        vm.prank(validator);\n        assetToken.approve(address(assetMgr), minActivateAmount);\n        vm.prank(address(valMgr));\n        assetMgr.depositToRegister(validator, minActivateAmount, withdrawAcc);\n\n        assertEq(assetMgr.getWithdrawAccount(validator), withdrawAcc);\n        assertEq(assetMgr.totalValidatorKro(validator), minActivateAmount);\n        assertEq(assetMgr.canWithdrawAt(validator), block.timestamp + minDelegationPeriod);\n        assertEq(assetToken.balanceOf(validator), beforeBalance - minActivateAmount);\n        assertEq(assetToken.balanceOf(address(assetMgr)), minActivateAmount);\n    }\n\n    function test_depositToRegister_callerNotValMgr_reverts() external {\n        vm.expectRevert(IAssetManager.NotAllowedCaller.selector);\n        assetMgr.depositToRegister(validator, minActivateAmount, withdrawAcc);\n    }\n\n    function test_depositToRegister_zeroWithdrawAcc_reverts() external {\n        vm.prank(address(valMgr));\n        vm.expectRevert(IAssetManager.ZeroAddress.selector);\n        assetMgr.depositToRegister(validator, minActivateAmount, address(0));\n    }\n\n    function test_deposit_succeeds() external {\n        _registerValidator(minActivateAmount);\n\n        uint120 beforeWeight = valMgr.getWeight(validator);\n        uint256 beforeBalance = assetToken.balanceOf(validator);\n        uint128 beforeValidatorKro = assetMgr.totalValidatorKro(validator);\n\n        vm.startPrank(validator);\n        assetToken.approve(address(assetMgr), bondAmount);\n        assetMgr.deposit(bondAmount);\n\n        assertEq(assetMgr.totalValidatorKro(validator), beforeValidatorKro + bondAmount);\n        assertEq(assetMgr.canWithdrawAt(validator), block.timestamp + minDelegationPeriod);\n        assertEq(valMgr.getWeight(validator), beforeWeight + bondAmount);\n        assertEq(assetToken.balanceOf(validator), beforeBalance - bondAmount);\n    }\n\n    function test_deposit_activate_succeeds() external {\n        _registerValidator(minActivateAmount - 1);\n        assertEq(valMgr.getWeight(validator), 0);\n\n        vm.startPrank(validator);\n        assetToken.approve(address(assetMgr), 1);\n        assetMgr.deposit(1);\n\n        assertEq(valMgr.getWeight(validator), minActivateAmount);\n    }\n\n    function test_deposit_notActivate_succeeds() external {\n        _registerValidator(minActivateAmount - 2);\n        assertEq(valMgr.getWeight(validator), 0);\n\n        vm.startPrank(validator);\n        assetToken.approve(address(assetMgr), 1);\n        assetMgr.deposit(1);\n\n        assertEq(valMgr.getWeight(validator), 0);\n    }\n\n    function test_deposit_inJailNotActivate_succeeds() external {\n        _registerValidator(minActivateAmount - 1);\n        assertEq(valMgr.getWeight(validator), 0);\n\n        mockValMgr.sendToJail(validator);\n        assertTrue(valMgr.inJail(validator));\n\n        vm.startPrank(validator);\n        assetToken.approve(address(assetMgr), 1);\n        assetMgr.deposit(1);\n\n        assertEq(valMgr.getWeight(validator), 0);\n    }\n\n    function test_deposit_zeroAsset_reverts() external {\n        vm.expectRevert(IAssetManager.NotAllowedZeroInput.selector);\n        assetMgr.deposit(0);\n    }\n\n    function test_deposit_validatorStatusNone_reverts() external {\n        vm.prank(validator);\n        vm.expectRevert(IAssetManager.ImproperValidatorStatus.selector);\n        assetMgr.deposit(bondAmount);\n    }\n\n    function test_withdraw_succeeds() public {\n        _registerValidator(minActivateAmount);\n        assertEq(valMgr.getWeight(validator), minActivateAmount);\n        uint256 beforeBalance = assetToken.balanceOf(validator);\n\n        address withdrawAccount = assetMgr.getWithdrawAccount(validator);\n        vm.warp(assetMgr.canWithdrawAt(validator));\n        vm.prank(withdrawAccount);\n        assetMgr.withdraw(validator, minActivateAmount);\n\n        assertEq(assetMgr.totalValidatorKro(validator), 0);\n        assertEq(valMgr.getWeight(validator), 0);\n        assertEq(assetToken.balanceOf(validator), beforeBalance);\n        assertEq(assetToken.balanceOf(withdrawAccount), minActivateAmount);\n    }\n\n    function test_withdraw_notWithdrawAcc_reverts() external {\n        _registerValidator(minActivateAmount);\n\n        vm.prank(validator);\n        vm.expectRevert(IAssetManager.NotAllowedCaller.selector);\n        assetMgr.withdraw(validator, minActivateAmount);\n    }\n\n    function test_withdraw_zeroAsset_reverts() external {\n        _registerValidator(minActivateAmount);\n\n        vm.prank(assetMgr.getWithdrawAccount(validator));\n        vm.expectRevert(IAssetManager.NotAllowedZeroInput.selector);\n        assetMgr.withdraw(validator, 0);\n    }\n\n    function test_withdraw_notElapsedMinDelegationPeriod_reverts() external {\n        _registerValidator(minActivateAmount);\n\n        vm.prank(assetMgr.getWithdrawAccount(validator));\n        vm.expectRevert(IAssetManager.NotElapsedMinDelegationPeriod.selector);\n        assetMgr.withdraw(validator, minActivateAmount);\n    }\n\n    function test_withdraw_notExpiredJailPeriod_reverts() external {\n        _registerValidator(minActivateAmount);\n\n        vm.warp(assetMgr.canWithdrawAt(validator));\n        mockValMgr.sendToJail(validator);\n\n        vm.prank(assetMgr.getWithdrawAccount(validator));\n        vm.expectRevert(IAssetManager.ImproperValidatorStatus.selector);\n        assetMgr.withdraw(validator, minActivateAmount);\n\n        vm.warp(valMgr.jailExpiresAt(validator));\n        vm.prank(assetMgr.getWithdrawAccount(validator));\n        assetMgr.withdraw(validator, minActivateAmount);\n    }\n\n    function test_withdraw_insufficientValidatorKro_reverts() external {\n        _registerValidator(minActivateAmount);\n\n        vm.warp(assetMgr.canWithdrawAt(validator));\n        vm.prank(assetMgr.getWithdrawAccount(validator));\n        vm.expectRevert(IAssetManager.InsufficientAsset.selector);\n        assetMgr.withdraw(validator, minActivateAmount + 1);\n    }\n\n    function test_withdraw_validatorKroBonded_reverts() external {\n        _registerValidator(minActivateAmount);\n\n        vm.prank(address(valMgr));\n        assetMgr.bondValidatorKro(validator);\n\n        address withdrawAccount = assetMgr.getWithdrawAccount(validator);\n        vm.warp(assetMgr.canWithdrawAt(validator));\n        vm.startPrank(withdrawAccount);\n        vm.expectRevert(IAssetManager.InsufficientAsset.selector);\n        assetMgr.withdraw(validator, minActivateAmount);\n\n        uint128 validatorKroBonded = assetMgr.totalValidatorKroBonded(validator);\n        assetMgr.withdraw(validator, minActivateAmount - validatorKroBonded);\n\n        assertEq(assetMgr.totalValidatorKro(validator), validatorKroBonded);\n        assertEq(valMgr.getWeight(validator), 0);\n        assertEq(assetToken.balanceOf(withdrawAccount), minActivateAmount - validatorKroBonded);\n    }\n\n    function test_delegate_succeeds() external {\n        _registerValidator(minActivateAmount);\n\n        uint128 shares = assetMgr.previewDelegate(validator, bondAmount);\n        uint256 beforeBalance = assetToken.balanceOf(delegator);\n        uint120 beforeWeight = valMgr.getWeight(validator);\n\n        _delegate(delegator, bondAmount);\n\n        assertEq(assetToken.balanceOf(delegator), beforeBalance - bondAmount);\n        assertEq(assetMgr.totalKroAssets(validator), bondAmount);\n        assertEq(assetMgr.getKroTotalShareBalance(validator, delegator), shares);\n        assertEq(\n            assetMgr.canUndelegateKroAt(validator, delegator),\n            block.timestamp + minDelegationPeriod\n        );\n        assertEq(valMgr.getWeight(validator), beforeWeight + bondAmount);\n    }\n\n    function test_delegate_validatorStatusNone_reverts() external {\n        vm.expectRevert(IAssetManager.ImproperValidatorStatus.selector);\n        assetMgr.delegate(validator, bondAmount);\n    }\n\n    function test_delegate_validatorStatusExited_reverts() external {\n        test_withdraw_succeeds();\n        assertTrue(valMgr.getStatus(validator) == IValidatorManager.ValidatorStatus.EXITED);\n\n        vm.expectRevert(IAssetManager.ImproperValidatorStatus.selector);\n        assetMgr.delegate(validator, bondAmount);\n    }\n\n    function test_delegate_validatorInJail_reverts() external {\n        _registerValidator(minActivateAmount);\n        mockValMgr.sendToJail(validator);\n        assertTrue(valMgr.inJail(validator));\n\n        vm.expectRevert(IAssetManager.ImproperValidatorStatus.selector);\n        assetMgr.delegate(validator, bondAmount);\n    }\n\n    function test_delegate_zeroAsset_reverts() external {\n        _registerValidator(minActivateAmount);\n\n        vm.expectRevert(IAssetManager.NotAllowedZeroInput.selector);\n        vm.prank(delegator);\n        assetMgr.delegate(validator, 0);\n    }\n\n    function test_delegateKgh_succeeds() external {\n        _registerValidator(minActivateAmount);\n        uint256 beforeBalance = assetToken.balanceOf(delegator);\n\n        uint256 tokenId = 0;\n        _delegateKgh(delegator, tokenId);\n\n        assertEq(assetToken.balanceOf(delegator), beforeBalance);\n        assertEq(assetMgr.getKghReward(validator, delegator), 0);\n        assertEq(kgh.ownerOf(tokenId), address(assetMgr));\n        assertEq(assetMgr.totalKghNum(validator), 1);\n        assertEq(assetMgr.getKghNum(validator, delegator), 1);\n        assertEq(\n            assetMgr.canUndelegateKghAt(validator, delegator, tokenId),\n            block.timestamp + minDelegationPeriod\n        );\n    }\n\n    function test_delegateKgh_claimBoostedReward_succeeds() external {\n        _registerValidator(minActivateAmount);\n        _delegateKgh(delegator, 0);\n\n        uint256 beforeBalance = assetToken.balanceOf(delegator);\n\n        // Increase boosted reward\n        uint128 boostedReward = mockValMgr.calculateBoostedReward(validator);\n        mockAssetMgr.increaseRewardPerKgh(validator, boostedReward);\n        assertEq(assetMgr.getKghReward(validator, delegator), boostedReward);\n\n        // Delegate one more KGH\n        _delegateKgh(delegator, 1);\n\n        assertEq(assetToken.balanceOf(delegator), beforeBalance + boostedReward);\n    }\n\n    function test_delegateKgh_validatorStatusNone_reverts() external {\n        vm.expectRevert(IAssetManager.ImproperValidatorStatus.selector);\n        assetMgr.delegateKgh(validator, 0);\n    }\n\n    function test_delegateKgh_validatorStatusExited_reverts() external {\n        test_withdraw_succeeds();\n        assertTrue(valMgr.getStatus(validator) == IValidatorManager.ValidatorStatus.EXITED);\n\n        vm.expectRevert(IAssetManager.ImproperValidatorStatus.selector);\n        assetMgr.delegateKgh(validator, 0);\n    }\n\n    function test_delegateKgh_validatorInJail_reverts() external {\n        _registerValidator(minActivateAmount);\n        mockValMgr.sendToJail(validator);\n        assertTrue(valMgr.inJail(validator));\n\n        vm.expectRevert(IAssetManager.ImproperValidatorStatus.selector);\n        assetMgr.delegateKgh(validator, 0);\n    }\n\n    function test_delegateKghBatch_succeeds() external {\n        _registerValidator(minActivateAmount);\n        uint256 beforeBalance = assetToken.balanceOf(delegator);\n\n        uint256 kghCount = 10;\n        _delegateKghBatch(kghCount);\n\n        assertEq(assetToken.balanceOf(delegator), beforeBalance);\n        assertEq(assetMgr.getKghReward(validator, delegator), 0);\n        assertEq(assetMgr.totalKghNum(validator), kghCount);\n        assertEq(assetMgr.getKghNum(validator, delegator), kghCount);\n        for (uint256 i = 1; i < kghCount + 1; i++) {\n            assertEq(kgh.ownerOf(i), address(assetMgr));\n            assertEq(\n                assetMgr.canUndelegateKghAt(validator, delegator, i),\n                block.timestamp + minDelegationPeriod\n            );\n        }\n    }\n\n    function test_delegateKghBatch_claimBoostedReward_succeeds() external {\n        _registerValidator(minActivateAmount);\n        _delegateKgh(delegator, 0);\n\n        uint256 beforeBalance = assetToken.balanceOf(delegator);\n\n        // Increase boosted reward\n        uint128 boostedReward = mockValMgr.calculateBoostedReward(validator);\n        mockAssetMgr.increaseRewardPerKgh(validator, boostedReward);\n        assertEq(assetMgr.getKghReward(validator, delegator), boostedReward);\n\n        // Delegate two more KGHs\n        _delegateKghBatch(2);\n\n        assertEq(assetToken.balanceOf(delegator), beforeBalance + boostedReward);\n    }\n\n    function test_delegateKghBatch_validatorStatusNone_reverts() external {\n        uint256[] memory tokenIds = new uint256[](0);\n        vm.expectRevert(IAssetManager.ImproperValidatorStatus.selector);\n        assetMgr.delegateKghBatch(validator, tokenIds);\n    }\n\n    function test_delegateKghBatch_validatorStatusExited_reverts() external {\n        test_withdraw_succeeds();\n        assertTrue(valMgr.getStatus(validator) == IValidatorManager.ValidatorStatus.EXITED);\n\n        uint256[] memory tokenIds = new uint256[](0);\n        vm.expectRevert(IAssetManager.ImproperValidatorStatus.selector);\n        assetMgr.delegateKghBatch(validator, tokenIds);\n    }\n\n    function test_delegateKghBatch_validatorInJail_reverts() external {\n        _registerValidator(minActivateAmount);\n        mockValMgr.sendToJail(validator);\n        assertTrue(valMgr.inJail(validator));\n\n        uint256[] memory tokenIds = new uint256[](0);\n        vm.expectRevert(IAssetManager.ImproperValidatorStatus.selector);\n        assetMgr.delegateKghBatch(validator, tokenIds);\n    }\n\n    function test_delegateKghBatch_zeroTokenIds_reverts() external {\n        _registerValidator(minActivateAmount);\n\n        uint256[] memory tokenIds = new uint256[](0);\n        vm.expectRevert(IAssetManager.NotAllowedZeroInput.selector);\n        assetMgr.delegateKghBatch(validator, tokenIds);\n    }\n\n    function test_undelegate_succeeds() external {\n        _registerValidator(minActivateAmount);\n        _delegate(delegator, bondAmount);\n        mockAssetMgr.increaseBaseReward(validator, baseReward);\n        uint256 beforeBalance = assetToken.balanceOf(delegator);\n\n        uint128 delegatorKro = _undelegate(delegator);\n\n        assertEq(assetMgr.totalKroAssets(validator), bondAmount + baseReward - delegatorKro);\n        assertEq(\n            valMgr.getWeight(validator),\n            minActivateAmount + bondAmount + baseReward - delegatorKro\n        );\n        assertEq(assetToken.balanceOf(delegator), beforeBalance + delegatorKro);\n    }\n\n    function test_undelegate_severalDelegators_succeeds() external {\n        _registerValidator(minActivateAmount);\n        _delegate(delegator, bondAmount);\n        mockAssetMgr.increaseBaseReward(validator, baseReward);\n\n        address delegator2 = makeAddr(\"delegator2\");\n        assetToken.mint(delegator2, bondAmount);\n        _delegate(delegator2, bondAmount);\n        mockAssetMgr.increaseBaseReward(validator, baseReward);\n        uint256 beforeBalance = assetToken.balanceOf(delegator);\n\n        uint128 delegatorKro = _undelegate(delegator);\n\n        assertEq(\n            assetMgr.totalKroAssets(validator),\n            bondAmount * 2 + baseReward * 2 - delegatorKro\n        );\n        assertEq(\n            valMgr.getWeight(validator),\n            minActivateAmount + bondAmount * 2 + baseReward * 2 - delegatorKro\n        );\n        assertEq(assetToken.balanceOf(delegator), beforeBalance + delegatorKro);\n    }\n\n    function test_undelegate_removedFromValidatorTree_succeeds() external {\n        _registerValidator(minActivateAmount - 1);\n        _delegate(delegator, bondAmount);\n\n        vm.prank(validator);\n        valMgr.activateValidator();\n        assertEq(valMgr.getWeight(validator), minActivateAmount - 1 + bondAmount);\n\n        _undelegate(delegator);\n\n        assertEq(valMgr.getWeight(validator), 0);\n    }\n\n    function test_undelegate_zeroAsset_reverts() external {\n        vm.expectRevert(IAssetManager.NotAllowedZeroInput.selector);\n        assetMgr.undelegate(validator, 0);\n    }\n\n    function test_undelegate_largeAsset_reverts() external {\n        vm.expectRevert(IAssetManager.InsufficientShare.selector);\n        assetMgr.undelegate(validator, 1);\n    }\n\n    function test_undelegate_notElapsedMinDelegationPeriod_reverts() external {\n        _registerValidator(minActivateAmount);\n        _delegate(delegator, bondAmount);\n\n        vm.expectRevert(IAssetManager.NotElapsedMinDelegationPeriod.selector);\n        vm.prank(delegator);\n        assetMgr.undelegate(validator, bondAmount);\n    }\n\n    function test_undelegateKgh_succeeds() external {\n        _registerValidator(minActivateAmount);\n        uint256 tokenId = 0;\n        _delegateKgh(delegator, tokenId);\n\n        uint128 boostedReward = mockValMgr.calculateBoostedReward(validator);\n        mockAssetMgr.increaseRewardPerKgh(validator, boostedReward);\n\n        uint256 beforeBalance = assetToken.balanceOf(delegator);\n        boostedReward = assetMgr.getKghReward(validator, delegator);\n\n        _undelegateKgh(delegator, tokenId);\n\n        assertEq(assetMgr.getKghReward(validator, delegator), 0);\n        assertEq(assetMgr.totalKghNum(validator), 0);\n        assertEq(assetMgr.getKghNum(validator, delegator), 0);\n        assertEq(assetMgr.canUndelegateKghAt(validator, delegator, tokenId), minDelegationPeriod);\n        assertEq(kgh.ownerOf(tokenId), delegator);\n        assertEq(assetToken.balanceOf(delegator), beforeBalance + boostedReward);\n    }\n\n    function test_undelegateKgh_noBoostedReward_succeeds() external {\n        _registerValidator(minActivateAmount);\n        uint256 tokenId = 0;\n        _delegateKgh(delegator, tokenId);\n        uint256 beforeBalance = assetToken.balanceOf(delegator);\n\n        _undelegateKgh(delegator, tokenId);\n\n        assertEq(assetToken.balanceOf(delegator), beforeBalance);\n    }\n\n    function test_undelegateKgh_severalDelegators_succeeds() external {\n        _registerValidator(minActivateAmount);\n        _delegateKgh(delegator, 0);\n        uint128 boostedReward = mockValMgr.calculateBoostedReward(validator);\n        mockAssetMgr.increaseRewardPerKgh(validator, boostedReward);\n\n        address delegator2 = makeAddr(\"delegator2\");\n        uint256 tokenId = 1;\n        _delegateKgh(delegator2, tokenId);\n        boostedReward = mockValMgr.calculateBoostedReward(validator);\n        mockAssetMgr.increaseRewardPerKgh(validator, boostedReward);\n\n        uint256 beforeBalance = assetToken.balanceOf(delegator2);\n        boostedReward = assetMgr.getKghReward(validator, delegator2);\n\n        _undelegateKgh(delegator2, tokenId);\n\n        assertEq(assetMgr.getKghReward(validator, delegator2), 0);\n        assertEq(assetMgr.totalKghNum(validator), 1);\n        assertEq(assetMgr.getKghNum(validator, delegator2), 0);\n        assertEq(assetMgr.canUndelegateKghAt(validator, delegator2, tokenId), minDelegationPeriod);\n        assertEq(kgh.ownerOf(tokenId), delegator2);\n        assertEq(assetToken.balanceOf(delegator2), beforeBalance + boostedReward);\n    }\n\n    function test_undelegateKgh_invalidTokenIds_reverts() external {\n        vm.expectRevert(IAssetManager.InvalidTokenIdsInput.selector);\n        assetMgr.undelegateKgh(validator, 0);\n    }\n\n    function test_undelegateKgh_notElapsedMinDelegationPeriod_reverts() external {\n        _registerValidator(minActivateAmount);\n        _delegateKgh(delegator, 0);\n\n        vm.expectRevert(IAssetManager.NotElapsedMinDelegationPeriod.selector);\n        vm.prank(delegator);\n        assetMgr.undelegateKgh(validator, 0);\n    }\n\n    function test_undelegateKghBatch_succeeds() external {\n        _registerValidator(minActivateAmount);\n        uint256 kghCount = 10;\n        _delegateKghBatch(kghCount);\n\n        uint128 boostedReward = mockValMgr.calculateBoostedReward(validator);\n        mockAssetMgr.increaseRewardPerKgh(validator, boostedReward);\n\n        uint256 beforeBalance = assetToken.balanceOf(delegator);\n        boostedReward = assetMgr.getKghReward(validator, delegator);\n\n        _undelegateKghBatch(kghCount);\n\n        assertEq(assetMgr.getKghReward(validator, delegator), 0);\n        assertEq(assetMgr.totalKghNum(validator), 0);\n        assertEq(assetMgr.getKghNum(validator, delegator), 0);\n        assertEq(assetToken.balanceOf(delegator), beforeBalance + boostedReward);\n        for (uint256 i = 1; i < kghCount + 1; i++) {\n            assertEq(kgh.ownerOf(i), delegator);\n            assertEq(assetMgr.canUndelegateKghAt(validator, delegator, i), minDelegationPeriod);\n        }\n    }\n\n    function test_undelegateKghBatch_noBoostedReward_succeeds() external {\n        _registerValidator(minActivateAmount);\n        uint256 kghCount = 10;\n        _delegateKghBatch(kghCount);\n        uint256 beforeBalance = assetToken.balanceOf(delegator);\n\n        _undelegateKghBatch(kghCount);\n\n        assertEq(assetToken.balanceOf(delegator), beforeBalance);\n    }\n\n    function test_undelegateKghBatch_zeroTokenIds_reverts() external {\n        uint256[] memory tokenIds = new uint256[](0);\n        vm.expectRevert(IAssetManager.NotAllowedZeroInput.selector);\n        assetMgr.undelegateKghBatch(validator, tokenIds);\n    }\n\n    function test_undelegateKghBatch_invalidTokenIds_reverts() external {\n        uint256[] memory tokenIds = new uint256[](1);\n        tokenIds[0] = 0;\n        vm.expectRevert(IAssetManager.InvalidTokenIdsInput.selector);\n        assetMgr.undelegateKghBatch(validator, tokenIds);\n    }\n\n    function test_undelegateKghBatch_notElapsedMinDelegationPeriod_reverts() external {\n        _registerValidator(minActivateAmount);\n        _delegateKgh(delegator, 0);\n        vm.warp(assetMgr.canUndelegateKghAt(validator, delegator, 0));\n        _delegateKgh(delegator, 1);\n\n        uint256[] memory tokenIds = new uint256[](2);\n        tokenIds[0] = 0;\n        tokenIds[1] = 1;\n        vm.expectRevert(IAssetManager.NotElapsedMinDelegationPeriod.selector);\n        vm.prank(delegator);\n        assetMgr.undelegateKghBatch(validator, tokenIds);\n    }\n\n    function test_claimKghReward_succeeds() external {\n        _registerValidator(minActivateAmount);\n        _delegateKgh(delegator, 0);\n        uint128 boostedReward = mockValMgr.calculateBoostedReward(validator);\n        mockAssetMgr.increaseRewardPerKgh(validator, boostedReward);\n        uint256 beforeBalance = assetToken.balanceOf(delegator);\n\n        boostedReward = assetMgr.getKghReward(validator, delegator);\n\n        vm.prank(delegator);\n        assetMgr.claimKghReward(validator);\n\n        assertEq(assetToken.balanceOf(delegator), beforeBalance + boostedReward);\n    }\n\n    function test_claimKghReward_zeroBoostedReward_reverts() external {\n        _registerValidator(minActivateAmount);\n        _delegateKgh(delegator, 0);\n\n        vm.prank(delegator);\n        vm.expectRevert(IAssetManager.InsufficientAsset.selector);\n        assetMgr.claimKghReward(validator);\n    }\n\n    function test_bondValidatorKro_succeeds() public {\n        _registerValidator(minActivateAmount);\n\n        vm.prank(address(valMgr));\n        assetMgr.bondValidatorKro(validator);\n\n        assertEq(assetMgr.totalValidatorKro(validator), minActivateAmount);\n        assertEq(assetMgr.totalValidatorKroBonded(validator), bondAmount);\n    }\n\n    function test_bondValidatorKro_callerNotValMgr_reverts() external {\n        vm.expectRevert(IAssetManager.NotAllowedCaller.selector);\n        assetMgr.bondValidatorKro(validator);\n    }\n\n    function test_bondValidatorKro_insufficientAsset_reverts() external {\n        vm.prank(address(valMgr));\n        vm.expectRevert(IAssetManager.InsufficientAsset.selector);\n        assetMgr.bondValidatorKro(validator);\n    }\n\n    function test_unbondValidatorKro_succeeds() external {\n        test_bondValidatorKro_succeeds();\n\n        vm.prank(address(valMgr));\n        assetMgr.unbondValidatorKro(validator);\n\n        assertEq(assetMgr.totalValidatorKro(validator), minActivateAmount);\n        assertEq(assetMgr.totalValidatorKroBonded(validator), 0);\n    }\n\n    function test_unbondValidatorKro_callerNotValMgr_reverts() external {\n        vm.expectRevert(IAssetManager.NotAllowedCaller.selector);\n        assetMgr.unbondValidatorKro(validator);\n    }\n\n    function test_increaseBalanceWithReward_succeeds() external {\n        test_bondValidatorKro_succeeds();\n        _delegateKgh(delegator, 0);\n\n        uint256 beforeBalance = assetToken.balanceOf(address(assetMgr));\n        uint256 beforeVaultBalance = assetToken.balanceOf(validatorRewardVault);\n\n        uint128 boostedReward = 5e18;\n        uint128 validatorReward = 10e18;\n        uint128 totalReward = baseReward + boostedReward + validatorReward;\n\n        vm.prank(address(valMgr));\n        assetMgr.increaseBalanceWithReward(validator, baseReward, boostedReward, validatorReward);\n\n        assertEq(assetToken.balanceOf(address(assetMgr)), beforeBalance + totalReward);\n        assertEq(assetToken.balanceOf(validatorRewardVault), beforeVaultBalance - totalReward);\n        assertEq(assetMgr.totalKroAssets(validator), baseReward);\n        assertEq(assetMgr.totalValidatorKro(validator), minActivateAmount + validatorReward);\n        assertEq(assetMgr.getKghReward(validator, delegator), boostedReward);\n        assertEq(assetMgr.totalValidatorKroBonded(validator), 0);\n    }\n\n    function test_increaseBalanceWithReward_validatorIsSC_succeeds() external {\n        uint256 beforeBalance = assetToken.balanceOf(address(assetMgr));\n        uint256 beforeSCBalance = assetToken.balanceOf(guardian);\n        uint256 beforeVaultBalance = assetToken.balanceOf(validatorRewardVault);\n\n        uint128 boostedReward = 5e18;\n        uint128 validatorReward = 10e18;\n        uint128 totalReward = baseReward + boostedReward + validatorReward;\n\n        vm.prank(address(valMgr));\n        assetMgr.increaseBalanceWithReward(guardian, baseReward, boostedReward, validatorReward);\n\n        assertEq(assetToken.balanceOf(address(assetMgr)), beforeBalance);\n        assertEq(assetToken.balanceOf(guardian), beforeSCBalance + totalReward);\n        assertEq(assetToken.balanceOf(validatorRewardVault), beforeVaultBalance - totalReward);\n    }\n\n    function test_increaseBalanceWithReward_callerNotValMgr_reverts() external {\n        vm.expectRevert(IAssetManager.NotAllowedCaller.selector);\n        assetMgr.increaseBalanceWithReward(validator, 0, 0, 0);\n    }\n\n    function test_increaseBalanceWithChallenge_succeeds() external {\n        assetToken.mint(address(assetMgr), bondAmount);\n\n        uint256 beforeSCBalance = assetToken.balanceOf(guardian);\n        uint128 tax = (bondAmount * assetMgr.TAX_NUMERATOR()) / assetMgr.TAX_DENOMINATOR();\n\n        vm.prank(address(valMgr));\n        uint128 challengeReward = assetMgr.increaseBalanceWithChallenge(validator, bondAmount);\n\n        assertEq(assetToken.balanceOf(guardian), beforeSCBalance + tax);\n        assertEq(assetMgr.totalValidatorKro(validator), bondAmount - tax);\n        assertEq(challengeReward, bondAmount - tax);\n    }\n\n    function test_increaseBalanceWithChallenge_winnerIsSC_succeeds() external {\n        assetToken.mint(address(assetMgr), bondAmount);\n\n        uint256 beforeSCBalance = assetToken.balanceOf(guardian);\n\n        vm.prank(address(valMgr));\n        uint128 challengeReward = assetMgr.increaseBalanceWithChallenge(guardian, bondAmount);\n\n        assertEq(assetToken.balanceOf(guardian), beforeSCBalance + bondAmount);\n        assertEq(challengeReward, bondAmount);\n    }\n\n    function test_increaseBalanceWithChallenge_callerNotValMgr_reverts() external {\n        vm.expectRevert(IAssetManager.NotAllowedCaller.selector);\n        assetMgr.increaseBalanceWithChallenge(validator, 0);\n    }\n\n    function test_decreaseBalanceWithChallenge_succeeds() external {\n        test_bondValidatorKro_succeeds();\n\n        vm.prank(address(valMgr));\n        uint128 challengeReward = assetMgr.decreaseBalanceWithChallenge(validator);\n\n        assertEq(assetMgr.totalValidatorKro(validator), minActivateAmount - bondAmount);\n        assertEq(assetMgr.totalValidatorKroBonded(validator), 0);\n        assertEq(challengeReward, bondAmount);\n    }\n\n    function test_decreaseBalanceWithChallenge_callerNotValMgr_reverts() external {\n        vm.expectRevert(IAssetManager.NotAllowedCaller.selector);\n        assetMgr.decreaseBalanceWithChallenge(validator);\n    }\n\n    function test_revertDecreaseBalanceWithChallenge_succeeds() external {\n        vm.prank(address(valMgr));\n        uint128 challengeReward = assetMgr.revertDecreaseBalanceWithChallenge(validator);\n\n        assertEq(assetMgr.totalValidatorKro(validator), bondAmount);\n        assertEq(assetMgr.totalValidatorKroBonded(validator), bondAmount);\n        assertEq(challengeReward, bondAmount);\n    }\n\n    function test_revertDecreaseBalanceWithChallenge_callerNotValMgr_reverts() external {\n        vm.expectRevert(IAssetManager.NotAllowedCaller.selector);\n        assetMgr.revertDecreaseBalanceWithChallenge(validator);\n    }\n}\n"
    },
    "contracts/test/BalancedWeightTree.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport { BalancedWeightTree } from \"../libraries/BalancedWeightTree.sol\";\n\ncontract BalancedWeightTree_Test is Test {\n    BalancedWeightTree.Tree internal tree;\n\n    function setUp() public {\n        for (uint256 i; i < 100; i++) {\n            address addr = makeAddr(Strings.toString(i));\n            BalancedWeightTree.insert(tree, addr, uint120(rand(i, 1000)));\n        }\n    }\n\n    function rand(uint256 _mixer, uint256 _range) private view returns (uint256) {\n        uint256 seed = uint256(\n            keccak256(abi.encodePacked(block.difficulty, block.timestamp, _mixer))\n        );\n        return seed % _range;\n    }\n\n    function testFuzz_insert_succeeds(address _addr, uint120 _weight) external {\n        vm.assume(_addr != address(0));\n        uint32 index = tree.nodeMap[_addr];\n        vm.assume(index == 0);\n\n        uint32 counter = tree.counter;\n        BalancedWeightTree.insert(tree, _addr, _weight);\n\n        index = tree.nodeMap[_addr];\n        assertEq(tree.counter, counter + 1);\n        assertEq(tree.nodes[index].addr, _addr);\n        assertEq(tree.nodes[index].weight, _weight);\n    }\n\n    function testFuzz_update_succeeds(uint32 _index, uint120 _weight) external {\n        uint32 index = (_index % tree.counter) + 1;\n        address addr = tree.nodes[index].addr;\n\n        bool succeed = BalancedWeightTree.update(tree, addr, _weight);\n\n        uint32 newIndex = tree.nodeMap[addr];\n        assertTrue(succeed);\n        assertEq(tree.nodes[newIndex].weight, _weight);\n    }\n\n    function testFuzz_remove_succeeds(uint32 _index) external {\n        uint32 removed = tree.removed;\n        uint32 index = (_index % tree.counter) + 1;\n        address addr = tree.nodes[index].addr;\n\n        bool succeed = BalancedWeightTree.remove(tree, addr);\n\n        assertTrue(succeed);\n        assertEq(tree.removed, removed + 1);\n        assertEq(tree.nodeMap[addr], 0);\n        assertTrue(tree.nodes[index].addr != addr);\n    }\n\n    function testFuzz_select_succeeds(uint120 _weight) external {\n        address selected = BalancedWeightTree.select(\n            tree,\n            _weight % tree.nodes[tree.root].weightSum\n        );\n\n        assertTrue(selected != address(0));\n    }\n}\n"
    },
    "contracts/test/BenchmarkTest.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/* Testing utilities */\nimport { Test } from \"forge-std/Test.sol\";\nimport { Vm } from \"forge-std/Vm.sol\";\n\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport \"./CommonTest.t.sol\";\n\n// Free function for setting the prevBaseFee param in the KromaPortal.\nfunction setPrevBaseFee(Vm _vm, address _portal, uint128 _prevBaseFee) {\n    _vm.store(address(_portal), bytes32(uint256(1)), bytes32((block.number << 192) | _prevBaseFee));\n}\n\ncontract SetPrevBaseFee_Test is Portal_Initializer {\n    function test_setPrevBaseFee_succeeds() external {\n        setPrevBaseFee(vm, address(portal), 100 gwei);\n        (uint128 prevBaseFee, , uint64 prevBlockNum) = portal.params();\n        assertEq(uint256(prevBaseFee), 100 gwei);\n        assertEq(uint256(prevBlockNum), block.number);\n    }\n}\n\n// Tests for obtaining pure gas cost estimates for commonly used functions.\n// The objective with these benchmarks is to strip down the actual test functions\n// so that they are nothing more than the call we want measure the gas cost of.\n// In order to achieve this we make no assertions, and handle everything else in the setUp()\n// function.\ncontract GasBenchMark_KromaPortal is Portal_Initializer {\n    // Reusable default values for a test withdrawal\n    Types.WithdrawalTransaction _defaultTx;\n\n    uint256 _submittedOutputIndex;\n    uint256 _submittedBlockNumber;\n    bytes[] _withdrawalProof;\n    Types.OutputRootProof internal _outputRootProof;\n    bytes32 _outputRoot;\n\n    // Use a constructor to set the storage vars above, so as to minimize the number of ffi calls.\n    constructor() {\n        super.setUp();\n        _defaultTx = Types.WithdrawalTransaction({\n            nonce: 0,\n            sender: alice,\n            target: bob,\n            value: 100,\n            gasLimit: 100_000,\n            data: hex\"\"\n        });\n\n        // Get withdrawal proof data we can use for testing.\n        bytes32 _storageRoot;\n        bytes32 _stateRoot;\n        (_stateRoot, _storageRoot, _outputRoot, , _withdrawalProof) = ffi\n            .getProveWithdrawalTransactionInputs(_defaultTx);\n\n        // Setup a dummy output root proof for reuse.\n        _outputRootProof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: _stateRoot,\n            messagePasserStorageRoot: _storageRoot,\n            blockHash: bytes32(uint256(0)),\n            nextBlockHash: bytes32(uint256(0))\n        });\n        _submittedBlockNumber = oracle.nextBlockNumber();\n        _submittedOutputIndex = oracle.nextOutputIndex();\n    }\n\n    // Get the system into a nice ready-to-use state.\n    function setUp() public override {\n        // Configure the oracle to return the output root we've prepared.\n        vm.warp(oracle.nextOutputMinL2Timestamp());\n        vm.prank(trusted);\n        oracle.submitL2Output(_outputRoot, _submittedBlockNumber, 0, 0);\n\n        // Warp beyond the finalization period for the block we've submitted.\n        vm.warp(\n            oracle.getL2Output(_submittedOutputIndex).timestamp +\n                oracle.FINALIZATION_PERIOD_SECONDS() +\n                1\n        );\n\n        // Fund the portal so that we can withdraw ETH.\n        vm.deal(address(portal), 0xFFFFFFFF);\n    }\n\n    function test_depositTransaction_benchmark() external {\n        portal.depositTransaction{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    function test_depositTransaction_benchmark_1() external {\n        setPrevBaseFee(vm, address(portal), 1 gwei);\n        portal.depositTransaction{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    function test_proveWithdrawalTransaction_benchmark() external {\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n}\n\ncontract GasBenchMark_L1CrossDomainMessenger is Messenger_Initializer {\n    function test_sendMessage_benchmark_0() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(portal), 1 gwei);\n        // The amount of data typically sent during a bridge deposit.\n        bytes\n            memory data = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n        vm.resumeGasMetering();\n        L1Messenger.sendMessage(bob, data, uint32(100));\n    }\n\n    function test_sendMessage_benchmark_1() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(portal), 10 gwei);\n        // The amount of data typically sent during a bridge deposit.\n        bytes\n            memory data = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n        vm.resumeGasMetering();\n        L1Messenger.sendMessage(bob, data, uint32(100));\n    }\n}\n\ncontract GasBenchMark_L1StandardBridge_Deposit is Bridge_Initializer {\n    function setUp() public virtual override {\n        super.setUp();\n        deal(address(L1Token), alice, 100000, true);\n        vm.startPrank(alice, alice);\n        L1Token.approve(address(L1Bridge), type(uint256).max);\n    }\n\n    function test_depositETH_benchmark_0() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(portal), 1 gwei);\n        vm.resumeGasMetering();\n        L1Bridge.bridgeETH{ value: 500 }(50000, hex\"\");\n    }\n\n    function test_depositETH_benchmark_1() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(portal), 10 gwei);\n        vm.resumeGasMetering();\n        L1Bridge.bridgeETH{ value: 500 }(50000, hex\"\");\n    }\n\n    function test_depositERC20_benchmark_0() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(portal), 1 gwei);\n        vm.resumeGasMetering();\n        L1Bridge.bridgeERC20({\n            _localToken: address(L1Token),\n            _remoteToken: address(L2Token),\n            _amount: 100,\n            _minGasLimit: 100_000,\n            _extraData: hex\"\"\n        });\n    }\n\n    function test_depositERC20_benchmark_1() external {\n        vm.pauseGasMetering();\n        setPrevBaseFee(vm, address(portal), 10 gwei);\n        vm.resumeGasMetering();\n        L1Bridge.bridgeERC20({\n            _localToken: address(L1Token),\n            _remoteToken: address(L2Token),\n            _amount: 100,\n            _minGasLimit: 100_000,\n            _extraData: hex\"\"\n        });\n    }\n}\n\ncontract GasBenchMark_L1StandardBridge_Finalize is Bridge_Initializer {\n    function setUp() public virtual override {\n        super.setUp();\n        deal(address(L1Token), address(L1Bridge), 100, true);\n        vm.mockCall(\n            address(L1Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.startPrank(address(L1Bridge.MESSENGER()));\n        vm.deal(address(L1Bridge.MESSENGER()), 100);\n    }\n\n    function test_finalizeBridgeETH_benchmark() external {\n        // TODO: Make this more accurate. It is underestimating the cost because it pranks\n        // the call coming from the messenger, which bypasses the portal\n        // and oracle.\n        L1Bridge.finalizeBridgeETH{ value: 100 }(alice, alice, 100, hex\"\");\n    }\n}\n\ncontract GasBenchMark_L2OutputOracle is L2OutputOracle_Initializer {\n    uint256 nextBlockNumber;\n\n    function setUp() public override {\n        super.setUp();\n\n        vm.deal(trusted, requiredBondAmount);\n        vm.prank(trusted);\n        pool.deposit{ value: requiredBondAmount }();\n\n        nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime();\n        vm.startPrank(trusted);\n    }\n\n    function test_submitL2Output_benchmark() external {\n        oracle.submitL2Output(nonZeroHash, nextBlockNumber, 0, 0);\n    }\n}\n"
    },
    "contracts/test/Bytes.t.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\n\nimport { Bytes } from \"../libraries/Bytes.sol\";\n\ncontract Bytes_equal_Test is Test {\n    /**\n     * @notice Manually checks equality of two dynamic `bytes` arrays in memory.\n     *\n     * @param _a The first `bytes` array to compare.\n     * @param _b The second `bytes` array to compare.\n     *\n     * @return True if the two `bytes` arrays are equal in memory.\n     */\n    function manualEq(bytes memory _a, bytes memory _b) internal pure returns (bool) {\n        bool _eq;\n        assembly {\n            _eq := and(\n                // Check if the contents of the two bytes arrays are equal in memory.\n                eq(keccak256(add(0x20, _a), mload(_a)), keccak256(add(0x20, _b), mload(_b))),\n                // Check if the length of the two bytes arrays are equal in memory.\n                // This is redundant given the above check, but included for completeness.\n                eq(mload(_a), mload(_b))\n            )\n        }\n        return _eq;\n    }\n\n    /**\n     * @notice Tests that the `equal` function in the `Bytes` library returns `false` if given two\n     *         non-equal byte arrays.\n     */\n    function testFuzz_equal_notEqual_works(bytes memory _a, bytes memory _b) public {\n        vm.assume(!manualEq(_a, _b));\n        assertFalse(Bytes.equal(_a, _b));\n    }\n\n    /**\n     * @notice Test whether or not the `equal` function in the `Bytes` library is equivalent to\n     *         manually checking equality of the two dynamic `bytes` arrays in memory.\n     */\n    function testDiff_equal_works(bytes memory _a, bytes memory _b) public {\n        assertEq(Bytes.equal(_a, _b), manualEq(_a, _b));\n    }\n}\n"
    },
    "contracts/test/Colosseum.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Types } from \"../libraries/Types.sol\";\nimport { IValidatorManager } from \"../L1/interfaces/IValidatorManager.sol\";\nimport { Colosseum } from \"../L1/Colosseum.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { ValidatorPool } from \"../L1/ValidatorPool.sol\";\nimport { ZKVerifier } from \"../L1/ZKVerifier.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { ColosseumTestData } from \"./testdata/ColosseumTestData.sol\";\nimport { Colosseum_Initializer } from \"./CommonTest.t.sol\";\nimport { MockL2OutputOracle } from \"./ValidatorManager.t.sol\";\n\ncontract MockColosseum is Colosseum {\n    constructor(\n        L2OutputOracle _l2Oracle,\n        ZKVerifier _zkVerifier,\n        uint256 _submissionInterval,\n        uint256 _creationPeriodSeconds,\n        uint256 _bisectionTimeout,\n        uint256 _provingTimeout,\n        bytes32 _dummyHash,\n        uint256 _maxTxs,\n        uint256[] memory _segmentsLengths,\n        address _securityCouncil,\n        address _zkMerkleTrie\n    )\n        Colosseum(\n            _l2Oracle,\n            _zkVerifier,\n            _submissionInterval,\n            _creationPeriodSeconds,\n            _bisectionTimeout,\n            _provingTimeout,\n            _dummyHash,\n            _maxTxs,\n            _segmentsLengths,\n            _securityCouncil,\n            _zkMerkleTrie\n        )\n    {}\n\n    function getChallenge(\n        uint256 _outputIndex,\n        address _challenger\n    ) external view returns (Types.Challenge memory) {\n        return challenges[_outputIndex][_challenger];\n    }\n\n    function isAbleToBisect(\n        uint256 _outputIndex,\n        address _challenger\n    ) external view returns (bool) {\n        return _isAbleToBisect(challenges[_outputIndex][_challenger]);\n    }\n\n    function hashPublicInput(\n        Types.PublicInputProof calldata _proof\n    ) external view returns (bytes32) {\n        return _hashPublicInput(_proof.srcOutputRootProof.stateRoot, _proof.publicInput);\n    }\n}\n\n// Test the implementations of the Colosseum\ncontract ColosseumTest is Colosseum_Initializer {\n    MockColosseum mockColosseum;\n    uint256 internal targetOutputIndex;\n    mapping(address => bool) internal isChallenger;\n\n    event ReadyToProve(uint256 indexed outputIndex, address indexed challenger);\n\n    function nextSender(Types.Challenge memory _challenge) internal pure returns (address) {\n        return _challenge.turn % 2 == 0 ? _challenge.challenger : _challenge.asserter;\n    }\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        MockColosseum mockColosseumImpl = new MockColosseum(\n            oracle,\n            zkVerifier,\n            submissionInterval,\n            creationPeriodSeconds,\n            bisectionTimeout,\n            provingTimeout,\n            DUMMY_HASH,\n            MAX_TXS,\n            segmentsLengths,\n            address(securityCouncil),\n            address(zkMerkleTrie)\n        );\n        vm.prank(multisig);\n        Proxy(payable(address(colosseum))).upgradeTo(address(mockColosseumImpl));\n        mockColosseum = MockColosseum(address(colosseum));\n\n        vm.prank(trusted);\n        pool.deposit{ value: trusted.balance }();\n        vm.prank(asserter);\n        pool.deposit{ value: asserter.balance }();\n\n        // Submit genesis output\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        // Roll to after the block number we'll submit\n        warpToSubmitTime();\n        vm.prank(pool.nextValidator());\n        oracle.submitL2Output(bytes32(nextBlockNumber), nextBlockNumber, 0, 0);\n\n        // Submit invalid output\n        nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime();\n        vm.prank(pool.nextValidator());\n        oracle.submitL2Output(keccak256(abi.encode()), nextBlockNumber, 0, 0);\n\n        vm.prank(challenger);\n        pool.deposit{ value: challenger.balance }();\n        isChallenger[challenger] = true;\n\n        targetOutputIndex = oracle.latestOutputIndex();\n    }\n\n    function _getOutputRoot(address _sender, uint256 _blockNumber) private view returns (bytes32) {\n        uint256 targetBlockNumber = ColosseumTestData.INVALID_BLOCK_NUMBER;\n        if (_blockNumber == targetBlockNumber - 1) {\n            return ColosseumTestData.PREV_OUTPUT_ROOT;\n        }\n\n        if (isChallenger[_sender]) {\n            if (_blockNumber == targetBlockNumber) {\n                return ColosseumTestData.TARGET_OUTPUT_ROOT;\n            }\n        } else if (_blockNumber >= targetBlockNumber) {\n            return keccak256(abi.encode(_blockNumber));\n        }\n\n        return bytes32(_blockNumber);\n    }\n\n    function _newSegments(\n        address _sender,\n        uint8 _turn,\n        uint256 _segStart,\n        uint256 _segSize\n    ) private view returns (bytes32[] memory) {\n        uint256 segLen = colosseum.segmentsLengths(_turn - 1);\n\n        bytes32[] memory arr = new bytes32[](segLen);\n\n        for (uint256 i = 0; i < segLen; i++) {\n            uint256 n = _segStart + i * (_segSize / (segLen - 1));\n            arr[i] = _getOutputRoot(_sender, n);\n        }\n\n        return arr;\n    }\n\n    function _detectFault(\n        Types.Challenge memory _challenge,\n        address _sender\n    ) private view returns (uint256) {\n        if (_sender == _challenge.challenger && _sender != nextSender(_challenge)) {\n            return 0;\n        }\n\n        uint256 segLen = colosseum.segmentsLengths(_challenge.turn - 1);\n        uint256 start = _challenge.segStart;\n        uint256 degree = _challenge.segSize / (segLen - 1);\n        uint256 current = start + degree;\n\n        for (uint256 i = 1; i < segLen; i++) {\n            bytes32 output = _getOutputRoot(_sender, current);\n\n            if (_challenge.segments[i] != output) {\n                return i - 1;\n            }\n\n            current += degree;\n        }\n\n        revert(\"failed to select\");\n    }\n\n    function _newChallenger(string memory name) private returns (address) {\n        address newAddr = makeAddr(name);\n\n        vm.deal(newAddr, 10 ether);\n        vm.prank(newAddr);\n        pool.deposit{ value: newAddr.balance }();\n        isChallenger[newAddr] = true;\n\n        return newAddr;\n    }\n\n    function _createChallenge(uint256 _outputIndex, address _challenger) private {\n        Types.CheckpointOutput memory targetOutput = oracle.getL2Output(_outputIndex);\n        uint256 end = targetOutput.l2BlockNumber;\n        uint256 start = end - oracle.SUBMISSION_INTERVAL();\n\n        assertTrue(\n            _getOutputRoot(targetOutput.submitter, end) != targetOutput.outputRoot,\n            \"not an invalid output\"\n        );\n\n        bytes32[] memory segments = _newSegments(_challenger, 1, start, end - start);\n\n        vm.prank(_challenger);\n        colosseum.createChallenge(_outputIndex, bytes32(0), 0, segments);\n\n        Types.Challenge memory challenge = mockColosseum.getChallenge(_outputIndex, _challenger);\n\n        assertEq(challenge.asserter, targetOutput.submitter);\n        assertEq(challenge.challenger, _challenger);\n        assertEq(challenge.timeoutAt, block.timestamp + colosseum.BISECTION_TIMEOUT());\n        assertEq(challenge.segments.length, colosseum.segmentsLengths(0));\n        assertEq(challenge.segStart, start);\n        assertEq(challenge.segSize, end - start);\n        assertEq(challenge.turn, 1);\n    }\n\n    function _bisect(uint256 _outputIndex, address _challenger, address _sender) private {\n        Types.Challenge memory challenge = mockColosseum.getChallenge(_outputIndex, _challenger);\n\n        uint256 position = _detectFault(challenge, _sender);\n        uint256 segSize = challenge.segSize / (colosseum.segmentsLengths(challenge.turn - 1) - 1);\n        uint256 segStart = challenge.segStart + position * segSize;\n\n        bytes32[] memory segments = _newSegments(_sender, challenge.turn + 1, segStart, segSize);\n\n        vm.prank(_sender);\n        // check that ReadyToProve event was emitted on the last bisection.\n        if (challenge.turn + 1 == segmentsLengths.length) {\n            vm.expectEmit(true, true, false, false);\n            emit ReadyToProve(_outputIndex, _challenger);\n        }\n        colosseum.bisect(_outputIndex, challenge.challenger, position, segments);\n\n        Types.Challenge memory newChallenge = mockColosseum.getChallenge(_outputIndex, _challenger);\n        assertEq(newChallenge.turn, challenge.turn + 1);\n        assertEq(newChallenge.segments.length, segments.length);\n        assertEq(newChallenge.segStart, segStart);\n        assertEq(newChallenge.segSize, segSize);\n    }\n\n    function _proveFault(\n        uint256 _outputIndex,\n        address _challenger\n    ) private returns (bytes32 publicInputHash) {\n        // get previous snapshot\n        Types.CheckpointOutput memory prevOutput = oracle.getL2Output(_outputIndex);\n\n        Types.Challenge memory challenge = mockColosseum.getChallenge(_outputIndex, _challenger);\n\n        uint256 position = _detectFault(challenge, challenge.challenger);\n        publicInputHash = _doProveFault(challenge.challenger, _outputIndex, position);\n\n        assertEq(\n            uint256(colosseum.getStatus(_outputIndex, challenge.challenger)),\n            uint256(Colosseum.ChallengeStatus.NONE)\n        );\n\n        Types.CheckpointOutput memory newOutput = oracle.getL2Output(_outputIndex);\n\n        assertEq(newOutput.submitter, _challenger);\n        assertEq(newOutput.outputRoot, bytes32(0));\n        assertEq(prevOutput.timestamp, newOutput.timestamp);\n        assertEq(prevOutput.l2BlockNumber, newOutput.l2BlockNumber);\n    }\n\n    function _doProveFault(\n        address _challenger,\n        uint256 _outputIndex,\n        uint256 _position\n    ) private returns (bytes32) {\n        (\n            Types.OutputRootProof memory srcOutputRootProof,\n            Types.OutputRootProof memory dstOutputRootProof\n        ) = ColosseumTestData.outputRootProof();\n        Types.PublicInput memory publicInput = ColosseumTestData.publicInput();\n        Types.BlockHeaderRLP memory rlps = ColosseumTestData.blockHeaderRLP();\n\n        ColosseumTestData.ProofPair memory pp = ColosseumTestData.proofAndPair();\n\n        (ColosseumTestData.Account memory account, bytes[] memory merkleProof) = ColosseumTestData\n            .merkleProof();\n\n        Types.PublicInputProof memory proof = Types.PublicInputProof({\n            srcOutputRootProof: srcOutputRootProof,\n            dstOutputRootProof: dstOutputRootProof,\n            publicInput: publicInput,\n            rlps: rlps,\n            l2ToL1MessagePasserBalance: bytes32(account.balance),\n            l2ToL1MessagePasserCodeHash: account.codeHash,\n            merkleProof: merkleProof\n        });\n\n        vm.prank(_challenger);\n        colosseum.proveFault(_outputIndex, _position, proof, pp.proof, pp.pair);\n\n        return mockColosseum.hashPublicInput(proof);\n    }\n\n    function _dismissChallenge(uint256 txId) private {\n        // confirm transaction without check condition\n        vm.prank(guardian1);\n        securityCouncil.confirmTransaction(txId);\n\n        vm.prank(guardian2);\n        securityCouncil.confirmTransaction(txId);\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(address(colosseum.L2_ORACLE()), address(oracle), \"oracle address not matched\");\n        assertEq(\n            address(colosseum.ZK_VERIFIER()),\n            address(zkVerifier),\n            \"zk verifier address not matched\"\n        );\n        assertEq(colosseum.CREATION_PERIOD_SECONDS(), creationPeriodSeconds);\n        assertEq(colosseum.BISECTION_TIMEOUT(), bisectionTimeout);\n        assertEq(colosseum.PROVING_TIMEOUT(), provingTimeout);\n        assertEq(colosseum.L2_ORACLE_SUBMISSION_INTERVAL(), submissionInterval);\n        assertEq(colosseum.DUMMY_HASH(), DUMMY_HASH);\n        assertEq(colosseum.MAX_TXS(), MAX_TXS);\n        assertEq(colosseum.SECURITY_COUNCIL(), address(securityCouncil));\n        assertEq(colosseum.ZK_MERKLE_TRIE(), address(zkMerkleTrie));\n    }\n\n    function test_initialize_succeeds() external {\n        assertEq(colosseum.segmentsLengths(0), segmentsLengths[0]);\n        assertEq(colosseum.segmentsLengths(1), segmentsLengths[1]);\n        assertEq(colosseum.segmentsLengths(2), segmentsLengths[2]);\n        assertEq(colosseum.segmentsLengths(3), segmentsLengths[3]);\n    }\n\n    function test_createChallenge_succeeds() external {\n        _createChallenge(targetOutputIndex, challenger);\n    }\n\n    function test_createChallenge_otherChallenger_succeeds() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n\n        address otherChallenger = makeAddr(\"other challenger\");\n\n        vm.deal(otherChallenger, 1 ether);\n        vm.prank(otherChallenger);\n        pool.deposit{ value: requiredBondAmount }();\n\n        _createChallenge(outputIndex, otherChallenger);\n\n        // ensure that both challenges are enabled.\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenger)),\n            uint256(Colosseum.ChallengeStatus.ASSERTER_TURN)\n        );\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, otherChallenger)),\n            uint256(Colosseum.ChallengeStatus.ASSERTER_TURN)\n        );\n    }\n\n    function test_createChallenge_genesisOutput_reverts() external {\n        uint256 segLen = colosseum.segmentsLengths(0);\n\n        vm.prank(challenger);\n        vm.expectRevert(Colosseum.NotAllowedGenesisOutput.selector);\n        colosseum.createChallenge(0, bytes32(0), 0, new bytes32[](segLen));\n    }\n\n    function test_createChallenge_asAsserter_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        Types.CheckpointOutput memory targetOutput = oracle.getL2Output(outputIndex);\n        uint256 segLen = colosseum.segmentsLengths(0);\n\n        vm.prank(targetOutput.submitter);\n        vm.expectRevert(Colosseum.NotAllowedCaller.selector);\n        colosseum.createChallenge(outputIndex, bytes32(0), 0, new bytes32[](segLen));\n    }\n\n    function test_createChallenge_existedChallenge_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenger)),\n            uint256(Colosseum.ChallengeStatus.ASSERTER_TURN)\n        );\n\n        uint256 segLen = colosseum.segmentsLengths(0);\n        vm.prank(challenger);\n        vm.expectRevert(Colosseum.ImproperChallengeStatus.selector);\n        colosseum.createChallenge(outputIndex, bytes32(0), 0, new bytes32[](segLen));\n    }\n\n    function test_createChallenge_withBadSegments_reverts() external {\n        uint256 latestBlockNumber = oracle.latestBlockNumber();\n        uint256 outputIndex = oracle.getL2OutputIndexAfter(latestBlockNumber);\n        uint256 segLen = colosseum.segmentsLengths(0);\n\n        vm.startPrank(challenger);\n\n        // invalid segments length\n        vm.expectRevert(Colosseum.InvalidSegmentsLength.selector);\n        colosseum.createChallenge(outputIndex, bytes32(0), 0, new bytes32[](segLen + 1));\n\n        bytes32[] memory segments = new bytes32[](segLen);\n\n        // invalid output root of the first segment\n        for (uint256 i = 0; i < segments.length; i++) {\n            segments[i] = keccak256(abi.encodePacked(\"wrong hash\", i));\n        }\n        segments[segLen - 1] = oracle.getL2Output(outputIndex).outputRoot;\n        vm.expectRevert(Colosseum.FirstSegmentMismatched.selector);\n        colosseum.createChallenge(outputIndex, bytes32(0), 0, segments);\n\n        // invalid output root of the last segment\n        for (uint256 i = 0; i < segments.length; i++) {\n            segments[i] = keccak256(abi.encodePacked(\"wrong hash\", i));\n        }\n        segments[0] = oracle.getL2Output(outputIndex - 1).outputRoot;\n        segments[segLen - 1] = oracle.getL2Output(outputIndex).outputRoot;\n        vm.expectRevert(Colosseum.LastSegmentMatched.selector);\n        colosseum.createChallenge(outputIndex, bytes32(0), 0, segments);\n\n        vm.stopPrank();\n    }\n\n    function test_createChallenge_notSubmittedOutput_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        uint256 segLen = colosseum.segmentsLengths(0);\n\n        vm.prank(challenger);\n        vm.expectRevert();\n        colosseum.createChallenge(outputIndex + 1, bytes32(0), 0, new bytes32[](segLen));\n    }\n\n    function test_createChallenge_afterChallengeProven_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        test_proveFault_succeeds();\n\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenger)),\n            uint256(Colosseum.ChallengeStatus.NONE)\n        );\n\n        uint256 segLen = colosseum.segmentsLengths(0);\n\n        vm.prank(challenger);\n        vm.expectRevert(Colosseum.OutputAlreadyDeleted.selector);\n        colosseum.createChallenge(outputIndex, bytes32(0), 0, new bytes32[](segLen));\n    }\n\n    function test_createChallenge_afterChallengerTimedOut_succeeds() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n\n        Types.Challenge memory challenge = mockColosseum.getChallenge(outputIndex, challenger);\n\n        _bisect(outputIndex, challenge.challenger, challenge.asserter);\n        challenge = mockColosseum.getChallenge(outputIndex, challenge.challenger);\n        vm.warp(challenge.timeoutAt + 1);\n\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenge.challenger)),\n            uint256(Colosseum.ChallengeStatus.CHALLENGER_TIMEOUT)\n        );\n\n        // the asserter calls the challengerTimeout() to close the timed out challenge.\n        vm.prank(challenge.asserter);\n        colosseum.challengerTimeout(outputIndex, challenge.challenger);\n\n        _createChallenge(outputIndex, challenge.challenger);\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenge.challenger)),\n            uint256(Colosseum.ChallengeStatus.ASSERTER_TURN)\n        );\n    }\n\n    function test_createChallenge_afterDismissed_succeeds() external {\n        uint256 outputIndex = targetOutputIndex;\n\n        test_dismissChallenge_succeeds();\n\n        _createChallenge(outputIndex, challenger);\n    }\n\n    function test_createChallenge_afterCreationPeriod_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n\n        Types.CheckpointOutput memory output = oracle.getL2Output(outputIndex);\n        // warp to creation deadline\n        vm.warp(output.timestamp + colosseum.CREATION_PERIOD_SECONDS() + 1);\n\n        bytes32[] memory segments = new bytes32[](0);\n        vm.prank(challenger);\n        vm.expectRevert(Colosseum.CreationPeriodPassed.selector);\n        colosseum.createChallenge(outputIndex, bytes32(0), 0, segments);\n    }\n\n    function test_createChallenge_wrongFork_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        uint256 segLen = colosseum.segmentsLengths(0);\n\n        vm.prank(challenger);\n        vm.expectRevert(Colosseum.L1Reorged.selector);\n        colosseum.createChallenge(\n            outputIndex,\n            bytes32(uint256(0x01)),\n            block.number - 1,\n            new bytes32[](segLen)\n        );\n    }\n\n    function test_bisect_succeeds() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n        Types.Challenge memory challenge = mockColosseum.getChallenge(outputIndex, challenger);\n\n        assertEq(nextSender(challenge), challenge.asserter);\n\n        _bisect(outputIndex, challenge.challenger, challenge.asserter);\n    }\n\n    function test_bisect_finalizedOutput_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n        Types.Challenge memory challenge = mockColosseum.getChallenge(outputIndex, challenger);\n\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenger)),\n            uint256(Colosseum.ChallengeStatus.ASSERTER_TURN)\n        );\n\n        Types.CheckpointOutput memory targetOutput = oracle.getL2Output(outputIndex);\n        vm.warp(targetOutput.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        uint256 segLen = colosseum.segmentsLengths(challenge.turn);\n\n        vm.prank(challenge.asserter);\n        vm.expectRevert(Colosseum.OutputAlreadyFinalized.selector);\n        colosseum.bisect(outputIndex, challenge.challenger, 0, new bytes32[](segLen));\n    }\n\n    function test_bisect_withBadSegments_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n        Types.Challenge memory challenge = mockColosseum.getChallenge(outputIndex, challenger);\n\n        assertEq(nextSender(challenge), challenge.asserter);\n\n        uint256 position = _detectFault(challenge, challenge.asserter);\n        uint256 segSize = challenge.segSize / (colosseum.segmentsLengths(challenge.turn - 1) - 1);\n        uint256 segStart = challenge.segStart + position * segSize;\n\n        bytes32[] memory segments = _newSegments(\n            challenge.asserter,\n            challenge.turn + 1,\n            segStart,\n            segSize\n        );\n\n        vm.startPrank(challenge.asserter);\n\n        // invalid output of the first segment\n        bytes32 firstSegment = segments[0];\n        segments[0] = keccak256(abi.encodePacked(\"wrong hash\", uint256(0)));\n        vm.expectRevert(Colosseum.FirstSegmentMismatched.selector);\n        colosseum.bisect(outputIndex, challenge.challenger, position, segments);\n\n        // invalid output of the last segment\n        segments[0] = firstSegment;\n        segments[segments.length - 1] = challenge.segments[position + 1];\n        vm.expectRevert(Colosseum.LastSegmentMatched.selector);\n        colosseum.bisect(outputIndex, challenge.challenger, position, segments);\n\n        vm.stopPrank();\n    }\n\n    function test_bisect_ifNotYourTurn_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n        Types.Challenge memory challenge = mockColosseum.getChallenge(outputIndex, challenger);\n\n        assertEq(nextSender(challenge), challenge.asserter);\n\n        uint256 segLen = colosseum.segmentsLengths(challenge.turn);\n\n        vm.prank(challenge.challenger);\n        vm.expectRevert(Colosseum.NotAllowedCaller.selector);\n        colosseum.bisect(outputIndex, challenge.challenger, 0, new bytes32[](segLen));\n    }\n\n    function test_bisect_whenAsserterTimedOut_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n        Types.Challenge memory challenge = mockColosseum.getChallenge(outputIndex, challenger);\n\n        assertEq(nextSender(challenge), challenge.asserter);\n\n        uint256 segLen = colosseum.segmentsLengths(challenge.turn);\n\n        vm.warp(challenge.timeoutAt + 1);\n        vm.prank(challenge.asserter);\n        vm.expectRevert(Colosseum.NotAllowedCaller.selector);\n        colosseum.bisect(outputIndex, challenge.challenger, 0, new bytes32[](segLen));\n\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenge.challenger)),\n            uint256(Colosseum.ChallengeStatus.ASSERTER_TIMEOUT)\n        );\n    }\n\n    function test_bisect_whenChallengerTimedOut_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n        Types.Challenge memory challenge = mockColosseum.getChallenge(outputIndex, challenger);\n\n        assertEq(nextSender(challenge), challenge.asserter);\n\n        _bisect(outputIndex, challenge.challenger, challenge.asserter);\n\n        // update challenge\n        challenge = mockColosseum.getChallenge(outputIndex, challenge.challenger);\n\n        uint256 segLen = colosseum.segmentsLengths(challenge.turn);\n\n        vm.warp(challenge.timeoutAt + 1);\n        vm.prank(challenge.challenger);\n        vm.expectRevert(Colosseum.NotAllowedCaller.selector);\n        colosseum.bisect(outputIndex, challenge.challenger, 0, new bytes32[](segLen));\n\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenger)),\n            uint256(Colosseum.ChallengeStatus.CHALLENGER_TIMEOUT)\n        );\n    }\n\n    function test_bisect_cancelChallenge_succeeds() external {\n        uint256 outputIndex = targetOutputIndex;\n        address otherChallenger = _newChallenger(\"other challenger\");\n\n        _createChallenge(outputIndex, otherChallenger);\n        Types.Challenge memory challenge = mockColosseum.getChallenge(outputIndex, otherChallenger);\n        // Make it the challenger turn\n        _bisect(outputIndex, otherChallenger, challenge.asserter);\n\n        // The output root of the target output index was replaced by another challenge.\n        test_proveFault_succeeds();\n\n        uint256 prevDeposit = pool.balanceOf(otherChallenger);\n        uint256 pendingBond = pool.getPendingBond(outputIndex, otherChallenger);\n\n        vm.prank(otherChallenger);\n        colosseum.bisect(outputIndex, otherChallenger, 0, new bytes32[](0));\n\n        // Ensure that the challenge has been deleted.\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, otherChallenger)),\n            uint256(Colosseum.ChallengeStatus.NONE)\n        );\n        // Ensure that the pending bond has been refunded.\n        vm.expectRevert(\"ValidatorPool: the pending bond does not exist\");\n        pool.getPendingBond(outputIndex, otherChallenger);\n        assertEq(pool.balanceOf(otherChallenger), prevDeposit + pendingBond);\n    }\n\n    function test_bisect_cancelChallenge_senderNotChallenger_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        address otherChallenger = _newChallenger(\"other challenger\");\n\n        _createChallenge(outputIndex, otherChallenger);\n        Types.Challenge memory challenge = mockColosseum.getChallenge(outputIndex, otherChallenger);\n        // Make it the challenger turn\n        _bisect(outputIndex, otherChallenger, challenge.asserter);\n\n        // The output root of the target output index was replaced by another challenge.\n        test_proveFault_succeeds();\n\n        vm.prank(challenger);\n        vm.expectRevert(Colosseum.OnlyChallengerCanCancel.selector);\n        colosseum.bisect(outputIndex, otherChallenger, 0, new bytes32[](0));\n    }\n\n    function test_proveFault_succeeds() public returns (bytes32 publicInputHash) {\n        uint256 outputIndex = targetOutputIndex;\n        Types.CheckpointOutput memory targetOutput = oracle.getL2Output(outputIndex);\n\n        _createChallenge(outputIndex, challenger);\n        Types.Challenge memory challenge = mockColosseum.getChallenge(outputIndex, challenger);\n\n        while (mockColosseum.isAbleToBisect(outputIndex, challenge.challenger)) {\n            challenge = mockColosseum.getChallenge(outputIndex, challenge.challenger);\n            _bisect(outputIndex, challenge.challenger, nextSender(challenge));\n        }\n\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenger)),\n            uint256(Colosseum.ChallengeStatus.READY_TO_PROVE)\n        );\n\n        publicInputHash = _proveFault(outputIndex, challenge.challenger);\n\n        (, bytes32 outputRoot, , ) = colosseum.deletedOutputs(outputIndex);\n        assertEq(outputRoot, targetOutput.outputRoot);\n        assertTrue(colosseum.verifiedPublicInputs(publicInputHash));\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenger)),\n            uint256(Colosseum.ChallengeStatus.NONE)\n        );\n    }\n\n    function test_proveFault_finalizedOutput_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n        Types.Challenge memory challenge = mockColosseum.getChallenge(outputIndex, challenger);\n\n        while (mockColosseum.isAbleToBisect(outputIndex, challenge.challenger)) {\n            challenge = mockColosseum.getChallenge(outputIndex, challenge.challenger);\n            _bisect(outputIndex, challenge.challenger, nextSender(challenge));\n        }\n\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenger)),\n            uint256(Colosseum.ChallengeStatus.READY_TO_PROVE)\n        );\n\n        Types.CheckpointOutput memory targetOutput = oracle.getL2Output(outputIndex);\n        vm.warp(targetOutput.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        vm.expectRevert(Colosseum.OutputAlreadyFinalized.selector);\n        _doProveFault(challenger, outputIndex, 0);\n    }\n\n    // TODO(pangssu): Testing is impossible in the current state. It must be fixed without fail.\n    // function test_proveFault_whenAsserterTimedOut_succeeds() external {\n    //     uint256 outputIndex = targetOutputIndex;\n    //\n    //     _createChallenge(outputIndex, challenger);\n    //\n    //     Types.Challenge memory challenge = mockColosseum.getChallenge(outputIndex, challenger);\n    //\n    //     assertEq(nextSender(challenge), challenge.asserter);\n    //\n    //     vm.warp(challenge.timeoutAt + 1);\n    //     // check the asserter timeout\n    //     assertEq(\n    //         uint256(colosseum.getStatus(outputIndex, challenge.challenger)),\n    //         uint256(Colosseum.ChallengeStatus.ASSERTER_TIMEOUT)\n    //     );\n    //\n    //     _proveFault(outputIndex, challenge.challenger);\n    // }\n\n    function test_proveFault_cancelChallenge_succeeds() external {\n        uint256 outputIndex = targetOutputIndex;\n        address otherChallenger = _newChallenger(\"other challenger\");\n\n        _createChallenge(outputIndex, otherChallenger);\n        Types.Challenge memory challenge = mockColosseum.getChallenge(outputIndex, otherChallenger);\n        while (mockColosseum.isAbleToBisect(outputIndex, otherChallenger)) {\n            challenge = mockColosseum.getChallenge(outputIndex, otherChallenger);\n            _bisect(outputIndex, otherChallenger, nextSender(challenge));\n        }\n\n        // The output root of the target output index was replaced by another challenge.\n        test_proveFault_succeeds();\n\n        uint256 prevDeposit = pool.balanceOf(otherChallenger);\n        uint256 pendingBond = pool.getPendingBond(outputIndex, otherChallenger);\n        Types.PublicInputProof memory _emptyProof;\n\n        vm.prank(otherChallenger);\n        colosseum.proveFault(outputIndex, 0, _emptyProof, new uint256[](0), new uint256[](0));\n\n        // Ensure that the challenge has been deleted.\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, otherChallenger)),\n            uint256(Colosseum.ChallengeStatus.NONE)\n        );\n        // Ensure that the pending bond has been refunded.\n        vm.expectRevert(\"ValidatorPool: the pending bond does not exist\");\n        pool.getPendingBond(outputIndex, otherChallenger);\n        assertEq(pool.balanceOf(otherChallenger), prevDeposit + pendingBond);\n    }\n\n    function test_dismissChallenge_succeeds() public {\n        uint256 outputIndex = targetOutputIndex;\n        Types.CheckpointOutput memory output = oracle.getL2Output(outputIndex);\n\n        bytes32 publicInputHash = test_proveFault_succeeds();\n        Types.CheckpointOutput memory newOutput = oracle.getL2Output(outputIndex);\n\n        vm.prank(address(securityCouncil));\n        colosseum.dismissChallenge(\n            outputIndex,\n            newOutput.submitter,\n            output.submitter,\n            output.outputRoot,\n            publicInputHash\n        );\n\n        (, bytes32 outputRoot, , ) = colosseum.deletedOutputs(outputIndex);\n        assertEq(outputRoot, bytes32(0));\n        assertFalse(colosseum.verifiedPublicInputs(publicInputHash));\n    }\n\n    function test_dismissChallenge_notSecurityCouncil_reverts() external {\n        test_proveFault_succeeds();\n\n        vm.prank(makeAddr(\"not_security_council\"));\n        vm.expectRevert(Colosseum.NotAllowedCaller.selector);\n        colosseum.dismissChallenge(0, address(0), address(0), bytes32(0), bytes32(0));\n    }\n\n    function test_dismissChallenge_outputNotDeleted_reverts() external {\n        vm.prank(address(securityCouncil));\n        vm.expectRevert(Colosseum.OutputNotDeleted.selector);\n        colosseum.dismissChallenge(\n            targetOutputIndex,\n            address(0),\n            address(0),\n            bytes32(0),\n            bytes32(0)\n        );\n    }\n\n    function test_dismissChallenge_finalizedOutput_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n        Types.Challenge memory challenge = mockColosseum.getChallenge(outputIndex, challenger);\n\n        while (mockColosseum.isAbleToBisect(outputIndex, challenge.challenger)) {\n            challenge = mockColosseum.getChallenge(outputIndex, challenge.challenger);\n            _bisect(outputIndex, challenge.challenger, nextSender(challenge));\n        }\n\n        Types.CheckpointOutput memory targetOutput = oracle.getL2Output(outputIndex);\n        vm.warp(targetOutput.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        vm.prank(address(securityCouncil));\n        vm.expectRevert(Colosseum.OutputAlreadyFinalized.selector);\n        colosseum.dismissChallenge(0, address(0), address(0), bytes32(0), bytes32(0));\n    }\n\n    function test_dismissChallenge_invalidOutputGiven_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        Types.CheckpointOutput memory output = oracle.getL2Output(outputIndex);\n\n        bytes32 publicInputHash = test_proveFault_succeeds();\n        Types.CheckpointOutput memory newOutput = oracle.getL2Output(outputIndex);\n\n        vm.prank(address(securityCouncil));\n        vm.expectRevert(Colosseum.InvalidOutputGiven.selector);\n        colosseum.dismissChallenge(\n            outputIndex,\n            newOutput.submitter,\n            output.submitter,\n            bytes32(0),\n            publicInputHash\n        );\n    }\n\n    function test_dismissChallenge_invalidAddressGiven_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        Types.CheckpointOutput memory output = oracle.getL2Output(outputIndex);\n\n        bytes32 publicInputHash = test_proveFault_succeeds();\n        Types.CheckpointOutput memory newOutput = oracle.getL2Output(outputIndex);\n\n        vm.prank(address(securityCouncil));\n        vm.expectRevert(Colosseum.InvalidAddressGiven.selector);\n        colosseum.dismissChallenge(\n            outputIndex,\n            address(0),\n            output.submitter,\n            output.outputRoot,\n            publicInputHash\n        );\n\n        vm.prank(address(securityCouncil));\n        vm.expectRevert(Colosseum.InvalidAddressGiven.selector);\n        colosseum.dismissChallenge(\n            outputIndex,\n            newOutput.submitter,\n            address(0),\n            output.outputRoot,\n            publicInputHash\n        );\n    }\n\n    function test_dismissChallenge_invalidPublicInput_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        Types.CheckpointOutput memory output = oracle.getL2Output(outputIndex);\n\n        test_proveFault_succeeds();\n        Types.CheckpointOutput memory newOutput = oracle.getL2Output(outputIndex);\n\n        vm.prank(address(securityCouncil));\n        vm.expectRevert(Colosseum.InvalidPublicInput.selector);\n        colosseum.dismissChallenge(\n            outputIndex,\n            newOutput.submitter,\n            output.submitter,\n            output.outputRoot,\n            bytes32(0)\n        );\n    }\n\n    function test_challengerTimeout_succeeds() public {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n        Types.Challenge memory challenge = mockColosseum.getChallenge(outputIndex, challenger);\n\n        assertEq(nextSender(challenge), challenge.asserter);\n\n        _bisect(outputIndex, challenge.challenger, challenge.asserter);\n\n        challenge = mockColosseum.getChallenge(outputIndex, challenge.challenger);\n        vm.warp(challenge.timeoutAt + 1);\n        // check the challenger timeout\n        assertEq(nextSender(challenge), challenge.challenger);\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenge.challenger)),\n            uint256(Colosseum.ChallengeStatus.CHALLENGER_TIMEOUT)\n        );\n\n        vm.prank(challenge.asserter);\n        colosseum.challengerTimeout(outputIndex, challenge.challenger);\n    }\n\n    function test_challengerNotCloseWhenAsserterTimeout_succeeds() external {\n        uint256 outputIndex = targetOutputIndex;\n        _createChallenge(outputIndex, challenger);\n        Types.Challenge memory challenge = mockColosseum.getChallenge(outputIndex, challenger);\n\n        assertEq(nextSender(challenge), challenge.asserter);\n\n        vm.warp(challenge.timeoutAt + 1);\n        // check the asserter timeout\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenge.challenger)),\n            uint256(Colosseum.ChallengeStatus.ASSERTER_TIMEOUT)\n        );\n        // then challenger do not anything\n\n        vm.warp(challenge.timeoutAt + colosseum.PROVING_TIMEOUT() + 1);\n        // check the challenger timeout\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, challenge.challenger)),\n            uint256(Colosseum.ChallengeStatus.CHALLENGER_TIMEOUT)\n        );\n    }\n\n    function test_cancelChallenge_succeeds() external {\n        uint256 outputIndex = targetOutputIndex;\n        address otherChallenger = _newChallenger(\"other challenger\");\n\n        _createChallenge(outputIndex, otherChallenger);\n\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, otherChallenger)),\n            uint256(Colosseum.ChallengeStatus.ASSERTER_TURN)\n        );\n\n        // The output root of the target output index was replaced by another challenge.\n        test_proveFault_succeeds();\n\n        assertEq(\n            uint256(colosseum.getStatus(outputIndex, otherChallenger)),\n            uint256(Colosseum.ChallengeStatus.ASSERTER_TURN)\n        );\n\n        uint256 prevDeposit = pool.balanceOf(otherChallenger);\n        uint256 pendingBond = pool.getPendingBond(outputIndex, otherChallenger);\n\n        vm.prank(otherChallenger);\n        colosseum.cancelChallenge(outputIndex);\n\n        // Ensure that the pending bond has been refunded.\n        vm.expectRevert(\"ValidatorPool: the pending bond does not exist\");\n        pool.getPendingBond(outputIndex, otherChallenger);\n        assertEq(pool.balanceOf(otherChallenger), prevDeposit + pendingBond);\n    }\n\n    function test_cancelChallenge_noChallenge_reverts() external {\n        vm.expectRevert(Colosseum.CannotCancelChallenge.selector);\n        colosseum.cancelChallenge(0);\n    }\n\n    function test_cancelChallenge_outputNotDeleted_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n\n        _createChallenge(outputIndex, challenger);\n\n        vm.prank(challenger);\n        vm.expectRevert(Colosseum.CannotCancelChallenge.selector);\n        colosseum.cancelChallenge(outputIndex);\n    }\n\n    function test_cancelChallenge_senderNotChallenger_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        address otherChallenger = _newChallenger(\"other challenger\");\n\n        _createChallenge(outputIndex, otherChallenger);\n\n        // The output root of the target output index was replaced by another challenge.\n        test_proveFault_succeeds();\n\n        vm.prank(challenger);\n        vm.expectRevert(Colosseum.OnlyChallengerCanCancel.selector);\n        colosseum.cancelChallenge(outputIndex);\n    }\n\n    function test_cancelChallenge_whenChallengerTimedOut_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n        address otherChallenger = _newChallenger(\"other challenger\");\n\n        _createChallenge(outputIndex, otherChallenger);\n        Types.Challenge memory challenge = mockColosseum.getChallenge(outputIndex, otherChallenger);\n        _bisect(outputIndex, otherChallenger, challenge.asserter);\n\n        vm.warp(challenge.timeoutAt + 1);\n        // The output root of the target output index was replaced by another challenge.\n        test_proveFault_succeeds();\n\n        vm.prank(otherChallenger);\n        vm.expectRevert(Colosseum.ImproperChallengeStatusToCancel.selector);\n        colosseum.cancelChallenge(outputIndex);\n    }\n\n    function test_forceDeleteOutput_succeeds() external {\n        uint256 outputIndex = targetOutputIndex;\n\n        _createChallenge(outputIndex, challenger);\n\n        Types.Challenge memory challenge = mockColosseum.getChallenge(outputIndex, challenger);\n\n        while (mockColosseum.isAbleToBisect(outputIndex, challenge.challenger)) {\n            challenge = mockColosseum.getChallenge(outputIndex, challenge.challenger);\n            _bisect(outputIndex, challenge.challenger, nextSender(challenge));\n        }\n\n        vm.prank(address(securityCouncil));\n        colosseum.forceDeleteOutput(outputIndex);\n    }\n\n    function test_forceDeleteOutput_notSecurityCouncil_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n\n        vm.prank(address(1));\n        vm.expectRevert(Colosseum.NotAllowedCaller.selector);\n        colosseum.forceDeleteOutput(outputIndex);\n    }\n\n    function test_forceDeleteOutput_finalizedOutput_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n\n        _createChallenge(outputIndex, challenger);\n\n        Types.Challenge memory challenge = mockColosseum.getChallenge(outputIndex, challenger);\n\n        while (mockColosseum.isAbleToBisect(outputIndex, challenge.challenger)) {\n            challenge = mockColosseum.getChallenge(outputIndex, challenge.challenger);\n            _bisect(outputIndex, challenge.challenger, nextSender(challenge));\n        }\n\n        vm.warp(oracle.finalizedAt(outputIndex) + 1);\n\n        vm.prank(address(securityCouncil));\n        vm.expectRevert(Colosseum.OutputAlreadyFinalized.selector);\n        colosseum.forceDeleteOutput(outputIndex);\n    }\n\n    function test_forceDeleteOutput_alreadyDeletedOutput_reverts() external {\n        uint256 outputIndex = targetOutputIndex;\n\n        _createChallenge(outputIndex, challenger);\n\n        Types.Challenge memory challenge = mockColosseum.getChallenge(outputIndex, challenger);\n\n        while (mockColosseum.isAbleToBisect(outputIndex, challenge.challenger)) {\n            challenge = mockColosseum.getChallenge(outputIndex, challenge.challenger);\n            _bisect(outputIndex, challenge.challenger, nextSender(challenge));\n        }\n\n        vm.prank(address(securityCouncil));\n        colosseum.forceDeleteOutput(outputIndex);\n\n        vm.prank(address(securityCouncil));\n        vm.expectRevert(Colosseum.OutputAlreadyDeleted.selector);\n        colosseum.forceDeleteOutput(outputIndex);\n    }\n\n    function test_isInCreationPeriod_succeeds() external {\n        uint256 outputIndex = targetOutputIndex;\n\n        assertEq(colosseum.isInCreationPeriod(outputIndex), true);\n\n        Types.CheckpointOutput memory output = oracle.getL2Output(outputIndex);\n        vm.warp(output.timestamp + colosseum.CREATION_PERIOD_SECONDS() + 1);\n\n        assertEq(colosseum.isInCreationPeriod(outputIndex), false);\n    }\n}\n\ncontract Colosseum_ValidatorSystemUpgrade_Test is Colosseum_Initializer {\n    MockColosseum mockColosseum;\n    MockL2OutputOracle mockOracle;\n    uint256 internal targetOutputIndex;\n\n    function setUp() public override {\n        super.setUp();\n\n        MockColosseum mockColosseumImpl = new MockColosseum(\n            oracle,\n            zkVerifier,\n            submissionInterval,\n            creationPeriodSeconds,\n            bisectionTimeout,\n            provingTimeout,\n            DUMMY_HASH,\n            MAX_TXS,\n            segmentsLengths,\n            address(securityCouncil),\n            address(zkMerkleTrie)\n        );\n        vm.prank(multisig);\n        Proxy(payable(address(colosseum))).upgradeTo(address(mockColosseumImpl));\n        mockColosseum = MockColosseum(address(colosseum));\n\n        address oracleAddress = address(oracle);\n        MockL2OutputOracle mockOracleImpl = new MockL2OutputOracle(\n            pool,\n            valMgr,\n            address(colosseum),\n            submissionInterval,\n            l2BlockTime,\n            startingBlockNumber,\n            startingTimestamp,\n            finalizationPeriodSeconds\n        );\n        vm.prank(multisig);\n        Proxy(payable(oracleAddress)).upgradeTo(address(mockOracleImpl));\n        mockOracle = MockL2OutputOracle(oracleAddress);\n\n        // Deploy ValidatorPool with new argument\n        terminateOutputIndex = 0;\n        poolImpl = new ValidatorPool({\n            _l2OutputOracle: oracle,\n            _portal: mockPortal,\n            _securityCouncil: guardian,\n            _trustedValidator: trusted,\n            _requiredBondAmount: requiredBondAmount,\n            _maxUnbond: maxUnbond,\n            _roundDuration: roundDuration,\n            _terminateOutputIndex: terminateOutputIndex\n        });\n        vm.prank(multisig);\n        Proxy(payable(address(pool))).upgradeTo(address(poolImpl));\n\n        // Submit outputs until ValidatorPool is terminated\n        vm.prank(trusted);\n        pool.deposit{ value: trusted.balance }();\n        for (uint256 i; i <= terminateOutputIndex; i++) {\n            _submitL2OutputV1();\n        }\n\n        // Only trusted validator can submit the first output with ValidatorManager\n        _registerValidator(trusted, minActivateAmount);\n\n        // Submit invalid output as asserter\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime();\n        vm.prank(valMgr.nextValidator());\n        oracle.submitL2Output(keccak256(abi.encode()), nextBlockNumber, 0, 0);\n\n        // To create challenge, challenger also registers validator\n        _registerValidator(challenger, minActivateAmount);\n\n        targetOutputIndex = oracle.latestOutputIndex();\n    }\n\n    function _nextSender(Types.Challenge memory challenge) private pure returns (address) {\n        return challenge.turn % 2 == 0 ? challenge.challenger : challenge.asserter;\n    }\n\n    function _getOutputRoot(address sender, uint256 blockNumber) private view returns (bytes32) {\n        uint256 targetBlockNumber = ColosseumTestData.INVALID_BLOCK_NUMBER;\n        if (blockNumber == targetBlockNumber - 1) {\n            return ColosseumTestData.PREV_OUTPUT_ROOT;\n        }\n\n        // If asserter, wrong output after targetBlockNumber\n        if (sender == trusted) {\n            if (blockNumber < targetBlockNumber - 1) {\n                return keccak256(abi.encode(blockNumber));\n            } else {\n                return keccak256(abi.encode());\n            }\n        }\n\n        // If challenger, correct output always\n        if (blockNumber == targetBlockNumber) {\n            return ColosseumTestData.TARGET_OUTPUT_ROOT;\n        } else {\n            return keccak256(abi.encode(blockNumber));\n        }\n    }\n\n    function _newSegments(\n        address sender,\n        uint8 turn,\n        uint256 segStart,\n        uint256 segSize\n    ) private view returns (bytes32[] memory) {\n        uint256 segLen = colosseum.segmentsLengths(turn - 1);\n\n        bytes32[] memory arr = new bytes32[](segLen);\n\n        for (uint256 i = 0; i < segLen; i++) {\n            uint256 n = segStart + i * (segSize / (segLen - 1));\n            arr[i] = _getOutputRoot(sender, n);\n        }\n\n        return arr;\n    }\n\n    function _getFirstSegments() private view returns (bytes32[] memory) {\n        Types.CheckpointOutput memory targetOutput = oracle.getL2Output(targetOutputIndex);\n        uint256 end = targetOutput.l2BlockNumber;\n        uint256 start = end - oracle.SUBMISSION_INTERVAL();\n\n        bytes32[] memory segments = _newSegments(challenger, 1, start, end - start);\n\n        return segments;\n    }\n\n    function _bisect(uint256 outputIndex, address _challenger, address sender) private {\n        Types.Challenge memory challenge = mockColosseum.getChallenge(outputIndex, _challenger);\n\n        uint256 position = _detectFault(challenge, sender);\n        uint256 segSize = challenge.segSize / (colosseum.segmentsLengths(challenge.turn - 1) - 1);\n        uint256 segStart = challenge.segStart + position * segSize;\n\n        bytes32[] memory segments = _newSegments(sender, challenge.turn + 1, segStart, segSize);\n\n        vm.prank(sender);\n        colosseum.bisect(outputIndex, challenge.challenger, position, segments);\n    }\n\n    function _detectFault(\n        Types.Challenge memory challenge,\n        address sender\n    ) private view returns (uint256) {\n        if (sender == challenge.challenger && sender != _nextSender(challenge)) {\n            return 0;\n        }\n\n        uint256 segLen = colosseum.segmentsLengths(challenge.turn - 1);\n        uint256 start = challenge.segStart;\n        uint256 degree = challenge.segSize / (segLen - 1);\n        uint256 current = start + degree;\n\n        for (uint256 i = 1; i < segLen; i++) {\n            bytes32 output = _getOutputRoot(sender, current);\n\n            if (challenge.segments[i] != output) {\n                return i - 1;\n            }\n\n            current += degree;\n        }\n\n        revert(\"failed to select faulty position\");\n    }\n\n    function _getProof()\n        private\n        pure\n        returns (ColosseumTestData.ProofPair memory, Types.PublicInputProof memory)\n    {\n        (\n            Types.OutputRootProof memory srcOutputRootProof,\n            Types.OutputRootProof memory dstOutputRootProof\n        ) = ColosseumTestData.outputRootProof();\n        Types.PublicInput memory publicInput = ColosseumTestData.publicInput();\n        Types.BlockHeaderRLP memory rlps = ColosseumTestData.blockHeaderRLP();\n        ColosseumTestData.ProofPair memory pp = ColosseumTestData.proofAndPair();\n        (ColosseumTestData.Account memory account, bytes[] memory merkleProof) = ColosseumTestData\n            .merkleProof();\n\n        Types.PublicInputProof memory proof = Types.PublicInputProof({\n            srcOutputRootProof: srcOutputRootProof,\n            dstOutputRootProof: dstOutputRootProof,\n            publicInput: publicInput,\n            rlps: rlps,\n            l2ToL1MessagePasserBalance: bytes32(account.balance),\n            l2ToL1MessagePasserCodeHash: account.codeHash,\n            merkleProof: merkleProof\n        });\n\n        return (pp, proof);\n    }\n\n    function test_createChallenge_callValidatorManager_succeeds() public {\n        bytes32[] memory segments = _getFirstSegments();\n\n        vm.expectCall(\n            address(valMgr),\n            abi.encodeWithSelector(IValidatorManager.isActive.selector, challenger)\n        );\n        vm.prank(challenger);\n        colosseum.createChallenge(targetOutputIndex, bytes32(0), 0, segments);\n\n        assertEq(assetMgr.totalValidatorKroBonded(challenger), bondAmount);\n    }\n\n    function test_createChallenge_notSatisfyCondition_reverts() external {\n        bytes32[] memory segments = _getFirstSegments();\n\n        vm.expectRevert(IValidatorManager.ImproperValidatorStatus.selector);\n        vm.prank(makeAddr(\"other challenger\"));\n        colosseum.createChallenge(targetOutputIndex, bytes32(0), 0, segments);\n    }\n\n    function test_proveFault_callValidatorManager_succeeds()\n        public\n        returns (bytes32 publicInputHash)\n    {\n        test_createChallenge_callValidatorManager_succeeds();\n\n        Types.Challenge memory challenge = mockColosseum.getChallenge(\n            targetOutputIndex,\n            challenger\n        );\n        uint128 beforeAsserterKro = assetMgr.totalValidatorKro(challenge.asserter);\n\n        while (mockColosseum.isAbleToBisect(targetOutputIndex, challenger)) {\n            _bisect(targetOutputIndex, challenger, _nextSender(challenge));\n            challenge = mockColosseum.getChallenge(targetOutputIndex, challenger);\n        }\n\n        (ColosseumTestData.ProofPair memory pp, Types.PublicInputProof memory proof) = _getProof();\n\n        uint256 position = _detectFault(challenge, challenge.challenger);\n\n        vm.expectCall(\n            address(valMgr),\n            abi.encodeWithSelector(\n                IValidatorManager.slash.selector,\n                targetOutputIndex,\n                challenger,\n                challenge.asserter\n            )\n        );\n        vm.prank(challenger);\n        colosseum.proveFault(targetOutputIndex, position, proof, pp.proof, pp.pair);\n\n        publicInputHash = mockColosseum.hashPublicInput(proof);\n\n        assertEq(assetMgr.totalValidatorKro(challenge.asserter), beforeAsserterKro - bondAmount);\n        assertEq(assetMgr.totalValidatorKro(challenger), minActivateAmount);\n    }\n\n    function test_dismissChallenge_callValidatorManager_succeeds() external {\n        Types.CheckpointOutput memory output = oracle.getL2Output(targetOutputIndex);\n        uint128 beforeAsserterKro = assetMgr.totalValidatorKro(output.submitter);\n\n        bytes32 publicInputHash = test_proveFault_callValidatorManager_succeeds();\n\n        vm.expectCall(\n            address(valMgr),\n            abi.encodeWithSelector(\n                IValidatorManager.revertSlash.selector,\n                targetOutputIndex,\n                output.submitter\n            )\n        );\n        vm.expectCall(\n            address(valMgr),\n            abi.encodeWithSelector(\n                IValidatorManager.slash.selector,\n                targetOutputIndex,\n                output.submitter,\n                challenger\n            )\n        );\n        vm.prank(address(securityCouncil));\n        colosseum.dismissChallenge(\n            targetOutputIndex,\n            challenger,\n            output.submitter,\n            output.outputRoot,\n            publicInputHash\n        );\n\n        assertEq(assetMgr.totalValidatorKro(output.submitter), beforeAsserterKro);\n        assertEq(assetMgr.totalValidatorKro(challenger), minActivateAmount - bondAmount);\n\n        // check if original output submitter gets output reward + challenge reward\n        uint128 tax = (bondAmount * assetMgr.TAX_NUMERATOR()) / assetMgr.TAX_DENOMINATOR();\n        uint128 challengeReward = bondAmount - tax;\n\n        mockOracle.mockSetNextFinalizeOutputIndex(terminateOutputIndex + 1);\n        vm.warp(oracle.finalizedAt(targetOutputIndex));\n        _submitL2OutputV2(false);\n\n        assertEq(\n            assetMgr.reflectiveWeight(output.submitter),\n            minActivateAmount + baseReward + challengeReward\n        );\n    }\n\n    function test_forceDeleteOutput_callValidatorManager_succeeds() external {\n        test_createChallenge_callValidatorManager_succeeds();\n\n        Types.Challenge memory challenge = mockColosseum.getChallenge(\n            targetOutputIndex,\n            challenger\n        );\n        uint128 beforeAsserterKro = assetMgr.totalValidatorKro(challenge.asserter);\n\n        while (mockColosseum.isAbleToBisect(targetOutputIndex, challenger)) {\n            _bisect(targetOutputIndex, challenger, _nextSender(challenge));\n            challenge = mockColosseum.getChallenge(targetOutputIndex, challenger);\n        }\n\n        vm.expectCall(\n            address(valMgr),\n            abi.encodeWithSelector(\n                IValidatorManager.slash.selector,\n                targetOutputIndex,\n                securityCouncil,\n                challenge.asserter\n            )\n        );\n        vm.prank(address(securityCouncil));\n        colosseum.forceDeleteOutput(targetOutputIndex);\n\n        assertEq(assetMgr.totalValidatorKro(challenge.asserter), beforeAsserterKro - bondAmount);\n        assertEq(assetMgr.totalValidatorKro(challenger), minActivateAmount);\n    }\n\n    function test_cancelChallenge_callValidatorManager_succeeds() external {\n        address otherChallenger = asserter;\n        _registerValidator(asserter, minActivateAmount);\n\n        bytes32[] memory segments = _getFirstSegments();\n        vm.prank(otherChallenger);\n        colosseum.createChallenge(targetOutputIndex, bytes32(0), 0, segments);\n\n        test_proveFault_callValidatorManager_succeeds();\n\n        vm.expectCall(\n            address(valMgr),\n            abi.encodeWithSelector(IValidatorManager.unbondValidatorKro.selector, otherChallenger)\n        );\n        vm.prank(otherChallenger);\n        colosseum.cancelChallenge(targetOutputIndex);\n\n        assertEq(assetMgr.totalValidatorKroBonded(otherChallenger), 0);\n    }\n\n    function test_challengerTimeout_callValidatorManager_succeeds() external {\n        test_createChallenge_callValidatorManager_succeeds();\n\n        Types.Challenge memory challenge = mockColosseum.getChallenge(\n            targetOutputIndex,\n            challenger\n        );\n        _bisect(targetOutputIndex, challenger, challenge.asserter);\n\n        challenge = mockColosseum.getChallenge(targetOutputIndex, challenger);\n        vm.warp(challenge.timeoutAt + 1);\n\n        // check the challenger timeout\n        assertEq(_nextSender(challenge), challenger);\n        assertTrue(\n            colosseum.getStatus(targetOutputIndex, challenger) ==\n                Colosseum.ChallengeStatus.CHALLENGER_TIMEOUT\n        );\n\n        vm.expectCall(\n            address(valMgr),\n            abi.encodeWithSelector(\n                IValidatorManager.slash.selector,\n                targetOutputIndex,\n                challenge.asserter,\n                challenger\n            )\n        );\n        vm.prank(challenge.asserter);\n        colosseum.challengerTimeout(targetOutputIndex, challenger);\n\n        assertEq(assetMgr.totalValidatorKro(challenger), minActivateAmount - bondAmount);\n    }\n}\n"
    },
    "contracts/test/CommonTest.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/* Testing utilities */\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { Test } from \"forge-std/Test.sol\";\n\nimport { SecurityCouncilToken } from \"../governance/SecurityCouncilToken.sol\";\nimport { TimeLock } from \"../governance/TimeLock.sol\";\nimport { UpgradeGovernor } from \"../governance/UpgradeGovernor.sol\";\nimport { AssetManager } from \"../L1/AssetManager.sol\";\nimport { Colosseum } from \"../L1/Colosseum.sol\";\nimport { IValidatorManager } from \"../L1/interfaces/IValidatorManager.sol\";\nimport { KromaPortal } from \"../L1/KromaPortal.sol\";\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\nimport { L1ERC721Bridge } from \"../L1/L1ERC721Bridge.sol\";\nimport { L1StandardBridge } from \"../L1/L1StandardBridge.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { SecurityCouncil } from \"../L1/SecurityCouncil.sol\";\nimport { ValidatorPool } from \"../L1/ValidatorPool.sol\";\nimport { ValidatorManager } from \"../L1/ValidatorManager.sol\";\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { SystemConfig } from \"../L1/SystemConfig.sol\";\nimport { ZKMerkleTrie } from \"../L1/ZKMerkleTrie.sol\";\nimport { ZKVerifier } from \"../L1/ZKVerifier.sol\";\nimport { L2CrossDomainMessenger } from \"../L2/L2CrossDomainMessenger.sol\";\nimport { L2ERC721Bridge } from \"../L2/L2ERC721Bridge.sol\";\nimport { L2StandardBridge } from \"../L2/L2StandardBridge.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { CodeDeployer } from \"../libraries/CodeDeployer.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { KromaMintableERC20 } from \"../universal/KromaMintableERC20.sol\";\nimport { KromaMintableERC20Factory } from \"../universal/KromaMintableERC20Factory.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\n\ncontract CommonTest is Test {\n    address alice = address(128);\n    address bob = address(256);\n    address multisig = address(512);\n\n    address immutable ZERO_ADDRESS = address(0);\n    address immutable NON_ZERO_ADDRESS = address(1);\n    uint256 immutable NON_ZERO_VALUE = 100;\n    uint256 immutable ZERO_VALUE = 0;\n    uint64 immutable NON_ZERO_GASLIMIT = 50000;\n    bytes32 nonZeroHash = keccak256(abi.encode(\"NON_ZERO\"));\n    bytes NON_ZERO_DATA = hex\"0000111122223333444455556666777788889999aaaabbbbccccddddeeeeffff0000\";\n\n    uint256 constant MAX_OUTPUT_ROOT_PROOF_VERSION = 0;\n\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 indexed version,\n        bytes opaqueData\n    );\n\n    FFIInterface ffi;\n\n    function setUp() public virtual {\n        // Give alice and bob some ETH\n        vm.deal(alice, 1 << 16);\n        vm.deal(bob, 1 << 16);\n        vm.deal(multisig, 1 << 16);\n\n        vm.label(alice, \"alice\");\n        vm.label(bob, \"bob\");\n        vm.label(multisig, \"multisig\");\n\n        // Make sure we have a non-zero base fee\n        vm.fee(1000000000);\n\n        ffi = new FFIInterface();\n    }\n\n    function emitTransactionDeposited(\n        address _from,\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    ) internal {\n        emit TransactionDeposited(\n            _from,\n            _to,\n            0,\n            abi.encodePacked(_mint, _value, _gasLimit, _isCreation, _data)\n        );\n    }\n\n    //payable proxy\n    function toProxy(address target) internal pure returns (Proxy) {\n        return Proxy(payable(target));\n    }\n}\n\ncontract UpgradeGovernor_Initializer is CommonTest {\n    address owner = makeAddr(\"owner\");\n\n    // Constructor arguments\n    uint256 internal initialVotingDelay = 0;\n    uint256 internal initialVotingPeriod = 30;\n    uint256 internal initialProposalThreshold = 1;\n    uint256 internal votesQuorumFraction = 70;\n    uint256 internal minDelaySeconds = 3;\n    string internal baseUri = \"\";\n\n    // Test data\n    address internal guardian1 = 0x0000000000000000000000000000000000001004;\n    address internal guardian2 = 0x0000000000000000000000000000000000001005;\n    address internal guardian3 = 0x0000000000000000000000000000000000001006;\n    address internal notGuardian = 0x0000000000000000000000000000000000002000;\n\n    address[] timeLockProposers = new address[](1);\n    address[] timeLockExecutors = new address[](1);\n\n    SecurityCouncilToken securityCouncilToken = SecurityCouncilToken(address(new Proxy(multisig)));\n    TimeLock timeLock = TimeLock(payable(address(new Proxy(multisig))));\n    UpgradeGovernor upgradeGovernor = UpgradeGovernor(payable(address(new Proxy(multisig))));\n\n    SecurityCouncilToken securityCouncilTokenImpl = new SecurityCouncilToken();\n    TimeLock timeLockImpl = new TimeLock();\n    UpgradeGovernor upgradeGovernorImpl = new UpgradeGovernor();\n\n    function setUp() public virtual override {\n        super.setUp();\n        vm.startPrank(multisig);\n\n        // setup SecurityCouncilToken\n        toProxy(address(securityCouncilToken)).upgradeToAndCall(\n            address(securityCouncilTokenImpl),\n            abi.encodeCall(SecurityCouncilToken.initialize, owner)\n        );\n\n        // setup TimeLock & UpgradeGovernor\n        timeLockProposers[0] = address(upgradeGovernor);\n        timeLockExecutors[0] = address(upgradeGovernor);\n\n        toProxy(address(timeLock)).upgradeToAndCall(\n            address(timeLockImpl),\n            abi.encodeCall(\n                TimeLock.initialize,\n                (minDelaySeconds, timeLockProposers, timeLockExecutors, address(upgradeGovernor))\n            )\n        );\n\n        toProxy(address(upgradeGovernor)).upgradeToAndCall(\n            address(upgradeGovernorImpl),\n            abi.encodeCall(\n                UpgradeGovernor.initialize,\n                (\n                    address(securityCouncilToken),\n                    payable(address(timeLock)),\n                    initialVotingDelay,\n                    initialVotingPeriod,\n                    initialProposalThreshold,\n                    votesQuorumFraction\n                )\n            )\n        );\n\n        //change proxy admin to upgradeGovernor\n        toProxy(address(securityCouncilToken)).changeAdmin(address(timeLock));\n        toProxy(address(timeLock)).changeAdmin(address(timeLock));\n        toProxy(address(upgradeGovernor)).changeAdmin(address(timeLock));\n\n        vm.stopPrank();\n    }\n}\n\ncontract MockKro is ERC20 {\n    constructor() ERC20(\"Kroma\", \"KRO\") {}\n\n    function mint(address to, uint256 amount) external {\n        _mint(to, amount);\n    }\n}\n\ncontract MockKgh is ERC721 {\n    constructor() ERC721(\"Test\", \"TST\") {}\n\n    function mint(address to, uint256 tokenId) external {\n        _mint(to, tokenId);\n    }\n}\n\ncontract L2OutputOracle_Initializer is UpgradeGovernor_Initializer {\n    // Test target\n    ValidatorPool pool;\n    ValidatorPool poolImpl;\n    AssetManager assetMgr;\n    AssetManager assetMgrImpl;\n    ValidatorManager valMgr;\n    ValidatorManager valMgrImpl;\n    L2OutputOracle oracle;\n    L2OutputOracle oracleImpl;\n    Colosseum colosseum;\n    SystemConfig systemConfig;\n    KromaPortal mockPortal;\n\n    L2ToL1MessagePasser messagePasser =\n        L2ToL1MessagePasser(payable(Predeploys.L2_TO_L1_MESSAGE_PASSER));\n\n    // Constructor arguments\n    uint256 internal submissionInterval = 1800;\n    uint256 internal l2BlockTime = 2;\n    uint256 internal startingBlockNumber = 10;\n    uint256 internal startingTimestamp = 1000;\n    uint256 internal finalizationPeriodSeconds = 7 days;\n    address internal guardian = 0x000000000000000000000000000000000000AaaD;\n\n    // ValidatorPool constructor arguments\n    address internal trusted = 0x000000000000000000000000000000000000aaaa;\n    uint256 internal requiredBondAmount = 0.1 ether;\n    uint256 internal maxUnbond = 2;\n    uint256 internal roundDuration = (submissionInterval * l2BlockTime) / 2;\n    uint256 internal terminateOutputIndex = 300; // just large enough value, set again in upgrade test\n\n    // AssetManager constructor arguments\n    MockKro assetToken;\n    MockKgh kgh;\n    address internal validatorRewardVault = makeAddr(\"validatorRewardVault\");\n    uint128 internal minDelegationPeriod = 7 days;\n    uint128 internal bondAmount = 10e18;\n\n    // ValidatorManager constructor arguments\n    uint128 internal commissionChangeDelaySeconds = 7 days;\n    uint128 internal softJailPeriodSeconds = 3 days;\n    uint128 internal hardJailPeriodSeconds = 7 days;\n    uint128 internal jailThreshold = 2;\n    uint128 internal maxOutputFinalizations = 10;\n    uint128 internal baseReward = 20e18;\n    uint128 internal minRegisterAmount = 10e18;\n    uint128 internal minActivateAmount = 100e18;\n    IValidatorManager.ConstructorParams constructorParams;\n\n    // Test data\n    address internal asserter = 0x000000000000000000000000000000000000aAaB;\n    address internal challenger = 0x000000000000000000000000000000000000AAaC;\n    address internal withdrawAcc = 0x000000000000000000000000000000000000AAaE;\n    address internal delegator = 0x000000000000000000000000000000000000AAAF;\n    uint256 initL1Time;\n\n    event OutputSubmitted(\n        bytes32 indexed outputRoot,\n        uint256 indexed l2OutputIndex,\n        uint256 indexed l2BlockNumber,\n        uint256 l1Timestamp\n    );\n\n    event OutputReplaced(\n        uint256 indexed outputIndex,\n        address indexed newSubmitter,\n        bytes32 newOutputRoot\n    );\n\n    // Advance the evm's time to meet the L2OutputOracle's requirements for submitL2Output\n    function warpToSubmitTime() public {\n        vm.warp(oracle.nextOutputMinL2Timestamp());\n    }\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        // Set up asset token and give actors some amount\n        assetToken = new MockKro();\n        assetToken.mint(trusted, minActivateAmount * 10);\n        assetToken.mint(asserter, minActivateAmount * 10);\n        assetToken.mint(challenger, minActivateAmount * 10);\n        assetToken.mint(delegator, minActivateAmount * 10);\n        // Set up validatorRewardVault\n        assetToken.mint(validatorRewardVault, baseReward * 1000);\n\n        // Set up KGH\n        kgh = new MockKgh();\n\n        // Give actors some ETH\n        vm.deal(trusted, requiredBondAmount * 10);\n        vm.deal(asserter, requiredBondAmount * 10);\n        vm.deal(challenger, requiredBondAmount * 10);\n\n        // Deploy proxies\n        pool = ValidatorPool(address(new Proxy(multisig)));\n        vm.label(address(pool), \"ValidatorPool\");\n        assetMgr = AssetManager(address(new Proxy(multisig)));\n        vm.label(address(assetMgr), \"AssetManager\");\n        valMgr = ValidatorManager(address(new Proxy(multisig)));\n        vm.label(address(valMgr), \"ValidatorManager\");\n        oracle = L2OutputOracle(address(new Proxy(multisig)));\n        vm.label(address(oracle), \"L2OutputOracle\");\n\n        // Allow AssetManager contract can get asset token from validatorRewardVault\n        vm.prank(validatorRewardVault);\n        assetToken.approve(address(assetMgr), baseReward * 1000);\n\n        ResourceMetering.ResourceConfig memory config = Constants.DEFAULT_RESOURCE_CONFIG();\n        systemConfig = new SystemConfig({\n            _owner: address(1),\n            _overhead: 0,\n            _scalar: 10000,\n            _batcherHash: bytes32(0),\n            _gasLimit: 30_000_000,\n            _unsafeBlockSigner: address(0),\n            _config: config,\n            _validatorRewardScalar: 5000\n        });\n\n        // Mock KromaPortal\n        mockPortal = new KromaPortal({\n            _l2Oracle: oracle,\n            _validatorPool: address(pool),\n            _guardian: guardian,\n            _paused: false,\n            _config: systemConfig,\n            _zkMerkleTrie: ZKMerkleTrie(address(0))\n        });\n\n        // Deploy the ValidatorPool\n        poolImpl = new ValidatorPool({\n            _l2OutputOracle: oracle,\n            _portal: mockPortal,\n            _securityCouncil: guardian,\n            _trustedValidator: trusted,\n            _requiredBondAmount: requiredBondAmount,\n            _maxUnbond: maxUnbond,\n            _roundDuration: roundDuration,\n            _terminateOutputIndex: terminateOutputIndex\n        });\n\n        // Deploy the AssetManager\n        assetMgrImpl = new AssetManager({\n            _assetToken: IERC20(assetToken),\n            _kgh: IERC721(kgh),\n            _securityCouncil: guardian,\n            _validatorRewardVault: validatorRewardVault,\n            _validatorManager: valMgr,\n            _minDelegationPeriod: minDelegationPeriod,\n            _bondAmount: bondAmount\n        });\n\n        // Deploy the ValidatorManager\n        constructorParams = IValidatorManager.ConstructorParams({\n            _l2Oracle: oracle,\n            _assetManager: assetMgr,\n            _trustedValidator: trusted,\n            _commissionChangeDelaySeconds: commissionChangeDelaySeconds,\n            _roundDurationSeconds: uint128(roundDuration),\n            _softJailPeriodSeconds: softJailPeriodSeconds,\n            _hardJailPeriodSeconds: hardJailPeriodSeconds,\n            _jailThreshold: jailThreshold,\n            _maxOutputFinalizations: maxOutputFinalizations,\n            _baseReward: baseReward,\n            _minRegisterAmount: minRegisterAmount,\n            _minActivateAmount: minActivateAmount\n        });\n        valMgrImpl = new ValidatorManager({ _constructorParams: constructorParams });\n\n        // By default the first block has timestamp and number zero, which will cause underflows in\n        // the tests, so we'll move forward to these block values.\n        initL1Time = startingTimestamp + 1;\n        vm.warp(initL1Time);\n        vm.roll(startingBlockNumber);\n        // Deploy the L2OutputOracle\n        oracleImpl = new L2OutputOracle({\n            _validatorPool: pool,\n            _validatorManager: valMgr,\n            _colosseum: address(colosseum),\n            _submissionInterval: submissionInterval,\n            _l2BlockTime: l2BlockTime,\n            _startingBlockNumber: startingBlockNumber,\n            _startingTimestamp: startingTimestamp,\n            _finalizationPeriodSeconds: finalizationPeriodSeconds\n        });\n\n        vm.prank(multisig);\n        Proxy(payable(address(pool))).upgradeToAndCall(\n            address(poolImpl),\n            abi.encodeWithSelector(ValidatorPool.initialize.selector)\n        );\n\n        vm.prank(multisig);\n        Proxy(payable(address(assetMgr))).upgradeTo(address(assetMgrImpl));\n\n        vm.prank(multisig);\n        Proxy(payable(address(valMgr))).upgradeTo(address(valMgrImpl));\n\n        vm.prank(multisig);\n        Proxy(payable(address(oracle))).upgradeToAndCall(\n            address(oracleImpl),\n            abi.encodeCall(L2OutputOracle.initialize, (startingBlockNumber, startingTimestamp))\n        );\n\n        // Set the L2ToL1MessagePasser at the correct address\n        vm.etch(Predeploys.L2_TO_L1_MESSAGE_PASSER, address(new L2ToL1MessagePasser()).code);\n\n        vm.label(Predeploys.L2_TO_L1_MESSAGE_PASSER, \"L2ToL1MessagePasser\");\n    }\n\n    function _registerValidator(address validator, uint128 assets) internal {\n        vm.startPrank(validator, validator);\n        assetToken.approve(address(assetMgr), uint256(assets));\n        valMgr.registerValidator(assets, 10, withdrawAcc);\n        vm.stopPrank();\n    }\n\n    function _submitL2OutputV1() internal {\n        warpToSubmitTime();\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        bytes32 outputRoot = keccak256(abi.encode(nextBlockNumber));\n        vm.prank(pool.nextValidator());\n        oracle.submitL2Output(outputRoot, nextBlockNumber, 0, 0);\n    }\n\n    function _submitL2OutputV2(bool isPublicRound) internal {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        bytes32 outputRoot = keccak256(abi.encode(nextBlockNumber));\n        if (!isPublicRound) {\n            vm.prank(valMgr.nextValidator());\n        }\n        oracle.submitL2Output(outputRoot, nextBlockNumber, 0, 0);\n    }\n}\n\ncontract ValidatorSystemUpgrade_Initializer is L2OutputOracle_Initializer {\n    function setUp() public virtual override {\n        super.setUp();\n\n        // The last output index of ValidatorPool is 3, first output index of ValidatorManager is 4\n        terminateOutputIndex = 3;\n        finalizationPeriodSeconds = 2 hours;\n\n        // Deploy L2OutputOracle with new arguments\n        oracleImpl = new L2OutputOracle({\n            _validatorPool: pool,\n            _validatorManager: valMgr,\n            _colosseum: address(colosseum),\n            _submissionInterval: submissionInterval,\n            _l2BlockTime: l2BlockTime,\n            _startingBlockNumber: startingBlockNumber,\n            _startingTimestamp: startingTimestamp,\n            _finalizationPeriodSeconds: finalizationPeriodSeconds\n        });\n        vm.prank(multisig);\n        Proxy(payable(address(oracle))).upgradeTo(address(oracleImpl));\n\n        // Deploy ValidatorPool with new arguments\n        poolImpl = new ValidatorPool({\n            _l2OutputOracle: oracle,\n            _portal: mockPortal,\n            _securityCouncil: guardian,\n            _trustedValidator: trusted,\n            _requiredBondAmount: requiredBondAmount,\n            _maxUnbond: maxUnbond,\n            _roundDuration: roundDuration,\n            _terminateOutputIndex: terminateOutputIndex\n        });\n        vm.prank(multisig);\n        Proxy(payable(address(pool))).upgradeTo(address(poolImpl));\n    }\n}\n\ncontract Poseidon2Deployer {\n    bytes constant poseidon2Code =\n        //solhint-disable-next-line max-line-length\n        hex\"38600c60003961260f6000f37c010000000000000000000000000000000000000000000000000000000060003504806329a5f2f6149063299e566014176200003757fe5b7f109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b6020527f16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e06040527f2b90bba00fca0589f617e7dcbfe82e0df706ab640ceb247b791a93b74e36736d6060527f2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd7716080527f2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe2360a0527f101071f0032379b697315876690f053d148d4e109f5fb065c8aacc55a0f89bfa60c0527f143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a760e0527f176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee2911610100527f19a3fc0a56702bf417ba7fee3802593fa644470307043f7773279cd71d25d5e0610120527f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000016024356004356000837f0ee9a592ba9a9518d05986d656f40c2114c4993c11bb29938d21d47304cd8e6e82089050837f00f1445235f2148c5986587169fc1bcd887b08d4d00868df5696fff40956e86483089150837f08dff3487e8ac99e1f29a058d0fa80b930c728730b7ab36ce879f3890ecf73f58408925083818180828009800909905083828180828009800909915083838180828009800909925062000249600052620025ba565b837f2f27be690fdaee46c3ce28f7532b13c856c35342c84bda6e20966310fadc01d082089050837f2b2ae1acf68b7b8d2416bebf3d4f6234b763fe04b8043ee48b8327bebca16cf283089150837f0319d062072bef7ecca5eac06f97d4d55952c175ab6b03eae64b44c7dbf11cfa84089250838181808280098009099050838281808280098009099150838381808280098009099250620002ec600052620025ba565b837f28813dcaebaeaa828a376df87af4a63bc8b7bf27ad49c6298ef7b387bf28526d82089050837f2727673b2ccbc903f181bf38e1c1d40d2033865200c352bc150928adddf9cb7883089150837f234ec45ca27727c2e74abd2b2a1494cd6efbd43e340587d6b8fb9e31e65cc632840892508381818082800980090990508382818082800980090991508383818082800980090992506200038f600052620025ba565b837f15b52534031ae18f7f862cb2cf7cf760ab10a8150a337b1ccd99ff6e8797d42882089050837f0dc8fad6d9e4b35f5ed9a3d186b79ce38e0e8a8d1b58b132d701d4eecf68d1f683089150837f1bcd95ffc211fbca600f705fad3fb567ea4eb378f62e1fec97805518a47e4d9c8408925083818180828009800909905083828180828009800909915083838180828009800909925062000432600052620025ba565b837f10520b0ab721cadfe9eff81b016fc34dc76da36c2578937817cb978d069de55982089050837f1f6d48149b8e7f7d9b257d8ed5fbbaf42932498075fed0ace88a9eb81f5627f683089150837f1d9655f652309014d29e00ef35a2089bfff8dc1c816f0dc9ca34bdb5460c870584089250838181808280098009099050620004bd600052620025ba565b837f04df5a56ff95bcafb051f7b1cd43a99ba731ff67e47032058fe3d4185697cc7d82089050837f0672d995f8fff640151b3d290cedaf148690a10a8c8424a7f6ec282b6e4be82883089150837f099952b414884454b21200d7ffafdd5f0c9a9dcc06f2708e9fc1d8209b5c75b98408925083818180828009800909905062000548600052620025ba565b837f052cba2255dfd00c7c483143ba8d469448e43586a9b4cd9183fd0e843a6b9fa682089050837f0b8badee690adb8eb0bd74712b7999af82de55707251ad7716077cb93c464ddc83089150837f119b1590f13307af5a1ee651020c07c749c15d60683a8050b963d0a8e4b2bdd184089250838181808280098009099050620005d3600052620025ba565b837f03150b7cd6d5d17b2529d36be0f67b832c4acfc884ef4ee5ce15be0bfb4a8d0982089050837f2cc6182c5e14546e3cf1951f173912355374efb83d80898abe69cb317c9ea56583089150837f005032551e6378c450cfe129a404b3764218cadedac14e2b92d2cd73111bf0f9840892508381818082800980090990506200065e600052620025ba565b837f233237e3289baa34bb147e972ebcb9516469c399fcc069fb88f9da2cc28276b582089050837f05c8f4f4ebd4a6e3c980d31674bfbe6323037f21b34ae5a4e80c2d4c24d6028083089150837f0a7b1db13042d396ba05d818a319f25252bcf35ef3aeed91ee1f09b2590fc65b84089250838181808280098009099050620006e9600052620025ba565b837f2a73b71f9b210cf5b14296572c9d32dbf156e2b086ff47dc5df542365a404ec082089050837f1ac9b0417abcc9a1935107e9ffc91dc3ec18f2c4dbe7f22976a760bb5c50c46083089150837f12c0339ae08374823fabb076707ef479269f3e4d6cb104349015ee046dc93fc08408925083818180828009800909905062000774600052620025ba565b837f0b7475b102a165ad7f5b18db4e1e704f52900aa3253baac68246682e56e9a28e82089050837f037c2849e191ca3edb1c5e49f6e8b8917c843e379366f2ea32ab3aa88d7f844883089150837f05a6811f8556f014e92674661e217e9bd5206c5c93a07dc145fdb176a716346f84089250838181808280098009099050620007ff600052620025ba565b837f29a795e7d98028946e947b75d54e9f044076e87a7b2883b47b675ef5f38bd66e82089050837f20439a0c84b322eb45a3857afc18f5826e8c7382c8a1585c507be199981fd22f83089150837f2e0ba8d94d9ecf4a94ec2050c7371ff1bb50f27799a84b6d4a2a6f2a0982c887840892508381818082800980090990506200088a600052620025ba565b837f143fd115ce08fb27ca38eb7cce822b4517822cd2109048d2e6d0ddcca17d71c882089050837f0c64cbecb1c734b857968dbbdcf813cdf8611659323dbcbfc84323623be9caf183089150837f028a305847c683f646fca925c163ff5ae74f348d62c2b670f1426cef9403da538408925083818180828009800909905062000915600052620025ba565b837f2e4ef510ff0b6fda5fa940ab4c4380f26a6bcb64d89427b824d6755b5db9e30c82089050837f0081c95bc43384e663d79270c956ce3b8925b4f6d033b078b96384f50579400e83089150837f2ed5f0c91cbd9749187e2fade687e05ee2491b349c039a0bba8a9f4023a0bb3884089250838181808280098009099050620009a0600052620025ba565b837f30509991f88da3504bbf374ed5aae2f03448a22c76234c8c990f01f33a73520682089050837f1c3f20fd55409a53221b7c4d49a356b9f0a1119fb2067b41a7529094424ec6ad83089150837f10b4e7f3ab5df003049514459b6e18eec46bb2213e8e131e170887b47ddcb96c8408925083818180828009800909905062000a2b600052620025ba565b837f2a1982979c3ff7f43ddd543d891c2abddd80f804c077d775039aa3502e43adef82089050837f1c74ee64f15e1db6feddbead56d6d55dba431ebc396c9af95cad0f1315bd5c9183089150837f07533ec850ba7f98eab9303cace01b4b9e4f2e8b82708cfa9c2fe45a0ae146a08408925083818180828009800909905062000ab6600052620025ba565b837f21576b438e500449a151e4eeaf17b154285c68f42d42c1808a11abf3764c075082089050837f2f17c0559b8fe79608ad5ca193d62f10bce8384c815f0906743d6930836d4a9e83089150837f2d477e3862d07708a79e8aae946170bc9775a4201318474ae665b0b1b7e2730e8408925083818180828009800909905062000b41600052620025ba565b837f162f5243967064c390e095577984f291afba2266c38f5abcd89be0f5b2747eab82089050837f2b4cb233ede9ba48264ecd2c8ae50d1ad7a8596a87f29f8a7777a7009239331183089150837f2c8fbcb2dd8573dc1dbaf8f4622854776db2eece6d85c4cf4254e7c35e03b07a8408925083818180828009800909905062000bcc600052620025ba565b837f1d6f347725e4816af2ff453f0cd56b199e1b61e9f601e9ade5e88db870949da982089050837f204b0c397f4ebe71ebc2d8b3df5b913df9e6ac02b68d31324cd49af5c456552983089150837f0c4cb9dc3c4fd8174f1149b3c63c3c2f9ecb827cd7dc25534ff8fb75bc79c5028408925083818180828009800909905062000c57600052620025ba565b837f174ad61a1448c899a25416474f4930301e5c49475279e0639a616ddc45bc7b5482089050837f1a96177bcf4d8d89f759df4ec2f3cde2eaaa28c177cc0fa13a9816d49a38d2ef83089150837f066d04b24331d71cd0ef8054bc60c4ff05202c126a233c1a8242ace360b8a30a8408925083818180828009800909905062000ce2600052620025ba565b837f2a4c4fc6ec0b0cf52195782871c6dd3b381cc65f72e02ad527037a62aa1bd80482089050837f13ab2d136ccf37d447e9f2e14a7cedc95e727f8446f6d9d7e55afc01219fd64983089150837f1121552fca26061619d24d843dc82769c1b04fcec26f55194c2e3e869acc6a9a8408925083818180828009800909905062000d6d600052620025ba565b837f00ef653322b13d6c889bc81715c37d77a6cd267d595c4a8909a5546c7c97cff182089050837f0e25483e45a665208b261d8ba74051e6400c776d652595d9845aca35d8a397d383089150837f29f536dcb9dd7682245264659e15d88e395ac3d4dde92d8c46448db979eeba898408925083818180828009800909905062000df8600052620025ba565b837f2a56ef9f2c53febadfda33575dbdbd885a124e2780bbea170e456baace0fa5be82089050837f1c8361c78eb5cf5decfb7a2d17b5c409f2ae2999a46762e8ee416240a8cb9af183089150837f151aff5f38b20a0fc0473089aaf0206b83e8e68a764507bfd3d0ab4be74319c58408925083818180828009800909905062000e83600052620025ba565b837f04c6187e41ed881dc1b239c88f7f9d43a9f52fc8c8b6cdd1e76e47615b51f10082089050837f13b37bd80f4d27fb10d84331f6fb6d534b81c61ed15776449e801b7ddc9c296783089150837f01a5c536273c2d9df578bfbd32c17b7a2ce3664c2a52032c9321ceb1c4e8a8e48408925083818180828009800909905062000f0e600052620025ba565b837f2ab3561834ca73835ad05f5d7acb950b4a9a2c666b9726da832239065b7c3b0282089050837f1d4d8ec291e720db200fe6d686c0d613acaf6af4e95d3bf69f7ed516a597b64683089150837f041294d2cc484d228f5784fe7919fd2bb925351240a04b711514c9c80b65af1d8408925083818180828009800909905062000f99600052620025ba565b837f154ac98e01708c611c4fa715991f004898f57939d126e392042971dd90e81fc682089050837f0b339d8acca7d4f83eedd84093aef51050b3684c88f8b0b04524563bc6ea4da483089150837f0955e49e6610c94254a4f84cfbab344598f0e71eaff4a7dd81ed95b50839c82e8408925083818180828009800909905062001024600052620025ba565b837f06746a6156eba54426b9e22206f15abca9a6f41e6f535c6f3525401ea065462682089050837f0f18f5a0ecd1423c496f3820c549c27838e5790e2bd0a196ac917c7ff32077fb83089150837f04f6eeca1751f7308ac59eff5beb261e4bb563583ede7bc92a738223d6f76e1384089250838181808280098009099050620010af600052620025ba565b837f2b56973364c4c4f5c1a3ec4da3cdce038811eb116fb3e45bc1768d26fc0b375882089050837f123769dd49d5b054dcd76b89804b1bcb8e1392b385716a5d83feb65d437f29ef83089150837f2147b424fc48c80a88ee52b91169aacea989f6446471150994257b2fb01c63e9840892508381818082800980090990506200113a600052620025ba565b837f0fdc1f58548b85701a6c5505ea332a29647e6f34ad4243c2ea54ad897cebe54d82089050837f12373a8251fea004df68abcf0f7786d4bceff28c5dbbe0c3944f685cc0a0b1f283089150837f21e4f4ea5f35f85bad7ea52ff742c9e8a642756b6af44203dd8a1f35c1a9003584089250838181808280098009099050620011c5600052620025ba565b837f16243916d69d2ca3dfb4722224d4c462b57366492f45e90d8a81934f1bc3b14782089050837f1efbe46dd7a578b4f66f9adbc88b4378abc21566e1a0453ca13a4159cac04ac283089150837f07ea5e8537cf5dd08886020e23a7f387d468d5525be66f853b672cc96a88969a8408925083818180828009800909905062001250600052620025ba565b837f05a8c4f9968b8aa3b7b478a30f9a5b63650f19a75e7ce11ca9fe16c0b76c00bc82089050837f20f057712cc21654fbfe59bd345e8dac3f7818c701b9c7882d9d57b72a32e83f83089150837f04a12ededa9dfd689672f8c67fee31636dcd8e88d01d49019bd90b33eb33db6984089250838181808280098009099050620012db600052620025ba565b837f27e88d8c15f37dcee44f1e5425a51decbd136ce5091a6767e49ec9544ccd101a82089050837f2feed17b84285ed9b8a5c8c5e95a41f66e096619a7703223176c41ee433de4d183089150837f1ed7cc76edf45c7c404241420f729cf394e5942911312a0d6972b8bd53aff2b88408925083818180828009800909905062001366600052620025ba565b837f15742e99b9bfa323157ff8c586f5660eac6783476144cdcadf2874be45466b1a82089050837f1aac285387f65e82c895fc6887ddf40577107454c6ec0317284f033f27d0c78583089150837f25851c3c845d4790f9ddadbdb6057357832e2e7a49775f71ec75a96554d67c7784089250838181808280098009099050620013f1600052620025ba565b837f15a5821565cc2ec2ce78457db197edf353b7ebba2c5523370ddccc3d9f146a6782089050837f2411d57a4813b9980efa7e31a1db5966dcf64f36044277502f15485f28c7172783089150837f002e6f8d6520cd4713e335b8c0b6d2e647e9a98e12f4cd2558828b5ef6cb4c9b840892508381818082800980090990506200147c600052620025ba565b837f2ff7bc8f4380cde997da00b616b0fcd1af8f0e91e2fe1ed7398834609e0315d282089050837f00b9831b948525595ee02724471bcd182e9521f6b7bb68f1e93be4febb0d3cbe83089150837f0a2f53768b8ebf6a86913b0e57c04e011ca408648a4743a87d77adbf0c9c35128408925083818180828009800909905062001507600052620025ba565b837f00248156142fd0373a479f91ff239e960f599ff7e94be69b7f2a290305e1198d82089050837f171d5620b87bfb1328cf8c02ab3f0c9a397196aa6a542c2350eb512a2b2bcda983089150837f170a4f55536f7dc970087c7c10d6fad760c952172dd54dd99d1045e4ec34a8088408925083818180828009800909905062001592600052620025ba565b837f29aba33f799fe66c2ef3134aea04336ecc37e38c1cd211ba482eca17e2dbfae182089050837f1e9bc179a4fdd758fdd1bb1945088d47e70d114a03f6a0e8b5ba650369e6497383089150837f1dd269799b660fad58f7f4892dfb0b5afeaad869a9c4b44f9c9e1c43bdaf8f09840892508381818082800980090990506200161d600052620025ba565b837f22cdbc8b70117ad1401181d02e15459e7ccd426fe869c7c95d1dd2cb0f24af3882089050837f0ef042e454771c533a9f57a55c503fcefd3150f52ed94a7cd5ba93b9c7dacefd83089150837f11609e06ad6c8fe2f287f3036037e8851318e8b08a0359a03b304ffca62e828484089250838181808280098009099050620016a8600052620025ba565b837f1166d9e554616dba9e753eea427c17b7fecd58c076dfe42708b08f5b783aa9af82089050837f2de52989431a859593413026354413db177fbf4cd2ac0b56f855a888357ee46683089150837f3006eb4ffc7a85819a6da492f3a8ac1df51aee5b17b8e89d74bf01cf5f71e9ad8408925083818180828009800909905062001733600052620025ba565b837f2af41fbb61ba8a80fdcf6fff9e3f6f422993fe8f0a4639f962344c822514508682089050837f119e684de476155fe5a6b41a8ebc85db8718ab27889e85e781b214bace4827c383089150837f1835b786e2e8925e188bea59ae363537b51248c23828f047cff784b97b3fd80084089250838181808280098009099050620017be600052620025ba565b837f28201a34c594dfa34d794996c6433a20d152bac2a7905c926c40e285ab32eeb682089050837f083efd7a27d1751094e80fefaf78b000864c82eb571187724a761f88c22cc4e783089150837f0b6f88a3577199526158e61ceea27be811c16df7774dd8519e079564f61fd13b8408925083818180828009800909905062001849600052620025ba565b837f0ec868e6d15e51d9644f66e1d6471a94589511ca00d29e1014390e6ee4254f5b82089050837f2af33e3f866771271ac0c9b3ed2e1142ecd3e74b939cd40d00d937ab84c9859183089150837f0b520211f904b5e7d09b5d961c6ace7734568c547dd6858b364ce5e47951f17884089250838181808280098009099050620018d4600052620025ba565b837f0b2d722d0919a1aad8db58f10062a92ea0c56ac4270e822cca228620188a1d4082089050837f1f790d4d7f8cf094d980ceb37c2453e957b54a9991ca38bbe0061d1ed6e562d483089150837f0171eb95dfbf7d1eaea97cd385f780150885c16235a2a6a8da92ceb01e504233840892508381818082800980090990506200195f600052620025ba565b837f0c2d0e3b5fd57549329bf6885da66b9b790b40defd2c8650762305381b16887382089050837f1162fb28689c27154e5a8228b4e72b377cbcafa589e283c35d3803054407a18d83089150837f2f1459b65dee441b64ad386a91e8310f282c5a92a89e19921623ef8249711bc084089250838181808280098009099050620019ea600052620025ba565b837f1e6ff3216b688c3d996d74367d5cd4c1bc489d46754eb712c243f70d1b53cfbb82089050837f01ca8be73832b8d0681487d27d157802d741a6f36cdc2a0576881f932647887583089150837f1f7735706ffe9fc586f976d5bdf223dc680286080b10cea00b9b5de315f9650e8408925083818180828009800909905062001a75600052620025ba565b837f2522b60f4ea3307640a0c2dce041fba921ac10a3d5f096ef4745ca838285f01982089050837f23f0bee001b1029d5255075ddc957f833418cad4f52b6c3f8ce16c235572575b83089150837f2bc1ae8b8ddbb81fcaac2d44555ed5685d142633e9df905f66d9401093082d598408925083818180828009800909905062001b00600052620025ba565b837f0f9406b8296564a37304507b8dba3ed162371273a07b1fc98011fcd6ad72205f82089050837f2360a8eb0cc7defa67b72998de90714e17e75b174a52ee4acb126c8cd995f0a883089150837f15871a5cddead976804c803cbaef255eb4815a5e96df8b006dcbbc2767f889488408925083818180828009800909905062001b8b600052620025ba565b837f193a56766998ee9e0a8652dd2f3b1da0362f4f54f72379544f957ccdeefb420f82089050837f2a394a43934f86982f9be56ff4fab1703b2e63c8ad334834e4309805e777ae0f83089150837f1859954cfeb8695f3e8b635dcb345192892cd11223443ba7b4166e8876c0d1428408925083818180828009800909905062001c16600052620025ba565b837f04e1181763050e58013444dbcb99f1902b11bc25d90bbdca408d3819f4fed32b82089050837f0fdb253dee83869d40c335ea64de8c5bb10eb82db08b5e8b1f5e5552bfd05f2383089150837f058cbe8a9a5027bdaa4efb623adead6275f08686f1c08984a9d7c5bae9b4f1c08408925083818180828009800909905062001ca1600052620025ba565b837f1382edce9971e186497eadb1aeb1f52b23b4b83bef023ab0d15228b4cceca59a82089050837f03464990f045c6ee0819ca51fd11b0be7f61b8eb99f14b77e1e6634601d9e8b583089150837f23f7bfc8720dc296fff33b41f98ff83c6fcab4605db2eb5aaa5bc137aeb70a588408925083818180828009800909905062001d2c600052620025ba565b837f0a59a158e3eec2117e6e94e7f0e9decf18c3ffd5e1531a9219636158bbaf62f282089050837f06ec54c80381c052b58bf23b312ffd3ce2c4eba065420af8f4c23ed0075fd07b83089150837f118872dc832e0eb5476b56648e867ec8b09340f7a7bcb1b4962f0ff9ed1f9d018408925083818180828009800909905062001db7600052620025ba565b837f13d69fa127d834165ad5c7cba7ad59ed52e0b0f0e42d7fea95e1906b520921b182089050837f169a177f63ea681270b1c6877a73d21bde143942fb71dc55fd8a49f19f10c77b83089150837f04ef51591c6ead97ef42f287adce40d93abeb032b922f66ffb7e9a5a7450544d8408925083818180828009800909905062001e42600052620025ba565b837f256e175a1dc079390ecd7ca703fb2e3b19ec61805d4f03ced5f45ee6dd0f69ec82089050837f30102d28636abd5fe5f2af412ff6004f75cc360d3205dd2da002813d3e2ceeb283089150837f10998e42dfcd3bbf1c0714bc73eb1bf40443a3fa99bef4a31fd31be182fcc7928408925083818180828009800909905062001ecd600052620025ba565b837f193edd8e9fcf3d7625fa7d24b598a1d89f3362eaf4d582efecad76f879e3686082089050837f18168afd34f2d915d0368ce80b7b3347d1c7a561ce611425f2664d7aa51f0b5d83089150837f29383c01ebd3b6ab0c017656ebe658b6a328ec77bc33626e29e2e95b33ea61118408925083818180828009800909905062001f58600052620025ba565b837f10646d2f2603de39a1f4ae5e7771a64a702db6e86fb76ab600bf573f9010c71182089050837f0beb5e07d1b27145f575f1395a55bf132f90c25b40da7b3864d0242dcb1117fb83089150837f16d685252078c133dc0d3ecad62b5c8830f95bb2e54b59abdffbf018d96fa3368408925083818180828009800909905062001fe3600052620025ba565b837f0a6abd1d833938f33c74154e0404b4b40a555bbbec21ddfafd672dd62047f01a82089050837f1a679f5d36eb7b5c8ea12a4c2dedc8feb12dffeec450317270a6f19b34cf186083089150837f0980fb233bd456c23974d50e0ebfde4726a423eada4e8f6ffbc7592e3f1b93d6840892508381818082800980090990506200206e600052620025ba565b837f161b42232e61b84cbf1810af93a38fc0cece3d5628c9282003ebacb5c312c72b82089050837f0ada10a90c7f0520950f7d47a60d5e6a493f09787f1564e5d09203db47de1a0b83089150837f1a730d372310ba82320345a29ac4238ed3f07a8a2b4e121bb50ddb9af407f45184089250838181808280098009099050620020f9600052620025ba565b837f2c8120f268ef054f817064c369dda7ea908377feaba5c4dffbda10ef58e8c55682089050837f1c7c8824f758753fa57c00789c684217b930e95313bcb73e6e7b8649a4968f7083089150837f2cd9ed31f5f8691c8e39e4077a74faa0f400ad8b491eb3f7b47b27fa3fd1cf778408925083818180828009800909905062002184600052620025ba565b837f23ff4f9d46813457cf60d92f57618399a5e022ac321ca550854ae23918a22eea82089050837f09945a5d147a4f66ceece6405dddd9d0af5a2c5103529407dff1ea58f180426d83089150837f188d9c528025d4c2b67660c6b771b90f7c7da6eaa29d3f268a6dd223ec6fc630840892508381818082800980090990506200220f600052620025ba565b837f3050e37996596b7f81f68311431d8734dba7d926d3633595e0c0d8ddf4f0f47f82089050837f15af1169396830a91600ca8102c35c426ceae5461e3f95d89d829518d30afd7883089150837f1da6d09885432ea9a06d9f37f873d985dae933e351466b2904284da3320d8acc840892508381818082800980090990506200229a600052620025ba565b837f2796ea90d269af29f5f8acf33921124e4e4fad3dbe658945e546ee411ddaa9cb82089050837f202d7dd1da0f6b4b0325c8b3307742f01e15612ec8e9304a7cb0319e01d32d6083089150837f096d6790d05bb759156a952ba263d672a2d7f9c788f4c831a29dace4c0f8be5f8408925083818180828009800909905062002325600052620025ba565b837f054efa1f65b0fce283808965275d877b438da23ce5b13e1963798cb1447d25a482089050837f1b162f83d917e93edb3308c29802deb9d8aa690113b2e14864ccf6e18e4165f183089150837f21e5241e12564dd6fd9f1cdd2a0de39eedfefc1466cc568ec5ceb745a0506edc84089250838181808280098009099050838281808280098009099150838381808280098009099250620023c8600052620025ba565b837f1cfb5662e8cf5ac9226a80ee17b36abecb73ab5f87e161927b4349e10e4bdf0882089050837f0f21177e302a771bbae6d8d1ecb373b62c99af346220ac0129c53f666eb2410083089150837f1671522374606992affb0dd7f71b12bec4236aede6290546bcef7e1f515c2320840892508381818082800980090990508382818082800980090991508383818082800980090992506200246b600052620025ba565b837f0fa3ec5b9488259c2eb4cf24501bfad9be2ec9e42c5cc8ccd419d2a692cad87082089050837f193c0e04e0bd298357cb266c1506080ed36edce85c648cc085e8c57b1ab54bba83089150837f102adf8ef74735a27e9128306dcbc3c99f6f7291cd406578ce14ea2adaba68f8840892508381818082800980090990508382818082800980090991508383818082800980090992506200250e600052620025ba565b837f0fe0af7858e49859e2a54d6f1ad945b1316aa24bfbdd23ae40a6d0cb70c3eab182089050837f216f6717bbc7dedb08536a2220843f4e2da5f1daa9ebdefde8a5ea7344798d2283089150837f1da55cc900f0d21f4a3e694391918a1b3c23b2ac773c6b3ef88e2e422832516184089250838181808280098009099050838281808280098009099150838381808280098009099250620025b1600052620025ba565b60005260206000f35b8360205182098460405184098591088460605185098591088460805183098560a05185098691088560c05186098691088560e0518409866101005186098791088661012051870987910894509250905060005156\";\n\n    function deployPoseidon2() public returns (address) {\n        return CodeDeployer.deployCode(poseidon2Code);\n    }\n}\n\ncontract Portal_Initializer is L2OutputOracle_Initializer, Poseidon2Deployer {\n    ZKMerkleTrie zkMerkleTrie;\n\n    // Test target\n    KromaPortal portalImpl;\n    KromaPortal portal;\n\n    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);\n    event WithdrawalProven(\n        bytes32 indexed withdrawalHash,\n        address indexed from,\n        address indexed to\n    );\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        vm.deal(trusted, requiredBondAmount * 100);\n        vm.prank(trusted);\n        pool.deposit{ value: trusted.balance }();\n\n        zkMerkleTrie = new ZKMerkleTrie(deployPoseidon2());\n\n        portalImpl = new KromaPortal({\n            _l2Oracle: oracle,\n            _validatorPool: address(pool),\n            _guardian: guardian,\n            _paused: true,\n            _config: systemConfig,\n            _zkMerkleTrie: zkMerkleTrie\n        });\n        Proxy proxy = new Proxy(multisig);\n        vm.prank(multisig);\n        proxy.upgradeToAndCall(\n            address(portalImpl),\n            abi.encodeWithSelector(KromaPortal.initialize.selector, false)\n        );\n        portal = KromaPortal(payable(address(proxy)));\n        vm.label(address(portal), \"KromaPortal\");\n    }\n}\n\ncontract Messenger_Initializer is Portal_Initializer {\n    L1CrossDomainMessenger L1Messenger;\n    L2CrossDomainMessenger L2Messenger =\n        L2CrossDomainMessenger(Predeploys.L2_CROSS_DOMAIN_MESSENGER);\n\n    event SentMessage(\n        address indexed target,\n        address indexed sender,\n        uint256 value,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n\n    event MessagePassed(\n        uint256 indexed nonce,\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes data,\n        bytes32 withdrawalHash\n    );\n\n    event RelayedMessage(bytes32 indexed msgHash);\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 mint,\n        uint256 value,\n        uint64 gasLimit,\n        bool isCreation,\n        bytes data\n    );\n\n    event WhatHappened(bool success, bytes returndata);\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        // Setup implementation\n        L1CrossDomainMessenger L1MessengerImpl = new L1CrossDomainMessenger(portal);\n\n        // Setup proxy\n        Proxy proxy = new Proxy(multisig);\n        vm.prank(multisig);\n        proxy.upgradeToAndCall(\n            address(L1MessengerImpl),\n            abi.encodeCall(L1Messenger.initialize, ())\n        );\n        L1Messenger = L1CrossDomainMessenger(address(proxy));\n\n        vm.etch(\n            Predeploys.L2_CROSS_DOMAIN_MESSENGER,\n            address(new L2CrossDomainMessenger(address(L1Messenger))).code\n        );\n\n        L2Messenger.initialize();\n\n        // Label addresses\n        vm.label(address(L1MessengerImpl), \"L1CrossDomainMessenger_Impl\");\n        vm.label(Predeploys.L2_CROSS_DOMAIN_MESSENGER, \"L2CrossDomainMessenger\");\n\n        vm.label(\n            AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)),\n            \"L1CrossDomainMessenger_aliased\"\n        );\n    }\n}\n\ncontract Bridge_Initializer is Messenger_Initializer {\n    L1StandardBridge L1Bridge;\n    L2StandardBridge L2Bridge;\n    KromaMintableERC20Factory L2TokenFactory;\n    KromaMintableERC20Factory L1TokenFactory;\n    ERC20 L1Token;\n    ERC20 BadL1Token;\n    KromaMintableERC20 L2Token;\n    ERC20 NativeL2Token;\n    ERC20 BadL2Token;\n    KromaMintableERC20 RemoteL1Token;\n\n    event DepositFailed(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    event ETHBridgeInitiated(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    event ETHBridgeFinalized(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    event ERC20BridgeInitiated(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    event ERC20BridgeFinalized(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        vm.label(Predeploys.L2_STANDARD_BRIDGE, \"L2StandardBridge\");\n        vm.label(Predeploys.KROMA_MINTABLE_ERC20_FACTORY, \"KromaMintableERC20Factory\");\n\n        // Deploy the L1 bridge and initialize it with the address of the\n        // L1CrossDomainMessenger\n        L1StandardBridge L1Bridge_Impl = new L1StandardBridge(payable(address(L1Messenger)));\n        Proxy proxy = new Proxy(multisig);\n        vm.prank(multisig);\n        proxy.upgradeTo(address(L1Bridge_Impl));\n\n        L1Bridge = L1StandardBridge(payable(address(proxy)));\n\n        vm.label(address(proxy), \"L1StandardBridge_Proxy\");\n        vm.label(address(L1Bridge_Impl), \"L1StandardBridge_Impl\");\n\n        // Deploy the L2StandardBridge, move it to the correct predeploy\n        // address and then initialize it\n        L2StandardBridge l2B = new L2StandardBridge(payable(proxy));\n        vm.etch(Predeploys.L2_STANDARD_BRIDGE, address(l2B).code);\n        L2Bridge = L2StandardBridge(payable(Predeploys.L2_STANDARD_BRIDGE));\n\n        // Set up the L2 mintable token factory\n        KromaMintableERC20Factory factory = new KromaMintableERC20Factory(\n            Predeploys.L2_STANDARD_BRIDGE\n        );\n        vm.etch(Predeploys.KROMA_MINTABLE_ERC20_FACTORY, address(factory).code);\n        L2TokenFactory = KromaMintableERC20Factory(Predeploys.KROMA_MINTABLE_ERC20_FACTORY);\n\n        L1Token = new ERC20(\"Native L1 Token\", \"L1T\");\n\n        // Deploy the L2 ERC20 now\n        L2Token = KromaMintableERC20(\n            L2TokenFactory.createKromaMintableERC20(\n                address(L1Token),\n                string(abi.encodePacked(\"L2-\", L1Token.name())),\n                string(abi.encodePacked(\"L2-\", L1Token.symbol()))\n            )\n        );\n\n        BadL2Token = KromaMintableERC20(\n            L2TokenFactory.createKromaMintableERC20(\n                address(1),\n                string(abi.encodePacked(\"L2-\", L1Token.name())),\n                string(abi.encodePacked(\"L2-\", L1Token.symbol()))\n            )\n        );\n\n        NativeL2Token = new ERC20(\"Native L2 Token\", \"L2T\");\n        L1TokenFactory = new KromaMintableERC20Factory(address(L1Bridge));\n\n        RemoteL1Token = KromaMintableERC20(\n            L1TokenFactory.createKromaMintableERC20(\n                address(NativeL2Token),\n                string(abi.encodePacked(\"L1-\", NativeL2Token.name())),\n                string(abi.encodePacked(\"L1-\", NativeL2Token.symbol()))\n            )\n        );\n\n        BadL1Token = KromaMintableERC20(\n            L1TokenFactory.createKromaMintableERC20(\n                address(1),\n                string(abi.encodePacked(\"L1-\", NativeL2Token.name())),\n                string(abi.encodePacked(\"L1-\", NativeL2Token.symbol()))\n            )\n        );\n    }\n}\n\ncontract ERC721Bridge_Initializer is Messenger_Initializer {\n    L1ERC721Bridge L1Bridge;\n    L2ERC721Bridge L2Bridge;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        // Deploy the L1ERC721Bridge.\n        L1Bridge = new L1ERC721Bridge(address(L1Messenger), Predeploys.L2_ERC721_BRIDGE);\n\n        // Deploy the implementation for the L2ERC721Bridge and etch it into the predeploy address.\n        vm.etch(\n            Predeploys.L2_ERC721_BRIDGE,\n            address(new L2ERC721Bridge(Predeploys.L2_CROSS_DOMAIN_MESSENGER, address(L1Bridge)))\n                .code\n        );\n\n        // Set up a reference to the L2ERC721Bridge.\n        L2Bridge = L2ERC721Bridge(Predeploys.L2_ERC721_BRIDGE);\n\n        // Label the L1 and L2 bridges.\n        vm.label(address(L1Bridge), \"L1ERC721Bridge\");\n        vm.label(address(L2Bridge), \"L2ERC721Bridge\");\n    }\n}\n\ncontract Colosseum_Initializer is Portal_Initializer {\n    uint256 immutable CHAIN_ID = 901;\n    bytes32 immutable DUMMY_HASH =\n        hex\"a1235b834d6f1f78f78bc4db856fbc49302cce2c519921347600693021e087f7\";\n    uint256 immutable MAX_TXS = 100;\n\n    // Test target\n    Colosseum colosseumImpl;\n\n    ZKVerifier zkVerifier;\n    ZKVerifier zkVerifierImpl;\n\n    SecurityCouncil securityCouncilImpl;\n    SecurityCouncil securityCouncil;\n\n    uint256[] segmentsLengths;\n\n    // Constructor arguments\n    uint256 internal creationPeriodSeconds = finalizationPeriodSeconds - 1 days;\n    uint256 internal bisectionTimeout = 30 minutes;\n    uint256 internal provingTimeout = 1 hours;\n\n    function setUp() public virtual override {\n        // Deploy the ZKVerifier\n        // Chain ID 901\n        Proxy verifierProxy = new Proxy(multisig);\n        zkVerifier = ZKVerifier(payable(address(verifierProxy)));\n        zkVerifierImpl = new ZKVerifier({\n            _hashScalar: 320249733861363579233664122910275244776871682298041722259709713127865988266,\n            _m56Px: 10562523051222313722242598090009468995962797550620498875847381887161707868237,\n            _m56Py: 9513303426200664798836374236127670900315412118702790832382598252192654200761\n        });\n        vm.prank(multisig);\n        verifierProxy.upgradeTo(address(zkVerifierImpl));\n\n        // case - L2OutputOracle submissionInterval == 1800\n        segmentsLengths.push(9);\n        segmentsLengths.push(6);\n        segmentsLengths.push(10);\n        segmentsLengths.push(6);\n\n        colosseum = Colosseum(payable(address(new Proxy(multisig))));\n\n        // Init L2OutputOracle after Colosseum contract deployment\n        super.setUp();\n\n        // Deploy the SecurityCouncil (after Colosseum contract deployment)\n        securityCouncil = SecurityCouncil(address(new Proxy(multisig)));\n        securityCouncilImpl = new SecurityCouncil(\n            address(colosseum),\n            payable(address(upgradeGovernor))\n        );\n        vm.prank(multisig);\n        toProxy(address(securityCouncil)).upgradeTo(address(securityCouncilImpl));\n\n        colosseumImpl = new Colosseum({\n            _l2Oracle: oracle,\n            _zkVerifier: zkVerifier,\n            _submissionInterval: submissionInterval,\n            _creationPeriodSeconds: creationPeriodSeconds,\n            _bisectionTimeout: bisectionTimeout,\n            _provingTimeout: provingTimeout,\n            _dummyHash: DUMMY_HASH,\n            _maxTxs: MAX_TXS,\n            _segmentsLengths: segmentsLengths,\n            _securityCouncil: address(securityCouncil),\n            _zkMerkleTrie: address(zkMerkleTrie)\n        });\n        vm.prank(multisig);\n        toProxy(address(colosseum)).upgradeToAndCall(\n            address(colosseumImpl),\n            abi.encodeCall(Colosseum.initialize, segmentsLengths)\n        );\n    }\n}\n\ncontract SecurityCouncil_Initializer is UpgradeGovernor_Initializer {\n    address colosseum = makeAddr(\"colosseum\");\n    SecurityCouncil securityCouncil;\n    SecurityCouncil securityCouncilImpl;\n\n    function setUp() public virtual override {\n        super.setUp();\n        securityCouncil = SecurityCouncil(address(new Proxy(multisig)));\n        securityCouncilImpl = new SecurityCouncil(colosseum, payable(address(upgradeGovernor)));\n        vm.prank(multisig);\n        toProxy(address(securityCouncil)).upgradeTo(address(securityCouncilImpl));\n    }\n}\n\ncontract FFIInterface is Test {\n    function getProveWithdrawalTransactionInputs(\n        Types.WithdrawalTransaction memory _tx\n    ) external returns (bytes32, bytes32, bytes32, bytes32, bytes[] memory) {\n        string[] memory cmds = new string[](9);\n        cmds[0] = \"scripts/go-ffi/go-ffi\";\n        cmds[1] = \"diff\";\n        cmds[2] = \"getProveWithdrawalTransactionInputs\";\n        cmds[3] = vm.toString(_tx.nonce);\n        cmds[4] = vm.toString(_tx.sender);\n        cmds[5] = vm.toString(_tx.target);\n        cmds[6] = vm.toString(_tx.value);\n        cmds[7] = vm.toString(_tx.gasLimit);\n        cmds[8] = vm.toString(_tx.data);\n\n        bytes memory result = vm.ffi(cmds);\n        (\n            bytes32 stateRoot,\n            bytes32 storageRoot,\n            bytes32 outputRoot,\n            bytes32 withdrawalHash,\n            bytes[] memory withdrawalProof\n        ) = abi.decode(result, (bytes32, bytes32, bytes32, bytes32, bytes[]));\n\n        return (stateRoot, storageRoot, outputRoot, withdrawalHash, withdrawalProof);\n    }\n\n    function hashCrossDomainMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external returns (bytes32) {\n        string[] memory cmds = new string[](9);\n        cmds[0] = \"scripts/go-ffi/go-ffi\";\n        cmds[1] = \"diff\";\n        cmds[2] = \"hashCrossDomainMessage\";\n        cmds[3] = vm.toString(_nonce);\n        cmds[4] = vm.toString(_sender);\n        cmds[5] = vm.toString(_target);\n        cmds[6] = vm.toString(_value);\n        cmds[7] = vm.toString(_gasLimit);\n        cmds[8] = vm.toString(_data);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes32));\n    }\n\n    function hashWithdrawal(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external returns (bytes32) {\n        string[] memory cmds = new string[](9);\n        cmds[0] = \"scripts/go-ffi/go-ffi\";\n        cmds[1] = \"diff\";\n        cmds[2] = \"hashWithdrawal\";\n        cmds[3] = vm.toString(_nonce);\n        cmds[4] = vm.toString(_sender);\n        cmds[5] = vm.toString(_target);\n        cmds[6] = vm.toString(_value);\n        cmds[7] = vm.toString(_gasLimit);\n        cmds[8] = vm.toString(_data);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes32));\n    }\n\n    function hashOutputRootProof(\n        bytes32 _version,\n        bytes32 _stateRoot,\n        bytes32 _messagePasserStorageRoot,\n        bytes32 _blockhash,\n        bytes32 _nextBlockhash\n    ) external returns (bytes32) {\n        string[] memory cmds = new string[](8);\n        cmds[0] = \"scripts/go-ffi/go-ffi\";\n        cmds[1] = \"diff\";\n        cmds[2] = \"hashOutputRootProof\";\n        cmds[3] = Strings.toHexString(uint256(_version));\n        cmds[4] = Strings.toHexString(uint256(_stateRoot));\n        cmds[5] = Strings.toHexString(uint256(_messagePasserStorageRoot));\n        cmds[6] = Strings.toHexString(uint256(_blockhash));\n        cmds[7] = Strings.toHexString(uint256(_nextBlockhash));\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes32));\n    }\n\n    function hashDepositTransaction(\n        address _from,\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gas,\n        bytes memory _data,\n        uint64 _logIndex\n    ) external returns (bytes32) {\n        string[] memory cmds = new string[](11);\n        cmds[0] = \"scripts/go-ffi/go-ffi\";\n        cmds[1] = \"diff\";\n        cmds[2] = \"hashDepositTransaction\";\n        cmds[3] = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n        cmds[4] = vm.toString(_logIndex);\n        cmds[5] = vm.toString(_from);\n        cmds[6] = vm.toString(_to);\n        cmds[7] = vm.toString(_mint);\n        cmds[8] = vm.toString(_value);\n        cmds[9] = vm.toString(_gas);\n        cmds[10] = vm.toString(_data);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes32));\n    }\n\n    function encodeDepositTransaction(\n        Types.UserDepositTransaction calldata txn\n    ) external returns (bytes memory) {\n        string[] memory cmds = new string[](12);\n        cmds[0] = \"scripts/go-ffi/go-ffi\";\n        cmds[1] = \"diff\";\n        cmds[2] = \"encodeDepositTransaction\";\n        cmds[3] = vm.toString(txn.from);\n        cmds[4] = vm.toString(txn.to);\n        cmds[5] = vm.toString(txn.value);\n        cmds[6] = vm.toString(txn.mint);\n        cmds[7] = vm.toString(txn.gasLimit);\n        cmds[8] = vm.toString(txn.isCreation);\n        cmds[9] = vm.toString(txn.data);\n        cmds[10] = vm.toString(txn.l1BlockHash);\n        cmds[11] = vm.toString(txn.logIndex);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes));\n    }\n\n    function encodeCrossDomainMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external returns (bytes memory) {\n        string[] memory cmds = new string[](9);\n        cmds[0] = \"scripts/go-ffi/go-ffi\";\n        cmds[1] = \"diff\";\n        cmds[2] = \"encodeCrossDomainMessage\";\n        cmds[3] = vm.toString(_nonce);\n        cmds[4] = vm.toString(_sender);\n        cmds[5] = vm.toString(_target);\n        cmds[6] = vm.toString(_value);\n        cmds[7] = vm.toString(_gasLimit);\n        cmds[8] = vm.toString(_data);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes));\n    }\n\n    function decodeVersionedNonce(uint256 nonce) external returns (uint256, uint256) {\n        string[] memory cmds = new string[](4);\n        cmds[0] = \"scripts/go-ffi/go-ffi\";\n        cmds[1] = \"diff\";\n        cmds[2] = \"decodeVersionedNonce\";\n        cmds[3] = vm.toString(nonce);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (uint256, uint256));\n    }\n\n    function getMerkleTrieFuzzCase(\n        string memory variant\n    ) external returns (bytes32, bytes memory, bytes memory, bytes[] memory) {\n        string[] memory cmds = new string[](3);\n        cmds[0] = \"./scripts/go-ffi/go-ffi\";\n        cmds[1] = \"trie\";\n        cmds[2] = variant;\n\n        return abi.decode(vm.ffi(cmds), (bytes32, bytes, bytes, bytes[]));\n    }\n}\n\n// Used for testing a future upgrade beyond the current implementations.\n// We include some variables so that we can sanity check accessing storage values after an upgrade.\ncontract NextImpl is Initializable {\n    // Initializable occupies the zero-th slot.\n    bytes32 slot1;\n    bytes32[19] __gap;\n    bytes32 slot21;\n    bytes32 public constant slot21Init = bytes32(hex\"1337\");\n\n    function initialize() public reinitializer(2) {\n        // Slot21 is unused by an of our upgradeable contracts.\n        // This is used to verify that we can access this value after an upgrade.\n        slot21 = slot21Init;\n    }\n}\n\ncontract Reverter {\n    fallback() external {\n        revert();\n    }\n}\n\n// Useful for testing reentrancy guards\ncontract CallerCaller {\n    event WhatHappened(bool success, bytes returndata);\n\n    fallback() external {\n        (bool success, bytes memory returndata) = msg.sender.call(msg.data);\n        emit WhatHappened(success, returndata);\n        assembly {\n            switch success\n            case 0 {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n            default {\n                return(add(returndata, 0x20), mload(returndata))\n            }\n        }\n    }\n}\n\n// Used for testing the `CrossDomainMessenger`'s per-message reentrancy guard.\ncontract ConfigurableCaller {\n    bool doRevert = true;\n    address target;\n    bytes payload;\n\n    event WhatHappened(bool success, bytes returndata);\n\n    /**\n     * @notice Call the configured target with the configured payload OR revert.\n     */\n    function call() external {\n        if (doRevert) {\n            revert(\"ConfigurableCaller: revert\");\n        } else {\n            (bool success, bytes memory returndata) = address(target).call(payload);\n            emit WhatHappened(success, returndata);\n            assembly {\n                switch success\n                case 0 {\n                    revert(add(returndata, 0x20), mload(returndata))\n                }\n                default {\n                    return(add(returndata, 0x20), mload(returndata))\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Set whether or not to have `call` revert.\n     */\n    function setDoRevert(bool _doRevert) external {\n        doRevert = _doRevert;\n    }\n\n    /**\n     * @notice Set the target for the call made in `call`.\n     */\n    function setTarget(address _target) external {\n        target = _target;\n    }\n\n    /**\n     * @notice Set the payload for the call made in `call`.\n     */\n    function setPayload(bytes calldata _payload) external {\n        payload = _payload;\n    }\n\n    /**\n     * @notice Fallback function that reverts if `doRevert` is true.\n     *         Otherwise, it does nothing.\n     */\n    fallback() external {\n        if (doRevert) {\n            revert(\"ConfigurableCaller: revert\");\n        }\n    }\n}\n"
    },
    "contracts/test/CrossDomainMessenger.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n// Libraries\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\nimport { Messenger_Initializer, Reverter, CallerCaller, CommonTest } from \"./CommonTest.t.sol\";\n\n// CrossDomainMessenger_Test is for testing functionality which is common to both the L1 and L2\n// CrossDomainMessenger contracts. For simplicity, we use the L1 Messenger as the test contract.\ncontract CrossDomainMessenger_BaseGas_Test is Messenger_Initializer {\n    // Ensure that baseGas passes for the max value of _minGasLimit,\n    // this is about 4 Billion.\n    function test_baseGas_succeeds() external view {\n        L1Messenger.baseGas(hex\"ff\", type(uint32).max);\n    }\n\n    // Fuzz for other values which might cause a revert in baseGas.\n    function testFuzz_baseGas_succeeds(uint32 _minGasLimit) external view {\n        L1Messenger.baseGas(hex\"ff\", _minGasLimit);\n    }\n}\n\n/**\n * @title ExternalRelay\n * @notice A mock external contract called via the SafeCall inside\n *         the CrossDomainMessenger's `relayMessage` function.\n */\ncontract ExternalRelay is CommonTest {\n    address internal portal;\n    address internal fuzzedSender;\n    L1CrossDomainMessenger internal L1Messenger;\n\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    constructor(L1CrossDomainMessenger _l1Messenger, address _portal) {\n        L1Messenger = _l1Messenger;\n        portal = _portal;\n    }\n\n    /**\n     * @notice Internal helper function to relay a message and perform assertions.\n     */\n    function _internalRelay(address _innerSender) internal {\n        address initialSender = L1Messenger.xDomainMessageSender();\n\n        bytes memory callMessage = getCallData();\n\n        bytes32 hash = Hashing.hashCrossDomainMessage({\n            _nonce: Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            _sender: _innerSender,\n            _target: address(this),\n            _value: 0,\n            _gasLimit: 0,\n            _data: callMessage\n        });\n\n        vm.expectEmit(true, true, true, true);\n        emit FailedRelayedMessage(hash);\n\n        vm.prank(address(portal));\n        L1Messenger.relayMessage({\n            _nonce: Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            _sender: _innerSender,\n            _target: address(this),\n            _value: 0,\n            _minGasLimit: 0,\n            _message: callMessage\n        });\n\n        assertTrue(L1Messenger.failedMessages(hash));\n        assertFalse(L1Messenger.successfulMessages(hash));\n        assertEq(initialSender, L1Messenger.xDomainMessageSender());\n    }\n\n    /**\n     * @notice externalCallWithMinGas is called by the CrossDomainMessenger.\n     */\n    function externalCallWithMinGas() external payable {\n        for (uint256 i = 0; i < 10; i++) {\n            address _innerSender;\n            unchecked {\n                _innerSender = address(uint160(uint256(uint160(fuzzedSender)) + i));\n            }\n            _internalRelay(_innerSender);\n        }\n    }\n\n    /**\n     * @notice Helper function to get the callData for an `externalCallWithMinGas`.\n     */\n    function getCallData() public pure returns (bytes memory) {\n        return abi.encodeWithSelector(ExternalRelay.externalCallWithMinGas.selector);\n    }\n\n    /**\n     * @notice Helper function to set the fuzzed sender.\n     */\n    function setFuzzedSender(address _fuzzedSender) public {\n        fuzzedSender = _fuzzedSender;\n    }\n}\n\n/**\n * @title CrossDomainMessenger_RelayMessage_Test\n * @notice Fuzz tests re-entrancy into the CrossDomainMessenger relayMessage function.\n */\ncontract CrossDomainMessenger_RelayMessage_Test is Messenger_Initializer {\n    // Storage slot of the l2Sender\n    uint256 constant senderSlotIndex = 50;\n\n    ExternalRelay public er;\n\n    function setUp() public override {\n        super.setUp();\n        er = new ExternalRelay(L1Messenger, address(portal));\n    }\n\n    /**\n     * @dev This test mocks an KromaPortal call to the L1CrossDomainMessenger via\n     *      the relayMessage function. The relayMessage function will then use SafeCall's\n     *      callWithMinGas to call the target with call data packed in the callMessage.\n     *      For this test, the callWithMinGas will call the mock ExternalRelay test contract\n     *      defined above, executing the externalCallWithMinGas function which will try to\n     *      re-enter the CrossDomainMessenger's relayMessage function, resulting in that message\n     *      being recorded as failed.\n     */\n    function testFuzz_relayMessageReenter_succeeds(address _sender, uint256 _gasLimit) external {\n        vm.assume(_sender != Predeploys.L2_CROSS_DOMAIN_MESSENGER);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        er.setFuzzedSender(_sender);\n        address target = address(er);\n        bytes memory callMessage = er.getCallData();\n\n        vm.expectCall(target, callMessage);\n\n        uint64 gasLimit = uint64(bound(_gasLimit, 0, 30_000_000));\n\n        bytes32 hash = Hashing.hashCrossDomainMessage({\n            _nonce: Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            _sender: sender,\n            _target: target,\n            _value: 0,\n            _gasLimit: gasLimit,\n            _data: callMessage\n        });\n\n        // Set the value of portal.l2Sender() to be the L2 Cross Domain Messenger\n        vm.store(address(portal), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n        vm.prank(address(portal));\n        L1Messenger.relayMessage({\n            _nonce: Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            _sender: sender,\n            _target: target,\n            _value: 0,\n            _minGasLimit: gasLimit,\n            _message: callMessage\n        });\n\n        assertTrue(L1Messenger.successfulMessages(hash));\n        assertEq(L1Messenger.failedMessages(hash), false);\n\n        // Ensures that the `xDomainMsgSender` is set back to `Predeploys.L2_CROSS_DOMAIN_MESSENGER`\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L1Messenger.xDomainMessageSender();\n    }\n}\n"
    },
    "contracts/test/CrossDomainOwnable.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\nimport { Vm, VmSafe } from \"forge-std/Vm.sol\";\n\nimport { CrossDomainOwnable } from \"../L2/CrossDomainOwnable.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { CommonTest, Portal_Initializer } from \"./CommonTest.t.sol\";\n\ncontract XDomainSetter is CrossDomainOwnable {\n    uint256 public value;\n\n    function set(uint256 _value) external onlyOwner {\n        value = _value;\n    }\n}\n\ncontract CrossDomainOwnable_Test is CommonTest {\n    XDomainSetter setter;\n\n    function setUp() public override {\n        super.setUp();\n        setter = new XDomainSetter();\n    }\n\n    // Check that the revert message is correct\n    function test_onlyOwner_notOwner_reverts() external {\n        vm.expectRevert(\"CrossDomainOwnable: caller is not the owner\");\n        setter.set(1);\n    }\n\n    // Check that making a call can set the value properly\n    function test_onlyOwner_succeeds() external {\n        assertEq(setter.value(), 0);\n\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(setter.owner()));\n        setter.set(1);\n        assertEq(setter.value(), 1);\n    }\n}\n\ncontract CrossDomainOwnableThroughPortal_Test is Portal_Initializer {\n    XDomainSetter setter;\n\n    function setUp() public override {\n        super.setUp();\n\n        vm.prank(alice);\n        setter = new XDomainSetter();\n    }\n\n    function test_depositTransaction_crossDomainOwner_succeeds() external {\n        vm.recordLogs();\n\n        vm.prank(alice);\n        portal.depositTransaction({\n            _to: address(setter),\n            _value: 0,\n            _gasLimit: 21_000,\n            _isCreation: false,\n            _data: abi.encodeWithSelector(XDomainSetter.set.selector, 1)\n        });\n\n        // Simulate the operation of the `kroma-node` by parsing data\n        // from logs\n        VmSafe.Log[] memory logs = vm.getRecordedLogs();\n        // Only 1 log emitted\n        assertEq(logs.length, 1);\n\n        VmSafe.Log memory log = logs[0];\n\n        // It is the expected topic\n        bytes32 topic = log.topics[0];\n        assertEq(topic, keccak256(\"TransactionDeposited(address,address,uint256,bytes)\"));\n\n        // from is indexed and the first argument to the event.\n        bytes32 _from = log.topics[1];\n        address from = Bytes32AddressLib.fromLast20Bytes(_from);\n\n        assertEq(AddressAliasHelper.undoL1ToL2Alias(from), alice);\n\n        // Make a call from the \"from\" value received from the log.\n        // In theory the opaque data could be parsed from the log\n        // and passed to a low level call to \"to\", but calling set\n        // directly on the setter is good enough.\n        vm.prank(from);\n        setter.set(1);\n        assertEq(setter.value(), 1);\n    }\n}\n"
    },
    "contracts/test/CrossDomainOwnable2.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\n\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { CrossDomainOwnable2 } from \"../L2/CrossDomainOwnable2.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { CommonTest, Messenger_Initializer } from \"./CommonTest.t.sol\";\n\ncontract XDomainSetter2 is CrossDomainOwnable2 {\n    uint256 public value;\n\n    function set(uint256 _value) external onlyOwner {\n        value = _value;\n    }\n}\n\ncontract CrossDomainOwnable2_Test is Messenger_Initializer {\n    XDomainSetter2 setter;\n\n    function setUp() public override {\n        super.setUp();\n        vm.prank(alice);\n        setter = new XDomainSetter2();\n    }\n\n    function test_onlyOwner_notMessenger_reverts() external {\n        vm.expectRevert(\"CrossDomainOwnable2: caller is not the messenger\");\n        setter.set(1);\n    }\n\n    function test_onlyOwner_notOwner_reverts() external {\n        // set the xDomainMsgSender storage slot\n        bytes32 key = bytes32(uint256(102));\n        bytes32 value = Bytes32AddressLib.fillLast12Bytes(address(alice));\n        vm.store(address(L2Messenger), key, value);\n\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"CrossDomainOwnable2: caller is not the owner\");\n        setter.set(1);\n    }\n\n    function test_onlyOwner_notOwner2_reverts() external {\n        uint240 nonce = 0;\n        address sender = bob;\n        address target = address(setter);\n        uint256 value = 0;\n        uint256 minGasLimit = 0;\n        bytes memory message = abi.encodeWithSelector(XDomainSetter2.set.selector, 1);\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: nonce, _version: 0 }),\n            sender,\n            target,\n            value,\n            minGasLimit,\n            message\n        );\n\n        // It should be a failed message. The revert is caught,\n        // so we cannot expectRevert here.\n        vm.expectEmit(true, true, true, true);\n        emit FailedRelayedMessage(hash);\n\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: nonce, _version: 0 }),\n            sender,\n            target,\n            value,\n            minGasLimit,\n            message\n        );\n\n        assertEq(setter.value(), 0);\n    }\n\n    function test_onlyOwner_succeeds() external {\n        address owner = setter.owner();\n\n        // Simulate the L2 execution where the call is coming from\n        // the L1CrossDomainMessenger\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 1, _version: 0 }),\n            owner,\n            address(setter),\n            0,\n            0,\n            abi.encodeWithSelector(XDomainSetter2.set.selector, 2)\n        );\n\n        assertEq(setter.value(), 2);\n    }\n}\n"
    },
    "contracts/test/CrossDomainOwnable3.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\n\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { CrossDomainOwnable3 } from \"../L2/CrossDomainOwnable3.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { CommonTest, Messenger_Initializer } from \"./CommonTest.t.sol\";\n\ncontract XDomainSetter3 is CrossDomainOwnable3 {\n    uint256 public value;\n\n    function set(uint256 _value) external onlyOwner {\n        value = _value;\n    }\n}\n\ncontract CrossDomainOwnable3_Test is Messenger_Initializer {\n    XDomainSetter3 setter;\n\n    /**\n     * @notice OpenZeppelin Ownable.sol transferOwnership event\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @notice CrossDomainOwnable3.sol transferOwnership event\n     */\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner,\n        bool isLocal\n    );\n\n    function setUp() public override {\n        super.setUp();\n        vm.prank(alice);\n        setter = new XDomainSetter3();\n    }\n\n    function test_constructor_succeeds() public {\n        assertEq(setter.owner(), alice);\n        assertEq(setter.isLocal(), true);\n    }\n\n    function test_localOnlyOwner_notOwner_reverts() public {\n        vm.prank(bob);\n        vm.expectRevert(\"CrossDomainOwnable3: caller is not the owner\");\n        setter.set(1);\n    }\n\n    function test_transferOwnership_notOwner_reverts() public {\n        vm.prank(bob);\n        vm.expectRevert(\"CrossDomainOwnable3: caller is not the owner\");\n        setter.transferOwnership({ _owner: bob, _isLocal: true });\n    }\n\n    function test_crossDomainOnlyOwner_notOwner_reverts() public {\n        vm.expectEmit(true, true, true, true);\n\n        // OpenZeppelin Ownable.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice);\n\n        // CrossDomainOwnable3.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice, false);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership({ _owner: alice, _isLocal: false });\n\n        // set the xDomainMsgSender storage slot\n        bytes32 key = bytes32(uint256(102));\n        bytes32 value = Bytes32AddressLib.fillLast12Bytes(bob);\n        vm.store(address(L2Messenger), key, value);\n\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"CrossDomainOwnable3: caller is not the owner\");\n        setter.set(1);\n    }\n\n    function test_crossDomainOnlyOwner_notOwner2_reverts() public {\n        vm.expectEmit(true, true, true, true);\n\n        // OpenZeppelin Ownable.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice);\n\n        // CrossDomainOwnable3.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice, false);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership({ _owner: alice, _isLocal: false });\n\n        assertEq(setter.isLocal(), false);\n\n        uint240 nonce = 0;\n        address sender = bob;\n        address target = address(setter);\n        uint256 value = 0;\n        uint256 minGasLimit = 0;\n        bytes memory message = abi.encodeWithSelector(XDomainSetter3.set.selector, 1);\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: nonce, _version: 0 }),\n            sender,\n            target,\n            value,\n            minGasLimit,\n            message\n        );\n\n        // It should be a failed message. The revert is caught,\n        // so we cannot expectRevert here.\n        vm.expectEmit(true, true, true, true, address(L2Messenger));\n        emit FailedRelayedMessage(hash);\n\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: nonce, _version: 0 }),\n            sender,\n            target,\n            value,\n            minGasLimit,\n            message\n        );\n\n        assertEq(setter.value(), 0);\n    }\n\n    function test_crossDomainOnlyOwner_notMessenger_reverts() public {\n        vm.expectEmit(true, true, true, true);\n\n        // OpenZeppelin Ownable.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice);\n\n        // CrossDomainOwnable3.sol transferOwnership event\n        emit OwnershipTransferred(alice, alice, false);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership({ _owner: alice, _isLocal: false });\n\n        vm.prank(bob);\n        vm.expectRevert(\"CrossDomainOwnable3: caller is not the messenger\");\n        setter.set(1);\n    }\n\n    function test_transferOwnership_zeroAddress_reverts() public {\n        vm.prank(setter.owner());\n        vm.expectRevert(\"CrossDomainOwnable3: new owner is the zero address\");\n        setter.transferOwnership({ _owner: address(0), _isLocal: true });\n    }\n\n    function test_transferOwnership_noLocalZeroAddress_reverts() public {\n        vm.prank(setter.owner());\n        vm.expectRevert(\"Ownable: new owner is the zero address\");\n        setter.transferOwnership(address(0));\n    }\n\n    function test_localOnlyOwner_succeeds() public {\n        assertEq(setter.isLocal(), true);\n        vm.prank(setter.owner());\n        setter.set(1);\n        assertEq(setter.value(), 1);\n    }\n\n    function test_localTransferOwnership_succeeds() public {\n        vm.expectEmit(true, true, true, true, address(setter));\n        emit OwnershipTransferred(alice, bob);\n        emit OwnershipTransferred(alice, bob, true);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership({ _owner: bob, _isLocal: true });\n\n        assertEq(setter.isLocal(), true);\n\n        vm.prank(bob);\n        setter.set(2);\n        assertEq(setter.value(), 2);\n    }\n\n    /**\n     * @notice The existing transferOwnership(address) method\n     *         still exists on the contract\n     */\n    function test_transferOwnershipNoLocal_succeeds() public {\n        bool isLocal = setter.isLocal();\n\n        vm.expectEmit(true, true, true, true, address(setter));\n        emit OwnershipTransferred(alice, bob);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership(bob);\n\n        // isLocal has not changed\n        assertEq(setter.isLocal(), isLocal);\n\n        vm.prank(bob);\n        setter.set(2);\n        assertEq(setter.value(), 2);\n    }\n\n    function test_crossDomainTransferOwnership_succeeds() public {\n        vm.expectEmit(true, true, true, true, address(setter));\n        emit OwnershipTransferred(alice, bob);\n        emit OwnershipTransferred(alice, bob, false);\n\n        vm.prank(setter.owner());\n        setter.transferOwnership({ _owner: bob, _isLocal: false });\n\n        assertEq(setter.isLocal(), false);\n\n        // Simulate the L2 execution where the call is coming from\n        // the L1CrossDomainMessenger\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 1, _version: 0 }),\n            bob,\n            address(setter),\n            0,\n            0,\n            abi.encodeWithSelector(XDomainSetter3.set.selector, 2)\n        );\n\n        assertEq(setter.value(), 2);\n    }\n}\n"
    },
    "contracts/test/Encoding.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract Encoding_Test is CommonTest {\n    function testFuzz_nonceVersioning_succeeds(uint240 _nonce, uint16 _version) external {\n        (uint240 nonce, uint16 version) = Encoding.decodeVersionedNonce(\n            Encoding.encodeVersionedNonce(_nonce, _version)\n        );\n        assertEq(version, _version);\n        assertEq(nonce, _nonce);\n    }\n\n    function testDiff_decodeVersionedNonce_succeeds(uint240 _nonce, uint16 _version) external {\n        uint256 nonce = uint256(Encoding.encodeVersionedNonce(_nonce, _version));\n        (uint256 decodedNonce, uint256 decodedVersion) = ffi.decodeVersionedNonce(nonce);\n\n        assertEq(_version, uint16(decodedVersion));\n\n        assertEq(_nonce, uint240(decodedNonce));\n    }\n\n    function testDiff_encodeCrossDomainMessage_succeeds(\n        uint240 _nonce,\n        uint8 _version,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        uint8 version = uint8(bound(uint256(_version), 0, 0));\n        uint256 nonce = Encoding.encodeVersionedNonce(_nonce, version);\n\n        bytes memory encoding = Encoding.encodeCrossDomainMessage(\n            nonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n\n        bytes memory _encoding = ffi.encodeCrossDomainMessage(\n            nonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n\n        assertEq(encoding, _encoding);\n    }\n\n    function testDiff_encodeDepositTransaction_succeeds(\n        address _from,\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gas,\n        bool isCreate,\n        bytes memory _data,\n        uint64 _logIndex\n    ) external {\n        Types.UserDepositTransaction memory t = Types.UserDepositTransaction(\n            _from,\n            _to,\n            isCreate,\n            _value,\n            _mint,\n            _gas,\n            _data,\n            bytes32(uint256(0)),\n            _logIndex\n        );\n\n        bytes memory txn = Encoding.encodeDepositTransaction(t);\n        bytes memory _txn = ffi.encodeDepositTransaction(t);\n\n        assertEq(txn, _txn);\n    }\n}\n"
    },
    "contracts/test/FeeVault.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { ProtocolVault } from \"../L2/ProtocolVault.sol\";\nimport { L1FeeVault } from \"../L2/L1FeeVault.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\n\n// Test the implementations of the FeeVault\ncontract FeeVault_Test is Bridge_Initializer {\n    ProtocolVault protocolVault = ProtocolVault(payable(Predeploys.PROTOCOL_VAULT));\n    L1FeeVault l1FeeVault = L1FeeVault(payable(Predeploys.L1_FEE_VAULT));\n\n    address constant recipient = address(0x10000);\n    address constant caller = address(0x10001);\n\n    event Withdrawal(uint256 value, address to, address from);\n\n    function setUp() public override {\n        super.setUp();\n        vm.etch(Predeploys.PROTOCOL_VAULT, address(new ProtocolVault(recipient)).code);\n        vm.etch(Predeploys.L1_FEE_VAULT, address(new L1FeeVault(recipient)).code);\n\n        vm.label(Predeploys.PROTOCOL_VAULT, \"ProtocolVault\");\n        vm.label(Predeploys.L1_FEE_VAULT, \"L1FeeVault\");\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(protocolVault.RECIPIENT(), recipient);\n        assertEq(l1FeeVault.RECIPIENT(), recipient);\n    }\n\n    function test_minWithdrawalAmount_succeeds() external {\n        assertEq(protocolVault.MIN_WITHDRAWAL_AMOUNT(), 0);\n        assertEq(l1FeeVault.MIN_WITHDRAWAL_AMOUNT(), 0);\n    }\n\n    function test_withdrawToL2_succeeds() external {\n        uint256 reward = 1 ether;\n        vm.deal(address(l1FeeVault), reward);\n        assertEq(payable(Predeploys.L1_FEE_VAULT).balance, reward);\n\n        uint256 prevBalance = payable(recipient).balance;\n\n        // No ether has been withdrawn yet\n        assertEq(l1FeeVault.totalProcessed(), 0);\n\n        vm.expectEmit(true, true, true, true, address(Predeploys.L1_FEE_VAULT));\n        emit Withdrawal(reward, recipient, recipient);\n\n        // Withdraw to L2\n        vm.prank(recipient);\n        l1FeeVault.withdrawToL2();\n\n        assertEq(l1FeeVault.totalProcessed(), reward);\n        assertEq(payable(recipient).balance, prevBalance + reward);\n    }\n\n    function test_withdraw_fromOtherEOA_reverts() external {\n        vm.expectRevert(\"FeeVault: the only recipient can call\");\n        vm.prank(caller);\n        l1FeeVault.withdraw();\n    }\n\n    function test_withdrawToL2_fromOtherEOA_reverts() external {\n        vm.expectRevert(\"FeeVault: the only recipient can call\");\n        vm.prank(caller);\n        l1FeeVault.withdrawToL2();\n    }\n}\n"
    },
    "contracts/test/GasPriceOracle.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n// Testing utilities\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\n// Libraries\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { GasPriceOracle } from \"../L2/GasPriceOracle.sol\";\nimport { L1Block } from \"../L2/L1Block.sol\";\n\ncontract GasPriceOracle_Test is CommonTest {\n    event OverheadUpdated(uint256);\n    event ScalarUpdated(uint256);\n    event DecimalsUpdated(uint256);\n\n    GasPriceOracle gasPriceOracle;\n    L1Block l1Block;\n    address depositor;\n\n    // The initial L1 context values\n    uint64 constant number = 10;\n    uint64 constant timestamp = 11;\n    uint256 constant baseFee = 2 * (10 ** 6);\n    uint256 constant blobBaseFee = 3 * (10 ** 6);\n    bytes32 constant hash = bytes32(uint256(64));\n    uint64 constant sequenceNumber = 0;\n    bytes32 constant batcherHash = bytes32(uint256(777));\n    uint256 constant l1FeeOverhead = 310;\n    uint256 constant l1FeeScalar = 10;\n    uint32 constant blobBaseFeeScalar = 15;\n    uint32 constant baseFeeScalar = 20;\n    uint256 constant validatorRewardScalar = 5000;\n\n    /// @dev Sets up the test suite.\n    function setUp() public virtual override {\n        super.setUp();\n        // place the L1Block contract at the predeploy address\n        vm.etch(Predeploys.L1_BLOCK_ATTRIBUTES, address(new L1Block()).code);\n\n        l1Block = L1Block(Predeploys.L1_BLOCK_ATTRIBUTES);\n        depositor = l1Block.DEPOSITOR_ACCOUNT();\n\n        // We are not setting the gas oracle at its predeploy\n        // address for simplicity purposes. Nothing in this test\n        // requires it to be at a particular address\n        gasPriceOracle = new GasPriceOracle();\n    }\n}\n\ncontract GasPriceOracleBedrock_Test is GasPriceOracle_Test {\n    /// @dev Sets up the test suite.\n    function setUp() public virtual override {\n        super.setUp();\n\n        vm.prank(depositor);\n        l1Block.setL1BlockValues({\n            _number: number,\n            _timestamp: timestamp,\n            _basefee: baseFee,\n            _hash: hash,\n            _sequenceNumber: sequenceNumber,\n            _batcherHash: batcherHash,\n            _l1FeeOverhead: l1FeeOverhead,\n            _l1FeeScalar: l1FeeScalar,\n            _validatorRewardScalar: validatorRewardScalar\n        });\n    }\n\n    /// @dev Tests that `l1BaseFee` is set correctly.\n    function test_l1BaseFee_succeeds() external {\n        assertEq(gasPriceOracle.l1BaseFee(), baseFee);\n    }\n\n    /// @dev Tests that `gasPrice` is set correctly.\n    function test_gasPrice_succeeds() external {\n        vm.fee(100);\n        uint256 gasPrice = gasPriceOracle.gasPrice();\n        assertEq(gasPrice, 100);\n    }\n\n    /// @dev Tests that `baseFee` is set correctly.\n    function test_baseFee_succeeds() external {\n        vm.fee(64);\n        uint256 gasPrice = gasPriceOracle.baseFee();\n        assertEq(gasPrice, 64);\n    }\n\n    /// @dev Tests that `scalar` is set correctly.\n    function test_scalar_succeeds() external {\n        assertEq(gasPriceOracle.scalar(), l1FeeScalar);\n    }\n\n    /// @dev Tests that `overhead` is set correctly.\n    function test_overhead_succeeds() external {\n        assertEq(gasPriceOracle.overhead(), l1FeeOverhead);\n    }\n\n    /// @dev Tests that `decimals` is set correctly.\n    function test_decimals_succeeds() external {\n        assertEq(gasPriceOracle.decimals(), 6);\n        assertEq(gasPriceOracle.DECIMALS(), 6);\n    }\n\n    /* [Kroma: START]\n    /// @dev Tests that `setGasPrice` reverts since it was removed in bedrock.\n    function test_setGasPrice_doesNotExist_reverts() external {\n        (bool success, bytes memory returndata) =\n            address(gasPriceOracle).call(abi.encodeWithSignature(\"setGasPrice(uint256)\", 1));\n\n        assertEq(success, false);\n        assertEq(returndata, hex\"\");\n    }\n\n    /// @dev Tests that `setL1BaseFee` reverts since it was removed in bedrock.\n    function test_setL1BaseFee_doesNotExist_reverts() external {\n        (bool success, bytes memory returndata) =\n            address(gasPriceOracle).call(abi.encodeWithSignature(\"setL1BaseFee(uint256)\", 1));\n\n        assertEq(success, false);\n        assertEq(returndata, hex\"\");\n    }\n    [Kroma: END] */\n}\n\ncontract GasPriceOracleEcotone_Test is GasPriceOracle_Test {\n    /// @dev Sets up the test suite.\n    function setUp() public virtual override {\n        super.setUp();\n\n        bytes memory calldataPacked = Encoding.encodeSetL1BlockValuesEcotone(\n            baseFeeScalar, blobBaseFeeScalar, sequenceNumber, timestamp, number, baseFee, blobBaseFee, hash, batcherHash, validatorRewardScalar\n        );\n\n        // Execute the function call\n        vm.prank(depositor);\n        (bool success,) = address(l1Block).call(calldataPacked);\n        require(success, \"Function call failed\");\n\n        vm.prank(depositor);\n        gasPriceOracle.setEcotone();\n    }\n\n    /// @dev Tests that `setEcotone` is only callable by the depositor.\n    function test_setEcotone_wrongCaller_reverts() external {\n        vm.expectRevert(\"GasPriceOracle: only the depositor account can set isEcotone flag\");\n        gasPriceOracle.setEcotone();\n    }\n\n    /// @dev Tests that `gasPrice` is set correctly.\n    function test_gasPrice_succeeds() external {\n        vm.fee(100);\n        uint256 gasPrice = gasPriceOracle.gasPrice();\n        assertEq(gasPrice, 100);\n    }\n\n    /// @dev Tests that `baseFee` is set correctly.\n    function test_baseFee_succeeds() external {\n        vm.fee(64);\n        uint256 gasPrice = gasPriceOracle.baseFee();\n        assertEq(gasPrice, 64);\n    }\n\n    /// @dev Tests that `overhead` reverts since it was removed in ecotone.\n    function test_overhead_legacyFunction_reverts() external {\n        vm.expectRevert(\"GasPriceOracle: overhead() is deprecated\");\n        gasPriceOracle.overhead();\n    }\n\n    /// @dev Tests that `scalar` reverts since it was removed in ecotone.\n    function test_scalar_legacyFunction_reverts() external {\n        vm.expectRevert(\"GasPriceOracle: scalar() is deprecated\");\n        gasPriceOracle.scalar();\n    }\n\n    /// @dev Tests that `l1BaseFee` is set correctly.\n    function test_l1BaseFee_succeeds() external {\n        assertEq(gasPriceOracle.l1BaseFee(), baseFee);\n    }\n\n    /// @dev Tests that `blobBaseFee` is set correctly.\n    function test_blobBaseFee_succeeds() external {\n        assertEq(gasPriceOracle.blobBaseFee(), blobBaseFee);\n    }\n\n    /// @dev Tests that `baseFeeScalar` is set correctly.\n    function test_baseFeeScalar_succeeds() external {\n        assertEq(gasPriceOracle.baseFeeScalar(), baseFeeScalar);\n    }\n\n    /// @dev Tests that `blobBaseFeeScalar` is set correctly.\n    function test_blobBaseFeeScalar_succeeds() external {\n        assertEq(gasPriceOracle.blobBaseFeeScalar(), blobBaseFeeScalar);\n    }\n\n    /// @dev Tests that `decimals` is set correctly.\n    function test_decimals_succeeds() external {\n        assertEq(gasPriceOracle.decimals(), 6);\n        assertEq(gasPriceOracle.DECIMALS(), 6);\n    }\n\n    /// @dev Tests that `getL1GasUsed` and `getL1Fee` return expected values\n    function test_getL1Fee_succeeds() external {\n        bytes memory data = hex\"0000010203\"; // 2 zero bytes, 3 non-zero bytes\n        // (2*4) + (3*16) + (68*16) == 1144\n        uint256 gas = gasPriceOracle.getL1GasUsed(data);\n        assertEq(gas, 1144);\n        uint256 price = gasPriceOracle.getL1Fee(data);\n        // gas * (2M*16*20 + 3M*15) / 16M == 48977.5\n        assertEq(price, 48977);\n    }\n}\n"
    },
    "contracts/test/GovernanceToken.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n// Testing utilities\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\n// Target contract dependencies\nimport { Proxy } from \"../universal/Proxy.sol\";\n\n// Target contract\nimport { GovernanceToken } from \"../governance/GovernanceToken.sol\";\n\ncontract GovernanceToken_Test is CommonTest {\n    address rando;\n    GovernanceToken governanceToken;\n    address bridge;\n    address remoteToken;\n    address mintManager;\n\n    event Mint(address indexed account, uint256 amount);\n\n    event Burn(address indexed account, uint256 amount);\n\n    /// @dev Sets up the test suite.\n    function setUp() public virtual override {\n        super.setUp();\n\n        rando = makeAddr(\"rando\");\n        bridge = makeAddr(\"bridge\");\n        remoteToken = makeAddr(\"remoteToken\");\n        mintManager = makeAddr(\"mintManager\");\n\n        governanceToken = GovernanceToken(address(new Proxy(multisig)));\n        GovernanceToken govTokenImpl = new GovernanceToken(bridge, remoteToken);\n        vm.prank(multisig);\n        toProxy(address(governanceToken)).upgradeToAndCall(\n            address(govTokenImpl),\n            abi.encodeCall(governanceToken.initialize, mintManager)\n        );\n        assertEq(governanceToken.pendingOwner(), mintManager);\n\n        vm.prank(mintManager);\n        governanceToken.acceptOwnership();\n        assertEq(governanceToken.owner(), mintManager);\n    }\n\n    /// @dev Tests that the constructor sets the correct initial state.\n    function test_constructor_succeeds() external {\n        assertEq(governanceToken.BRIDGE(), bridge);\n        assertEq(governanceToken.REMOTE_TOKEN(), remoteToken);\n        assertEq(governanceToken.name(), \"Kroma\");\n        assertEq(governanceToken.symbol(), \"KRO\");\n        assertEq(governanceToken.decimals(), 18);\n        assertEq(governanceToken.totalSupply(), 0);\n    }\n\n    /// @dev Tests that the owner can successfully call `mint`.\n    function test_mint_fromOwner_succeeds() external {\n        // Mint 100 tokens.\n        vm.expectEmit(true, false, false, true, address(governanceToken));\n        emit Mint(rando, 100);\n        vm.prank(mintManager);\n        governanceToken.mint(rando, 100);\n\n        // Balances have updated correctly.\n        assertEq(governanceToken.balanceOf(rando), 100);\n        assertEq(governanceToken.totalSupply(), 100);\n    }\n\n    /// @dev Tests the bridge contract can successfully call `mint`.\n    function test_mint_fromBridge_succeeds() external {\n        // Mint 100 tokens.\n        vm.expectEmit(true, false, false, true, address(governanceToken));\n        emit Mint(rando, 100);\n        vm.prank(bridge);\n        governanceToken.mint(rando, 100);\n\n        // Balances have updated correctly.\n        assertEq(governanceToken.balanceOf(rando), 100);\n        assertEq(governanceToken.totalSupply(), 100);\n    }\n\n    /// @dev Tests that `mint` reverts when called by a non-minter.\n    function test_mint_fromNotMinter_reverts() external {\n        // Mint 100 tokens as rando.\n        vm.prank(rando);\n        vm.expectRevert(\"GovernanceToken: only bridge or owner can mint\");\n        governanceToken.mint(rando, 100);\n\n        // Balance does not update.\n        assertEq(governanceToken.balanceOf(rando), 0);\n        assertEq(governanceToken.totalSupply(), 0);\n    }\n\n    /// @dev Tests that the bridge contract can successfully call `burn`.\n    function test_burn_fromBridge_succeeds() external {\n        // Mint 100 tokens to rando.\n        vm.prank(mintManager);\n        governanceToken.mint(rando, 100);\n\n        // Bridge burns rando's tokens.\n        vm.expectEmit(true, false, false, true, address(governanceToken));\n        emit Burn(rando, 100);\n        vm.prank(bridge);\n        governanceToken.burn(rando, 100);\n\n        // Balances have updated correctly.\n        assertEq(governanceToken.balanceOf(rando), 0);\n        assertEq(governanceToken.totalSupply(), 0);\n    }\n\n    /// @dev Tests that other than bridge contract cannot call `burn`.\n    function test_burn_fromNotBridge_reverts() external {\n        // Mint 100 tokens to rando.\n        vm.prank(mintManager);\n        governanceToken.mint(rando, 100);\n\n        vm.expectRevert(\"KromaMintableERC20: only bridge can mint and burn\");\n        vm.prank(rando);\n        governanceToken.burn(rando, 100);\n    }\n\n    /// @dev Tests that `transfer` correctly transfers tokens.\n    function test_transfer_succeeds() external {\n        // Mint 100 tokens to rando.\n        vm.prank(mintManager);\n        governanceToken.mint(rando, 100);\n\n        // Rando transfers 50 tokens to alice.\n        vm.prank(rando);\n        governanceToken.transfer(alice, 50);\n\n        // Balances have updated correctly.\n        assertEq(governanceToken.balanceOf(alice), 50);\n        assertEq(governanceToken.balanceOf(rando), 50);\n        assertEq(governanceToken.totalSupply(), 100);\n    }\n\n    /// @dev Tests that `approve` correctly sets allowances.\n    function test_approve_succeeds() external {\n        // Mint 100 tokens to rando.\n        vm.prank(mintManager);\n        governanceToken.mint(rando, 100);\n\n        // Rando approves alice to spend 50 tokens.\n        vm.prank(rando);\n        governanceToken.approve(alice, 50);\n\n        // Allowances have updated.\n        assertEq(governanceToken.allowance(rando, alice), 50);\n    }\n\n    /// @dev Tests that `transferFrom` correctly transfers tokens.\n    function test_transferFrom_succeeds() external {\n        // Mint 100 tokens to rando.\n        vm.prank(mintManager);\n        governanceToken.mint(rando, 100);\n\n        // Rando approves alice to spend 50 tokens.\n        vm.prank(rando);\n        governanceToken.approve(alice, 50);\n\n        // Alice transfers 50 tokens from rando to alice.\n        vm.prank(alice);\n        governanceToken.transferFrom(rando, alice, 50);\n\n        // Balances have updated correctly.\n        assertEq(governanceToken.balanceOf(alice), 50);\n        assertEq(governanceToken.balanceOf(rando), 50);\n        assertEq(governanceToken.totalSupply(), 100);\n    }\n\n    /// @dev Tests that `increaseAllowance` correctly increases allowances.\n    function test_increaseAllowance_succeeds() external {\n        // Mint 100 tokens to rando.\n        vm.prank(mintManager);\n        governanceToken.mint(rando, 100);\n\n        // Rando approves alice to spend 50 tokens.\n        vm.prank(rando);\n        governanceToken.approve(alice, 50);\n\n        // Rando increases allowance by 50 tokens.\n        vm.prank(rando);\n        governanceToken.increaseAllowance(alice, 50);\n\n        // Allowances have updated.\n        assertEq(governanceToken.allowance(rando, alice), 100);\n    }\n\n    /// @dev Tests that `decreaseAllowance` correctly decreases allowances.\n    function test_decreaseAllowance_succeeds() external {\n        // Mint 100 tokens to rando.\n        vm.prank(mintManager);\n        governanceToken.mint(rando, 100);\n\n        // Rando approves alice to spend 100 tokens.\n        vm.prank(rando);\n        governanceToken.approve(alice, 100);\n\n        // Rando decreases allowance by 50 tokens.\n        vm.prank(rando);\n        governanceToken.decreaseAllowance(alice, 50);\n\n        // Allowances have updated.\n        assertEq(governanceToken.allowance(rando, alice), 50);\n    }\n}\n"
    },
    "contracts/test/Hashing.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Arithmetic } from \"../libraries/Arithmetic.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract Hashing_hashDepositSource_Test is CommonTest {\n    /**\n     * @notice Tests that hashDepositSource returns the correct hash in a simple case.\n     */\n    function test_hashDepositSource_succeeds() external {\n        assertEq(\n            Hashing.hashDepositSource(\n                0xd25df7858efc1778118fb133ac561b138845361626dfb976699c5287ed0f4959,\n                0x1\n            ),\n            0xf923fb07134d7d287cb52c770cc619e17e82606c21a875c92f4c63b65280a5cc\n        );\n    }\n}\n\ncontract Hashing_hashCrossDomainMessage_Test is CommonTest {\n    /**\n     * @notice Tests that hashCrossDomainMessage returns the correct hash in a simple case.\n     */\n    function testDiff_hashCrossDomainMessage_succeeds(\n        uint240 _nonce,\n        uint16 _version,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        // Ensure the version is valid.\n        uint16 version = uint16(bound(uint256(_version), 0, 0));\n        uint256 nonce = Encoding.encodeVersionedNonce(_nonce, version);\n\n        assertEq(\n            Hashing.hashCrossDomainMessage(nonce, _sender, _target, _value, _gasLimit, _data),\n            ffi.hashCrossDomainMessage(nonce, _sender, _target, _value, _gasLimit, _data)\n        );\n    }\n}\n\ncontract Hashing_hashWithdrawal_Test is CommonTest {\n    /**\n     * @notice Tests that hashWithdrawal returns the correct hash in a simple case.\n     */\n    function testDiff_hashWithdrawal_succeeds(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        assertEq(\n            Hashing.hashWithdrawal(\n                Types.WithdrawalTransaction(_nonce, _sender, _target, _value, _gasLimit, _data)\n            ),\n            ffi.hashWithdrawal(_nonce, _sender, _target, _value, _gasLimit, _data)\n        );\n    }\n}\n\ncontract Hashing_hashOutputRootProof_Test is CommonTest {\n    /**\n     * @notice Tests that hashOutputRootProof returns the correct hash in a simple case.\n     */\n    function testDiff_hashOutputRootProof_succeeds(\n        bytes32 _version,\n        bytes32 _stateRoot,\n        bytes32 _messagePasserStorageRoot,\n        bytes32 _blockHash,\n        bytes32 _nextBlockHash\n    ) external {\n        _version = bytes32(Arithmetic.clamp(uint256(_version), 0, MAX_OUTPUT_ROOT_PROOF_VERSION));\n        assertEq(\n            Hashing.hashOutputRootProof(\n                Types.OutputRootProof({\n                    version: _version,\n                    stateRoot: _stateRoot,\n                    messagePasserStorageRoot: _messagePasserStorageRoot,\n                    blockHash: _blockHash,\n                    nextBlockHash: _nextBlockHash\n                })\n            ),\n            ffi.hashOutputRootProof(\n                _version,\n                _stateRoot,\n                _messagePasserStorageRoot,\n                _blockHash,\n                _nextBlockHash\n            )\n        );\n    }\n}\n\ncontract Hashing_hashDepositTransaction_Test is CommonTest {\n    /**\n     * @notice Tests that hashDepositTransaction returns the correct hash in a simple case.\n     */\n    function testDiff_hashDepositTransaction_succeeds(\n        address _from,\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gas,\n        bytes memory _data,\n        uint64 _logIndex\n    ) external {\n        assertEq(\n            Hashing.hashDepositTransaction(\n                Types.UserDepositTransaction(\n                    _from,\n                    _to,\n                    false, // isCreate\n                    _value,\n                    _mint,\n                    _gas,\n                    _data,\n                    bytes32(uint256(0)),\n                    _logIndex\n                )\n            ),\n            ffi.hashDepositTransaction(_from, _to, _mint, _value, _gas, _data, _logIndex)\n        );\n    }\n}\n"
    },
    "contracts/test/KromaMintableERC20.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {\n    IKromaMintableERC20\n} from \"../universal/IKromaMintableERC20.sol\";\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\n\ncontract KromaMintableERC20_Test is Bridge_Initializer {\n    event Mint(address indexed account, uint256 amount);\n    event Burn(address indexed account, uint256 amount);\n\n    function test_semver_succeeds() external {\n        assertEq(L2Token.version(), \"1.0.0\");\n    }\n\n    function test_remoteToken_succeeds() external {\n        assertEq(L2Token.REMOTE_TOKEN(), address(L1Token));\n    }\n\n    function test_bridge_succeeds() external {\n        assertEq(L2Token.BRIDGE(), address(L2Bridge));\n    }\n\n    function test_mint_succeeds() external {\n        vm.expectEmit(true, true, true, true);\n        emit Mint(alice, 100);\n\n        vm.prank(address(L2Bridge));\n        L2Token.mint(alice, 100);\n\n        assertEq(L2Token.balanceOf(alice), 100);\n    }\n\n    function test_mint_notBridge_reverts() external {\n        // NOT the bridge\n        vm.expectRevert(\"KromaMintableERC20: only bridge can mint and burn\");\n        vm.prank(address(alice));\n        L2Token.mint(alice, 100);\n    }\n\n    function test_burn_succeeds() external {\n        vm.prank(address(L2Bridge));\n        L2Token.mint(alice, 100);\n\n        vm.expectEmit(true, true, true, true);\n        emit Burn(alice, 100);\n\n        vm.prank(address(L2Bridge));\n        L2Token.burn(alice, 100);\n\n        assertEq(L2Token.balanceOf(alice), 0);\n    }\n\n    function test_burn_notBridge_reverts() external {\n        // NOT the bridge\n        vm.expectRevert(\"KromaMintableERC20: only bridge can mint and burn\");\n        vm.prank(address(alice));\n        L2Token.burn(alice, 100);\n    }\n\n    function test_erc165_supportsInterface_succeeds() external {\n        // The assertEq calls in this test are comparing the manual calculation of the iface,\n        // with what is returned by the solidity's type().interfaceId, just to be safe.\n        bytes4 iface1 = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n        assertEq(iface1, type(IERC165).interfaceId);\n        assert(L2Token.supportsInterface(iface1));\n\n        bytes4 iface2 = L2Token.REMOTE_TOKEN.selector ^\n            L2Token.BRIDGE.selector ^\n            L2Token.mint.selector ^\n            L2Token.burn.selector;\n        assertEq(iface2, type(IKromaMintableERC20).interfaceId);\n        assert(L2Token.supportsInterface(iface2));\n    }\n}\n"
    },
    "contracts/test/KromaMintableERC20Factory.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\nimport { LibRLP } from \"./RLP.t.sol\";\n\ncontract KromaMintableTokenFactory_Test is Bridge_Initializer {\n    event KromaMintableERC20Created(\n        address indexed localToken,\n        address indexed remoteToken,\n        address deployer\n    );\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_bridge_succeeds() external {\n        assertEq(address(L2TokenFactory.BRIDGE()), address(L2Bridge));\n    }\n\n    function test_createKromaMintableERC20_succeeds() external {\n        address remote = address(4);\n        address local = LibRLP.computeAddress(address(L2TokenFactory), 2);\n\n        vm.expectEmit(true, true, true, true);\n        emit KromaMintableERC20Created(local, remote, alice);\n\n        vm.prank(alice);\n        L2TokenFactory.createKromaMintableERC20(remote, \"Beep\", \"BOOP\");\n    }\n\n    function test_createKromaMintableERC20_sameTwice_succeeds() external {\n        address remote = address(4);\n\n        vm.prank(alice);\n        L2TokenFactory.createKromaMintableERC20(remote, \"Beep\", \"BOOP\");\n\n        address local = LibRLP.computeAddress(address(L2TokenFactory), 3);\n\n        vm.expectEmit(true, true, true, true);\n        emit KromaMintableERC20Created(local, remote, alice);\n\n        vm.prank(alice);\n        L2TokenFactory.createKromaMintableERC20(remote, \"Beep\", \"BOOP\");\n    }\n\n    function test_createKromaMintableERC20_remoteIsZero_succeeds() external {\n        address remote = address(0);\n        vm.expectRevert(\"KromaMintableERC20Factory: must provide remote token address\");\n        L2TokenFactory.createKromaMintableERC20(remote, \"Beep\", \"BOOP\");\n    }\n}\n"
    },
    "contracts/test/KromaMintableERC721.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport { KromaMintableERC721 } from \"../universal/KromaMintableERC721.sol\";\nimport { ERC721Bridge_Initializer } from \"./CommonTest.t.sol\";\n\ncontract KromaMintableERC721_Test is ERC721Bridge_Initializer {\n    ERC721 internal L1Token;\n    KromaMintableERC721 internal L2Token;\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    event Mint(address indexed account, uint256 tokenId);\n\n    event Burn(address indexed account, uint256 tokenId);\n\n    function setUp() public override {\n        super.setUp();\n\n        // Set up the token pair.\n        L1Token = new ERC721(\"L1Token\", \"L1T\");\n        L2Token = new KromaMintableERC721(\n            address(L2Bridge),\n            1,\n            address(L1Token),\n            \"L2Token\",\n            \"L2T\"\n        );\n\n        // Label the addresses for nice traces.\n        vm.label(address(L1Token), \"L1ERC721Token\");\n        vm.label(address(L2Token), \"L2ERC721Token\");\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(L2Token.name(), \"L2Token\");\n        assertEq(L2Token.symbol(), \"L2T\");\n        assertEq(L2Token.remoteChainId(), 1);\n        assertEq(L2Token.REMOTE_TOKEN(), address(L1Token));\n        assertEq(L2Token.BRIDGE(), address(L2Bridge));\n        assertEq(L2Token.REMOTE_CHAIN_ID(), 1);\n    }\n\n    function test_safeMint_succeeds() external {\n        // Expect a transfer event.\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(0), alice, 1);\n\n        // Expect a mint event.\n        vm.expectEmit(true, true, true, true);\n        emit Mint(alice, 1);\n\n        // Mint the token.\n        vm.prank(address(L2Bridge));\n        L2Token.safeMint(alice, 1);\n\n        // Token should be owned by alice.\n        assertEq(L2Token.ownerOf(1), alice);\n    }\n\n    function test_safeMint_notBridge_reverts() external {\n        // Try to mint the token.\n        vm.expectRevert(\"KromaMintableERC721: only bridge can call this function\");\n        vm.prank(address(alice));\n        L2Token.safeMint(alice, 1);\n    }\n\n    function test_burn_succeeds() external {\n        // Mint the token first.\n        vm.prank(address(L2Bridge));\n        L2Token.safeMint(alice, 1);\n\n        // Expect a transfer event.\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(alice, address(0), 1);\n\n        // Expect a burn event.\n        vm.expectEmit(true, true, true, true);\n        emit Burn(alice, 1);\n\n        // Burn the token.\n        vm.prank(address(L2Bridge));\n        L2Token.burn(alice, 1);\n\n        // Token should be owned by address(0).\n        vm.expectRevert(\"ERC721: invalid token ID\");\n        L2Token.ownerOf(1);\n    }\n\n    function test_burn_notBridge_reverts() external {\n        // Mint the token first.\n        vm.prank(address(L2Bridge));\n        L2Token.safeMint(alice, 1);\n\n        // Try to burn the token.\n        vm.expectRevert(\"KromaMintableERC721: only bridge can call this function\");\n        vm.prank(address(alice));\n        L2Token.burn(alice, 1);\n    }\n\n    function test_tokenURI_succeeds() external {\n        // Mint the token first.\n        vm.prank(address(L2Bridge));\n        L2Token.safeMint(alice, 1);\n\n        // Token URI should be correct.\n        assertEq(\n            L2Token.tokenURI(1),\n            string(\n                abi.encodePacked(\n                    \"ethereum:\",\n                    Strings.toHexString(uint160(address(L1Token)), 20),\n                    \"@\",\n                    Strings.toString(uint256(1)),\n                    \"/tokenURI?uint256=\",\n                    Strings.toString(uint256(1))\n                )\n            )\n        );\n    }\n}\n"
    },
    "contracts/test/KromaMintableERC721Factory.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport { KromaMintableERC721 } from \"../universal/KromaMintableERC721.sol\";\nimport { KromaMintableERC721Factory } from \"../universal/KromaMintableERC721Factory.sol\";\nimport { ERC721Bridge_Initializer } from \"./CommonTest.t.sol\";\nimport { LibRLP } from \"./RLP.t.sol\";\n\ncontract KromaMintableERC721Factory_Test is ERC721Bridge_Initializer {\n    KromaMintableERC721Factory internal factory;\n\n    event KromaMintableERC721Created(\n        address indexed localToken,\n        address indexed remoteToken,\n        address deployer\n    );\n\n    function setUp() public override {\n        super.setUp();\n\n        // Set up the token pair.\n        factory = new KromaMintableERC721Factory(address(L2Bridge), 1);\n\n        // Label the addresses for nice traces.\n        vm.label(address(factory), \"KromaMintableERC721Factory\");\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(factory.BRIDGE(), address(L2Bridge));\n        assertEq(factory.REMOTE_CHAIN_ID(), 1);\n    }\n\n    function test_createKromaMintableERC721_succeeds() external {\n        // Predict the address based on the factory address and nonce.\n        address predicted = LibRLP.computeAddress(address(factory), 1);\n\n        // Expect a token creation event.\n        vm.expectEmit(true, true, true, true);\n        emit KromaMintableERC721Created(predicted, address(1234), alice);\n\n        // Create the token.\n        vm.prank(alice);\n        KromaMintableERC721 created = KromaMintableERC721(\n            factory.createKromaMintableERC721(address(1234), \"L2Token\", \"L2T\")\n        );\n\n        // Token address should be correct.\n        assertEq(address(created), predicted);\n\n        // Should be marked as created by the factory.\n        assertEq(factory.isKromaMintableERC721(address(created)), true);\n\n        // Token should've been constructed correctly.\n        assertEq(created.name(), \"L2Token\");\n        assertEq(created.symbol(), \"L2T\");\n        assertEq(created.REMOTE_TOKEN(), address(1234));\n        assertEq(created.BRIDGE(), address(L2Bridge));\n        assertEq(created.REMOTE_CHAIN_ID(), 1);\n    }\n\n    function test_createKromaMintableERC721_zeroRemoteToken_reverts() external {\n        // Try to create a token with a zero remote token address.\n        vm.expectRevert(\"KromaMintableERC721Factory: L1 token address cannot be address(0)\");\n        factory.createKromaMintableERC721(address(0), \"L2Token\", \"L2T\");\n    }\n}\n"
    },
    "contracts/test/KromaPortal.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { stdError } from \"forge-std/Test.sol\";\n\nimport { KromaPortal } from \"../L1/KromaPortal.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Portal_Initializer, CommonTest, NextImpl } from \"./CommonTest.t.sol\";\n\ncontract KromaPortal_Test is Portal_Initializer {\n    event Paused(address);\n    event Unpaused(address);\n\n    function test_constructor_succeeds() external {\n        assertEq(address(portal.L2_ORACLE()), address(oracle));\n        assertEq(portal.l2Sender(), 0x000000000000000000000000000000000000dEaD);\n        assertEq(portal.paused(), false);\n    }\n\n    /**\n     * @notice The KromaPortal can be paused by the GUARDIAN\n     */\n    function test_pause_succeeds() external {\n        address guardian = portal.GUARDIAN();\n\n        assertEq(portal.paused(), false);\n\n        vm.expectEmit(true, true, true, true, address(portal));\n        emit Paused(guardian);\n\n        vm.prank(guardian);\n        portal.pause();\n\n        assertEq(portal.paused(), true);\n    }\n\n    /**\n     * @notice The KromaPortal reverts when an account that is not the\n     *         GUARDIAN calls `pause()`\n     */\n    function test_pause_onlyGuardian_reverts() external {\n        assertEq(portal.paused(), false);\n\n        assertTrue(portal.GUARDIAN() != alice);\n        vm.expectRevert(\"KromaPortal: only guardian can pause\");\n        vm.prank(alice);\n        portal.pause();\n\n        assertEq(portal.paused(), false);\n    }\n\n    /**\n     * @notice The KromaPortal can be unpaused by the GUARDIAN\n     */\n    function test_unpause_succeeds() external {\n        address guardian = portal.GUARDIAN();\n\n        vm.prank(guardian);\n        portal.pause();\n        assertEq(portal.paused(), true);\n\n        vm.expectEmit(true, true, true, true, address(portal));\n        emit Unpaused(guardian);\n        vm.prank(guardian);\n        portal.unpause();\n\n        assertEq(portal.paused(), false);\n    }\n\n    /**\n     * @notice The KromaPortal reverts when an account that is not\n     *         the GUARDIAN calls `unpause()`\n     */\n    function test_unpause_onlyGuardian_reverts() external {\n        address guardian = portal.GUARDIAN();\n\n        vm.prank(guardian);\n        portal.pause();\n        assertEq(portal.paused(), true);\n\n        assertTrue(portal.GUARDIAN() != alice);\n        vm.expectRevert(\"KromaPortal: only guardian can unpause\");\n        vm.prank(alice);\n        portal.unpause();\n\n        assertEq(portal.paused(), true);\n    }\n\n    function test_receive_succeeds() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(alice, alice, 100, 100, 100_000, false, hex\"\");\n\n        // give alice money and send as an eoa\n        vm.deal(alice, 2 ** 64);\n        vm.prank(alice, alice);\n        (bool s, ) = address(portal).call{ value: 100 }(hex\"\");\n\n        assert(s);\n        assertEq(address(portal).balance, 100);\n    }\n\n    // Test: depositTransaction fails when contract creation has a non-zero destination address\n    function test_depositTransaction_contractCreation_reverts() external {\n        // contract creation must have a target of address(0)\n        vm.expectRevert(\"KromaPortal: must send to address(0) when creating a contract\");\n        portal.depositTransaction(address(1), 1, 0, true, hex\"\");\n    }\n\n    /**\n     * @notice Prevent gasless deposits from being force processed in L2 by\n     *         ensuring that they have a large enough gas limit set.\n     */\n    function test_depositTransaction_smallGasLimit_reverts() external {\n        vm.expectRevert(\"KromaPortal: gas limit must cover instrinsic gas cost\");\n        portal.depositTransaction({\n            _to: address(1),\n            _value: 0,\n            _gasLimit: 0,\n            _isCreation: false,\n            _data: hex\"\"\n        });\n    }\n\n    // Test: depositTransaction should emit the correct log when an EOA deposits a tx with 0 value\n    function test_depositTransaction_noValueEOA_succeeds() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            address(this),\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        portal.depositTransaction(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    // Test: depositTransaction should emit the correct log when a contract deposits a tx with 0 value\n    function test_depositTransaction_noValueContract_succeeds() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        portal.depositTransaction(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    // Test: depositTransaction should emit the correct log when an EOA deposits a contract creation with 0 value\n    function test_depositTransaction_createWithZeroValueForEOA_succeeds() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            address(this),\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n\n        portal.depositTransaction(ZERO_ADDRESS, ZERO_VALUE, NON_ZERO_GASLIMIT, true, NON_ZERO_DATA);\n    }\n\n    // Test: depositTransaction should emit the correct log when a contract deposits a contract creation with 0 value\n    function test_depositTransaction_createWithZeroValueForContract_succeeds() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n\n        portal.depositTransaction(ZERO_ADDRESS, ZERO_VALUE, NON_ZERO_GASLIMIT, true, NON_ZERO_DATA);\n    }\n\n    // Test: depositTransaction should increase its eth balance when an EOA deposits a transaction with ETH\n    function test_depositTransaction_withEthValueFromEOA_succeeds() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            address(this),\n            NON_ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        portal.depositTransaction{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n        assertEq(address(portal).balance, NON_ZERO_VALUE);\n    }\n\n    // Test: depositTransaction should increase its eth balance when a contract deposits a transaction with ETH\n    function test_depositTransaction_withEthValueFromContract_succeeds() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            NON_ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        portal.depositTransaction{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    // Test: depositTransaction should increase its eth balance when an EOA deposits a contract creation with ETH\n    function test_depositTransaction_withEthValueAndEOAContractCreation_succeeds() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            address(this),\n            ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            hex\"\"\n        );\n\n        portal.depositTransaction{ value: NON_ZERO_VALUE }(\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            hex\"\"\n        );\n        assertEq(address(portal).balance, NON_ZERO_VALUE);\n    }\n\n    // Test: depositTransaction should increase its eth balance when a contract deposits a contract creation with ETH\n    function test_depositTransaction_withEthValueAndContractContractCreation_succeeds() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n\n        portal.depositTransaction{ value: NON_ZERO_VALUE }(\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n        assertEq(address(portal).balance, NON_ZERO_VALUE);\n    }\n\n    function test_simple_isOutputFinalized_succeeds() external {\n        uint256 ts = block.timestamp;\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.CheckpointOutput(\n                    trusted,\n                    bytes32(uint256(1)),\n                    uint128(ts),\n                    uint128(startingBlockNumber)\n                )\n            )\n        );\n\n        // warp to the finalization period\n        vm.warp(ts + oracle.FINALIZATION_PERIOD_SECONDS());\n        assertEq(portal.isOutputFinalized(0), false);\n\n        // warp past the finalization period\n        vm.warp(ts + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        assertEq(portal.isOutputFinalized(0), true);\n    }\n\n    function test_isOutputFinalized_succeeds() external {\n        uint256 checkpoint = oracle.nextBlockNumber();\n        uint256 nextOutputIndex = oracle.nextOutputIndex();\n        vm.roll(checkpoint);\n        warpToSubmitTime();\n        vm.prank(trusted);\n        oracle.submitL2Output(keccak256(abi.encode(2)), checkpoint, 0, 0);\n\n        // warp to the final second of the finalization period\n        uint256 finalizationHorizon = block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS();\n        vm.warp(finalizationHorizon);\n        // The checkpointed block should not be finalized until 1 second from now.\n        assertEq(portal.isOutputFinalized(nextOutputIndex), false);\n        // Nor should a block after it\n        vm.expectRevert(stdError.indexOOBError);\n        assertEq(portal.isOutputFinalized(nextOutputIndex + 1), false);\n\n        // warp past the finalization period\n        vm.warp(finalizationHorizon + 1);\n        // It should now be finalized.\n        assertEq(portal.isOutputFinalized(nextOutputIndex), true);\n        // But not the block after it.\n        vm.expectRevert(stdError.indexOOBError);\n        assertEq(portal.isOutputFinalized(nextOutputIndex + 1), false);\n    }\n}\n\ncontract KromaPortal_FinalizeWithdrawal_Test is Portal_Initializer {\n    // Reusable default values for a test withdrawal\n    Types.WithdrawalTransaction _defaultTx;\n\n    uint256 _submittedOutputIndex;\n    uint256 _submittedBlockNumber;\n    bytes32 _stateRoot;\n    bytes32 _storageRoot;\n    bytes32 _outputRoot;\n    bytes32 _withdrawalHash;\n    bytes[] _withdrawalProof;\n    Types.OutputRootProof internal _outputRootProof;\n\n    // Use a constructor to set the storage vars above, so as to minimize the number of ffi calls.\n    constructor() {\n        super.setUp();\n        _defaultTx = Types.WithdrawalTransaction({\n            nonce: 0,\n            sender: alice,\n            target: bob,\n            value: 100,\n            gasLimit: 100_000,\n            data: hex\"\"\n        });\n        // Get withdrawal proof data we can use for testing.\n        (_stateRoot, _storageRoot, _outputRoot, _withdrawalHash, _withdrawalProof) = ffi\n            .getProveWithdrawalTransactionInputs(_defaultTx);\n\n        // Setup a dummy output root proof for reuse.\n        _outputRootProof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: _stateRoot,\n            messagePasserStorageRoot: _storageRoot,\n            blockHash: bytes32(uint256(0)),\n            nextBlockHash: bytes32(uint256(0))\n        });\n        _submittedBlockNumber = oracle.nextBlockNumber();\n        _submittedOutputIndex = oracle.nextOutputIndex();\n    }\n\n    // Get the system into a nice ready-to-use state.\n    function setUp() public override {\n        // Configure the oracle to return the output root we've prepared.\n        warpToSubmitTime();\n        vm.prank(trusted);\n        oracle.submitL2Output(_outputRoot, _submittedBlockNumber, 0, 0);\n\n        // Warp beyond the finalization period for the block we've submitted.\n        vm.warp(\n            oracle.getL2Output(_submittedOutputIndex).timestamp +\n                oracle.FINALIZATION_PERIOD_SECONDS() +\n                1\n        );\n        // Fund the portal so that we can withdraw ETH.\n        vm.deal(address(portal), 0xFFFFFFFF);\n    }\n\n    // Utility function used in the subsequent test. This is necessary to assert that the\n    // reentrant call will revert.\n    function callPortalAndExpectRevert() external payable {\n        vm.expectRevert(\"KromaPortal: can only trigger one withdrawal per transaction\");\n        // Arguments here don't matter, as the require check is the first thing that happens.\n        // We assume that this has already been proven.\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n        // Assert that the withdrawal was not finalized.\n        assertFalse(portal.finalizedWithdrawals(Hashing.hashWithdrawal(_defaultTx)));\n    }\n\n    /**\n     * @notice Proving withdrawal transactions should revert when paused\n     */\n    function test_proveWithdrawalTransaction_paused_reverts() external {\n        vm.prank(portal.GUARDIAN());\n        portal.pause();\n\n        vm.expectRevert(\"KromaPortal: paused\");\n        portal.proveWithdrawalTransaction({\n            _tx: _defaultTx,\n            _l2OutputIndex: _submittedOutputIndex,\n            _outputRootProof: _outputRootProof,\n            _withdrawalProof: _withdrawalProof\n        });\n    }\n\n    // Test: proveWithdrawalTransaction cannot prove a withdrawal with itself (the KromaPortal) as the target.\n    function test_proveWithdrawalTransaction_onSelfCall_reverts() external {\n        _defaultTx.target = address(portal);\n        vm.expectRevert(\"KromaPortal: you cannot send messages to the portal contract\");\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n\n    // Test: proveWithdrawalTransaction reverts if the outputRootProof does not match the output root\n    function test_proveWithdrawalTransaction_onInvalidOutputRootProof_reverts() external {\n        // Modify the version to invalidate the withdrawal proof.\n        _outputRootProof.version = bytes32(uint256(MAX_OUTPUT_ROOT_PROOF_VERSION + 1));\n        vm.expectRevert(\"Hashing: unknown output root proof version\");\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n\n    // Test: proveWithdrawalTransaction reverts if the passed transaction's withdrawalHash has\n    // already been proven.\n    function test_proveWithdrawalTransaction_replayProve_reverts() external {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        vm.expectRevert(\"KromaPortal: withdrawal hash has already been proven\");\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n\n    // Test: proveWithdrawalTransaction succeeds if the passed transaction's withdrawalHash has\n    // already been proven AND the output root has changed AND the l2BlockNumber stays the same.\n    function test_proveWithdrawalTransaction_replayProveChangedOutputRoot_succeeds() external {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Compute the storage slot of the outputRoot corresponding to the `withdrawalHash`\n        // inside of the `provenWithdrawal`s mapping.\n        bytes32 slot;\n        assembly {\n            mstore(0x00, sload(_withdrawalHash.slot))\n            mstore(0x20, 52) // 52 is the slot of the `provenWithdrawals` mapping in KromaPortal\n            slot := keccak256(0x00, 0x40)\n        }\n\n        // Store a different output root within the `provenWithdrawals` mapping without\n        // touching the l2BlockNumber or timestamp.\n        vm.store(address(portal), slot, bytes32(0));\n\n        // Warp ahead 1 second\n        vm.warp(block.timestamp + 1);\n\n        // Even though we have already proven this withdrawalHash, we should be allowed to re-submit\n        // our proof with a changed outputRoot\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Ensure that the withdrawal was updated within the mapping\n        (, uint128 timestamp, ) = portal.provenWithdrawals(_withdrawalHash);\n        assertEq(timestamp, block.timestamp);\n    }\n\n    // Test: proveWithdrawalTransaction succeeds if the passed transaction's withdrawalHash has\n    // already been proven AND the output root + output index + l2BlockNumber changes.\n    function test_proveWithdrawalTransaction_replayProveChangedOutputRootAndOutputIndex_succeeds()\n        external\n    {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Compute the storage slot of the outputRoot corresponding to the `withdrawalHash`\n        // inside of the `provenWithdrawal`s mapping.\n        bytes32 slot;\n        assembly {\n            mstore(0x00, sload(_withdrawalHash.slot))\n            mstore(0x20, 52) // 52 is the slot of the `provenWithdrawals` mapping in KromaPortal\n            slot := keccak256(0x00, 0x40)\n        }\n\n        // Store a dummy output root within the `provenWithdrawals` mapping without touching the\n        // l2BlockNumber or timestamp.\n        vm.store(address(portal), slot, bytes32(0));\n\n        // Fetch the checkpoint output at `_submittedOutputIndex` from the L2OutputOracle\n        Types.CheckpointOutput memory output = portal.L2_ORACLE().getL2Output(\n            _submittedOutputIndex\n        );\n\n        // Propose the same output root again, creating the same output at a different index + l2BlockNumber.\n        vm.startPrank(trusted);\n        portal.L2_ORACLE().submitL2Output(\n            output.outputRoot,\n            portal.L2_ORACLE().nextBlockNumber(),\n            blockhash(block.number),\n            block.number\n        );\n        vm.stopPrank();\n\n        // Warp ahead 1 second\n        vm.warp(block.timestamp + 1);\n\n        // Even though we have already proven this withdrawalHash, we should be allowed to re-submit\n        // our proof with a changed outputRoot + a different output index\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex + 1,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Ensure that the withdrawal was updated within the mapping\n        (, uint128 timestamp, ) = portal.provenWithdrawals(_withdrawalHash);\n        assertEq(timestamp, block.timestamp);\n    }\n\n    // Test: proveWithdrawalTransaction succeeds and emits the WithdrawalProven event.\n    function test_proveWithdrawalTransaction_validWithdrawalProof_succeeds() external {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n\n    // Test: finalizeWithdrawalTransaction succeeds and emits the WithdrawalFinalized event.\n    function test_finalizeWithdrawalTransaction_provenWithdrawalHash_succeeds() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        vm.expectEmit(true, true, false, true);\n        emit WithdrawalFinalized(_withdrawalHash, true);\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        assert(address(bob).balance == bobBalanceBefore + 100);\n    }\n\n    /**\n     * @notice Finalizing withdrawal transactions should revert when paused\n     */\n    function test_finalizeWithdrawalTransaction_paused_reverts() external {\n        vm.prank(portal.GUARDIAN());\n        portal.pause();\n\n        vm.expectRevert(\"KromaPortal: paused\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the withdrawal has not been proven.\n    function test_finalizeWithdrawalTransaction_ifWithdrawalNotProven_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        vm.expectRevert(\"KromaPortal: withdrawal has not been proven yet\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        assert(address(bob).balance == bobBalanceBefore);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if withdrawal not proven long enough ago.\n    function test_finalizeWithdrawalTransaction_ifWithdrawalProofNotOldEnough_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Mock a call where the resulting output root is anything but the original output root. In\n        // this case we just use bytes32(uint256(1)).\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(bytes32(uint256(1)), _submittedBlockNumber)\n        );\n\n        vm.expectRevert(\"KromaPortal: proven withdrawal finalization period has not elapsed\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        assert(address(bob).balance == bobBalanceBefore);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the provenWithdrawal's timestamp is less\n    // than the L2 output oracle's starting timestamp\n    function test_finalizeWithdrawalTransaction_timestampLessThanL2OracleStart_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        // Prove our withdrawal\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Warp to after the finalization period\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Mock a startingTimestamp change on the L2 Oracle\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSignature(\"startingTimestamp()\"),\n            abi.encode(block.timestamp + 1)\n        );\n\n        // Attempt to finalize the withdrawal\n        vm.expectRevert(\"KromaPortal: withdrawal timestamp less than L2 Oracle starting timestamp\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        // Ensure that bob's balance has remained the same\n        assertEq(bobBalanceBefore, address(bob).balance);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the output root proven is not the same as the\n    // output root at the time of finalization.\n    function test_finalizeWithdrawalTransaction_ifOutputRootChanges_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        // Prove our withdrawal\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Warp to after the finalization period\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Mock an outputRoot change on the checkpoint output before attempting\n        // to finalize the withdrawal.\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.CheckpointOutput(\n                    trusted,\n                    bytes32(uint256(0)),\n                    uint128(block.timestamp),\n                    uint128(_submittedBlockNumber)\n                )\n            )\n        );\n\n        // Attempt to finalize the withdrawal\n        vm.expectRevert(\"KromaPortal: output root proven is not the same as current output root\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        // Ensure that bob's balance has remained the same\n        assertEq(bobBalanceBefore, address(bob).balance);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the checkpoint output's timestamp has\n    // not passed the finalization period.\n    function test_finalizeWithdrawalTransaction_ifOutputTimestampIsNotFinalized_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        // Prove our withdrawal\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Warp to after the finalization period\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Mock a timestamp change on the checkpoint output that has not passed the\n        // finalization period.\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.CheckpointOutput(\n                    trusted,\n                    _outputRoot,\n                    uint128(block.timestamp + 1),\n                    uint128(_submittedBlockNumber)\n                )\n            )\n        );\n\n        // Attempt to finalize the withdrawal\n        vm.expectRevert(\"KromaPortal: checkpoint output finalization period has not elapsed\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        // Ensure that bob's balance has remained the same\n        assertEq(bobBalanceBefore, address(bob).balance);\n    }\n\n    // Test: finalizeWithdrawalTransaction fails because the target reverts,\n    // and emits the WithdrawalFinalized event with success=false.\n    function test_finalizeWithdrawalTransaction_targetFails_fails() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n        vm.etch(bob, hex\"fe\"); // Contract with just the invalid opcode.\n\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalFinalized(_withdrawalHash, false);\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        assert(address(bob).balance == bobBalanceBefore);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the finalization period has not yet passed.\n    function test_finalizeWithdrawalTransaction_onRecentWithdrawal_reverts() external {\n        // Setup the Oracle to return an output with a recent timestamp\n        uint256 recentTimestamp = block.timestamp - 1000;\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.CheckpointOutput(\n                    trusted,\n                    _outputRoot,\n                    uint128(recentTimestamp),\n                    uint128(_submittedBlockNumber)\n                )\n            )\n        );\n\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        vm.expectRevert(\"KromaPortal: proven withdrawal finalization period has not elapsed\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the withdrawal has already been finalized.\n    function test_finalizeWithdrawalTransaction_onReplay_reverts() external {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(_withdrawalHash, alice, bob);\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalFinalized(_withdrawalHash, true);\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        vm.expectRevert(\"KromaPortal: withdrawal has already been finalized\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if insufficient gas is supplied.\n    function test_finalizeWithdrawalTransaction_onInsufficientGas_reverts() external {\n        // This number was identified through trial and error.\n        uint256 gasLimit = 150_000;\n        Types.WithdrawalTransaction memory insufficientGasTx = Types.WithdrawalTransaction({\n            nonce: 0,\n            sender: alice,\n            target: bob,\n            value: 100,\n            gasLimit: gasLimit,\n            data: hex\"\"\n        });\n\n        // Get updated proof inputs.\n        (bytes32 stateRoot, bytes32 storageRoot, , , bytes[] memory withdrawalProof) = ffi\n            .getProveWithdrawalTransactionInputs(insufficientGasTx);\n        Types.OutputRootProof memory outputRootProof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: stateRoot,\n            messagePasserStorageRoot: storageRoot,\n            blockHash: bytes32(uint256(0)),\n            nextBlockHash: bytes32(uint256(0))\n        });\n\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.CheckpointOutput(\n                    trusted,\n                    Hashing.hashOutputRootProof(outputRootProof),\n                    uint128(block.timestamp),\n                    uint128(_submittedBlockNumber)\n                )\n            )\n        );\n\n        portal.proveWithdrawalTransaction(\n            insufficientGasTx,\n            _submittedOutputIndex,\n            outputRootProof,\n            withdrawalProof\n        );\n\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        vm.expectRevert(\"SafeCall: Not enough gas\");\n        portal.finalizeWithdrawalTransaction{ gas: gasLimit }(insufficientGasTx);\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if a sub-call attempts to finalize another\n    // withdrawal.\n    function test_finalizeWithdrawalTransaction_onReentrancy_reverts() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        // Copy and modify the default test values to attempt a reentrant call by first calling to\n        // this contract's callPortalAndExpectRevert() function above.\n        Types.WithdrawalTransaction memory _testTx = _defaultTx;\n        _testTx.target = address(this);\n        _testTx.data = abi.encodeWithSelector(this.callPortalAndExpectRevert.selector);\n\n        // Get modified proof inputs.\n        (\n            bytes32 stateRoot,\n            bytes32 storageRoot,\n            bytes32 outputRoot,\n            bytes32 withdrawalHash,\n            bytes[] memory withdrawalProof\n        ) = ffi.getProveWithdrawalTransactionInputs(_testTx);\n        Types.OutputRootProof memory outputRootProof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: stateRoot,\n            messagePasserStorageRoot: storageRoot,\n            blockHash: bytes32(uint256(0)),\n            nextBlockHash: bytes32(uint256(0))\n        });\n\n        // Setup the Oracle to return the outputRoot we want as well as a finalized timestamp.\n        uint256 finalizedTimestamp = block.timestamp - oracle.FINALIZATION_PERIOD_SECONDS() - 1;\n        vm.mockCall(\n            address(portal.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(\n                Types.CheckpointOutput(\n                    trusted,\n                    outputRoot,\n                    uint128(finalizedTimestamp),\n                    uint128(_submittedBlockNumber)\n                )\n            )\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalProven(withdrawalHash, alice, address(this));\n        portal.proveWithdrawalTransaction(\n            _testTx,\n            _submittedBlockNumber,\n            outputRootProof,\n            withdrawalProof\n        );\n\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n        vm.expectCall(address(this), _testTx.data);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalFinalized(withdrawalHash, true);\n        portal.finalizeWithdrawalTransaction(_testTx);\n\n        // Ensure that bob's balance was not changed by the reentrant call.\n        assert(address(bob).balance == bobBalanceBefore);\n    }\n\n    function testDiff_finalizeWithdrawalTransaction_succeeds(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        vm.assume(\n            _target != address(portal) && // Cannot call the kroma portal or a contract\n                _target.code.length == 0 && // No accounts with code\n                _target != CONSOLE && // The console has no code but behaves like a contract\n                uint160(_target) > 9 // No precompiles (or zero address)\n        );\n\n        // Total ETH supply is currently about 120M ETH.\n        uint256 value = bound(_value, 0, 200_000_000 ether);\n        vm.deal(address(portal), value);\n\n        uint256 gasLimit = bound(_gasLimit, 0, 50_000_000);\n        uint256 nonce = messagePasser.messageNonce();\n\n        // Get a withdrawal transaction and mock proof from the differential testing script.\n        Types.WithdrawalTransaction memory _tx = Types.WithdrawalTransaction({\n            nonce: nonce,\n            sender: _sender,\n            target: _target,\n            value: value,\n            gasLimit: gasLimit,\n            data: _data\n        });\n        (\n            bytes32 stateRoot,\n            bytes32 storageRoot,\n            bytes32 outputRoot,\n            bytes32 withdrawalHash,\n            bytes[] memory withdrawalProof\n        ) = ffi.getProveWithdrawalTransactionInputs(_tx);\n\n        // Create the output root proof\n        Types.OutputRootProof memory proof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: stateRoot,\n            messagePasserStorageRoot: storageRoot,\n            blockHash: bytes32(uint256(0)),\n            nextBlockHash: bytes32(uint256(0))\n        });\n\n        // Ensure the values returned from ffi are correct\n        assertEq(outputRoot, Hashing.hashOutputRootProof(proof));\n        assertEq(withdrawalHash, Hashing.hashWithdrawal(_tx));\n\n        // Setup the Oracle to return the outputRoot\n        vm.mockCall(\n            address(oracle),\n            abi.encodeWithSelector(oracle.getL2Output.selector),\n            abi.encode(address(0), outputRoot, block.timestamp, 100)\n        );\n\n        // Prove the withdrawal transaction\n        portal.proveWithdrawalTransaction(\n            _tx,\n            1, // l2OutputIndex\n            proof,\n            withdrawalProof\n        );\n        (bytes32 _root, , ) = portal.provenWithdrawals(withdrawalHash);\n        assertTrue(_root != bytes32(0));\n\n        // Warp past the finalization period\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Finalize the withdrawal transaction\n        vm.expectCallMinGas(_tx.target, _tx.value, uint64(_tx.gasLimit), _tx.data);\n        portal.finalizeWithdrawalTransaction(_tx);\n        assertTrue(portal.finalizedWithdrawals(withdrawalHash));\n    }\n}\n\ncontract KromaPortalUpgradeable_Test is Portal_Initializer {\n    Proxy internal proxy;\n    uint64 initialBlockNum;\n\n    function setUp() public override {\n        super.setUp();\n        initialBlockNum = uint64(block.number);\n        proxy = Proxy(payable(address(portal)));\n    }\n\n    function test_params_initValuesOnProxy_succeeds() external {\n        KromaPortal p = KromaPortal(payable(address(proxy)));\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = p.params();\n        ResourceMetering.ResourceConfig memory rcfg = systemConfig.resourceConfig();\n\n        assertEq(prevBaseFee, rcfg.minimumBaseFee);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum);\n    }\n\n    function test_initialize_cannotInitProxy_reverts() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        KromaPortal(payable(proxy)).initialize(false);\n    }\n\n    function test_initialize_cannotInitImpl_reverts() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        KromaPortal(portalImpl).initialize(false);\n    }\n\n    function test_upgradeToAndCall_upgrading_succeeds() external {\n        // Check an unused slot before upgrading.\n        bytes32 slot21Before = vm.load(address(portal), bytes32(uint256(21)));\n        assertEq(bytes32(0), slot21Before);\n\n        NextImpl nextImpl = new NextImpl();\n        vm.startPrank(multisig);\n        proxy.upgradeToAndCall(\n            address(nextImpl),\n            abi.encodeWithSelector(NextImpl.initialize.selector)\n        );\n        assertEq(proxy.implementation(), address(nextImpl));\n\n        // Verify that the NextImpl contract initialized its values according as expected\n        bytes32 slot21After = vm.load(address(portal), bytes32(uint256(21)));\n        bytes32 slot21Expected = NextImpl(address(portal)).slot21Init();\n        assertEq(slot21Expected, slot21After);\n    }\n}\n\n/**\n * @title KromaPortalResourceFuzz_Test\n * @dev Test various values of the resource metering config to ensure that deposits cannot be\n *         broken by changing the config.\n */\ncontract KromaPortalResourceFuzz_Test is Portal_Initializer {\n    /**\n     * @dev The max gas limit observed throughout this test. Setting this too high can cause\n     *      the test to take too long to run.\n     */\n    uint256 constant MAX_GAS_LIMIT = 30_000_000;\n\n    /**\n     * @dev Test that various values of the resource metering config will not break deposits.\n     */\n    function testFuzz_systemConfigDeposit_succeeds(\n        uint32 _maxResourceLimit,\n        uint8 _elasticityMultiplier,\n        uint8 _baseFeeMaxChangeDenominator,\n        uint32 _minimumBaseFee,\n        uint32 _systemTxMaxGas,\n        uint128 _maximumBaseFee,\n        uint64 _gasLimit,\n        uint64 _prevBoughtGas,\n        uint128 _prevBaseFee,\n        uint8 _blockDiff\n    ) external {\n        // Get the set system gas limit\n        uint64 gasLimit = systemConfig.gasLimit();\n        // Bound resource config\n        _maxResourceLimit = uint32(bound(_maxResourceLimit, 21000, MAX_GAS_LIMIT / 8));\n        _gasLimit = uint64(bound(_gasLimit, 21000, _maxResourceLimit));\n        _prevBaseFee = uint128(bound(_prevBaseFee, 0, 5 gwei));\n        // Prevent values that would cause reverts\n        vm.assume(gasLimit >= _gasLimit);\n        vm.assume(_minimumBaseFee < _maximumBaseFee);\n        vm.assume(_baseFeeMaxChangeDenominator > 1);\n        vm.assume(uint256(_maxResourceLimit) + uint256(_systemTxMaxGas) <= gasLimit);\n        vm.assume(_elasticityMultiplier > 0);\n        vm.assume(\n            ((_maxResourceLimit / _elasticityMultiplier) * _elasticityMultiplier) ==\n                _maxResourceLimit\n        );\n        _prevBoughtGas = uint64(bound(_prevBoughtGas, 0, _maxResourceLimit - _gasLimit));\n        _blockDiff = uint8(bound(_blockDiff, 0, 3));\n\n        // Create a resource config to mock the call to the system config with\n        ResourceMetering.ResourceConfig memory rcfg = ResourceMetering.ResourceConfig({\n            maxResourceLimit: _maxResourceLimit,\n            elasticityMultiplier: _elasticityMultiplier,\n            baseFeeMaxChangeDenominator: _baseFeeMaxChangeDenominator,\n            minimumBaseFee: _minimumBaseFee,\n            systemTxMaxGas: _systemTxMaxGas,\n            maximumBaseFee: _maximumBaseFee\n        });\n        vm.mockCall(\n            address(systemConfig),\n            abi.encodeWithSelector(systemConfig.resourceConfig.selector),\n            abi.encode(rcfg)\n        );\n\n        // Set the resource params\n        uint256 _prevBlockNum = block.number - _blockDiff;\n        vm.store(\n            address(portal),\n            bytes32(uint256(1)),\n            bytes32((_prevBlockNum << 192) | (uint256(_prevBoughtGas) << 128) | _prevBaseFee)\n        );\n        // Ensure that the storage setting is correct\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = portal.params();\n        assertEq(prevBaseFee, _prevBaseFee);\n        assertEq(prevBoughtGas, _prevBoughtGas);\n        assertEq(prevBlockNum, _prevBlockNum);\n\n        // Do a deposit, should not revert\n        portal.depositTransaction{ gas: MAX_GAS_LIMIT }({\n            _to: address(0x20),\n            _value: 0x40,\n            _gasLimit: _gasLimit,\n            _isCreation: false,\n            _data: hex\"\"\n        });\n    }\n}\n"
    },
    "contracts/test/KromaVestingWallet.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { GovernanceToken } from \"../governance/GovernanceToken.sol\";\nimport { KromaVestingWallet } from \"../universal/KromaVestingWallet.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract KromaVestingWalletTest is CommonTest {\n    uint64 immutable SECONDS_PER_3_MONTHS = 365 days / 4;\n\n    KromaVestingWallet vestingWallet;\n    address beneficiary;\n    uint64 startTime;\n    uint64 durationNum;\n    uint64 durationSec;\n    uint64 cliffDivider;\n    uint64 vestingCycle;\n\n    GovernanceToken token;\n    address tokenOwner;\n    uint256 totalAllocation;\n\n    function setUp() public override {\n        super.setUp();\n\n        beneficiary = makeAddr(\"beneficiary\");\n        vestingCycle = SECONDS_PER_3_MONTHS;\n        startTime = vestingCycle;\n        durationNum = 12;\n        durationSec = vestingCycle * durationNum;\n        cliffDivider = 4;\n\n        tokenOwner = makeAddr(\"tokenOwner\");\n        totalAllocation = 15 * 10_000_000 * (10 ** 18);\n\n        vestingWallet = KromaVestingWallet(payable(address(new Proxy(multisig))));\n        KromaVestingWallet vestingWalletImpl = new KromaVestingWallet(cliffDivider, vestingCycle);\n        vm.prank(multisig);\n        toProxy(address(vestingWallet)).upgradeToAndCall(\n            address(vestingWalletImpl),\n            abi.encodeCall(vestingWallet.initialize, (beneficiary, startTime, durationSec))\n        );\n\n        token = GovernanceToken(address(new Proxy(multisig)));\n        GovernanceToken tokenImpl = new GovernanceToken(ZERO_ADDRESS, ZERO_ADDRESS);\n        vm.prank(multisig);\n        toProxy(address(token)).upgradeToAndCall(\n            address(tokenImpl),\n            abi.encodeCall(token.initialize, tokenOwner)\n        );\n        vm.prank(tokenOwner);\n        token.acceptOwnership();\n\n        vm.prank(tokenOwner);\n        token.mint(address(vestingWallet), totalAllocation);\n        assertEq(token.balanceOf(address(vestingWallet)), totalAllocation);\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(vestingWallet.CLIFF_DIVIDER(), cliffDivider);\n        assertEq(vestingWallet.VESTING_CYCLE(), vestingCycle);\n    }\n\n    function test_constructor_zeroValues_reverts() external {\n        vm.expectRevert(\"KromaVestingWallet: cliff divider is zero\");\n        new KromaVestingWallet(0, vestingCycle);\n\n        vm.expectRevert(\"KromaVestingWallet: vesting cycle is zero\");\n        new KromaVestingWallet(cliffDivider, 0);\n    }\n\n    function test_initialize_succeeds() external {\n        assertEq(vestingWallet.beneficiary(), beneficiary);\n        assertEq(vestingWallet.start(), startTime);\n        assertEq(vestingWallet.duration(), durationSec);\n    }\n\n    function test_initialize_durationNotMultiple_reverts() external {\n        vestingWallet = KromaVestingWallet(payable(address(new Proxy(multisig))));\n        KromaVestingWallet vestingWalletImpl = new KromaVestingWallet(cliffDivider, vestingCycle);\n\n        vm.prank(multisig);\n        vm.expectRevert(\"Proxy: delegatecall to new implementation contract failed\");\n        toProxy(address(vestingWallet)).upgradeToAndCall(\n            address(vestingWalletImpl),\n            abi.encodeCall(vestingWallet.initialize, (beneficiary, startTime, durationSec + 1))\n        );\n    }\n\n    function test_release_token_succeeds() external {\n        // Ensure test env is set properly\n        assertEq(token.balanceOf(beneficiary), 0);\n        assertTrue(block.timestamp < startTime);\n\n        uint256 cliffAmount = totalAllocation / cliffDivider;\n        uint256 vestingAmountPer3Months = (totalAllocation - cliffAmount) / durationNum;\n\n        vm.startPrank(beneficiary);\n        vestingWallet.release(address(token));\n        assertEq(token.balanceOf(beneficiary), 0);\n\n        vm.warp(startTime);\n        vestingWallet.release(address(token));\n        assertEq(token.balanceOf(beneficiary), cliffAmount);\n\n        vm.warp(startTime + vestingCycle / 2);\n        vestingWallet.release(address(token));\n        assertEq(token.balanceOf(beneficiary), cliffAmount);\n\n        vm.warp(startTime + vestingCycle);\n        vestingWallet.release(address(token));\n        assertEq(token.balanceOf(beneficiary), cliffAmount + vestingAmountPer3Months);\n\n        vm.warp(startTime + durationSec);\n        vestingWallet.release(address(token));\n        assertEq(token.balanceOf(beneficiary), totalAllocation);\n    }\n\n    function test_release_tokenAfterFullyVested_succeeds() external {\n        // Ensure test env is set properly\n        assertEq(token.balanceOf(beneficiary), 0);\n\n        vm.warp(startTime + durationSec + 1);\n\n        vm.prank(beneficiary);\n        vestingWallet.release(address(token));\n        assertEq(token.balanceOf(beneficiary), totalAllocation);\n    }\n\n    function test_release_succeeds() external {\n        uint256 totalEthAllocation = 1 ether;\n        vm.deal(address(vestingWallet), totalEthAllocation);\n\n        // Ensure test env is set properly\n        assertEq(beneficiary.balance, 0);\n        assertTrue(block.timestamp < startTime);\n\n        uint256 cliffAmount = totalEthAllocation / cliffDivider;\n        uint256 vestingAmountPer3Months = (totalEthAllocation - cliffAmount) / durationNum;\n\n        vm.startPrank(beneficiary);\n        vestingWallet.release();\n        assertEq(beneficiary.balance, 0);\n\n        vm.warp(startTime);\n        vestingWallet.release();\n        assertEq(beneficiary.balance, cliffAmount);\n\n        vm.warp(startTime + vestingCycle / 2);\n        vestingWallet.release();\n        assertEq(beneficiary.balance, cliffAmount);\n\n        vm.warp(startTime + vestingCycle);\n        vestingWallet.release();\n        assertEq(beneficiary.balance, cliffAmount + vestingAmountPer3Months);\n\n        vm.warp(startTime + durationSec);\n        vestingWallet.release();\n        assertEq(beneficiary.balance, totalEthAllocation);\n    }\n\n    function test_release_afterFullyVested_succeeds() external {\n        uint256 totalEthAllocation = 1 ether;\n        vm.deal(address(vestingWallet), totalEthAllocation);\n\n        // Ensure test env is set properly\n        assertEq(beneficiary.balance, 0);\n\n        vm.warp(startTime + durationSec + 1);\n\n        vm.prank(beneficiary);\n        vestingWallet.release();\n        assertEq(beneficiary.balance, totalEthAllocation);\n    }\n\n    function test_release_notBeneficiary_reverts() external {\n        vm.startPrank(tokenOwner);\n\n        vm.expectRevert(\"KromaVestingWallet: caller is not beneficiary\");\n        vestingWallet.release(address(token));\n\n        vm.expectRevert(\"KromaVestingWallet: caller is not beneficiary\");\n        vestingWallet.release();\n    }\n}\n"
    },
    "contracts/test/L1Block.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n// Testing utilities\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\n// Libraries\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\n\n// Target contract\nimport { GovernanceToken } from \"../governance/GovernanceToken.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { L1Block } from \"../L2/L1Block.sol\";\n\ncontract L1BlockTest is CommonTest {\n    L1Block l1Block;\n    address depositor;\n    bytes32 immutable NON_ZERO_HASH = keccak256(abi.encode(1));\n\n    /// @dev Sets up the test suite.\n    function setUp() public virtual override {\n        super.setUp();\n        l1Block = new L1Block();\n        depositor = l1Block.DEPOSITOR_ACCOUNT();\n        vm.prank(depositor);\n        l1Block.setL1BlockValues({\n            _number: uint64(1),\n            _timestamp: uint64(2),\n            _basefee: 3,\n            _hash: NON_ZERO_HASH,\n            _sequenceNumber: uint64(4),\n            _batcherHash: bytes32(0),\n            _l1FeeOverhead: 2,\n            _l1FeeScalar: 3,\n            _validatorRewardScalar: 1\n        });\n    }\n}\n\ncontract L1BlockBedrock_Test is L1BlockTest {\n    // @dev Tests that `setL1BlockValues` updates the values correctly.\n    function testFuzz_updatesValues_succeeds(\n        uint64 n,\n        uint64 t,\n        uint256 b,\n        bytes32 h,\n        uint64 s,\n        bytes32 bt,\n        uint256 fo,\n        uint256 fs,\n        uint256 vrr\n    )\n        external\n    {\n        vrr = bound(vrr, 0, 10000);\n        vm.prank(depositor);\n        l1Block.setL1BlockValues(n, t, b, h, s, bt, fo, fs, vrr);\n        assertEq(l1Block.number(), n);\n        assertEq(l1Block.timestamp(), t);\n        assertEq(l1Block.basefee(), b);\n        assertEq(l1Block.hash(), h);\n        assertEq(l1Block.sequenceNumber(), s);\n        assertEq(l1Block.batcherHash(), bt);\n        assertEq(l1Block.l1FeeOverhead(), fo);\n        assertEq(l1Block.l1FeeScalar(), fs);\n        assertEq(l1Block.validatorRewardScalar(), vrr);\n    }\n\n    /// @dev Tests that `setL1BlockValues` can set max values.\n    function test_updateValues_succeeds() external {\n        vm.prank(depositor);\n        l1Block.setL1BlockValues({\n            _number: type(uint64).max,\n            _timestamp: type(uint64).max,\n            _basefee: type(uint256).max,\n            _hash: keccak256(abi.encode(1)),\n            _sequenceNumber: type(uint64).max,\n            _batcherHash: bytes32(type(uint256).max),\n            _l1FeeOverhead: type(uint256).max,\n            _l1FeeScalar: type(uint256).max,\n            _validatorRewardScalar: 10000\n        });\n    }\n}\n\ncontract L1BlockEcotone_Test is L1BlockTest {\n    /// @dev Tests that setL1BlockValuesEcotone updates the values appropriately.\n    function testFuzz_setL1BlockValuesEcotone_succeeds(\n        uint32 baseFeeScalar,\n        uint32 blobBaseFeeScalar,\n        uint64 sequenceNumber,\n        uint64 timestamp,\n        uint64 number,\n        uint256 baseFee,\n        uint256 blobBaseFee,\n        bytes32 hash,\n        bytes32 batcherHash,\n        uint256 validatorRewardScalar\n    )\n        external\n    {\n        bytes memory functionCallDataPacked = Encoding.encodeSetL1BlockValuesEcotone(\n            baseFeeScalar, blobBaseFeeScalar, sequenceNumber, timestamp, number, baseFee, blobBaseFee, hash, batcherHash, validatorRewardScalar\n        );\n\n        vm.prank(depositor);\n        (bool success,) = address(l1Block).call(functionCallDataPacked);\n        assertTrue(success, \"Function call failed\");\n\n        assertEq(l1Block.baseFeeScalar(), baseFeeScalar);\n        assertEq(l1Block.blobBaseFeeScalar(), blobBaseFeeScalar);\n        assertEq(l1Block.sequenceNumber(), sequenceNumber);\n        assertEq(l1Block.timestamp(), timestamp);\n        assertEq(l1Block.number(), number);\n        assertEq(l1Block.basefee(), baseFee);\n        assertEq(l1Block.blobBaseFee(), blobBaseFee);\n        assertEq(l1Block.hash(), hash);\n        assertEq(l1Block.batcherHash(), batcherHash);\n        assertEq(l1Block.validatorRewardScalar(), validatorRewardScalar);\n\n        // ensure we didn't accidentally pollute the 128 bits of the sequencenum+scalars slot that\n        // should be empty\n        bytes32 scalarsSlot = vm.load(address(l1Block), bytes32(uint256(3)));\n        bytes32 mask128 = hex\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000\";\n\n        assertEq(0, scalarsSlot & mask128);\n\n        // ensure we didn't accidentally pollute the 128 bits of the number & timestamp slot that\n        // should be empty\n        bytes32 numberTimestampSlot = vm.load(address(l1Block), bytes32(uint256(0)));\n        assertEq(0, numberTimestampSlot & mask128);\n    }\n\n    /// @dev Tests that `setL1BlockValuesEcotone` succeeds if sender address is the depositor\n    function test_setL1BlockValuesEcotone_isDepositor_succeeds() external {\n        bytes memory functionCallDataPacked = Encoding.encodeSetL1BlockValuesEcotone(\n            type(uint32).max,\n            type(uint32).max,\n            type(uint64).max,\n            type(uint64).max,\n            type(uint64).max,\n            type(uint256).max,\n            type(uint256).max,\n            bytes32(type(uint256).max),\n            bytes32(type(uint256).max),\n            type(uint256).max\n        );\n\n        vm.prank(depositor);\n        (bool success,) = address(l1Block).call(functionCallDataPacked);\n        assertTrue(success, \"function call failed\");\n    }\n\n    /// @dev Tests that `setL1BlockValuesEcotone` fails if sender address is not the depositor\n    function test_setL1BlockValuesEcotone_notDepositor_fails() external {\n        bytes memory functionCallDataPacked = Encoding.encodeSetL1BlockValuesEcotone(\n            type(uint32).max,\n            type(uint32).max,\n            type(uint64).max,\n            type(uint64).max,\n            type(uint64).max,\n            type(uint256).max,\n            type(uint256).max,\n            bytes32(type(uint256).max),\n            bytes32(type(uint256).max),\n            type(uint256).max\n        );\n\n        (bool success, bytes memory data) = address(l1Block).call(functionCallDataPacked);\n        assertTrue(!success, \"function call should have failed\");\n        // make sure return value is the expected function selector for \"NotDepositor()\"\n        bytes memory expReturn = hex\"3cc50b45\";\n        assertEq(data, expReturn);\n    }\n}\n"
    },
    "contracts/test/L1CrossDomainMessenger.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { KromaPortal } from \"../L1/KromaPortal.sol\";\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Messenger_Initializer, Reverter, ConfigurableCaller } from \"./CommonTest.t.sol\";\nimport { L2OutputOracle_Initializer } from \"./L2OutputOracle.t.sol\";\n\ncontract L1CrossDomainMessenger_Test is Messenger_Initializer {\n    // Receiver address for testing\n    address recipient = address(0xabbaacdc);\n\n    // Storage slot of the l2Sender\n    uint256 constant senderSlotIndex = 50;\n\n    // the version is encoded in the nonce\n    function test_messageVersion_succeeds() external {\n        (, uint16 version) = Encoding.decodeVersionedNonce(L1Messenger.messageNonce());\n        assertEq(version, L1Messenger.MESSAGE_VERSION());\n    }\n\n    // sendMessage: should be able to send a single message\n    function test_sendMessage_succeeds() external {\n        // deposit transaction on the kroma portal should be called\n        vm.expectCall(\n            address(portal),\n            abi.encodeWithSelector(\n                KromaPortal.depositTransaction.selector,\n                Predeploys.L2_CROSS_DOMAIN_MESSENGER,\n                0,\n                L1Messenger.baseGas(hex\"ff\", 100),\n                false,\n                Encoding.encodeCrossDomainMessage(\n                    L1Messenger.messageNonce(),\n                    alice,\n                    recipient,\n                    0,\n                    100,\n                    hex\"ff\"\n                )\n            )\n        );\n\n        // TransactionDeposited event\n        vm.expectEmit(true, true, true, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)),\n            Predeploys.L2_CROSS_DOMAIN_MESSENGER,\n            0,\n            0,\n            L1Messenger.baseGas(hex\"ff\", 100),\n            false,\n            Encoding.encodeCrossDomainMessage(\n                L1Messenger.messageNonce(),\n                alice,\n                recipient,\n                0,\n                100,\n                hex\"ff\"\n            )\n        );\n\n        // SentMessage event\n        vm.expectEmit(true, true, true, true);\n        emit SentMessage(recipient, alice, 0, hex\"ff\", L1Messenger.messageNonce(), 100);\n\n        vm.prank(alice);\n        L1Messenger.sendMessage(recipient, hex\"ff\", uint32(100));\n    }\n\n    // sendMessage: should be able to send the same message twice\n    function test_sendMessage_twice_succeeds() external {\n        uint256 nonce = L1Messenger.messageNonce();\n        L1Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        L1Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        // the nonce increments for each message sent\n        assertEq(nonce + 2, L1Messenger.messageNonce());\n    }\n\n    function test_xDomainSender_notSet_reverts() external {\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L1Messenger.xDomainMessageSender();\n    }\n\n    function test_relayMessage_v2_reverts() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        // Set the value of portal.l2Sender() to be the L2 Cross Domain Messenger.\n        vm.store(address(portal), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n\n        // Expect a revert.\n        vm.expectRevert(\"CrossDomainMessenger: only version 0 messages is supported at this time\");\n\n        // Try to relay a v2 message.\n        vm.prank(address(portal));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 2 }), // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            hex\"1111\"\n        );\n    }\n\n    // relayMessage: should send a successful call to the target contract\n    function test_relayMessage_succeeds() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        vm.expectCall(target, hex\"1111\");\n\n        // set the value of portal.l2Sender() to be the L2 Cross Domain Messenger.\n        vm.store(address(portal), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n        vm.prank(address(portal));\n\n        vm.expectEmit(true, true, true, true);\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            hex\"1111\"\n        );\n\n        emit RelayedMessage(hash);\n\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            hex\"1111\"\n        );\n\n        // the message hash is in the successfulMessages mapping\n        assert(L1Messenger.successfulMessages(hash));\n        // it is not in the received messages mapping\n        assertEq(L1Messenger.failedMessages(hash), false);\n    }\n\n    // relayMessage: should revert if attempting to relay a message sent to an L1 system contract\n    function test_relayMessage_toSystemContract_reverts() external {\n        // set the target to be the KromaPortal\n        address target = address(portal);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n        bytes memory message = hex\"1111\";\n\n        vm.prank(address(portal));\n        vm.expectRevert(\"CrossDomainMessenger: message cannot be replayed\");\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            message\n        );\n\n        vm.store(address(portal), 0, bytes32(abi.encode(sender)));\n        vm.expectRevert(\"CrossDomainMessenger: message cannot be replayed\");\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            message\n        );\n    }\n\n    // relayMessage: should revert if eth is sent from a contract other than the standard bridge\n    function test_replayMessage_withValue_reverts() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n        bytes memory message = hex\"1111\";\n\n        vm.expectRevert(\n            \"CrossDomainMessenger: value must be zero unless message is from a system address\"\n        );\n        L1Messenger.relayMessage{ value: 100 }(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            message\n        );\n    }\n\n    // relayMessage: the xDomainMessageSender is reset to the original value\n    function test_xDomainMessageSender_reset_succeeds() external {\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L1Messenger.xDomainMessageSender();\n\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        vm.store(address(portal), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n        vm.prank(address(portal));\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            address(0),\n            address(0),\n            0,\n            0,\n            hex\"\"\n        );\n\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L1Messenger.xDomainMessageSender();\n    }\n\n    // relayMessage: should send a successful call to the target contract after the first message\n    // fails and ETH gets stuck, but the second message succeeds\n    function test_relayMessage_retryAfterFailure_succeeds() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n        uint256 value = 100;\n\n        vm.expectCall(target, hex\"1111\");\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        vm.store(address(portal), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n        vm.etch(target, address(new Reverter()).code);\n        vm.deal(address(portal), value);\n        vm.prank(address(portal));\n        L1Messenger.relayMessage{ value: value }(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        assertEq(address(L1Messenger).balance, value);\n        assertEq(address(target).balance, 0);\n        assertEq(L1Messenger.successfulMessages(hash), false);\n        assertEq(L1Messenger.failedMessages(hash), true);\n\n        vm.expectEmit(true, true, true, true);\n\n        emit RelayedMessage(hash);\n\n        vm.etch(target, address(0).code);\n        vm.prank(address(sender));\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        assertEq(address(L1Messenger).balance, 0);\n        assertEq(address(target).balance, value);\n        assertEq(L1Messenger.successfulMessages(hash), true);\n        assertEq(L1Messenger.failedMessages(hash), true);\n    }\n}\n"
    },
    "contracts/test/L1ERC721Bridge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport { L1ERC721Bridge } from \"../L1/L1ERC721Bridge.sol\";\nimport { L2ERC721Bridge } from \"../L2/L2ERC721Bridge.sol\";\nimport { Messenger_Initializer } from \"./CommonTest.t.sol\";\n\ncontract TestERC721 is ERC721 {\n    constructor() ERC721(\"Test\", \"TST\") {}\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n}\n\ncontract L1ERC721Bridge_Test is Messenger_Initializer {\n    TestERC721 internal localToken;\n    TestERC721 internal remoteToken;\n    L1ERC721Bridge internal bridge;\n    address internal constant otherBridge = address(0x3456);\n    uint256 internal constant tokenId = 1;\n\n    event ERC721BridgeInitiated(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    event ERC721BridgeFinalized(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    function setUp() public override {\n        super.setUp();\n\n        // Create necessary contracts.\n        bridge = new L1ERC721Bridge(address(L1Messenger), otherBridge);\n        localToken = new TestERC721();\n        remoteToken = new TestERC721();\n\n        // Label the bridge so we get nice traces.\n        vm.label(address(bridge), \"L1ERC721Bridge\");\n\n        // Mint alice a token.\n        localToken.mint(alice, tokenId);\n\n        // Approve the bridge to transfer the token.\n        vm.prank(alice);\n        localToken.approve(address(bridge), tokenId);\n    }\n\n    function test_constructor_succeeds() public {\n        assertEq(address(bridge.MESSENGER()), address(L1Messenger));\n        assertEq(address(bridge.OTHER_BRIDGE()), otherBridge);\n    }\n\n    function test_bridgeERC721_succeeds() public {\n        // Expect a call to the messenger.\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeCall(\n                L1Messenger.sendMessage,\n                (\n                    address(otherBridge),\n                    abi.encodeCall(\n                        L2ERC721Bridge.finalizeBridgeERC721,\n                        (\n                            address(remoteToken),\n                            address(localToken),\n                            alice,\n                            alice,\n                            tokenId,\n                            hex\"5678\"\n                        )\n                    ),\n                    1234\n                )\n            )\n        );\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeInitiated(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), true);\n        assertEq(localToken.ownerOf(tokenId), address(bridge));\n    }\n\n    function test_bridgeERC721_fromContract_reverts() external {\n        // Bridge the token.\n        vm.etch(alice, hex\"01\");\n        vm.prank(alice);\n        vm.expectRevert(\"ERC721Bridge: account is not externally owned\");\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_localTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert();\n        bridge.bridgeERC721(address(0), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_remoteTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert(\"L1ERC721Bridge: remote token cannot be address(0)\");\n        bridge.bridgeERC721(address(localToken), address(0), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_wrongOwner_reverts() external {\n        // Bridge the token.\n        vm.prank(bob);\n        vm.expectRevert(\"ERC721: transfer from incorrect owner\");\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_succeeds() external {\n        // Expect a call to the messenger.\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeCall(\n                L1Messenger.sendMessage,\n                (\n                    address(otherBridge),\n                    abi.encodeCall(\n                        L2ERC721Bridge.finalizeBridgeERC721,\n                        (address(remoteToken), address(localToken), alice, bob, tokenId, hex\"5678\")\n                    ),\n                    1234\n                )\n            )\n        );\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeInitiated(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            bob,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721To(\n            address(localToken),\n            address(remoteToken),\n            bob,\n            tokenId,\n            1234,\n            hex\"5678\"\n        );\n\n        // Token is locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), true);\n        assertEq(localToken.ownerOf(tokenId), address(bridge));\n    }\n\n    function test_bridgeERC721To_localTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert();\n        bridge.bridgeERC721To(address(0), address(remoteToken), bob, tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_remoteTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert(\"L1ERC721Bridge: remote token cannot be address(0)\");\n        bridge.bridgeERC721To(address(localToken), address(0), bob, tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_wrongOwner_reverts() external {\n        // Bridge the token.\n        vm.prank(bob);\n        vm.expectRevert(\"ERC721: transfer from incorrect owner\");\n        bridge.bridgeERC721To(\n            address(localToken),\n            address(remoteToken),\n            bob,\n            tokenId,\n            1234,\n            hex\"5678\"\n        );\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_finalizeBridgeERC721_succeeds() external {\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeFinalized(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(L1Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L1Messenger));\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Token is not locked in the bridge.\n        assertEq(bridge.deposits(address(localToken), address(remoteToken), tokenId), false);\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_finalizeBridgeERC721_notViaLocalMessenger_reverts() external {\n        // Finalize a withdrawal.\n        vm.prank(alice);\n        vm.expectRevert(\"ERC721Bridge: function can only be called from the other bridge\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_notFromRemoteMessenger_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(L1Messenger.xDomainMessageSender.selector),\n            abi.encode(alice)\n        );\n        vm.prank(address(L1Messenger));\n        vm.expectRevert(\"ERC721Bridge: function can only be called from the other bridge\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_selfToken_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(L1Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L1Messenger));\n        vm.expectRevert(\"L1ERC721Bridge: local token cannot be self\");\n        bridge.finalizeBridgeERC721(\n            address(bridge),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_notEscrowed_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(L1Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L1Messenger));\n        vm.expectRevert(\"L1ERC721Bridge: Token ID is not escrowed in the L1 Bridge\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n}\n"
    },
    "contracts/test/L1StandardBridge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { stdStorage, StdStorage } from \"forge-std/Test.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { KromaPortal } from \"../L1/KromaPortal.sol\";\nimport { L2StandardBridge } from \"../L2/L2StandardBridge.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\n\ncontract L1StandardBridge_Getter_Test is Bridge_Initializer {\n    function test_getters_succeeds() external view {\n        assert(L1Bridge.OTHER_BRIDGE() == L2Bridge);\n        assert(L1Bridge.MESSENGER() == L1Messenger);\n    }\n}\n\ncontract L1StandardBridge_Initialize_Test is Bridge_Initializer {\n    function test_initialize_succeeds() external {\n        assertEq(address(L1Bridge.MESSENGER()), address(L1Messenger));\n\n        assertEq(address(L1Bridge.OTHER_BRIDGE()), Predeploys.L2_STANDARD_BRIDGE);\n\n        assertEq(address(L2Bridge), Predeploys.L2_STANDARD_BRIDGE);\n    }\n}\n\ncontract L1StandardBridge_Initialize_TestFail is Bridge_Initializer {}\n\ncontract L1StandardBridge_Receive_Test is Bridge_Initializer {\n    // receive\n    // - can accept ETH\n    function test_receive_succeeds() external {\n        assertEq(address(portal).balance, 0);\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHBridgeInitiated(alice, alice, 100, hex\"\");\n\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                abi.encodeWithSelector(\n                    StandardBridge.finalizeBridgeETH.selector,\n                    alice,\n                    alice,\n                    100,\n                    hex\"\"\n                ),\n                200_000\n            )\n        );\n\n        vm.prank(alice, alice);\n        (bool success, ) = address(L1Bridge).call{ value: 100 }(hex\"\");\n        assertEq(success, true);\n        assertEq(address(portal).balance, 100);\n    }\n}\n\ncontract L1StandardBridge_Receive_TestFail {}\n\ncontract PreBridgeETH is Bridge_Initializer {\n    function _preBridgeETH() internal {\n        assertEq(address(portal).balance, 0);\n        uint256 nonce = L1Messenger.messageNonce();\n        uint256 version = 0; // Internal constant in the KromaPortal: DEPOSIT_VERSION\n        address l1MessengerAliased = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeETH.selector,\n            alice,\n            alice,\n            500,\n            hex\"dead\"\n        );\n\n        vm.expectCall(\n            address(L1Bridge),\n            500,\n            abi.encodeWithSelector(L1Bridge.bridgeETH.selector, 50000, hex\"dead\")\n        );\n\n        vm.expectCall(\n            address(L1Messenger),\n            500,\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                message,\n                50000\n            )\n        );\n\n        bytes memory innerMessage = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L1Bridge),\n            address(L2Bridge),\n            500,\n            50000,\n            message\n        );\n\n        uint64 baseGas = L1Messenger.baseGas(message, 50000);\n        vm.expectCall(\n            address(portal),\n            500,\n            abi.encodeWithSelector(\n                KromaPortal.depositTransaction.selector,\n                address(L2Messenger),\n                500,\n                baseGas,\n                false,\n                innerMessage\n            )\n        );\n\n        bytes memory opaqueData = abi.encodePacked(\n            uint256(500),\n            uint256(500),\n            baseGas,\n            false,\n            innerMessage\n        );\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHBridgeInitiated(alice, alice, 500, hex\"dead\");\n\n        // KromaPortal emits a TransactionDeposited event on `depositTransaction` call\n        vm.expectEmit(true, true, true, true, address(portal));\n        emit TransactionDeposited(l1MessengerAliased, address(L2Messenger), version, opaqueData);\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L1Messenger));\n        emit SentMessage(address(L2Bridge), address(L1Bridge), 500, message, nonce, 50000);\n\n        vm.prank(alice, alice);\n    }\n}\n\ncontract L1StandardBridge_BridgeETH_Test is PreBridgeETH {\n    // BridgeETH\n    // - emits ETHBridgeInitiated\n    // - calls kromaPortal.depositTransaction\n    // - only EOA\n    // - ETH ends up in the kromaPortal\n    function test_bridgeETH_succeeds() external {\n        _preBridgeETH();\n        L1Bridge.bridgeETH{ value: 500 }(50000, hex\"dead\");\n        assertEq(address(portal).balance, 500);\n    }\n}\n\ncontract L1StandardBridge_BridgeETH_TestFail is Bridge_Initializer {\n    function test_BridgeETH_notEoa_reverts() external {\n        // turn alice into a contract\n        vm.etch(alice, address(L1Token).code);\n\n        vm.expectRevert(\"StandardBridge: function can only be called from an EOA\");\n        vm.prank(alice);\n        L1Bridge.bridgeETH{ value: 1 }(300, hex\"\");\n    }\n}\n\ncontract PreBridgeETHTo is Bridge_Initializer {\n    function _preBridgeETHTo() internal {\n        assertEq(address(portal).balance, 0);\n        uint256 nonce = L1Messenger.messageNonce();\n        uint256 version = 0; // Internal constant in the KromaPortal: DEPOSIT_VERSION\n        address l1MessengerAliased = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        vm.expectCall(\n            address(L1Bridge),\n            600,\n            abi.encodeWithSelector(L1Bridge.bridgeETHTo.selector, bob, 60000, hex\"dead\")\n        );\n\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeETH.selector,\n            alice,\n            bob,\n            600,\n            hex\"dead\"\n        );\n\n        // the L1 bridge should call\n        // L1CrossDomainMessenger.sendMessage\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                message,\n                60000\n            )\n        );\n\n        bytes memory innerMessage = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L1Bridge),\n            address(L2Bridge),\n            600,\n            60000,\n            message\n        );\n\n        uint64 baseGas = L1Messenger.baseGas(message, 60000);\n        vm.expectCall(\n            address(portal),\n            abi.encodeWithSelector(\n                KromaPortal.depositTransaction.selector,\n                address(L2Messenger),\n                600,\n                baseGas,\n                false,\n                innerMessage\n            )\n        );\n\n        bytes memory opaqueData = abi.encodePacked(\n            uint256(600),\n            uint256(600),\n            baseGas,\n            false,\n            innerMessage\n        );\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHBridgeInitiated(alice, bob, 600, hex\"dead\");\n\n        // KromaPortal emits a TransactionDeposited event on `depositTransaction` call\n        vm.expectEmit(true, true, true, true, address(portal));\n        emit TransactionDeposited(l1MessengerAliased, address(L2Messenger), version, opaqueData);\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L1Messenger));\n        emit SentMessage(address(L2Bridge), address(L1Bridge), 600, message, nonce, 60000);\n\n        // deposit eth to bob\n        vm.prank(alice, alice);\n    }\n}\n\ncontract L1StandardBridge_BridgeETHTo_Test is PreBridgeETHTo {\n    // BridgeETHTo\n    // - emits ETHBridgeInitiated\n    // - calls kromaPortal.depositTransaction\n    // - only EOA\n    // - ETH ends up in the kromaPortal\n    function test_bridgeETHTo_succeeds() external {\n        _preBridgeETHTo();\n        L1Bridge.bridgeETHTo{ value: 600 }(bob, 60000, hex\"dead\");\n        assertEq(address(portal).balance, 600);\n    }\n}\n\ncontract L1StandardBridge_BridgeETHTo_TestFail is Bridge_Initializer {}\n\ncontract L1StandardBridge_BridgeERC20_Test is Bridge_Initializer {\n    using stdStorage for StdStorage;\n\n    // bridgeERC20\n    // - updates bridge.deposits\n    // - calls kromaPortal.depositTransaction\n    // - only callable by EOA\n    function test_bridgeERC20_succeeds() external {\n        uint256 nonce = L1Messenger.messageNonce();\n        uint256 version = 0; // Internal constant in the KromaPortal: DEPOSIT_VERSION\n        address l1MessengerAliased = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        // Deal Alice's ERC20 State\n        deal(address(L1Token), alice, 100000, true);\n        vm.prank(alice);\n        L1Token.approve(address(L1Bridge), type(uint256).max);\n\n        // The L1Bridge should transfer alice's tokens to itself\n        vm.expectCall(\n            address(L1Token),\n            abi.encodeWithSelector(ERC20.transferFrom.selector, alice, address(L1Bridge), 100)\n        );\n\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeERC20.selector,\n            address(L2Token),\n            address(L1Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n\n        // the L1 bridge should call L1CrossDomainMessenger.sendMessage\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                message,\n                10000\n            )\n        );\n\n        bytes memory innerMessage = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L1Bridge),\n            address(L2Bridge),\n            0,\n            10000,\n            message\n        );\n\n        uint64 baseGas = L1Messenger.baseGas(message, 10000);\n        vm.expectCall(\n            address(portal),\n            abi.encodeWithSelector(\n                KromaPortal.depositTransaction.selector,\n                address(L2Messenger),\n                0,\n                baseGas,\n                false,\n                innerMessage\n            )\n        );\n\n        bytes memory opaqueData = abi.encodePacked(\n            uint256(0),\n            uint256(0),\n            baseGas,\n            false,\n            innerMessage\n        );\n\n        // ERC20BridgeInitiated event emitted by the StandardBridge\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ERC20BridgeInitiated(address(L1Token), address(L2Token), alice, alice, 100, hex\"\");\n\n        // KromaPortal emits a TransactionDeposited event on `depositTransaction` call\n        vm.expectEmit(true, true, true, true, address(portal));\n        emit TransactionDeposited(l1MessengerAliased, address(L2Messenger), version, opaqueData);\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L1Messenger));\n        emit SentMessage(address(L2Bridge), address(L1Bridge), 0, message, nonce, 10000);\n\n        vm.prank(alice);\n        L1Bridge.bridgeERC20(address(L1Token), address(L2Token), 100, 10000, hex\"\");\n        assertEq(L1Bridge.deposits(address(L1Token), address(L2Token)), 100);\n    }\n}\n\ncontract L1StandardBridge_BridgeERC20_TestFail is Bridge_Initializer {\n    function test_bridgeERC20_notEoa_reverts() external {\n        // turn alice into a contract\n        vm.etch(alice, hex\"ffff\");\n\n        vm.expectRevert(\"StandardBridge: function can only be called from an EOA\");\n        vm.prank(alice, alice);\n        L1Bridge.bridgeERC20(address(0), address(0), 100, 100, hex\"\");\n    }\n}\n\ncontract L1StandardBridge_BridgeERC20To_Test is Bridge_Initializer {\n    // bridgeERC20To\n    // - updates bridge.deposits\n    // - calls kromaPortal.depositTransaction\n    // - callable by a contract\n    function test_bridgeERC20To_succeeds() external {\n        uint256 nonce = L1Messenger.messageNonce();\n        uint256 version = 0; // Internal constant in the KromaPortal: DEPOSIT_VERSION\n        address l1MessengerAliased = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeERC20.selector,\n            address(L2Token),\n            address(L1Token),\n            alice,\n            bob,\n            1000,\n            hex\"\"\n        );\n\n        bytes memory innerMessage = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L1Bridge),\n            address(L2Bridge),\n            0,\n            10000,\n            message\n        );\n\n        uint64 baseGas = L1Messenger.baseGas(message, 10000);\n        bytes memory opaqueData = abi.encodePacked(\n            uint256(0),\n            uint256(0),\n            baseGas,\n            false,\n            innerMessage\n        );\n\n        deal(address(L1Token), alice, 100000, true);\n\n        vm.prank(alice);\n        L1Token.approve(address(L1Bridge), type(uint256).max);\n\n        // ERC20BridgeInitiated event emitted by the StandardBridge\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ERC20BridgeInitiated(address(L1Token), address(L2Token), alice, bob, 1000, hex\"\");\n\n        // KromaPortal emits a TransactionDeposited event on `depositTransaction` call\n        vm.expectEmit(true, true, true, true, address(portal));\n        emit TransactionDeposited(l1MessengerAliased, address(L2Messenger), version, opaqueData);\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L1Messenger));\n        emit SentMessage(address(L2Bridge), address(L1Bridge), 0, message, nonce, 10000);\n\n        // the L1 bridge should call L1CrossDomainMessenger.sendMessage\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                message,\n                10000\n            )\n        );\n        // The L1 XDM should call KromaPortal.depositTransaction\n        vm.expectCall(\n            address(portal),\n            abi.encodeWithSelector(\n                KromaPortal.depositTransaction.selector,\n                address(L2Messenger),\n                0,\n                baseGas,\n                false,\n                innerMessage\n            )\n        );\n\n        vm.expectCall(\n            address(L1Token),\n            abi.encodeWithSelector(ERC20.transferFrom.selector, alice, address(L1Bridge), 1000)\n        );\n\n        vm.prank(alice);\n        L1Bridge.bridgeERC20To(address(L1Token), address(L2Token), bob, 1000, 10000, hex\"\");\n\n        assertEq(L1Bridge.deposits(address(L1Token), address(L2Token)), 1000);\n    }\n}\n\ncontract L1StandardBridge_FinalizeETHWithdrawal_Test is Bridge_Initializer {\n    using stdStorage for StdStorage;\n\n    // finalizeETHWithdrawal\n    // - only callable by L2 bridge\n    function test_finalizeETHWithdrawal_succeeds() external {\n        uint256 aliceBalance = alice.balance;\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHBridgeFinalized(alice, alice, 100, hex\"\");\n\n        vm.expectCall(alice, hex\"\");\n\n        vm.mockCall(\n            address(L1Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        // ensure that the messenger has ETH to call with\n        vm.deal(address(L1Bridge.MESSENGER()), 100);\n        vm.prank(address(L1Bridge.MESSENGER()));\n        L1Bridge.finalizeBridgeETH{ value: 100 }(alice, alice, 100, hex\"\");\n\n        assertEq(address(L1Bridge.MESSENGER()).balance, 0);\n        assertEq(aliceBalance + 100, alice.balance);\n    }\n}\n\ncontract L1StandardBridge_FinalizeETHWithdrawal_TestFail is Bridge_Initializer {}\n\ncontract L1StandardBridge_FinalizeBridgeERC20Withdrawal_Test is Bridge_Initializer {\n    using stdStorage for StdStorage;\n\n    // finalizeBridgeERC20Withdrawal\n    // - updates bridge.deposits\n    // - only callable by L2 bridge\n    function test_finalizeBridgeERC20Withdrawal_succeeds() external {\n        deal(address(L1Token), address(L1Bridge), 100, true);\n\n        uint256 slot = stdstore\n            .target(address(L1Bridge))\n            .sig(\"deposits(address,address)\")\n            .with_key(address(L1Token))\n            .with_key(address(L2Token))\n            .find();\n\n        // Give the L1 bridge some ERC20 tokens\n        vm.store(address(L1Bridge), bytes32(slot), bytes32(uint256(100)));\n        assertEq(L1Bridge.deposits(address(L1Token), address(L2Token)), 100);\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ERC20BridgeFinalized(address(L1Token), address(L2Token), alice, alice, 100, hex\"\");\n\n        vm.expectCall(\n            address(L1Token),\n            abi.encodeWithSelector(ERC20.transfer.selector, alice, 100)\n        );\n\n        vm.mockCall(\n            address(L1Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.prank(address(L1Bridge.MESSENGER()));\n        L1Bridge.finalizeBridgeERC20(address(L1Token), address(L2Token), alice, alice, 100, hex\"\");\n\n        assertEq(L1Token.balanceOf(address(L1Bridge)), 0);\n        assertEq(L1Token.balanceOf(address(alice)), 100);\n    }\n}\n\ncontract L1StandardBridge_FinalizeBridgeERC20Withdrawal_TestFail is Bridge_Initializer {\n    function test_finalizeBridgeERC20Withdrawal_notMessenger_reverts() external {\n        vm.mockCall(\n            address(L1Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.prank(address(28));\n        vm.expectRevert(\"StandardBridge: function can only be called from the other bridge\");\n        L1Bridge.finalizeBridgeERC20(address(L1Token), address(L2Token), alice, alice, 100, hex\"\");\n    }\n\n    function test_finalizeBridgeERC20Withdrawal_notOtherBridge_reverts() external {\n        vm.mockCall(\n            address(L1Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(address(0)))\n        );\n        vm.prank(address(L1Bridge.MESSENGER()));\n        vm.expectRevert(\"StandardBridge: function can only be called from the other bridge\");\n        L1Bridge.finalizeBridgeERC20(address(L1Token), address(L2Token), alice, alice, 100, hex\"\");\n    }\n}\n\ncontract L1StandardBridge_FinalizeBridgeETH_Test is Bridge_Initializer {\n    function test_finalizeBridgeETH_succeeds() external {\n        address messenger = address(L1Bridge.MESSENGER());\n        vm.mockCall(\n            messenger,\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(messenger, 100);\n        vm.prank(messenger);\n\n        vm.expectEmit(true, true, true, true, address(L1Bridge));\n        emit ETHBridgeFinalized(alice, alice, 100, hex\"\");\n\n        L1Bridge.finalizeBridgeETH{ value: 100 }(alice, alice, 100, hex\"\");\n    }\n}\n\ncontract L1StandardBridge_FinalizeBridgeETH_TestFail is Bridge_Initializer {\n    function test_finalizeBridgeETH_incorrectValue_reverts() external {\n        address messenger = address(L1Bridge.MESSENGER());\n        vm.mockCall(\n            messenger,\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(messenger, 100);\n        vm.prank(messenger);\n        vm.expectRevert(\"StandardBridge: amount sent does not match amount required\");\n        L1Bridge.finalizeBridgeETH{ value: 50 }(alice, alice, 100, hex\"\");\n    }\n\n    function test_finalizeBridgeETH_sendToSelf_reverts() external {\n        address messenger = address(L1Bridge.MESSENGER());\n        vm.mockCall(\n            messenger,\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(messenger, 100);\n        vm.prank(messenger);\n        vm.expectRevert(\"StandardBridge: cannot send to self\");\n        L1Bridge.finalizeBridgeETH{ value: 100 }(alice, address(L1Bridge), 100, hex\"\");\n    }\n\n    function test_finalizeBridgeETH_sendToMessenger_reverts() external {\n        address messenger = address(L1Bridge.MESSENGER());\n        vm.mockCall(\n            messenger,\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(messenger, 100);\n        vm.prank(messenger);\n        vm.expectRevert(\"StandardBridge: cannot send to messenger\");\n        L1Bridge.finalizeBridgeETH{ value: 100 }(alice, messenger, 100, hex\"\");\n    }\n}\n"
    },
    "contracts/test/L2CrossDomainMessenger.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { L2CrossDomainMessenger } from \"../L2/L2CrossDomainMessenger.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Messenger_Initializer, Reverter, ConfigurableCaller } from \"./CommonTest.t.sol\";\n\ncontract L2CrossDomainMessenger_Test is Messenger_Initializer {\n    // Receiver address for testing\n    address recipient = address(0xabbaacdc);\n\n    function test_messageVersion_succeeds() external {\n        (, uint16 version) = Encoding.decodeVersionedNonce(L2Messenger.messageNonce());\n        assertEq(version, L2Messenger.MESSAGE_VERSION());\n    }\n\n    function test_sendMessage_succeeds() external {\n        bytes memory xDomainCallData = Encoding.encodeCrossDomainMessage(\n            L2Messenger.messageNonce(),\n            alice,\n            recipient,\n            0,\n            100,\n            hex\"ff\"\n        );\n        vm.expectCall(\n            address(messagePasser),\n            abi.encodeWithSelector(\n                L2ToL1MessagePasser.initiateWithdrawal.selector,\n                address(L1Messenger),\n                L2Messenger.baseGas(hex\"ff\", 100),\n                xDomainCallData\n            )\n        );\n\n        // MessagePassed event\n        vm.expectEmit(true, true, true, true);\n        emit MessagePassed(\n            messagePasser.messageNonce(),\n            address(L2Messenger),\n            address(L1Messenger),\n            0,\n            L2Messenger.baseGas(hex\"ff\", 100),\n            xDomainCallData,\n            Hashing.hashWithdrawal(\n                Types.WithdrawalTransaction({\n                    nonce: messagePasser.messageNonce(),\n                    sender: address(L2Messenger),\n                    target: address(L1Messenger),\n                    value: 0,\n                    gasLimit: L2Messenger.baseGas(hex\"ff\", 100),\n                    data: xDomainCallData\n                })\n            )\n        );\n\n        vm.prank(alice);\n        L2Messenger.sendMessage(recipient, hex\"ff\", uint32(100));\n    }\n\n    function test_sendMessage_twice_succeeds() external {\n        uint256 nonce = L2Messenger.messageNonce();\n        L2Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        L2Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        // the nonce increments for each message sent\n        assertEq(nonce + 2, L2Messenger.messageNonce());\n    }\n\n    function test_xDomainSender_senderNotSet_reverts() external {\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L2Messenger.xDomainMessageSender();\n    }\n\n    function test_relayMessage_v1_reverts() external {\n        address target = address(0xabcd);\n        address sender = address(L1Messenger);\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        // Expect a revert.\n        vm.expectRevert(\"CrossDomainMessenger: only version 0 messages is supported at this time\");\n\n        // Try to relay a v1 message.\n        vm.prank(caller);\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 1 }), // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            hex\"1111\"\n        );\n    }\n\n    function test_relayMessage_succeeds() external {\n        address target = address(0xabcd);\n        address sender = address(L1Messenger);\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        vm.expectCall(target, hex\"1111\");\n\n        vm.prank(caller);\n\n        vm.expectEmit(true, true, true, true);\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            hex\"1111\"\n        );\n\n        emit RelayedMessage(hash);\n\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            hex\"1111\"\n        );\n\n        // the message hash is in the successfulMessages mapping\n        assert(L2Messenger.successfulMessages(hash));\n        // it is not in the received messages mapping\n        assertEq(L2Messenger.failedMessages(hash), false);\n    }\n\n    // relayMessage: should revert if attempting to relay a message sent to an L1 system contract\n    function test_relayMessage_toSystemContract_reverts() external {\n        address target = address(messagePasser);\n        address sender = address(L1Messenger);\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n        bytes memory message = hex\"1111\";\n\n        vm.prank(caller);\n        vm.expectRevert(\"CrossDomainMessenger: message cannot be replayed\");\n        L1Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            0,\n            0,\n            message\n        );\n    }\n\n    // relayMessage: the xDomainMessageSender is reset to the original value\n    function test_xDomainMessageSender_reset_succeeds() external {\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L2Messenger.xDomainMessageSender();\n\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n        vm.prank(caller);\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            address(0),\n            address(0),\n            0,\n            0,\n            hex\"\"\n        );\n\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L2Messenger.xDomainMessageSender();\n    }\n\n    // relayMessage: should send a successful call to the target contract after the first message\n    // fails and ETH gets stuck, but the second message succeeds\n    function test_relayMessage_retry_succeeds() external {\n        address target = address(0xabcd);\n        address sender = address(L1Messenger);\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n        uint256 value = 100;\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        vm.etch(target, address(new Reverter()).code);\n        vm.deal(address(caller), value);\n        vm.prank(caller);\n        L2Messenger.relayMessage{ value: value }(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        assertEq(address(L2Messenger).balance, value);\n        assertEq(address(target).balance, 0);\n        assertEq(L2Messenger.successfulMessages(hash), false);\n        assertEq(L2Messenger.failedMessages(hash), true);\n\n        vm.expectEmit(true, true, true, true);\n\n        emit RelayedMessage(hash);\n\n        vm.etch(target, address(0).code);\n        vm.prank(address(sender));\n        L2Messenger.relayMessage(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }), // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        assertEq(address(L2Messenger).balance, 0);\n        assertEq(address(target).balance, value);\n        assertEq(L2Messenger.successfulMessages(hash), true);\n        assertEq(L2Messenger.failedMessages(hash), true);\n    }\n}\n"
    },
    "contracts/test/L2ERC721Bridge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport { L1ERC721Bridge } from \"../L1/L1ERC721Bridge.sol\";\nimport { L2ERC721Bridge } from \"../L2/L2ERC721Bridge.sol\";\nimport { KromaMintableERC721 } from \"../universal/KromaMintableERC721.sol\";\nimport { Messenger_Initializer } from \"./CommonTest.t.sol\";\n\ncontract TestERC721 is ERC721 {\n    constructor() ERC721(\"Test\", \"TST\") {}\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n}\n\ncontract TestMintableERC721 is KromaMintableERC721 {\n    constructor(address _bridge, address _remoteToken)\n        KromaMintableERC721(_bridge, 1, _remoteToken, \"Test\", \"TST\")\n    {}\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n}\n\ncontract L2ERC721Bridge_Test is Messenger_Initializer {\n    TestMintableERC721 internal localToken;\n    TestERC721 internal remoteToken;\n    L2ERC721Bridge internal bridge;\n    address internal constant otherBridge = address(0x3456);\n    uint256 internal constant tokenId = 1;\n\n    event ERC721BridgeInitiated(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    event ERC721BridgeFinalized(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    function setUp() public override {\n        super.setUp();\n\n        // Create necessary contracts.\n        bridge = new L2ERC721Bridge(address(L2Messenger), otherBridge);\n        remoteToken = new TestERC721();\n        localToken = new TestMintableERC721(address(bridge), address(remoteToken));\n\n        // Label the bridge so we get nice traces.\n        vm.label(address(bridge), \"L2ERC721Bridge\");\n\n        // Mint alice a token.\n        localToken.mint(alice, tokenId);\n\n        // Approve the bridge to transfer the token.\n        vm.prank(alice);\n        localToken.approve(address(bridge), tokenId);\n    }\n\n    function test_constructor_succeeds() public {\n        assertEq(address(bridge.MESSENGER()), address(L2Messenger));\n        assertEq(address(bridge.OTHER_BRIDGE()), otherBridge);\n    }\n\n    function test_bridgeERC721_succeeds() public {\n        // Expect a call to the messenger.\n        vm.expectCall(\n            address(L2Messenger),\n            abi.encodeCall(\n                L2Messenger.sendMessage,\n                (\n                    address(otherBridge),\n                    abi.encodeCall(\n                        L2ERC721Bridge.finalizeBridgeERC721,\n                        (\n                            address(remoteToken),\n                            address(localToken),\n                            alice,\n                            alice,\n                            tokenId,\n                            hex\"5678\"\n                        )\n                    ),\n                    1234\n                )\n            )\n        );\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeInitiated(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is burned.\n        vm.expectRevert(\"ERC721: invalid token ID\");\n        localToken.ownerOf(tokenId);\n    }\n\n    function test_bridgeERC721_fromContract_reverts() external {\n        // Bridge the token.\n        vm.etch(alice, hex\"01\");\n        vm.prank(alice);\n        vm.expectRevert(\"ERC721Bridge: account is not externally owned\");\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_localTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert();\n        bridge.bridgeERC721(address(0), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_remoteTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert(\"L2ERC721Bridge: remote token cannot be address(0)\");\n        bridge.bridgeERC721(address(localToken), address(0), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721_wrongOwner_reverts() external {\n        // Bridge the token.\n        vm.prank(bob);\n        vm.expectRevert(\"L2ERC721Bridge: Withdrawal is not being initiated by NFT owner\");\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_succeeds() external {\n        // Expect a call to the messenger.\n        vm.expectCall(\n            address(L2Messenger),\n            abi.encodeCall(\n                L2Messenger.sendMessage,\n                (\n                    address(otherBridge),\n                    abi.encodeCall(\n                        L1ERC721Bridge.finalizeBridgeERC721,\n                        (address(remoteToken), address(localToken), alice, bob, tokenId, hex\"5678\")\n                    ),\n                    1234\n                )\n            )\n        );\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeInitiated(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            bob,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721To(\n            address(localToken),\n            address(remoteToken),\n            bob,\n            tokenId,\n            1234,\n            hex\"5678\"\n        );\n\n        // Token is burned.\n        vm.expectRevert(\"ERC721: invalid token ID\");\n        localToken.ownerOf(tokenId);\n    }\n\n    function test_bridgeERC721To_localTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert();\n        bridge.bridgeERC721To(address(0), address(remoteToken), bob, tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_remoteTokenZeroAddress_reverts() external {\n        // Bridge the token.\n        vm.prank(alice);\n        vm.expectRevert(\"L2ERC721Bridge: remote token cannot be address(0)\");\n        bridge.bridgeERC721To(address(localToken), address(0), bob, tokenId, 1234, hex\"5678\");\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_bridgeERC721To_wrongOwner_reverts() external {\n        // Bridge the token.\n        vm.prank(bob);\n        vm.expectRevert(\"L2ERC721Bridge: Withdrawal is not being initiated by NFT owner\");\n        bridge.bridgeERC721To(\n            address(localToken),\n            address(remoteToken),\n            bob,\n            tokenId,\n            1234,\n            hex\"5678\"\n        );\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_finalizeBridgeERC721_succeeds() external {\n        // Bridge the token.\n        vm.prank(alice);\n        bridge.bridgeERC721(address(localToken), address(remoteToken), tokenId, 1234, hex\"5678\");\n\n        // Expect an event to be emitted.\n        vm.expectEmit(true, true, true, true);\n        emit ERC721BridgeFinalized(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(L2Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L2Messenger));\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n\n        // Token is not locked in the bridge.\n        assertEq(localToken.ownerOf(tokenId), alice);\n    }\n\n    function test_finalizeBridgeERC721_interfaceNotCompliant_reverts() external {\n        // Create a non-compliant token\n        NonCompliantERC721 nonCompliantToken = new NonCompliantERC721(alice);\n\n        // Bridge the non-compliant token.\n        vm.prank(alice);\n        bridge.bridgeERC721(address(nonCompliantToken), address(0x01), tokenId, 1234, hex\"5678\");\n\n        // Attempt to finalize the withdrawal. Should revert because the token does not claim\n        // to be compliant with the `IKromaMintableERC721` interface.\n        vm.mockCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(L2Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"L2ERC721Bridge: local token interface is not compliant\");\n        bridge.finalizeBridgeERC721(\n            address(address(nonCompliantToken)),\n            address(address(0x01)),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_notViaLocalMessenger_reverts() external {\n        // Finalize a withdrawal.\n        vm.prank(alice);\n        vm.expectRevert(\"ERC721Bridge: function can only be called from the other bridge\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_notFromRemoteMessenger_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(L2Messenger.xDomainMessageSender.selector),\n            abi.encode(alice)\n        );\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"ERC721Bridge: function can only be called from the other bridge\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_selfToken_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(L2Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"L2ERC721Bridge: local token cannot be self\");\n        bridge.finalizeBridgeERC721(\n            address(bridge),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n\n    function test_finalizeBridgeERC721_alreadyExists_reverts() external {\n        // Finalize a withdrawal.\n        vm.mockCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(L2Messenger.xDomainMessageSender.selector),\n            abi.encode(otherBridge)\n        );\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"ERC721: token already minted\");\n        bridge.finalizeBridgeERC721(\n            address(localToken),\n            address(remoteToken),\n            alice,\n            alice,\n            tokenId,\n            hex\"5678\"\n        );\n    }\n}\n\n/**\n * @dev A non-compliant ERC721 token that does not implement the full ERC721 interface.\n *\n * This is used to test that the bridge will revert if the token does not claim to support\n * the ERC721 interface.\n */\ncontract NonCompliantERC721 {\n    address internal immutable owner;\n\n    address public immutable REMOTE_TOKEN;\n\n    constructor(address _owner) {\n        owner = _owner;\n        REMOTE_TOKEN = address(0x01);\n    }\n\n    function ownerOf(uint256) external view returns (address) {\n        return owner;\n    }\n\n    function burn(address, uint256) external {\n        // Do nothing.\n    }\n\n    function supportsInterface(bytes4) external pure returns (bool) {\n        return false;\n    }\n}\n"
    },
    "contracts/test/L2OutputOracle.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { stdError } from \"forge-std/Test.sol\";\n\nimport { Types } from \"../libraries/Types.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { ValidatorPool } from \"../L1/ValidatorPool.sol\";\nimport { IValidatorManager } from \"../L1/interfaces/IValidatorManager.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport {\n    L2OutputOracle_Initializer,\n    ValidatorSystemUpgrade_Initializer,\n    NextImpl\n} from \"./CommonTest.t.sol\";\n\ncontract L2OutputOracleTest is L2OutputOracle_Initializer {\n    bytes32 submittedOutput1 = keccak256(abi.encode(1));\n\n    function setUp() public override {\n        super.setUp();\n\n        vm.prank(trusted);\n        pool.deposit{ value: trusted.balance }();\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(address(oracle.VALIDATOR_POOL()), address(pool));\n        assertEq(address(oracle.VALIDATOR_MANAGER()), address(valMgr));\n        assertEq(oracle.COLOSSEUM(), address(colosseum));\n        assertEq(oracle.SUBMISSION_INTERVAL(), submissionInterval);\n        assertEq(oracle.L2_BLOCK_TIME(), l2BlockTime);\n        assertEq(oracle.FINALIZATION_PERIOD_SECONDS(), finalizationPeriodSeconds);\n        assertEq(oracle.latestBlockNumber(), startingBlockNumber);\n        assertEq(oracle.startingBlockNumber(), startingBlockNumber);\n        assertEq(oracle.startingTimestamp(), startingTimestamp);\n    }\n\n    function test_constructor_badTimestamp_reverts() external {\n        vm.expectRevert(\"L2OutputOracle: starting L2 timestamp must be less than current time\");\n        new L2OutputOracle({\n            _validatorPool: pool,\n            _validatorManager: valMgr,\n            _colosseum: address(colosseum),\n            _submissionInterval: submissionInterval,\n            _l2BlockTime: l2BlockTime,\n            _startingBlockNumber: startingBlockNumber,\n            _startingTimestamp: block.timestamp + 1,\n            _finalizationPeriodSeconds: finalizationPeriodSeconds\n        });\n    }\n\n    function test_constructor_l2BlockTimeZero_reverts() external {\n        vm.expectRevert(\"L2OutputOracle: L2 block time must be greater than 0\");\n        new L2OutputOracle({\n            _validatorPool: pool,\n            _validatorManager: valMgr,\n            _colosseum: address(colosseum),\n            _submissionInterval: submissionInterval,\n            _l2BlockTime: 0,\n            _startingBlockNumber: startingBlockNumber,\n            _startingTimestamp: block.timestamp,\n            _finalizationPeriodSeconds: finalizationPeriodSeconds\n        });\n    }\n\n    function test_constructor_submissionInterval_reverts() external {\n        vm.expectRevert(\"L2OutputOracle: submission interval must be greater than 0\");\n        new L2OutputOracle({\n            _validatorPool: pool,\n            _validatorManager: valMgr,\n            _colosseum: address(colosseum),\n            _submissionInterval: 0,\n            _l2BlockTime: l2BlockTime,\n            _startingBlockNumber: startingBlockNumber,\n            _startingTimestamp: block.timestamp,\n            _finalizationPeriodSeconds: finalizationPeriodSeconds\n        });\n    }\n\n    /****************\n     * Getter Tests *\n     ****************/\n\n    // Test: latestBlockNumber() should return the correct value\n    function test_latestBlockNumber_succeeds() external {\n        uint256 submittedNumber = oracle.nextBlockNumber();\n\n        // Roll to after the block number we'll submit\n        warpToSubmitTime();\n        vm.prank(trusted);\n        oracle.submitL2Output(submittedOutput1, submittedNumber, 0, 0);\n        assertEq(oracle.latestBlockNumber(), submittedNumber);\n    }\n\n    // Test: getL2Output() should return the correct value\n    function test_getL2Output_succeeds() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        uint256 nextOutputIndex = oracle.nextOutputIndex();\n        warpToSubmitTime();\n        vm.prank(trusted);\n        oracle.submitL2Output(submittedOutput1, nextBlockNumber, 0, 0);\n\n        Types.CheckpointOutput memory output = oracle.getL2Output(nextOutputIndex);\n        assertEq(output.outputRoot, submittedOutput1);\n        assertEq(output.timestamp, block.timestamp);\n\n        // The block number is larger than the latest submitted output:\n        vm.expectRevert(stdError.indexOOBError);\n        oracle.getL2Output(nextOutputIndex + 1);\n    }\n\n    // Test: getL2OutputIndexAfter() returns correct value when input is exact block\n    function test_getL2OutputIndexAfter_sameBlock_succeeds() external {\n        bytes32 output1 = keccak256(abi.encode(1));\n        uint256 nextBlockNumber1 = oracle.nextBlockNumber();\n        warpToSubmitTime();\n        vm.prank(trusted);\n        oracle.submitL2Output(output1, nextBlockNumber1, 0, 0);\n\n        // Querying with exact same block as submitted returns the output.\n        uint256 index1 = oracle.getL2OutputIndexAfter(nextBlockNumber1);\n        assertEq(index1, 0);\n    }\n\n    // Test: getL2OutputIndexAfter() returns correct value when input is previous block\n    function test_getL2OutputIndexAfter_previousBlock_succeeds() external {\n        bytes32 output1 = keccak256(abi.encode(1));\n        uint256 nextBlockNumber1 = oracle.nextBlockNumber();\n        warpToSubmitTime();\n        vm.prank(trusted);\n        oracle.submitL2Output(output1, nextBlockNumber1, 0, 0);\n\n        // Querying with previous block returns the output too.\n        uint256 index1 = oracle.getL2OutputIndexAfter(nextBlockNumber1 - 1);\n        assertEq(index1, 0);\n    }\n\n    // Test: getL2OutputIndexAfter() returns correct value during binary search\n    function test_getL2OutputIndexAfter_multipleOutputsExist_succeeds() external {\n        bytes32 output1 = keccak256(abi.encode(1));\n        uint256 nextBlockNumber1 = oracle.nextBlockNumber();\n        warpToSubmitTime();\n        vm.prank(trusted);\n        oracle.submitL2Output(output1, nextBlockNumber1, 0, 0);\n\n        bytes32 output2 = keccak256(abi.encode(2));\n        uint256 nextBlockNumber2 = oracle.nextBlockNumber();\n        warpToSubmitTime();\n        vm.prank(trusted);\n        oracle.submitL2Output(output2, nextBlockNumber2, 0, 0);\n\n        bytes32 output3 = keccak256(abi.encode(3));\n        uint256 nextBlockNumber3 = oracle.nextBlockNumber();\n        warpToSubmitTime();\n        vm.prank(trusted);\n        oracle.submitL2Output(output3, nextBlockNumber3, 0, 0);\n\n        bytes32 output4 = keccak256(abi.encode(4));\n        uint256 nextBlockNumber4 = oracle.nextBlockNumber();\n        warpToSubmitTime();\n        vm.prank(trusted);\n        oracle.submitL2Output(output4, nextBlockNumber4, 0, 0);\n\n        // Querying with a block number between the first and second output\n        uint256 index1 = oracle.getL2OutputIndexAfter(nextBlockNumber1 + 1);\n        assertEq(index1, 1);\n\n        // Querying with a block number between the second and third output\n        uint256 index2 = oracle.getL2OutputIndexAfter(nextBlockNumber2 + 1);\n        assertEq(index2, 2);\n\n        // Querying with a block number between the third and fourth output\n        uint256 index3 = oracle.getL2OutputIndexAfter(nextBlockNumber3 + 1);\n        assertEq(index3, 3);\n    }\n\n    // Test: getL2OutputIndexAfter() reverts when no output exists yet\n    function test_getL2OutputIndexAfter_noOutputsExist_reverts() external {\n        vm.expectRevert(\"L2OutputOracle: cannot get output as no outputs have been submitted yet\");\n        oracle.getL2OutputIndexAfter(0);\n    }\n\n    // Test: nextBlockNumber() should return the correct value\n    function test_nextBlockNumber_succeeds() external {\n        assertEq(oracle.nextBlockNumber(), oracle.latestBlockNumber());\n\n        test_submitL2Output_submitAnotherOutput_succeeds();\n\n        assertEq(\n            oracle.nextBlockNumber(),\n            // The return value should match this arithmetic\n            oracle.latestBlockNumber() + oracle.SUBMISSION_INTERVAL()\n        );\n    }\n\n    function test_computeL2Timestamp_succeeds() external {\n        // reverts if timestamp is too low\n        vm.expectRevert(stdError.arithmeticError);\n        oracle.computeL2Timestamp(startingBlockNumber - 1);\n\n        // returns the correct value...\n        // ... for the very first block\n        assertEq(oracle.computeL2Timestamp(startingBlockNumber), startingTimestamp);\n\n        // ... for the first block after the starting block\n        assertEq(\n            oracle.computeL2Timestamp(startingBlockNumber + 1),\n            startingTimestamp + l2BlockTime\n        );\n\n        // ... for some other block number\n        assertEq(\n            oracle.computeL2Timestamp(startingBlockNumber + 96024),\n            startingTimestamp + l2BlockTime * 96024\n        );\n    }\n\n    function test_nextOutputMinL2Timestamp_succeeds() external {\n        assertEq(\n            oracle.nextOutputMinL2Timestamp(),\n            oracle.computeL2Timestamp(oracle.nextBlockNumber() + 1)\n        );\n    }\n\n    /*****************************\n     * Submit Tests - Happy Path *\n     *****************************/\n\n    // Test: submitL2Output succeeds when given valid input, and no block hash and number are\n    // specified.\n    function test_submitL2Output_submitAnotherOutput_succeeds() public {\n        startingBlockNumber = oracle.startingBlockNumber();\n        bytes32 submittedOutput2 = keccak256(abi.encode());\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        uint256 nextOutputIndex = oracle.nextOutputIndex();\n        warpToSubmitTime();\n        uint256 submittedNumber = oracle.latestBlockNumber();\n\n        // Ensure the submissionInterval is enforced\n        if (nextBlockNumber == startingBlockNumber) {\n            assertEq(nextBlockNumber, submittedNumber);\n        } else {\n            assertEq(nextBlockNumber, submittedNumber + submissionInterval);\n        }\n\n        vm.roll(nextBlockNumber + 1);\n\n        uint128 finalizedAt = uint128(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS());\n        vm.expectCall(\n            address(oracle.VALIDATOR_POOL()),\n            abi.encodeWithSelector(ValidatorPool.createBond.selector, nextOutputIndex, finalizedAt)\n        );\n        vm.expectEmit(true, true, true, true);\n        emit OutputSubmitted(submittedOutput2, nextOutputIndex, nextBlockNumber, block.timestamp);\n        vm.prank(trusted);\n        oracle.submitL2Output(submittedOutput2, nextBlockNumber, 0, 0);\n    }\n\n    // Test: submitL2Output succeeds when given valid input, and when a block hash and number are\n    // specified for reorg protection.\n    function test_submitWithBlockhashAndHeight_succeeds() external {\n        // Get the number and hash of a previous block in the chain\n        uint256 prevL1BlockNumber = block.number - 1;\n        bytes32 prevL1BlockHash = blockhash(prevL1BlockNumber);\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime();\n\n        vm.prank(trusted);\n        oracle.submitL2Output(nonZeroHash, nextBlockNumber, prevL1BlockHash, prevL1BlockNumber);\n    }\n\n    /***************************\n     * Submit Tests - Sad Path *\n     ***************************/\n\n    // Test: submitL2Output fails if called by a party that is not the validator.\n    function test_submitL2Output_notValidator_reverts() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime();\n\n        vm.prank(address(128));\n        vm.expectRevert(\"L2OutputOracle: only the next selected validator can submit output\");\n        oracle.submitL2Output(nonZeroHash, nextBlockNumber, 0, 0);\n    }\n\n    // Test: submitL2Output fails given a zero blockhash.\n    function test_submitL2Output_emptyOutput_reverts() external {\n        bytes32 outputToSubmit = bytes32(0);\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime();\n        vm.prank(trusted);\n        vm.expectRevert(\"L2OutputOracle: L2 checkpoint output cannot be the zero hash\");\n        oracle.submitL2Output(outputToSubmit, nextBlockNumber, 0, 0);\n    }\n\n    // Test: submitL2Output fails if the block number doesn't match the next expected number.\n    function test_submitL2Output_unexpectedBlockNumber_reverts() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime();\n        vm.prank(trusted);\n        vm.expectRevert(\"L2OutputOracle: block number must be equal to next expected block number\");\n        oracle.submitL2Output(nonZeroHash, nextBlockNumber - 1, 0, 0);\n    }\n\n    // Test: submitL2Output fails if it would have a timestamp in the future.\n    function test_submitL2Output_futureTimetamp_reverts() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        uint256 nextTimestamp = oracle.nextOutputMinL2Timestamp();\n        vm.warp(nextTimestamp - 1);\n        vm.prank(trusted);\n        vm.expectRevert(\"L2OutputOracle: cannot submit L2 output in the future\");\n        oracle.submitL2Output(nonZeroHash, nextBlockNumber, 0, 0);\n    }\n\n    // Test: submitL2Output fails if a non-existent L1 block hash and number are provided for reorg\n    // protection.\n    function test_submitL2Output_wrongFork_reverts() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime();\n        vm.prank(trusted);\n        vm.expectRevert(\n            \"L2OutputOracle: block hash does not match the hash at the expected height\"\n        );\n        oracle.submitL2Output(\n            nonZeroHash,\n            nextBlockNumber,\n            bytes32(uint256(0x01)),\n            block.number - 1\n        );\n    }\n\n    // Test: submitL2Output fails when given valid input, but the block hash and number do not\n    // match.\n    function test_submitL2Output_unmatchedBlockhash_reverts() external {\n        // Move ahead to block 100 so that we can reference historical blocks\n        vm.roll(100);\n\n        // Get the number and hash of a previous block in the chain\n        uint256 l1BlockNumber = block.number - 1;\n        bytes32 l1BlockHash = blockhash(l1BlockNumber);\n\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToSubmitTime();\n        vm.prank(trusted);\n\n        // This will fail when foundry no longer returns zerod block hashes\n        vm.expectRevert(\n            \"L2OutputOracle: block hash does not match the hash at the expected height\"\n        );\n        oracle.submitL2Output(nonZeroHash, nextBlockNumber, l1BlockHash, l1BlockNumber - 1);\n    }\n\n    /*****************************\n     * Replace Tests - Happy Path *\n     *****************************/\n\n    function test_replaceL2Output_succeeds() external {\n        test_submitL2Output_submitAnotherOutput_succeeds();\n        test_submitL2Output_submitAnotherOutput_succeeds();\n        test_submitL2Output_submitAnotherOutput_succeeds();\n\n        uint256 outputIndex = oracle.latestOutputIndex() - 1;\n        bytes32 newOutputRoot = keccak256(abi.encode(\"new_output\"));\n\n        vm.prank(address(colosseum));\n        vm.expectEmit(true, true, false, false);\n        emit OutputReplaced(outputIndex, challenger, newOutputRoot);\n        oracle.replaceL2Output(outputIndex, newOutputRoot, challenger);\n\n        // validate that the output root is replaced\n        Types.CheckpointOutput memory output = oracle.getL2Output(outputIndex);\n        assertEq(newOutputRoot, output.outputRoot);\n        assertEq(challenger, output.submitter);\n    }\n\n    /***************************\n     * Replace Tests - Sad Path *\n     ***************************/\n\n    function test_replaceL2Output_ifNotChallenger_reverts() external {\n        uint256 latestBlockNumber = oracle.latestBlockNumber();\n\n        vm.expectRevert(\"L2OutputOracle: only the colosseum contract can replace an output\");\n        oracle.replaceL2Output(latestBlockNumber, keccak256(abi.encode(\"new_output\")), address(1));\n    }\n\n    function test_replaceL2Output_zeroAddress_reverts() external {\n        uint256 latestBlockNumber = oracle.latestBlockNumber();\n\n        vm.prank(address(colosseum));\n        vm.expectRevert(\"L2OutputOracle: submitter address cannot be zero\");\n        oracle.replaceL2Output(latestBlockNumber, keccak256(abi.encode(\"new_output\")), address(0));\n    }\n\n    function test_replaceL2Output_nonExistent_reverts() external {\n        test_submitL2Output_submitAnotherOutput_succeeds();\n\n        uint256 latestBlockNumber = oracle.latestBlockNumber();\n\n        vm.prank(address(colosseum));\n        vm.expectRevert(\"L2OutputOracle: cannot replace an output after the latest output index\");\n        oracle.replaceL2Output(\n            latestBlockNumber + 1,\n            keccak256(abi.encode(\"new_output\")),\n            challenger\n        );\n    }\n\n    function test_replaceL2Output_finalized_reverts() external {\n        test_submitL2Output_submitAnotherOutput_succeeds();\n\n        // Warp past the finalization period + 1 second\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        uint256 latestOutputIndex = oracle.latestOutputIndex();\n\n        // Try to delete a finalized output\n        vm.prank(address(colosseum));\n        vm.expectRevert(\"L2OutputOracle: cannot replace an output that has already been finalized\");\n        oracle.replaceL2Output(latestOutputIndex, keccak256(abi.encode(\"new_output\")), challenger);\n    }\n}\n\ncontract L2OutputOracle_ValidatorSystemUpgrade_Test is ValidatorSystemUpgrade_Initializer {\n    function setUp() public override {\n        super.setUp();\n\n        vm.prank(trusted);\n        pool.deposit{ value: trusted.balance }();\n        _registerValidator(trusted, minActivateAmount);\n\n        // Submit outputs to leave 1 output before ValidatorPool is terminated\n        for (uint256 i; i <= terminateOutputIndex - 1; i++) {\n            _submitL2OutputV1();\n        }\n    }\n\n    function test_submitL2Output_upgradeValidatorSystem_succeeds() external {\n        // Assert terminateOutputIndex still interacts with ValidatorPool\n        warpToSubmitTime();\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        bytes32 outputRoot = keccak256(abi.encode(nextBlockNumber));\n\n        assertFalse(pool.isTerminated(oracle.nextOutputIndex()));\n        assertEq(pool.nextValidator(), trusted);\n\n        uint128 finalizedAt = uint128(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS());\n        vm.expectCall(\n            address(oracle.VALIDATOR_POOL()),\n            abi.encodeWithSelector(ValidatorPool.nextValidator.selector)\n        );\n        vm.expectCall(\n            address(oracle.VALIDATOR_POOL()),\n            abi.encodeWithSelector(\n                ValidatorPool.createBond.selector,\n                oracle.nextOutputIndex(),\n                finalizedAt\n            )\n        );\n        vm.prank(trusted);\n        oracle.submitL2Output(outputRoot, nextBlockNumber, 0, 0);\n\n        // Assert terminateOutputIndex + 1 interacts with ValidatorManager\n        warpToSubmitTime();\n        nextBlockNumber = oracle.nextBlockNumber();\n        outputRoot = keccak256(abi.encode(nextBlockNumber));\n\n        assertTrue(pool.isTerminated(oracle.nextOutputIndex()));\n        assertEq(valMgr.nextValidator(), trusted);\n\n        vm.expectCall(\n            address(oracle.VALIDATOR_MANAGER()),\n            abi.encodeWithSelector(IValidatorManager.checkSubmissionEligibility.selector, trusted)\n        );\n        vm.expectCall(\n            address(oracle.VALIDATOR_MANAGER()),\n            abi.encodeWithSelector(\n                IValidatorManager.afterSubmitL2Output.selector,\n                oracle.nextOutputIndex()\n            )\n        );\n        vm.prank(trusted);\n        oracle.submitL2Output(outputRoot, nextBlockNumber, 0, 0);\n    }\n\n    function test_setNextFinalizeOutputIndex_succeeds() external {\n        // Only ValidatorPool can set finalized output before upgrade\n        vm.prank(address(pool));\n        oracle.setNextFinalizeOutputIndex(1);\n        assertEq(oracle.nextFinalizeOutputIndex(), 1);\n\n        vm.prank(address(pool));\n        oracle.setNextFinalizeOutputIndex(terminateOutputIndex + 1);\n        assertEq(oracle.nextFinalizeOutputIndex(), terminateOutputIndex + 1);\n\n        // Now only ValidatorManager can set finalized output after upgrade\n        vm.prank(address(valMgr));\n        oracle.setNextFinalizeOutputIndex(terminateOutputIndex + 2);\n        assertEq(oracle.nextFinalizeOutputIndex(), terminateOutputIndex + 2);\n    }\n\n    function test_setNextFinalizeOutputIndex_wrongCaller_reverts() external {\n        // Only ValidatorPool can set finalized output before upgrade\n        vm.prank(address(valMgr));\n        vm.expectRevert(\n            \"L2OutputOracle: only the validator pool contract can set next finalize output index\"\n        );\n        oracle.setNextFinalizeOutputIndex(1);\n\n        // Now only ValidatorManager can set finalized output after upgrade\n        vm.prank(address(pool));\n        vm.expectRevert(\n            \"L2OutputOracle: only the validator manager contract can set next finalize output index\"\n        );\n        oracle.setNextFinalizeOutputIndex(terminateOutputIndex + 2);\n    }\n}\n\ncontract L2OutputOracleUpgradeable_Test is L2OutputOracle_Initializer {\n    Proxy internal proxy;\n\n    function setUp() public override {\n        super.setUp();\n        proxy = Proxy(payable(address(oracle)));\n    }\n\n    function test_initValuesOnProxy_succeeds() external {\n        assertEq(submissionInterval, oracleImpl.SUBMISSION_INTERVAL());\n        assertEq(l2BlockTime, oracleImpl.L2_BLOCK_TIME());\n        assertEq(startingBlockNumber, oracleImpl.startingBlockNumber());\n        assertEq(startingTimestamp, oracleImpl.startingTimestamp());\n\n        assertEq(address(oracle.VALIDATOR_POOL()), address(pool));\n        assertEq(address(oracle.VALIDATOR_MANAGER()), address(valMgr));\n        assertEq(address(colosseum), oracleImpl.COLOSSEUM());\n    }\n\n    function test_initializeProxy_alreadyInitialized_reverts() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        L2OutputOracle(payable(proxy)).initialize(startingBlockNumber, startingTimestamp);\n    }\n\n    function test_initializeImpl_alreadyInitialized_reverts() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        L2OutputOracle(oracleImpl).initialize(startingBlockNumber, startingTimestamp);\n    }\n\n    function test_upgrading_succeeds() external {\n        // Check an unused slot before upgrading.\n        bytes32 slot21Before = vm.load(address(oracle), bytes32(uint256(21)));\n        assertEq(bytes32(0), slot21Before);\n\n        NextImpl nextImpl = new NextImpl();\n        vm.startPrank(multisig);\n        proxy.upgradeToAndCall(\n            address(nextImpl),\n            abi.encodeWithSelector(NextImpl.initialize.selector)\n        );\n        assertEq(proxy.implementation(), address(nextImpl));\n\n        // Verify that the NextImpl contract initialized its values according as expected\n        bytes32 slot21After = vm.load(address(oracle), bytes32(uint256(21)));\n        bytes32 slot21Expected = NextImpl(address(oracle)).slot21Init();\n        assertEq(slot21Expected, slot21After);\n    }\n}\n"
    },
    "contracts/test/L2StandardBridge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { stdStorage, StdStorage } from \"forge-std/Test.sol\";\n\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { KromaMintableERC20 } from \"../universal/KromaMintableERC20.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\n\ncontract L2StandardBridge_Test is Bridge_Initializer {\n    using stdStorage for StdStorage;\n\n    function test_initialize_succeeds() external {\n        assertEq(address(L2Bridge.MESSENGER()), address(L2Messenger));\n        assertEq(address(L1Bridge.OTHER_BRIDGE()), address(L2Bridge));\n        assertEq(address(L2Bridge.OTHER_BRIDGE()), address(L1Bridge));\n    }\n\n    // receive\n    // - can accept ETH\n    function test_receive_succeeds() external {\n        assertEq(address(messagePasser).balance, 0);\n        vm.prank(alice, alice);\n        (bool success, ) = address(L2Bridge).call{ value: 100 }(hex\"\");\n        assertEq(success, true);\n        assertEq(address(messagePasser).balance, 100);\n    }\n}\n\ncontract PreBridgeERC20 is Bridge_Initializer {\n    function _preBridgeERC20() internal {\n        // Alice has 100 L2Token\n        deal(address(L2Token), alice, 100, true);\n        assertEq(L2Token.balanceOf(alice), 100);\n        uint256 nonce = L2Messenger.messageNonce();\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeERC20.selector,\n            address(L1Token),\n            address(L2Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n        uint64 baseGas = L2Messenger.baseGas(message, 1000);\n        bytes memory withdrawalData = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L2Bridge),\n            address(L1Bridge),\n            0,\n            1000,\n            message\n        );\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction({\n                nonce: nonce,\n                sender: address(L2Messenger),\n                target: address(L1Messenger),\n                value: 0,\n                gasLimit: baseGas,\n                data: withdrawalData\n            })\n        );\n\n        vm.expectCall(\n            address(L2Bridge),\n            abi.encodeWithSelector(\n                L2Bridge.bridgeERC20.selector,\n                address(L2Token),\n                address(L1Token),\n                100,\n                1000,\n                hex\"\"\n            )\n        );\n\n        vm.expectCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L1Bridge),\n                message,\n                1000\n            )\n        );\n\n        vm.expectCall(\n            Predeploys.L2_TO_L1_MESSAGE_PASSER,\n            abi.encodeWithSelector(\n                L2ToL1MessagePasser.initiateWithdrawal.selector,\n                address(L1Messenger),\n                baseGas,\n                withdrawalData\n            )\n        );\n\n        // The L2Bridge should burn the tokens\n        vm.expectCall(\n            address(L2Token),\n            abi.encodeWithSelector(KromaMintableERC20.burn.selector, alice, 100)\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit ERC20BridgeInitiated(address(L2Token), address(L1Token), alice, alice, 100, hex\"\");\n\n        vm.expectEmit(true, true, true, true);\n        emit MessagePassed(\n            nonce,\n            address(L2Messenger),\n            address(L1Messenger),\n            0,\n            baseGas,\n            withdrawalData,\n            withdrawalHash\n        );\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true);\n        emit SentMessage(address(L1Bridge), address(L2Bridge), 0, message, nonce, 1000);\n\n        vm.prank(alice, alice);\n    }\n}\n\ncontract L2StandardBridge_BridgeERC20_Test is PreBridgeERC20 {\n    // BridgeERC20\n    // - token is burned\n    // - emits ERC20BridgeInitiated\n    // - calls Withdrawer.initiateWithdrawal\n    function test_bridgeERC20_succeeds() external {\n        _preBridgeERC20();\n        L2Bridge.bridgeERC20(address(L2Token), address(L1Token), 100, 1000, hex\"\");\n\n        assertEq(L2Token.balanceOf(alice), 0);\n    }\n}\n\ncontract PreBridgeERC20To is Bridge_Initializer {\n    function _preBridgeERC20To() internal {\n        deal(address(L2Token), alice, 100, true);\n        assertEq(L2Token.balanceOf(alice), 100);\n        uint256 nonce = L2Messenger.messageNonce();\n        bytes memory message = abi.encodeWithSelector(\n            StandardBridge.finalizeBridgeERC20.selector,\n            address(L1Token),\n            address(L2Token),\n            alice,\n            bob,\n            100,\n            hex\"\"\n        );\n        uint64 baseGas = L2Messenger.baseGas(message, 1000);\n        bytes memory withdrawalData = abi.encodeWithSelector(\n            CrossDomainMessenger.relayMessage.selector,\n            nonce,\n            address(L2Bridge),\n            address(L1Bridge),\n            0,\n            1000,\n            message\n        );\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction({\n                nonce: nonce,\n                sender: address(L2Messenger),\n                target: address(L1Messenger),\n                value: 0,\n                gasLimit: baseGas,\n                data: withdrawalData\n            })\n        );\n\n        vm.expectEmit(true, true, true, true, address(L2Bridge));\n        emit ERC20BridgeInitiated(address(L2Token), address(L1Token), alice, bob, 100, hex\"\");\n\n        vm.expectEmit(true, true, true, true, address(messagePasser));\n        emit MessagePassed(\n            nonce,\n            address(L2Messenger),\n            address(L1Messenger),\n            0,\n            baseGas,\n            withdrawalData,\n            withdrawalHash\n        );\n\n        // SentMessage event emitted by the CrossDomainMessenger\n        vm.expectEmit(true, true, true, true, address(L2Messenger));\n        emit SentMessage(address(L1Bridge), address(L2Bridge), 0, message, nonce, 1000);\n\n        vm.expectCall(\n            address(L2Bridge),\n            abi.encodeWithSelector(\n                L2Bridge.bridgeERC20To.selector,\n                address(L2Token),\n                address(L1Token),\n                bob,\n                100,\n                1000,\n                hex\"\"\n            )\n        );\n\n        vm.expectCall(\n            address(L2Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L1Bridge),\n                message,\n                1000\n            )\n        );\n\n        vm.expectCall(\n            Predeploys.L2_TO_L1_MESSAGE_PASSER,\n            abi.encodeWithSelector(\n                L2ToL1MessagePasser.initiateWithdrawal.selector,\n                address(L1Messenger),\n                baseGas,\n                withdrawalData\n            )\n        );\n\n        // The L2Bridge should burn the tokens\n        vm.expectCall(\n            address(L2Token),\n            abi.encodeWithSelector(KromaMintableERC20.burn.selector, alice, 100)\n        );\n\n        vm.prank(alice, alice);\n    }\n}\n\ncontract L2StandardBridge_BridgeERC20To_Test is PreBridgeERC20To {\n    // bridgeERC20To\n    // - token is burned\n    // - emits ERC20BridgeInitiated w/ correct recipient\n    // - calls Withdrawer.initiateWithdrawal\n    function test_bridgeERC20To_succeeds() external {\n        _preBridgeERC20To();\n        L2Bridge.bridgeERC20To(address(L2Token), address(L1Token), bob, 100, 1000, hex\"\");\n        assertEq(L2Token.balanceOf(alice), 0);\n    }\n}\n\ncontract L2StandardBridge_Bridge_Test is Bridge_Initializer {\n    // finalizeDeposit\n    // - only callable by l1Bridge\n    // - supported token pair emits ERC20BridgeFinalized\n    // - invalid deposit calls Withdrawer.initiateWithdrawal\n    function test_finalizeBridgeERC20_succeeds() external {\n        vm.mockCall(\n            address(L2Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.OTHER_BRIDGE()))\n        );\n\n        vm.expectCall(\n            address(L2Token),\n            abi.encodeWithSelector(KromaMintableERC20.mint.selector, alice, 100)\n        );\n\n        vm.expectEmit(true, true, true, true, address(L2Bridge));\n        emit ERC20BridgeFinalized(address(L2Token), address(L1Token), alice, alice, 100, hex\"\");\n\n        vm.prank(address(L2Messenger));\n        L2Bridge.finalizeBridgeERC20(address(L2Token), address(L1Token), alice, alice, 100, hex\"\");\n    }\n\n    function test_finalizeBridgeETH_incorrectValue_reverts() external {\n        vm.mockCall(\n            address(L2Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(address(L2Messenger), 100);\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"StandardBridge: amount sent does not match amount required\");\n        L2Bridge.finalizeBridgeETH{ value: 50 }(alice, alice, 100, hex\"\");\n    }\n\n    function test_finalizeBridgeETH_sendToSelf_reverts() external {\n        vm.mockCall(\n            address(L2Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(address(L2Messenger), 100);\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"StandardBridge: cannot send to self\");\n        L2Bridge.finalizeBridgeETH{ value: 100 }(alice, address(L2Bridge), 100, hex\"\");\n    }\n\n    function test_finalizeBridgeETH_sendToMessenger_reverts() external {\n        vm.mockCall(\n            address(L2Bridge.MESSENGER()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(address(L2Messenger), 100);\n        vm.prank(address(L2Messenger));\n        vm.expectRevert(\"StandardBridge: cannot send to messenger\");\n        L2Bridge.finalizeBridgeETH{ value: 100 }(alice, address(L2Messenger), 100, hex\"\");\n    }\n}\n\ncontract L2StandardBridge_FinalizeBridgeETH_Test is Bridge_Initializer {\n    function test_finalizeBridgeETH_succeeds() external {\n        address messenger = address(L2Bridge.MESSENGER());\n        vm.mockCall(\n            messenger,\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.OTHER_BRIDGE()))\n        );\n        vm.deal(messenger, 100);\n        vm.prank(messenger);\n\n        vm.expectEmit(true, true, true, true);\n        emit ETHBridgeFinalized(alice, alice, 100, hex\"\");\n\n        L2Bridge.finalizeBridgeETH{ value: 100 }(alice, alice, 100, hex\"\");\n    }\n}\n"
    },
    "contracts/test/L2ToL1MessagePasser.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract L2ToL1MessagePasserTest is CommonTest {\n    L2ToL1MessagePasser messagePasser;\n\n    event MessagePassed(\n        uint256 indexed nonce,\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes data,\n        bytes32 withdrawalHash\n    );\n\n    event WithdrawerBalanceBurnt(uint256 indexed amount);\n\n    function setUp() public virtual override {\n        super.setUp();\n        messagePasser = new L2ToL1MessagePasser();\n    }\n\n    function testFuzz_initiateWithdrawal_succeeds(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        uint256 nonce = messagePasser.messageNonce();\n\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction({\n                nonce: nonce,\n                sender: _sender,\n                target: _target,\n                value: _value,\n                gasLimit: _gasLimit,\n                data: _data\n            })\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit MessagePassed(nonce, _sender, _target, _value, _gasLimit, _data, withdrawalHash);\n\n        vm.deal(_sender, _value);\n        vm.prank(_sender);\n        messagePasser.initiateWithdrawal{ value: _value }(_target, _gasLimit, _data);\n\n        assertEq(messagePasser.sentMessages(withdrawalHash), true);\n\n        bytes32 slot = keccak256(bytes.concat(withdrawalHash, bytes32(0)));\n\n        assertEq(vm.load(address(messagePasser), slot), bytes32(uint256(1)));\n    }\n\n    // Test: initiateWithdrawal should emit the correct log when called by a contract\n    function test_initiateWithdrawal_fromContract_succeeds() external {\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction(\n                messagePasser.messageNonce(),\n                address(this),\n                address(4),\n                100,\n                64000,\n                hex\"\"\n            )\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit MessagePassed(\n            messagePasser.messageNonce(),\n            address(this),\n            address(4),\n            100,\n            64000,\n            hex\"\",\n            withdrawalHash\n        );\n\n        vm.deal(address(this), 2**64);\n        messagePasser.initiateWithdrawal{ value: 100 }(address(4), 64000, hex\"\");\n    }\n\n    // Test: initiateWithdrawal should emit the correct log when called by an EOA\n    function test_initiateWithdrawal_fromEOA_succeeds() external {\n        uint256 gasLimit = 64000;\n        address target = address(4);\n        uint256 value = 100;\n        bytes memory data = hex\"ff\";\n        uint256 nonce = messagePasser.messageNonce();\n\n        // EOA emulation\n        vm.prank(alice, alice);\n        vm.deal(alice, 2**64);\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction(nonce, alice, target, value, gasLimit, data)\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit MessagePassed(nonce, alice, target, value, gasLimit, data, withdrawalHash);\n\n        messagePasser.initiateWithdrawal{ value: value }(target, gasLimit, data);\n\n        // the sent messages mapping is filled\n        assertEq(messagePasser.sentMessages(withdrawalHash), true);\n        // the nonce increments\n        assertEq(nonce + 1, messagePasser.messageNonce());\n    }\n\n    // Test: burn should destroy the ETH held in the contract\n    function test_burn_succeeds() external {\n        messagePasser.initiateWithdrawal{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            NON_ZERO_GASLIMIT,\n            NON_ZERO_DATA\n        );\n\n        assertEq(address(messagePasser).balance, NON_ZERO_VALUE);\n        vm.expectEmit(true, false, false, false);\n        emit WithdrawerBalanceBurnt(NON_ZERO_VALUE);\n        messagePasser.burn();\n\n        // The Withdrawer should have no balance\n        assertEq(address(messagePasser).balance, 0);\n    }\n}\n"
    },
    "contracts/test/MintManager.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n// Testing utilities\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\n// Target contract dependencies\nimport { GovernanceToken } from \"../governance/GovernanceToken.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\n\n// Target contract\nimport { MintManager } from \"../governance/MintManager.sol\";\n\ncontract MintManagerTest is CommonTest {\n    address owner;\n    address rando;\n    GovernanceToken governanceToken;\n    MintManager mintManager;\n\n    address[] recipients = new address[](10);\n    uint256[] shares = new uint256[](10);\n    uint256 SHARE_DENOMINATOR;\n    uint256 MINT_CAP;\n\n    /// @dev Sets up the test suite.\n    function setUp() public virtual override {\n        super.setUp();\n\n        owner = makeAddr(\"owner\");\n        rando = makeAddr(\"rando\");\n\n        governanceToken = GovernanceToken(address(new Proxy(multisig)));\n\n        SHARE_DENOMINATOR = 10 ** 5;\n        for (uint256 i = 0; i < recipients.length; i++) {\n            string memory name = string(abi.encodePacked(\"recipient\", i));\n            recipients[i] = makeAddr(name);\n            shares[i] = SHARE_DENOMINATOR / recipients.length;\n        }\n        mintManager = new MintManager(address(governanceToken), owner, recipients, shares);\n        assertEq(mintManager.pendingOwner(), owner);\n\n        vm.prank(owner);\n        mintManager.acceptOwnership();\n        assertEq(mintManager.owner(), owner);\n\n        GovernanceToken govTokenImpl = new GovernanceToken(address(0), address(0));\n        vm.prank(multisig);\n        toProxy(address(governanceToken)).upgradeToAndCall(\n            address(govTokenImpl),\n            abi.encodeCall(governanceToken.initialize, address(mintManager))\n        );\n        assertEq(governanceToken.pendingOwner(), address(mintManager));\n\n        vm.prank(owner);\n        mintManager.acceptOwnershipOfToken();\n        assertEq(governanceToken.owner(), address(mintManager));\n\n        MINT_CAP = mintManager.MINT_CAP() * 10 ** governanceToken.decimals();\n    }\n\n    /// @dev Tests that the constructor properly configures the contract.\n    function test_constructor_succeeds() external {\n        assertEq(address(mintManager.GOVERNANCE_TOKEN()), address(governanceToken));\n\n        assertEq(mintManager.owner(), owner);\n\n        for (uint256 i = 0; i < recipients.length; i++) {\n            assertEq(mintManager.recipients(i), recipients[i]);\n            assertEq(mintManager.shareOf(recipients[i]), shares[i]);\n        }\n    }\n\n    function test_constructor_sameRecipient_succeeds() external {\n        recipients = new address[](3);\n        shares = new uint256[](3);\n\n        recipients[0] = address(1);\n        recipients[1] = address(2);\n        recipients[2] = address(2);\n\n        shares[0] = 3;\n        shares[1] = 1;\n        shares[2] = 2;\n\n        mintManager = new MintManager(address(governanceToken), owner, recipients, shares);\n\n        vm.expectRevert(bytes(\"\"));\n        mintManager.recipients(2);\n        assertEq(mintManager.recipients(0), recipients[0]);\n        assertEq(mintManager.recipients(1), recipients[1]);\n        assertEq(mintManager.shareOf(recipients[0]), shares[0]);\n        assertEq(mintManager.shareOf(recipients[1]), shares[1] + shares[2]);\n    }\n\n    function test_constructor_invalidLengthArray_reverts() external {\n        recipients = new address[](2);\n        shares = new uint256[](1);\n\n        vm.expectRevert(\"MintManager: invalid length of array\");\n        mintManager = new MintManager(address(governanceToken), owner, recipients, shares);\n    }\n\n    function test_constructor_zeroRecipient_reverts() external {\n        recipients = new address[](1);\n        shares = new uint256[](1);\n\n        recipients[0] = address(0);\n        shares[0] = SHARE_DENOMINATOR;\n\n        vm.expectRevert(\"MintManager: recipient address cannot be 0\");\n        mintManager = new MintManager(address(governanceToken), owner, recipients, shares);\n    }\n\n    function test_constructor_zeroShares_reverts() external {\n        recipients = new address[](1);\n        shares = new uint256[](1);\n\n        recipients[0] = makeAddr(\"recipient\");\n        shares[0] = 0;\n\n        vm.expectRevert(\"MintManager: share cannot be 0\");\n        mintManager = new MintManager(address(governanceToken), owner, recipients, shares);\n    }\n\n    function test_constructor_tooManyShares_reverts() external {\n        recipients = new address[](10);\n        shares = new uint256[](10);\n\n        for (uint256 i = 0; i < recipients.length; i++) {\n            string memory name = string(abi.encodePacked(\"recipient\", i));\n            recipients[i] = makeAddr(name);\n            shares[i] = SHARE_DENOMINATOR / (recipients.length - 1);\n        }\n\n        vm.expectRevert(\"MintManager: max total share is equal or less than SHARE_DENOMINATOR\");\n        mintManager = new MintManager(address(governanceToken), owner, recipients, shares);\n    }\n\n    function test_mint_succeeds() public {\n        assertFalse(mintManager.minted());\n\n        // Mint once.\n        vm.prank(owner);\n        mintManager.mint();\n\n        assertTrue(mintManager.minted());\n\n        uint256 totalAmount;\n        for (uint256 i = 0; i < recipients.length; i++) {\n            address recipient = recipients[i];\n            uint256 share = mintManager.shareOf(recipient);\n            uint256 amount = (MINT_CAP * share) / SHARE_DENOMINATOR;\n            totalAmount += amount;\n        }\n\n        // Token balance increases.\n        assertEq(governanceToken.balanceOf(address(mintManager)), totalAmount);\n    }\n\n    function test_mint_fromNotOwner_reverts() external {\n        // Mint from rando fails.\n        vm.prank(rando);\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        mintManager.mint();\n    }\n\n    function test_mint_alreadyMinted_reverts() external {\n        test_mint_succeeds();\n\n        // Mint again.\n        vm.prank(owner);\n        vm.expectRevert(\"MintManager: already minted on this chain\");\n        mintManager.mint();\n    }\n\n    function test_distribute_succeeds() public {\n        test_mint_succeeds();\n\n        vm.prank(owner);\n        mintManager.distribute();\n\n        for (uint256 i = 0; i < recipients.length; i++) {\n            address recipient = recipients[i];\n            uint256 share = mintManager.shareOf(recipient);\n            uint256 amount = (MINT_CAP * share) / SHARE_DENOMINATOR;\n            assertEq(governanceToken.balanceOf(recipient), amount);\n        }\n    }\n\n    function test_distribute_fromNotOwner_reverts() external {\n        vm.prank(rando);\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        mintManager.distribute();\n    }\n\n    function test_renounceOwnershipOfToken_succeeds() external {\n        test_mint_succeeds();\n\n        assertEq(governanceToken.owner(), address(mintManager));\n\n        vm.prank(owner);\n        mintManager.renounceOwnershipOfToken();\n\n        assertEq(governanceToken.owner(), address(0));\n    }\n\n    function test_renounceOwnershipOfToken_fromNotOwner_reverts() external {\n        vm.prank(rando);\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        mintManager.renounceOwnershipOfToken();\n    }\n\n    function test_renounceOwnershipOfToken_beforeMinted_reverts() external {\n        vm.prank(owner);\n        vm.expectRevert(\"MintManager: not minted before renounce ownership\");\n        mintManager.renounceOwnershipOfToken();\n    }\n\n    function test_transferAndAcceptOwnershipOfToken_succeeds() external {\n        assertEq(governanceToken.owner(), address(mintManager));\n\n        address newOwner = makeAddr(\"newOwner\");\n        MintManager newMintManager = new MintManager(\n            address(governanceToken),\n            newOwner,\n            recipients,\n            shares\n        );\n        vm.prank(newOwner);\n        newMintManager.acceptOwnership();\n\n        vm.prank(owner);\n        mintManager.transferOwnershipOfToken(address(newMintManager));\n        assertEq(governanceToken.pendingOwner(), address(newMintManager));\n        assertEq(governanceToken.owner(), address(mintManager));\n\n        vm.prank(newOwner);\n        newMintManager.acceptOwnershipOfToken();\n        assertEq(governanceToken.pendingOwner(), ZERO_ADDRESS);\n        assertEq(governanceToken.owner(), address(newMintManager));\n    }\n\n    function test_transferOwnershipOfToken_fromNotOwner_reverts() external {\n        vm.prank(rando);\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        mintManager.transferOwnershipOfToken(rando);\n    }\n\n    function test_acceptOwnershipOfToken_fromNotOwner_reverts() external {\n        vm.prank(rando);\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        mintManager.acceptOwnershipOfToken();\n    }\n}\n"
    },
    "contracts/test/NodeReader.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { NodeReader } from \"../libraries/NodeReader.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract NodeReader_Test is CommonTest {\n    function test_readUint8_bytestring00() external {\n        NodeReader.Item memory item = NodeReader.toItem(hex\"00\");\n        assertEq(NodeReader.readUint8(item), uint8(0x00));\n    }\n\n    function test_readUint8_bytestring01() external {\n        NodeReader.Item memory item = NodeReader.toItem(hex\"01\");\n        assertEq(NodeReader.readUint8(item), uint8(0x01));\n    }\n\n    function test_readUint8_bytestring7f() external {\n        NodeReader.Item memory item = NodeReader.toItem(hex\"7f\");\n        assertEq(NodeReader.readUint8(item), uint8(0x7f));\n    }\n\n    function test_readUint8_too_short_bytestring() external {\n        vm.expectRevert(\"NodeReader: too short for uint8\");\n        NodeReader.Item memory item = NodeReader.toItem(hex\"\");\n        NodeReader.readUint8(item);\n    }\n\n    function test_readCompressedFlags_length01_and_flag000003() external {\n        NodeReader.Item memory item = NodeReader.toItem(hex\"01030000\");\n        (uint32 compressedFlags, uint8 len) = NodeReader.readCompressedFlags(item);\n        assertEq(compressedFlags, uint32(3));\n        assertEq(len, uint8(1));\n    }\n\n    function test_readCompressedFlags_too_short_byte() external {\n        vm.expectRevert(\"NodeReader: too short for uint32\");\n        NodeReader.Item memory item = NodeReader.toItem(hex\"\");\n        NodeReader.readCompressedFlags(item);\n    }\n\n    function test_readBytes32_32bytesting() external {\n        NodeReader.Item memory item = NodeReader.toItem(\n            hex\"000102030405060708090a0b0c0d0e0f101112131415161718192a2b2c2d2e2f\"\n        );\n        assertEq(\n            NodeReader.readBytes32(item),\n            hex\"000102030405060708090a0b0c0d0e0f101112131415161718192a2b2c2d2e2f\"\n        );\n    }\n\n    function test_readBytes32_too_short_byte() external {\n        vm.expectRevert(\"NodeReader: too short for bytes32\");\n        NodeReader.Item memory item = NodeReader.toItem(hex\"\");\n        NodeReader.readBytes32(item);\n    }\n\n    function test_readBytesN_4bytesting() external {\n        NodeReader.Item memory item = NodeReader.toItem(hex\"0001020304\");\n        assertEq(NodeReader.readBytesN(item, 4), bytes32(uint256(0x010203)));\n    }\n\n    function test_readBytesN_too_short_byte() external {\n        vm.expectRevert(\"NodeReader: too short for n bytes\");\n        NodeReader.Item memory item = NodeReader.toItem(hex\"0001020304\");\n        NodeReader.readBytesN(item, 6);\n    }\n\n    function test_readNode_middle_node() external {\n        bytes memory middleHex = new bytes(65);\n        bytes32 childL = hex\"0000000000000000000000000000000000000000000000000000000000000000\";\n        bytes32 childR = hex\"04470b58d80eeb26da85b2c2db5c254900656fb459c07729f556ff02534ab32a\";\n        assembly {\n            mstore8(add(middleHex, 32), 0)\n            mstore(add(middleHex, 33), childL)\n            mstore(add(middleHex, 65), childR)\n        }\n        NodeReader.Node memory node = NodeReader.readNode(middleHex);\n        assertEq(uint256(node.nodeType), uint256(NodeReader.NodeType.MIDDLE));\n        assertEq(node.childL, childL);\n        assertEq(node.childR, childR);\n    }\n\n    function test_readNode_leaf_node() external {\n        bytes memory leafHex = new bytes(102);\n        bytes32 nodeKey = hex\"7f9d3bbc51d12566ecc6049ca6bf76e32828c22b197405f63a833b566fe7da0a\";\n        bytes32 value = hex\"0000000000000000000000000000000000000000000000000000000000000001\";\n        assembly {\n            mstore8(add(leafHex, 32), 1)\n            mstore(add(leafHex, 33), nodeKey)\n            mstore8(add(leafHex, 65), 1)\n            mstore8(add(leafHex, 66), 1)\n            mstore8(add(leafHex, 67), 0)\n            mstore8(add(leafHex, 68), 0)\n            mstore(add(leafHex, 69), value)\n            mstore8(add(leafHex, 101), 0)\n        }\n        NodeReader.Node memory node = NodeReader.readNode(leafHex);\n        assertEq(uint256(node.nodeType), uint256(NodeReader.NodeType.LEAF));\n        assertEq(node.nodeKey, nodeKey);\n        assertEq(node.compressedFlags, 1);\n        assertEq(node.valuePreimage.length, 1);\n        assertEq(node.valuePreimage[0], value);\n    }\n\n    function test_readNode_empty_node() external {\n        bytes memory emptyHex = new bytes(1);\n        assembly {\n            mstore8(add(emptyHex, 32), 2)\n        }\n        NodeReader.Node memory node = NodeReader.readNode(emptyHex);\n        assertEq(uint256(node.nodeType), uint256(NodeReader.NodeType.EMPTY));\n    }\n\n    function test_readNode_root_node() external {\n        vm.expectRevert(\"NodeReader: unexpected root node type\");\n        bytes memory rootHex = new bytes(1);\n        assembly {\n            mstore8(add(rootHex, 32), 3)\n        }\n        NodeReader.readNode(rootHex);\n    }\n\n    function test_readNode_invalid_node() external {\n        vm.expectRevert(\"NodeReader: invalid node type\");\n        bytes memory invalidHex = new bytes(1);\n        assembly {\n            mstore8(add(invalidHex, 32), 4)\n        }\n        NodeReader.readNode(invalidHex);\n    }\n}\n"
    },
    "contracts/test/Proxy.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\nimport { Test } from \"forge-std/Test.sol\";\n\nimport { Proxy } from \"../universal/Proxy.sol\";\n\ncontract SimpleStorage {\n    mapping(uint256 => uint256) internal store;\n\n    function get(uint256 key) external payable returns (uint256) {\n        return store[key];\n    }\n\n    function set(uint256 key, uint256 value) external payable {\n        store[key] = value;\n    }\n}\n\ncontract Clasher {\n    function upgradeTo(address) external pure {\n        revert(\"upgradeTo\");\n    }\n}\n\ncontract Proxy_Test is Test {\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    address alice = address(64);\n\n    bytes32 internal constant IMPLEMENTATION_KEY =\n        bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1);\n\n    bytes32 internal constant OWNER_KEY = bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1);\n\n    Proxy proxy;\n    SimpleStorage simpleStorage;\n\n    function setUp() external {\n        // Deploy a proxy and simple storage contract as\n        // the implementation\n        proxy = new Proxy(alice);\n        simpleStorage = new SimpleStorage();\n\n        vm.prank(alice);\n        proxy.upgradeTo(address(simpleStorage));\n    }\n\n    function test_implementationKey_succeeds() external {\n        // The hardcoded implementation key should be correct\n        vm.prank(alice);\n        proxy.upgradeTo(address(6));\n\n        bytes32 key = vm.load(address(proxy), IMPLEMENTATION_KEY);\n        assertEq(address(6), Bytes32AddressLib.fromLast20Bytes(key));\n\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(6));\n    }\n\n    function test_ownerKey_succeeds() external {\n        // The hardcoded owner key should be correct\n        vm.prank(alice);\n        proxy.changeAdmin(address(6));\n\n        bytes32 key = vm.load(address(proxy), OWNER_KEY);\n        assertEq(address(6), Bytes32AddressLib.fromLast20Bytes(key));\n\n        vm.prank(address(6));\n        address owner = proxy.admin();\n        assertEq(owner, address(6));\n    }\n\n    function test_proxyCallToImp_notAdmin_succeeds() external {\n        // The implementation does not have a `upgradeTo`\n        // method, calling `upgradeTo` not as the owner\n        // should revert.\n        vm.expectRevert();\n        proxy.upgradeTo(address(64));\n\n        // Call `upgradeTo` as the owner, it should succeed\n        // and emit the `Upgraded` event.\n        vm.expectEmit(true, true, true, true);\n        emit Upgraded(address(64));\n        vm.prank(alice);\n        proxy.upgradeTo(address(64));\n\n        // Get the implementation as the owner\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(64));\n    }\n\n    function test_ownerProxyCall_notAdmin_succeeds() external {\n        // Calling `changeAdmin` not as the owner should revert\n        // as the implementation does not have a `changeAdmin` method.\n        vm.expectRevert();\n        proxy.changeAdmin(address(1));\n\n        // Call `changeAdmin` as the owner, it should succeed\n        // and emit the `AdminChanged` event.\n        vm.expectEmit(true, true, true, true);\n        emit AdminChanged(alice, address(1));\n        vm.prank(alice);\n        proxy.changeAdmin(address(1));\n\n        // Calling `admin` not as the owner should\n        // revert as the implementation does not have\n        // a `admin` method.\n        vm.expectRevert();\n        proxy.admin();\n\n        // Calling `admin` as the owner should work.\n        vm.prank(address(1));\n        address owner = proxy.admin();\n        assertEq(owner, address(1));\n    }\n\n    function test_delegatesToImpl_succeeds() external {\n        // Call the storage setter on the proxy\n        SimpleStorage(address(proxy)).set(1, 1);\n\n        // The key should not be set in the implementation\n        uint256 result = simpleStorage.get(1);\n        assertEq(result, 0);\n        {\n            // The key should be set in the proxy\n            uint256 expect = SimpleStorage(address(proxy)).get(1);\n            assertEq(expect, 1);\n        }\n\n        {\n            // The owner should be able to call through the proxy\n            // when there is not a function selector crash\n            vm.prank(alice);\n            uint256 expect = SimpleStorage(address(proxy)).get(1);\n            assertEq(expect, 1);\n        }\n    }\n\n    function test_upgradeToAndCall_succeeds() external {\n        {\n            // There should be nothing in the current proxy storage\n            uint256 expect = SimpleStorage(address(proxy)).get(1);\n            assertEq(expect, 0);\n        }\n\n        // Deploy a new SimpleStorage\n        simpleStorage = new SimpleStorage();\n\n        // Set the new SimpleStorage as the implementation\n        // and call.\n        vm.expectEmit(true, true, true, true);\n        emit Upgraded(address(simpleStorage));\n        vm.prank(alice);\n        proxy.upgradeToAndCall(\n            address(simpleStorage),\n            abi.encodeWithSelector(simpleStorage.set.selector, 1, 1)\n        );\n\n        // The call should have impacted the state\n        uint256 result = SimpleStorage(address(proxy)).get(1);\n        assertEq(result, 1);\n    }\n\n    function test_upgradeToAndCall_functionDoesNotExist_reverts() external {\n        // Get the current implementation address\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(simpleStorage));\n\n        // Deploy a new SimpleStorage\n        simpleStorage = new SimpleStorage();\n\n        // Set the new SimpleStorage as the implementation\n        // and call. This reverts because the calldata doesn't\n        // match a function on the implementation.\n        vm.expectRevert(\"Proxy: delegatecall to new implementation contract failed\");\n        vm.prank(alice);\n        proxy.upgradeToAndCall(address(simpleStorage), hex\"\");\n\n        // The implementation address should have not\n        // updated because the call to `upgradeToAndCall`\n        // reverted.\n        vm.prank(alice);\n        address postImpl = proxy.implementation();\n        assertEq(impl, postImpl);\n\n        // The attempt to `upgradeToAndCall`\n        // should revert when it is not called by the owner.\n        vm.expectRevert();\n        proxy.upgradeToAndCall(\n            address(simpleStorage),\n            abi.encodeWithSelector(simpleStorage.set.selector, 1, 1)\n        );\n    }\n\n    function test_upgradeToAndCall_isPayable_succeeds() external {\n        // Give alice some funds\n        vm.deal(alice, 1 ether);\n        // Set the implementation and call and send\n        // value.\n        vm.prank(alice);\n        proxy.upgradeToAndCall{ value: 1 ether }(\n            address(simpleStorage),\n            abi.encodeWithSelector(simpleStorage.set.selector, 1, 1)\n        );\n\n        // The implementation address should be correct\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(simpleStorage));\n\n        // The proxy should have a balance\n        assertEq(address(proxy).balance, 1 ether);\n    }\n\n    function test_upgradeTo_clashingFunctionSignatures_succeeds() external {\n        // Clasher has a clashing function with the proxy.\n        Clasher clasher = new Clasher();\n\n        // Set the clasher as the implementation.\n        vm.prank(alice);\n        proxy.upgradeTo(address(clasher));\n\n        {\n            // Assert that the implementation was set properly.\n            vm.prank(alice);\n            address impl = proxy.implementation();\n            assertEq(impl, address(clasher));\n        }\n\n        // Call the clashing function on the proxy\n        // not as the owner so that the call passes through.\n        // The implementation will revert so we can be\n        // sure that the call passed through.\n        vm.expectRevert(bytes(\"upgradeTo\"));\n        proxy.upgradeTo(address(0));\n\n        {\n            // Now call the clashing function as the owner\n            // and be sure that it doesn't pass through to\n            // the implementation.\n            vm.prank(alice);\n            proxy.upgradeTo(address(0));\n            vm.prank(alice);\n            address impl = proxy.implementation();\n            assertEq(impl, address(0));\n        }\n    }\n\n    // Allow for `eth_call` to call proxy methods\n    // by setting \"from\" to `address(0)`.\n    function test_implementation_zeroAddressCaller_succeeds() external {\n        vm.prank(address(0));\n        address impl = proxy.implementation();\n        assertEq(impl, address(simpleStorage));\n    }\n\n    function test_implementation_isZeroAddress_reverts() external {\n        // Set `address(0)` as the implementation.\n        vm.prank(alice);\n        proxy.upgradeTo(address(0));\n\n        (bool success, bytes memory returndata) = address(proxy).call(hex\"\");\n        assertEq(success, false);\n\n        bytes memory err = abi.encodeWithSignature(\n            \"Error(string)\",\n            \"Proxy: implementation not initialized\"\n        );\n\n        assertEq(returndata, err);\n    }\n}\n"
    },
    "contracts/test/ProxyAdmin.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\n\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { ProxyAdmin } from \"../universal/ProxyAdmin.sol\";\nimport { SimpleStorage } from \"./Proxy.t.sol\";\n\ncontract ProxyAdmin_Test is Test {\n    address alice = address(64);\n\n    Proxy proxy;\n\n    ProxyAdmin admin;\n\n    SimpleStorage implementation;\n\n    function setUp() external {\n        // Deploy the proxy admin\n        admin = new ProxyAdmin(alice);\n        // Deploy the standard proxy\n        proxy = new Proxy(address(admin));\n\n        implementation = new SimpleStorage();\n    }\n\n    function test_owner_succeeds() external {\n        assertEq(admin.owner(), alice);\n    }\n\n    function test_getProxyImplementation_succeeds() external {\n        {\n            address impl = admin.getProxyImplementation(payable(proxy));\n            assertEq(impl, address(0));\n        }\n\n        vm.prank(alice);\n        admin.upgrade(payable(proxy), address(implementation));\n\n        {\n            address impl = admin.getProxyImplementation(payable(proxy));\n            assertEq(impl, address(implementation));\n        }\n    }\n\n    function test_getProxyAdmin_succeeds() external {\n        address owner = admin.getProxyAdmin(payable(proxy));\n        assertEq(owner, address(admin));\n    }\n\n    function test_changeProxyAdmin_succeeds() external {\n        vm.prank(alice);\n        admin.changeProxyAdmin(payable(proxy), address(128));\n\n        // The proxy is no longer the admin and can\n        // no longer call the proxy interface.\n        vm.expectRevert(\"Proxy: implementation not initialized\");\n        admin.getProxyAdmin(payable(proxy));\n\n        // Call the proxy contract directly to get the admin.\n        // Different proxy types have different interfaces.\n        vm.prank(address(128));\n        assertEq(Proxy(payable(proxy)).admin(), address(128));\n    }\n\n    function test_upgrade_succeeds() external {\n        vm.prank(alice);\n        admin.upgrade(payable(proxy), address(implementation));\n\n        address impl = admin.getProxyImplementation(payable(proxy));\n        assertEq(impl, address(implementation));\n    }\n\n    function test_upgradeAndCall_succeeds() external {\n        vm.prank(alice);\n        admin.upgradeAndCall(\n            payable(proxy),\n            address(implementation),\n            abi.encodeWithSelector(SimpleStorage.set.selector, 1, 1)\n        );\n\n        address impl = admin.getProxyImplementation(payable(proxy));\n        assertEq(impl, address(implementation));\n\n        uint256 got = SimpleStorage(address(proxy)).get(1);\n        assertEq(got, 1);\n    }\n\n    function test_onlyOwner_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        admin.changeProxyAdmin(payable(proxy), address(0));\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        admin.upgrade(payable(proxy), address(implementation));\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        admin.upgradeAndCall(payable(proxy), address(implementation), hex\"\");\n    }\n}\n"
    },
    "contracts/test/RLP.t.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\n\n/**\n * @title LibRLP\n * @notice Via https://github.com/Rari-Capital/solmate/issues/207.\n */\nlibrary LibRLP {\n    using Bytes32AddressLib for bytes32;\n\n    function computeAddress(address deployer, uint256 nonce) internal pure returns (address) {\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\n        // A one byte integer uses its own value as its length prefix, there is no additional \"0x80 + length\" prefix that comes before it.\n        if (nonce == 0x00)\n            return\n                keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80)))\n                    .fromLast20Bytes();\n        if (nonce <= 0x7f)\n            return\n                keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce)))\n                    .fromLast20Bytes();\n\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\n        if (nonce <= type(uint8).max)\n            return\n                keccak256(\n                    abi.encodePacked(\n                        bytes1(0xd7),\n                        bytes1(0x94),\n                        deployer,\n                        bytes1(0x81),\n                        uint8(nonce)\n                    )\n                ).fromLast20Bytes();\n        if (nonce <= type(uint16).max)\n            return\n                keccak256(\n                    abi.encodePacked(\n                        bytes1(0xd8),\n                        bytes1(0x94),\n                        deployer,\n                        bytes1(0x82),\n                        uint16(nonce)\n                    )\n                ).fromLast20Bytes();\n        if (nonce <= type(uint24).max)\n            return\n                keccak256(\n                    abi.encodePacked(\n                        bytes1(0xd9),\n                        bytes1(0x94),\n                        deployer,\n                        bytes1(0x83),\n                        uint24(nonce)\n                    )\n                ).fromLast20Bytes();\n\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\n        return\n            keccak256(\n                abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce))\n            ).fromLast20Bytes();\n    }\n}\n"
    },
    "contracts/test/ResourceMetering.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\n\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\n\ncontract MeterUser is ResourceMetering {\n    ResourceMetering.ResourceConfig public innerConfig;\n\n    constructor() {\n        initialize();\n        innerConfig = Constants.DEFAULT_RESOURCE_CONFIG();\n    }\n\n    function initialize() public initializer {\n        __ResourceMetering_init();\n    }\n\n    function resourceConfig() public view returns (ResourceMetering.ResourceConfig memory) {\n        return _resourceConfig();\n    }\n\n    function _resourceConfig()\n        internal\n        view\n        override\n        returns (ResourceMetering.ResourceConfig memory)\n    {\n        return innerConfig;\n    }\n\n    function use(uint64 _amount) public metered(_amount) {}\n\n    function set(\n        uint128 _prevBaseFee,\n        uint64 _prevBoughtGas,\n        uint64 _prevBlockNum\n    ) public {\n        params = ResourceMetering.ResourceParams({\n            prevBaseFee: _prevBaseFee,\n            prevBoughtGas: _prevBoughtGas,\n            prevBlockNum: _prevBlockNum\n        });\n    }\n\n    function setParams(ResourceMetering.ResourceConfig memory newConfig) public {\n        innerConfig = newConfig;\n    }\n}\n\n/**\n * @title ResourceConfig\n * @notice The tests are based on the default config values. It is expected that\n *         the config values used in these tests are ran in production.\n */\ncontract ResourceMetering_Test is Test {\n    MeterUser internal meter;\n    uint64 initialBlockNum;\n\n    function setUp() public {\n        meter = new MeterUser();\n        initialBlockNum = uint64(block.number);\n    }\n\n    function test_meter_initialResourceParams_succeeds() external {\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n        ResourceMetering.ResourceConfig memory rcfg = meter.resourceConfig();\n\n        assertEq(prevBaseFee, rcfg.minimumBaseFee);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum);\n    }\n\n    function test_meter_updateParamsNoChange_succeeds() external {\n        meter.use(0); // equivalent to just updating the base fee and block number\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n        meter.use(0);\n        (uint128 postBaseFee, uint64 postBoughtGas, uint64 postBlockNum) = meter.params();\n\n        assertEq(postBaseFee, prevBaseFee);\n        assertEq(postBoughtGas, prevBoughtGas);\n        assertEq(postBlockNum, prevBlockNum);\n    }\n\n    function test_meter_updateOneEmptyBlock_succeeds() external {\n        vm.roll(initialBlockNum + 1);\n        meter.use(0);\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, 1 gwei);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum + 1);\n    }\n\n    function test_meter_updateTwoEmptyBlocks_succeeds() external {\n        vm.roll(initialBlockNum + 2);\n        meter.use(0);\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, 1 gwei);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum + 2);\n    }\n\n    function test_meter_updateTenEmptyBlocks_succeeds() external {\n        vm.roll(initialBlockNum + 10);\n        meter.use(0);\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, 1 gwei);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum + 10);\n    }\n\n    function test_meter_updateNoGasDelta_succeeds() external {\n        ResourceMetering.ResourceConfig memory rcfg = meter.resourceConfig();\n        uint256 target = uint256(rcfg.maxResourceLimit) / uint256(rcfg.elasticityMultiplier);\n        meter.use(uint64(target));\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, 1000000000);\n        assertEq(prevBoughtGas, target);\n        assertEq(prevBlockNum, initialBlockNum);\n    }\n\n    function test_meter_useMax_succeeds() external {\n        ResourceMetering.ResourceConfig memory rcfg = meter.resourceConfig();\n        uint64 target = uint64(rcfg.maxResourceLimit) / uint64(rcfg.elasticityMultiplier);\n        uint64 elasticityMultiplier = uint64(rcfg.elasticityMultiplier);\n        meter.use(target * elasticityMultiplier);\n\n        (, uint64 prevBoughtGas, ) = meter.params();\n        assertEq(prevBoughtGas, target * elasticityMultiplier);\n\n        vm.roll(initialBlockNum + 1);\n        meter.use(0);\n        (uint128 postBaseFee, , ) = meter.params();\n        assertEq(postBaseFee, 2125000000);\n    }\n\n    /**\n     * @notice This tests that the metered modifier reverts if\n     *         the ResourceConfig baseFeeMaxChangeDenominator\n     *         is set to 1.\n     *         Since the metered modifier internally calls\n     *         solmate's powWad function, it will revert\n     *         with the error string \"UNEXPECTED\" since the\n     *         first parameter will be computed as 0.\n     */\n    function test_meter_denominatorEq1_reverts() external {\n        ResourceMetering.ResourceConfig memory rcfg = meter.resourceConfig();\n        uint64 target = uint64(rcfg.maxResourceLimit) / uint64(rcfg.elasticityMultiplier);\n        uint64 elasticityMultiplier = uint64(rcfg.elasticityMultiplier);\n        rcfg.baseFeeMaxChangeDenominator = 1;\n        meter.setParams(rcfg);\n        meter.use(target * elasticityMultiplier);\n\n        (, uint64 prevBoughtGas, ) = meter.params();\n        assertEq(prevBoughtGas, target * elasticityMultiplier);\n\n        vm.roll(initialBlockNum + 2);\n\n        vm.expectRevert(\"UNDEFINED\");\n        meter.use(0);\n    }\n\n    function test_meter_useMoreThanMax_reverts() external {\n        ResourceMetering.ResourceConfig memory rcfg = meter.resourceConfig();\n        uint64 target = uint64(rcfg.maxResourceLimit) / uint64(rcfg.elasticityMultiplier);\n        uint64 elasticityMultiplier = uint64(rcfg.elasticityMultiplier);\n\n        vm.expectRevert(\"ResourceMetering: cannot buy more gas than available gas limit\");\n        meter.use(target * elasticityMultiplier + 1);\n    }\n\n    // Demonstrates that the resource metering arithmetic can tolerate very large gaps between\n    // deposits.\n    function testFuzz_meter_largeBlockDiff_succeeds(uint64 _amount, uint256 _blockDiff) external {\n        // This test fails if the following line is commented out.\n        // At 12 seconds per block, this number is effectively unreachable.\n        vm.assume(_blockDiff < 433576281058164217753225238677900874458691);\n\n        ResourceMetering.ResourceConfig memory rcfg = meter.resourceConfig();\n        uint64 target = uint64(rcfg.maxResourceLimit) / uint64(rcfg.elasticityMultiplier);\n        uint64 elasticityMultiplier = uint64(rcfg.elasticityMultiplier);\n\n        vm.assume(_amount < target * elasticityMultiplier);\n        vm.roll(initialBlockNum + _blockDiff);\n        meter.use(_amount);\n    }\n}\n\n/**\n * @title CustomMeterUser\n * @notice A simple wrapper around `ResourceMetering` that allows the initial\n *         params to be set in the constructor.\n */\ncontract CustomMeterUser is ResourceMetering {\n    uint256 public startGas;\n    uint256 public endGas;\n\n    constructor(\n        uint128 _prevBaseFee,\n        uint64 _prevBoughtGas,\n        uint64 _prevBlockNum\n    ) {\n        params = ResourceMetering.ResourceParams({\n            prevBaseFee: _prevBaseFee,\n            prevBoughtGas: _prevBoughtGas,\n            prevBlockNum: _prevBlockNum\n        });\n    }\n\n    function _resourceConfig()\n        internal\n        pure\n        override\n        returns (ResourceMetering.ResourceConfig memory)\n    {\n        return Constants.DEFAULT_RESOURCE_CONFIG();\n    }\n\n    function use(uint64 _amount) public returns (uint256) {\n        uint256 initialGas = gasleft();\n        _metered(_amount, initialGas);\n        return initialGas - gasleft();\n    }\n}\n\n/**\n * @title ArtifactResourceMetering_Test\n * @notice A table test that sets the state of the ResourceParams and then requests\n *         various amounts of gas. This test ensures that a wide range of values\n *         can safely be used with the `ResourceMetering` contract.\n *         It also writes a CSV file to disk that includes useful information\n *         about how much gas is used and how expensive it is in USD terms to\n *         purchase the deposit gas.\n */\ncontract ArtifactResourceMetering_Test is Test {\n    uint128 internal minimumBaseFee;\n    uint128 internal maximumBaseFee;\n    uint64 internal maxResourceLimit;\n    uint64 internal targetResourceLimit;\n\n    string internal outfile;\n\n    // keccak256(abi.encodeWithSignature(\"Error(string)\", \"ResourceMetering: cannot buy more gas than available gas limit\"))\n    bytes32 internal cannotBuyMoreGas =\n        0x84edc668cfd5e050b8999f43ff87a1faaa93e5f935b20bc1dd4d3ff157ccf429;\n    // keccak256(abi.encodeWithSignature(\"Panic(uint256)\", 0x11))\n    bytes32 internal overflowErr =\n        0x1ca389f2c8264faa4377de9ce8e14d6263ef29c68044a9272d405761bab2db27;\n    // keccak256(hex\"\")\n    bytes32 internal emptyReturnData =\n        0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n    /**\n     * @notice Sets up the tests by getting constants from the ResourceMetering\n     *         contract.\n     */\n    function setUp() public {\n        vm.roll(1_000_000);\n\n        MeterUser base = new MeterUser();\n        ResourceMetering.ResourceConfig memory rcfg = base.resourceConfig();\n        minimumBaseFee = uint128(rcfg.minimumBaseFee);\n        maximumBaseFee = rcfg.maximumBaseFee;\n        maxResourceLimit = uint64(rcfg.maxResourceLimit);\n        targetResourceLimit = uint64(rcfg.maxResourceLimit) / uint64(rcfg.elasticityMultiplier);\n\n        outfile = string.concat(vm.projectRoot(), \"/.resource-metering.csv\");\n        try vm.removeFile(outfile) {} catch {}\n    }\n\n    /**\n     * @notice Generate a CSV file. The call to `meter` should be called with at\n     *         most the L1 block gas limit. Without specifying the amount of\n     *         gas, it can take very long to execute.\n     */\n    function test_meter_generateArtifact_succeeds() external {\n        vm.writeLine(\n            outfile,\n            \"prevBaseFee,prevBoughtGas,prevBlockNumDiff,l1BaseFee,requestedGas,gasConsumed,ethPrice,usdCost,success\"\n        );\n\n        // prevBaseFee value in ResourceParams\n        uint128[] memory prevBaseFees = new uint128[](5);\n        prevBaseFees[0] = minimumBaseFee;\n        prevBaseFees[1] = maximumBaseFee;\n        prevBaseFees[2] = uint128(50 gwei);\n        prevBaseFees[3] = uint128(100 gwei);\n        prevBaseFees[4] = uint128(200 gwei);\n\n        // prevBoughtGas value in ResourceParams\n        uint64[] memory prevBoughtGases = new uint64[](1);\n        prevBoughtGases[0] = uint64(0);\n\n        // prevBlockNum diff, simulates blocks with no deposits when non zero\n        uint64[] memory prevBlockNumDiffs = new uint64[](2);\n        prevBlockNumDiffs[0] = 0;\n        prevBlockNumDiffs[1] = 1;\n\n        // The amount of L2 gas that a user requests\n        uint64[] memory requestedGases = new uint64[](3);\n        requestedGases[0] = maxResourceLimit;\n        requestedGases[1] = targetResourceLimit;\n        requestedGases[2] = uint64(100_000);\n\n        // The L1 base fee\n        uint256[] memory l1BaseFees = new uint256[](4);\n        l1BaseFees[0] = 1 gwei;\n        l1BaseFees[1] = 50 gwei;\n        l1BaseFees[2] = 75 gwei;\n        l1BaseFees[3] = 100 gwei;\n\n        // USD price of 1 ether\n        uint256[] memory ethPrices = new uint256[](2);\n        ethPrices[0] = 1600;\n        ethPrices[1] = 3200;\n\n        // Iterate over all of the test values and run a test\n        for (uint256 i; i < prevBaseFees.length; i++) {\n            for (uint256 j; j < prevBoughtGases.length; j++) {\n                for (uint256 k; k < prevBlockNumDiffs.length; k++) {\n                    for (uint256 l; l < requestedGases.length; l++) {\n                        for (uint256 m; m < l1BaseFees.length; m++) {\n                            for (uint256 n; n < ethPrices.length; n++) {\n                                uint256 snapshotId = vm.snapshot();\n\n                                uint128 prevBaseFee = prevBaseFees[i];\n                                uint64 prevBoughtGas = prevBoughtGases[j];\n                                uint64 prevBlockNumDiff = prevBlockNumDiffs[k];\n                                uint64 requestedGas = requestedGases[l];\n                                uint256 l1BaseFee = l1BaseFees[m];\n                                uint256 ethPrice = ethPrices[n];\n                                string memory result = \"success\";\n\n                                vm.fee(l1BaseFee);\n\n                                CustomMeterUser meter = new CustomMeterUser({\n                                    _prevBaseFee: prevBaseFee,\n                                    _prevBoughtGas: prevBoughtGas,\n                                    _prevBlockNum: uint64(block.number)\n                                });\n\n                                vm.roll(block.number + prevBlockNumDiff);\n\n                                // Call the metering code and catch the various\n                                // types of errors.\n                                uint256 gasConsumed = 0;\n                                try meter.use{ gas: 30_000_000 }(requestedGas) returns (\n                                    uint256 _gasConsumed\n                                ) {\n                                    gasConsumed = _gasConsumed;\n                                } catch (bytes memory err) {\n                                    bytes32 hash = keccak256(err);\n                                    if (hash == cannotBuyMoreGas) {\n                                        result = \"ResourceMetering: cannot buy more gas than available gas limit\";\n                                    } else if (hash == overflowErr) {\n                                        result = \"arithmetic overflow/underflow\";\n                                    } else if (hash == emptyReturnData) {\n                                        result = \"out of gas\";\n                                    } else {\n                                        result = \"UNKNOWN ERROR\";\n                                    }\n                                }\n\n                                // Compute the USD cost of the gas used\n                                uint256 usdCost = (gasConsumed * l1BaseFee * ethPrice) / 1 ether;\n\n                                vm.writeLine(\n                                    outfile,\n                                    string.concat(\n                                        vm.toString(prevBaseFee),\n                                        \",\",\n                                        vm.toString(prevBoughtGas),\n                                        \",\",\n                                        vm.toString(prevBlockNumDiff),\n                                        \",\",\n                                        vm.toString(l1BaseFee),\n                                        \",\",\n                                        vm.toString(requestedGas),\n                                        \",\",\n                                        vm.toString(gasConsumed),\n                                        \",\",\n                                        \"$\",\n                                        vm.toString(ethPrice),\n                                        \",\",\n                                        \"$\",\n                                        vm.toString(usdCost),\n                                        \",\",\n                                        result\n                                    )\n                                );\n\n                                assertTrue(vm.revertTo(snapshotId));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/test/SafeCall.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract SafeCall_Test is CommonTest {\n    function testFuzz_call_succeeds(\n        address from,\n        address to,\n        uint256 gas,\n        uint64 value,\n        bytes memory data\n    ) external {\n        vm.assume(from.balance == 0);\n        vm.assume(to.balance == 0);\n        // no precompiles (mainnet)\n        assumeNoPrecompiles(to, 1);\n        // don't call the vm\n        vm.assume(to != address(vm));\n        vm.assume(from != address(vm));\n        // don't call the console\n        vm.assume(to != address(0x000000000000000000636F6e736F6c652e6c6f67));\n        // don't call the create2 deployer\n        vm.assume(to != address(0x4e59b44847b379578588920cA78FbF26c0B4956C));\n        // don't call the default test contract\n        vm.assume(to != address(0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f));\n\n        assertEq(from.balance, 0, \"from balance is 0\");\n        vm.deal(from, value);\n        assertEq(from.balance, value, \"from balance not dealt\");\n\n        uint256[2] memory balancesBefore = [from.balance, to.balance];\n\n        vm.expectCall(to, value, data);\n        vm.prank(from);\n        bool success = SafeCall.call(to, gas, value, data);\n\n        assertTrue(success, \"call not successful\");\n        if (from == to) {\n            assertEq(from.balance, balancesBefore[0], \"Self-send did not change balance\");\n        } else {\n            assertEq(from.balance, balancesBefore[0] - value, \"from balance not drained\");\n            assertEq(to.balance, balancesBefore[1] + value, \"to balance received\");\n        }\n    }\n\n    function testFuzz_callWithMinGas_hasEnough_succeeds(\n        address from,\n        address to,\n        uint64 minGas,\n        uint64 value,\n        bytes memory data\n    ) external {\n        vm.assume(from.balance == 0);\n        vm.assume(to.balance == 0);\n        // no precompiles (mainnet)\n        assumeNoPrecompiles(to, 1);\n        // don't call the vm\n        vm.assume(to != address(vm));\n        vm.assume(from != address(vm));\n        // don't call the console\n        vm.assume(to != address(0x000000000000000000636F6e736F6c652e6c6f67));\n        // don't call the create2 deployer\n        vm.assume(to != address(0x4e59b44847b379578588920cA78FbF26c0B4956C));\n        // don't call the default test contract\n        vm.assume(to != address(0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f));\n\n        assertEq(from.balance, 0, \"from balance is 0\");\n        vm.deal(from, value);\n        assertEq(from.balance, value, \"from balance not dealt\");\n\n        // Bound minGas to [0, l1_block_gas_limit]\n        minGas = uint64(bound(minGas, 0, 30_000_000));\n\n        uint256[2] memory balancesBefore = [from.balance, to.balance];\n\n        vm.expectCallMinGas(to, value, minGas, data);\n        vm.prank(from);\n        bool success = SafeCall.callWithMinGas(to, minGas, value, data);\n\n        assertTrue(success, \"call not successful\");\n        if (from == to) {\n            assertEq(from.balance, balancesBefore[0], \"Self-send did not change balance\");\n        } else {\n            assertEq(from.balance, balancesBefore[0] - value, \"from balance not drained\");\n            assertEq(to.balance, balancesBefore[1] + value, \"to balance received\");\n        }\n    }\n\n    function test_callWithMinGas_noLeakageLow_succeeds() external {\n        SimpleSafeCaller caller = new SimpleSafeCaller();\n\n        for (uint64 i = 40_000; i < 100_000; i++) {\n            uint256 snapshot = vm.snapshot();\n\n            // 65_907 is the exact amount of gas required to make the safe call\n            // successfully.\n            if (i < 65_907) {\n                assertFalse(caller.makeSafeCall(i, 25_000));\n            } else {\n                vm.expectCallMinGas(\n                    address(caller),\n                    0,\n                    25_000,\n                    abi.encodeWithSelector(caller.setA.selector, 1)\n                );\n                assertTrue(caller.makeSafeCall(i, 25_000));\n            }\n\n            assertTrue(vm.revertTo(snapshot));\n        }\n    }\n\n    function test_callWithMinGas_noLeakageHigh_succeeds() external {\n        SimpleSafeCaller caller = new SimpleSafeCaller();\n\n        for (uint64 i = 15_200_000; i < 15_300_000; i++) {\n            uint256 snapshot = vm.snapshot();\n\n            // 15_278_606 is the exact amount of gas required to make the safe call\n            // successfully.\n            if (i < 15_278_606) {\n                assertFalse(caller.makeSafeCall(i, 15_000_000));\n            } else {\n                vm.expectCallMinGas(\n                    address(caller),\n                    0,\n                    15_000_000,\n                    abi.encodeWithSelector(caller.setA.selector, 1)\n                );\n                assertTrue(caller.makeSafeCall(i, 15_000_000));\n            }\n\n            assertTrue(vm.revertTo(snapshot));\n        }\n    }\n}\n\ncontract SimpleSafeCaller {\n    uint256 public a;\n\n    function makeSafeCall(uint64 gas, uint64 minGas) external returns (bool) {\n        return\n            SafeCall.call(\n                address(this),\n                gas,\n                0,\n                abi.encodeWithSelector(this.makeSafeCallMinGas.selector, minGas)\n            );\n    }\n\n    function makeSafeCallMinGas(uint64 minGas) external returns (bool) {\n        return\n            SafeCall.callWithMinGas(\n                address(this),\n                minGas,\n                0,\n                abi.encodeWithSelector(this.setA.selector, 1)\n            );\n    }\n\n    function setA(uint256 _a) external {\n        a = _a;\n    }\n}\n"
    },
    "contracts/test/SecurityCouncil.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Colosseum } from \"../L1/Colosseum.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { SecurityCouncil_Initializer } from \"./CommonTest.t.sol\";\n\ncontract SecurityCouncilTest is SecurityCouncil_Initializer {\n    /**\n     *  Events\n     */\n    event TransactionSubmitted(address indexed sender, uint256 indexed transactionId);\n    event TransactionConfirmed(address indexed sender, uint256 indexed transactionId);\n    event TransactionExecuted(address indexed sender, uint256 indexed transactionId);\n    event ConfirmationRevoked(address indexed sender, uint256 indexed transactionId);\n    event ValidationRequested(\n        uint256 indexed transactionId,\n        bytes32 outputRoot,\n        uint256 l2BlockNumber\n    );\n    event DeletionRequested(uint256 indexed transactionId, uint256 indexed outputIndex);\n\n    uint256 blockNumber = 0;\n    address private txTarget;\n    uint256 private txValue;\n    bytes private txData;\n\n    function setUp() public virtual override {\n        super.setUp();\n        // dummy transaction data\n        txTarget = makeAddr(\"target\");\n        txValue = 0;\n        txData = bytes(\"anydata\");\n\n        _roll(1);\n        // minting to guardians\n        vm.prank(owner);\n        securityCouncilToken.safeMint(guardian1, baseUri);\n        vm.prank(owner);\n        securityCouncilToken.safeMint(guardian2, baseUri);\n        vm.prank(owner);\n        securityCouncilToken.safeMint(guardian3, baseUri);\n\n        assertEq(securityCouncilToken.balanceOf(guardian1), 1);\n        assertEq(securityCouncilToken.balanceOf(guardian2), 1);\n        assertEq(securityCouncilToken.balanceOf(guardian3), 1);\n        assertEq(securityCouncilToken.getVotes(guardian1), 1);\n        assertEq(securityCouncilToken.getVotes(guardian2), 1);\n        assertEq(securityCouncilToken.getVotes(guardian3), 1);\n        assertEq(securityCouncilToken.owner(), owner);\n\n        _roll(1);\n    }\n\n    function test_initialize_succeeds() external {\n        assertEq(address(securityCouncil.COLOSSEUM()), colosseum);\n        assertEq(address(securityCouncil.GOVERNOR()), address(upgradeGovernor));\n    }\n\n    function test_submitTransaction_onlyTokenOwner_reverts() external {\n        vm.prank(makeAddr(\"not governance\"));\n        vm.expectRevert(\"TokenMultiSigWallet: only allowed to governance token owner\");\n        securityCouncil.submitTransaction(txTarget, txValue, txData);\n    }\n\n    function test_submitTransaction_targetInvalid_reverts() external {\n        vm.startPrank(guardian1);\n        vm.expectRevert(\"TokenMultiSigWallet: address is not valid\");\n        securityCouncil.submitTransaction(address(0), txValue, txData);\n        vm.stopPrank();\n    }\n\n    function test_submitTransaction_transactionExists_reverts() external {\n        vm.startPrank(guardian1);\n        securityCouncil.submitTransaction(txTarget, txValue, txData);\n        vm.expectRevert(\"TokenMultiSigWallet: transaction already exists\");\n        securityCouncil.submitTransaction(txTarget, txValue, txData);\n        vm.stopPrank();\n    }\n\n    function test_submitTransaction_succeeds() external {\n        vm.startPrank(guardian1);\n        vm.expectEmit(true, true, false, true);\n        uint256 transactionId = securityCouncil.generateTransactionId(txTarget, txValue, txData);\n        emit TransactionSubmitted(guardian1, transactionId);\n        uint256 resTransactionId = securityCouncil.submitTransaction(txTarget, txValue, txData);\n        assertEq(transactionId, resTransactionId);\n        (,bool executed,,) = securityCouncil.transactions(transactionId);\n        assertEq(executed, false);\n        vm.stopPrank();\n    }\n\n    function test_confirmTransaction_onlyTokenOwner_reverts() external {\n        vm.prank(guardian1);\n        uint256 transactionId = securityCouncil.submitTransaction(txTarget, txValue, txData);\n\n        vm.startPrank(makeAddr(\"not governance\"));\n        vm.expectRevert(\"TokenMultiSigWallet: only allowed to governance token owner\");\n        securityCouncil.confirmTransaction(transactionId);\n        vm.stopPrank();\n    }\n\n    function test_confirmTransaction_nonExistent_reverts() external {\n        vm.startPrank(guardian1);\n        vm.expectRevert(\"TokenMultiSigWallet: transaction does not exist\");\n        securityCouncil.confirmTransaction(0);\n        vm.stopPrank();\n    }\n\n    function test_confirmTransaction_alreadyConfirmed_reverts() external {\n        vm.startPrank(guardian1);\n        uint256 transactionId = securityCouncil.submitTransaction(txTarget, txValue, txData);\n        securityCouncil.confirmTransaction(transactionId);\n        vm.expectRevert(\"TokenMultiSigWallet: already confirmed\");\n        securityCouncil.confirmTransaction(transactionId);\n        vm.stopPrank();\n    }\n\n    function test_confirmTransaction_succeeds() external {\n        vm.startPrank(guardian1);\n        uint256 transactionId = securityCouncil.submitTransaction(txTarget, txValue, txData);\n        vm.expectEmit(true, true, false, true);\n        emit TransactionConfirmed(guardian1, transactionId);\n        uint256 confirmCountOld = securityCouncil.getConfirmationCount(transactionId);\n        securityCouncil.confirmTransaction(transactionId);\n        uint256 confirmCountNew = securityCouncil.getConfirmationCount(transactionId);\n        assertEq(confirmCountOld + securityCouncil.getVotes(guardian1), confirmCountNew);\n        bool confirmed = securityCouncil.isConfirmedBy(transactionId, guardian1);\n        assertTrue(confirmed);\n        vm.stopPrank();\n    }\n\n    function test_executeTransaction_succeeds() external {\n        vm.startPrank(guardian1);\n        uint256 transactionId = securityCouncil.submitTransaction(txTarget, txValue, txData);\n        securityCouncil.confirmTransaction(transactionId);\n        vm.stopPrank();\n\n        vm.startPrank(guardian2);\n        vm.expectEmit(true, true, false, true);\n        emit TransactionConfirmed(guardian2, transactionId);\n        vm.expectEmit(true, true, false, true);\n        emit TransactionExecuted(guardian2, transactionId);\n        securityCouncil.confirmTransaction(transactionId);\n        vm.stopPrank();\n    }\n\n    function test_requestValidation_reverts() external {\n        vm.prank(makeAddr(\"not colosseum\"));\n        vm.expectRevert(\"SecurityCouncil: only the colosseum contract can be a sender\");\n        securityCouncil.requestValidation(bytes32(\"dummy output root\"), txValue, txData);\n    }\n\n    function test_requestValidation_succeeds() external {\n        vm.startPrank(colosseum);\n        // request output validation\n        uint128 l2BlockNumber = 3;\n        vm.expectEmit(true, false, false, true);\n        uint256 transactionId = securityCouncil.generateTransactionId(colosseum, txValue, txData);\n        emit ValidationRequested(transactionId, bytes32(\"dummy output root\"), l2BlockNumber);\n        securityCouncil.requestValidation(bytes32(\"dummy output root\"), l2BlockNumber, txData);\n        vm.stopPrank();\n    }\n\n    function test_requestValidation_execute_succeeds() external {\n        vm.startPrank(colosseum);\n        // request output validation\n        uint256 l2BlockNumber = 3;\n        vm.expectEmit(true, false, false, true);\n        uint256 transactionId = securityCouncil.generateTransactionId(colosseum, txValue, txData);\n        emit ValidationRequested(transactionId, bytes32(\"dummy output root\"), l2BlockNumber);\n        securityCouncil.requestValidation(bytes32(\"dummy output root\"), l2BlockNumber, txData);\n\n        // check transaction not executed\n        Types.MultiSigTransaction memory t;\n        (t.target, t.executed, t.value, t.data) = securityCouncil.transactions(transactionId);\n        assertEq(t.executed, false);\n        vm.stopPrank();\n\n        // confirm transaction to execute\n        vm.prank(guardian1);\n        securityCouncil.confirmTransaction(transactionId);\n        vm.prank(guardian2);\n        securityCouncil.confirmTransaction(transactionId);\n\n        // check transaction confirmed\n        assertTrue(securityCouncil.isConfirmedBy(transactionId, guardian1));\n        assertTrue(securityCouncil.isConfirmedBy(transactionId, guardian2));\n\n        // check transaction executed\n        (t.target, t.executed, t.value, t.data) = securityCouncil.transactions(transactionId);\n        assertEq(t.executed, true);\n    }\n\n    function test_requestDeletion_succeeds() external {\n        vm.startPrank(guardian1);\n        // request output deletion\n        uint256 outputIndex = 1;\n        vm.expectEmit(true, true, false, true);\n        bytes memory message = abi.encodeWithSelector(\n            Colosseum.forceDeleteOutput.selector,\n            outputIndex\n        );\n        uint256 transactionId = securityCouncil.generateTransactionId(securityCouncil.COLOSSEUM(), 0, message);\n        emit DeletionRequested(transactionId, outputIndex);\n        securityCouncil.requestDeletion(outputIndex, false);\n\n        // check transaction not executed\n        Types.MultiSigTransaction memory t;\n        (t.target, t.executed, t.value, t.data) = securityCouncil.transactions(transactionId);\n        assertEq(t.executed, false);\n        vm.stopPrank();\n\n        // confirm transaction to execute\n        vm.prank(guardian2);\n        securityCouncil.confirmTransaction(transactionId);\n\n        // check transaction confirmed\n        assertTrue(securityCouncil.isConfirmedBy(transactionId, guardian1));\n        assertTrue(securityCouncil.isConfirmedBy(transactionId, guardian2));\n\n        // check transaction executed\n        (t.target, t.executed, t.value, t.data) = securityCouncil.transactions(transactionId);\n        assertEq(t.executed, true);\n    }\n\n    function test_requestDeletion_alreadyRequested_reverts() external {\n        vm.startPrank(guardian1);\n        // request output deletion\n        uint256 outputIndex = 1;\n        vm.expectEmit(true, true, false, true);\n        bytes memory message = abi.encodeWithSelector(\n            Colosseum.forceDeleteOutput.selector,\n            outputIndex\n        );\n        uint256 transactionId = securityCouncil.generateTransactionId(securityCouncil.COLOSSEUM(), 0, message);\n        emit DeletionRequested(transactionId, outputIndex);\n        securityCouncil.requestDeletion(outputIndex, false);\n\n        // try to request the same output index\n        vm.expectRevert(\"SecurityCouncil: the output has already been requested to be deleted\");\n        securityCouncil.requestDeletion(outputIndex, false);\n        vm.stopPrank();\n    }\n\n    function test_requestDeletion_force_succeeds() external {\n        vm.startPrank(guardian1);\n        // request output deletion\n        uint256 outputIndex = 1;\n        vm.expectEmit(true, true, false, true);\n        bytes memory message = abi.encodeWithSelector(\n            Colosseum.forceDeleteOutput.selector,\n            outputIndex\n        );\n        uint256 transactionId = securityCouncil.generateTransactionId(securityCouncil.COLOSSEUM(), 0, message);\n        emit DeletionRequested(transactionId, outputIndex);\n        securityCouncil.requestDeletion(outputIndex, false);\n\n        _roll(1);\n\n        // try to request the same output index\n        vm.expectEmit(true, true, false, true);\n        transactionId = securityCouncil.generateTransactionId(securityCouncil.COLOSSEUM(), 0, message);\n        emit DeletionRequested(transactionId, outputIndex);\n        securityCouncil.requestDeletion(outputIndex, true);\n        vm.stopPrank();\n    }\n\n    function _roll(uint256 addBlockNumber) private {\n        blockNumber += addBlockNumber;\n        vm.roll(blockNumber);\n    }\n}\n"
    },
    "contracts/test/StandardBridge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { KromaMintableERC20 } from \"../universal/KromaMintableERC20.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\n/**\n * @title StandardBridgeTester\n * @notice Simple wrapper around the StandardBridge contract that exposes\n *         internal functions so they can be more easily tested directly.\n */\ncontract StandardBridgeTester is StandardBridge {\n    constructor(address payable _messenger, address payable _otherBridge)\n        StandardBridge(_messenger, _otherBridge)\n    {}\n\n    function isKromaMintableERC20(address _token) external view returns (bool) {\n        return _isKromaMintableERC20(_token);\n    }\n\n    function isCorrectTokenPair(address _mintableToken, address _otherToken)\n        external\n        view\n        returns (bool)\n    {\n        return _isCorrectTokenPair(_mintableToken, _otherToken);\n    }\n\n    receive() external payable override {}\n}\n\n/**\n * @title StandardBridge_Stateless_Test\n * @notice Tests internal functions that require no existing state or contract\n *         interactions with the messenger.\n */\ncontract StandardBridge_Stateless_Test is CommonTest {\n    StandardBridgeTester internal bridge;\n    KromaMintableERC20 internal mintable;\n    ERC20 internal erc20;\n\n    function setUp() public override {\n        super.setUp();\n\n        bridge = new StandardBridgeTester({\n            _messenger: payable(address(0)),\n            _otherBridge: payable(address(0))\n        });\n\n        mintable = new KromaMintableERC20({\n            _bridge: address(0),\n            _remoteToken: address(0),\n            _name: \"Stonks\",\n            _symbol: \"STONK\"\n        });\n\n        erc20 = new ERC20(\"Altcoin\", \"ALT\");\n    }\n\n    /**\n     * @notice Test coverage for identifying KromaMintableERC20 tokens.\n     *         This function should return true for\n     *         KromaMintableERC20 tokens and false for any accounts that\n     *         do not implement the interface.\n     */\n    function test_isKromaMintableERC20_succeeds() external {\n        // Both the modern and legacy mintable tokens should return true\n        assertTrue(bridge.isKromaMintableERC20(address(mintable)));\n        // A regular ERC20 should return false\n        assertFalse(bridge.isKromaMintableERC20(address(erc20)));\n        // Non existent contracts should return false and not revert\n        assertEq(address(0x20).code.length, 0);\n        assertFalse(bridge.isKromaMintableERC20(address(0x20)));\n    }\n\n    /**\n     * @notice Test coverage of isCorrectTokenPair under different types of\n     *         tokens.\n     */\n    function test_isCorrectTokenPair_succeeds() external {\n        // Modern + known to be correct remote token\n        assertTrue(bridge.isCorrectTokenPair(address(mintable), mintable.REMOTE_TOKEN()));\n        // Modern + known to be incorrect remote token\n        assertTrue(mintable.REMOTE_TOKEN() != address(0x20));\n        assertFalse(bridge.isCorrectTokenPair(address(mintable), address(0x20)));\n    }\n}\n"
    },
    "contracts/test/SystemConfig.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { SystemConfig } from \"../L1/SystemConfig.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract SystemConfig_Init is CommonTest {\n    SystemConfig sysConf;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({\n            maxResourceLimit: 20_000_000,\n            elasticityMultiplier: 10,\n            baseFeeMaxChangeDenominator: 8,\n            minimumBaseFee: 1 gwei,\n            systemTxMaxGas: 1_000_000,\n            maximumBaseFee: type(uint128).max\n        });\n\n        sysConf = new SystemConfig({\n            _owner: alice,\n            _overhead: 2100,\n            _scalar: 1000000,\n            _batcherHash: bytes32(hex\"abcd\"),\n            _gasLimit: 30_000_000,\n            _unsafeBlockSigner: address(1),\n            _config: config,\n            _validatorRewardScalar: 5000\n        });\n    }\n}\n\ncontract SystemConfig_Initialize_TestFail is SystemConfig_Init {\n    function test_initialize_lowGasLimit_reverts() external {\n        uint64 minimumGasLimit = sysConf.minimumGasLimit();\n\n        ResourceMetering.ResourceConfig memory cfg = ResourceMetering.ResourceConfig({\n            maxResourceLimit: 20_000_000,\n            elasticityMultiplier: 10,\n            baseFeeMaxChangeDenominator: 8,\n            minimumBaseFee: 1 gwei,\n            systemTxMaxGas: 1_000_000,\n            maximumBaseFee: type(uint128).max\n        });\n\n        vm.expectRevert(\"SystemConfig: gas limit too low\");\n\n        new SystemConfig({\n            _owner: alice,\n            _overhead: 0,\n            _scalar: 0,\n            _batcherHash: bytes32(hex\"\"),\n            _gasLimit: minimumGasLimit - 1,\n            _unsafeBlockSigner: address(1),\n            _config: cfg,\n            _validatorRewardScalar: 5000\n        });\n    }\n}\n\ncontract SystemConfig_Setters_TestFail is SystemConfig_Init {\n    function test_setBatcherHash_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sysConf.setBatcherHash(bytes32(hex\"\"));\n    }\n\n    function test_setGasConfig_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sysConf.setGasConfig(0, 0);\n    }\n\n    function test_setGasLimit_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sysConf.setGasLimit(0);\n    }\n\n    function test_setUnsafeBlockSigner_notOwner_reverts() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sysConf.setUnsafeBlockSigner(address(0x20));\n    }\n\n    function test_setResourceConfig_notOwner_reverts() external {\n        ResourceMetering.ResourceConfig memory config = Constants.DEFAULT_RESOURCE_CONFIG();\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sysConf.setResourceConfig(config);\n    }\n\n    function test_setResourceConfig_badMinMax_reverts() external {\n        ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({\n            maxResourceLimit: 20_000_000,\n            elasticityMultiplier: 10,\n            baseFeeMaxChangeDenominator: 8,\n            systemTxMaxGas: 1_000_000,\n            minimumBaseFee: 2 gwei,\n            maximumBaseFee: 1 gwei\n        });\n        vm.prank(sysConf.owner());\n        vm.expectRevert(\"SystemConfig: min base fee must be less than max base\");\n        sysConf.setResourceConfig(config);\n    }\n\n    function test_setResourceConfig_zeroDenominator_reverts() external {\n        ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({\n            maxResourceLimit: 20_000_000,\n            elasticityMultiplier: 10,\n            baseFeeMaxChangeDenominator: 0,\n            systemTxMaxGas: 1_000_000,\n            minimumBaseFee: 1 gwei,\n            maximumBaseFee: 2 gwei\n        });\n        vm.prank(sysConf.owner());\n        vm.expectRevert(\"SystemConfig: denominator must be larger than 1\");\n        sysConf.setResourceConfig(config);\n    }\n\n    function test_setResourceConfig_lowGasLimit_reverts() external {\n        uint64 gasLimit = sysConf.gasLimit();\n\n        ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({\n            maxResourceLimit: uint32(gasLimit),\n            elasticityMultiplier: 10,\n            baseFeeMaxChangeDenominator: 8,\n            systemTxMaxGas: uint32(gasLimit),\n            minimumBaseFee: 1 gwei,\n            maximumBaseFee: 2 gwei\n        });\n        vm.prank(sysConf.owner());\n        vm.expectRevert(\"SystemConfig: gas limit too low\");\n        sysConf.setResourceConfig(config);\n    }\n\n    function test_setResourceConfig_badPrecision_reverts() external {\n        ResourceMetering.ResourceConfig memory config = ResourceMetering.ResourceConfig({\n            maxResourceLimit: 20_000_000,\n            elasticityMultiplier: 11,\n            baseFeeMaxChangeDenominator: 8,\n            systemTxMaxGas: 1_000_000,\n            minimumBaseFee: 1 gwei,\n            maximumBaseFee: 2 gwei\n        });\n        vm.prank(sysConf.owner());\n        vm.expectRevert(\"SystemConfig: precision loss with target resource limit\");\n        sysConf.setResourceConfig(config);\n    }\n\n    function test_setValidatorRewardScalar_outOfRange_reverts() external {\n        vm.prank(sysConf.owner());\n        vm.expectRevert(\"SystemConfig: the max value of validator reward scalar has been exceeded\");\n        sysConf.setValidatorRewardScalar(type(uint32).max);\n    }\n}\n\ncontract SystemConfig_Setters_Test is SystemConfig_Init {\n    event ConfigUpdate(\n        uint256 indexed version,\n        SystemConfig.UpdateType indexed updateType,\n        bytes data\n    );\n\n    function testFuzz_setBatcherHash_succeeds(bytes32 newBatcherHash) external {\n        vm.expectEmit(true, true, true, true);\n        emit ConfigUpdate(0, SystemConfig.UpdateType.BATCHER, abi.encode(newBatcherHash));\n\n        vm.prank(sysConf.owner());\n        sysConf.setBatcherHash(newBatcherHash);\n        assertEq(sysConf.batcherHash(), newBatcherHash);\n    }\n\n    function testFuzz_setGasConfig_succeeds(uint256 newOverhead, uint256 newScalar) external {\n        vm.expectEmit(true, true, true, true);\n        emit ConfigUpdate(\n            0,\n            SystemConfig.UpdateType.GAS_CONFIG,\n            abi.encode(newOverhead, newScalar)\n        );\n\n        vm.prank(sysConf.owner());\n        sysConf.setGasConfig(newOverhead, newScalar);\n        assertEq(sysConf.overhead(), newOverhead);\n        assertEq(sysConf.scalar(), newScalar);\n    }\n\n    function testFuzz_setGasLimit_succeeds(uint64 newGasLimit) external {\n        uint64 minimumGasLimit = sysConf.minimumGasLimit();\n        newGasLimit = uint64(\n            bound(uint256(newGasLimit), uint256(minimumGasLimit), uint256(type(uint64).max))\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit ConfigUpdate(0, SystemConfig.UpdateType.GAS_LIMIT, abi.encode(newGasLimit));\n\n        vm.prank(sysConf.owner());\n        sysConf.setGasLimit(newGasLimit);\n        assertEq(sysConf.gasLimit(), newGasLimit);\n    }\n\n    function testFuzz_setUnsafeBlockSigner_succeeds(address newUnsafeSigner) external {\n        vm.expectEmit(true, true, true, true);\n        emit ConfigUpdate(\n            0,\n            SystemConfig.UpdateType.UNSAFE_BLOCK_SIGNER,\n            abi.encode(newUnsafeSigner)\n        );\n\n        vm.prank(sysConf.owner());\n        sysConf.setUnsafeBlockSigner(newUnsafeSigner);\n        assertEq(sysConf.unsafeBlockSigner(), newUnsafeSigner);\n    }\n\n    function testFuzz_setValidatorRewardScalar_succeeds(uint256 validatorRewardScalar) external {\n        validatorRewardScalar = bound(\n            validatorRewardScalar,\n            0,\n            Constants.VALIDATOR_REWARD_DENOMINATOR\n        );\n        vm.expectEmit(true, true, true, true);\n        emit ConfigUpdate(\n            0,\n            SystemConfig.UpdateType.VALIDATOR_REWARD_SCALAR,\n            abi.encode(validatorRewardScalar)\n        );\n\n        vm.prank(sysConf.owner());\n        sysConf.setValidatorRewardScalar(validatorRewardScalar);\n        assertEq(sysConf.validatorRewardScalar(), validatorRewardScalar);\n    }\n}\n"
    },
    "contracts/test/UpgradeGovernor.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UpgradeGovernor_Initializer } from \"./CommonTest.t.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\n\ncontract UpgradeGovernorTest is UpgradeGovernor_Initializer {\n    uint256 blockNumber = 0;\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    function setUp() public virtual override {\n        super.setUp();\n        _roll(1);\n        // minting to guardians\n        vm.prank(owner);\n        securityCouncilToken.safeMint(guardian1, baseUri);\n        vm.prank(owner);\n        securityCouncilToken.safeMint(guardian2, baseUri);\n\n        vm.prank(guardian1);\n        securityCouncilToken.delegate(guardian1);\n        vm.prank(guardian2);\n        securityCouncilToken.delegate(guardian2);\n\n        assertEq(securityCouncilToken.balanceOf(guardian1), 1);\n        assertEq(securityCouncilToken.balanceOf(guardian2), 1);\n        assertEq(securityCouncilToken.getVotes(guardian1), 1);\n        assertEq(securityCouncilToken.getVotes(guardian2), 1);\n        assertEq(securityCouncilToken.owner(), owner);\n\n        _roll(1);\n    }\n\n    function test_initialize_succeeds() external {\n        // check securityCouncilToken\n        assertEq(securityCouncilToken.symbol(), \"KSC\");\n\n        // check timeLock\n        bytes32 PROPOSER_ROLE = timeLock.PROPOSER_ROLE();\n        bytes32 EXECUTOR_ROLE = timeLock.EXECUTOR_ROLE();\n        bytes32 ADMIN_ROLE = timeLock.TIMELOCK_ADMIN_ROLE();\n        assertTrue(timeLock.hasRole(PROPOSER_ROLE, address(upgradeGovernor)));\n        assertTrue(timeLock.hasRole(EXECUTOR_ROLE, address(upgradeGovernor)));\n        assertTrue(timeLock.hasRole(ADMIN_ROLE, address(upgradeGovernor)));\n\n        // check upgradeGovernor\n        assertEq(address(upgradeGovernor.token()), address(securityCouncilToken));\n        assertEq(upgradeGovernor.timelock(), address(timeLock));\n        assertEq(upgradeGovernor.votingDelay(), initialVotingDelay);\n        assertEq(upgradeGovernor.votingPeriod(), initialVotingPeriod);\n        assertEq(upgradeGovernor.proposalThreshold(), initialProposalThreshold);\n\n        // check proxy admin\n        vm.startPrank(address(timeLock));\n        assertEq(Proxy(payable(address(upgradeGovernor))).admin(), address(timeLock));\n        assertEq(Proxy(payable(address(securityCouncilToken))).admin(), address(timeLock));\n        assertEq(Proxy(payable(address(timeLock))).admin(), address(timeLock));\n        vm.stopPrank();\n    }\n\n    function _createProposal() private returns (uint256) {\n        address[] memory targetContracts = new address[](1);\n        targetContracts[0] = address(upgradeGovernor);\n        uint256[] memory values = new uint256[](1);\n        values[0] = 0;\n        bytes[] memory callDatas = new bytes[](1);\n        callDatas[0] = abi.encodeCall(upgradeGovernor.setVotingDelay, 10);\n        vm.prank(guardian1);\n        uint256 proposalId = upgradeGovernor.propose(\n            targetContracts,\n            values,\n            callDatas,\n            \"test proposal\"\n        );\n        _roll(1);\n        return proposalId;\n    }\n\n    function _queue() private returns (uint256) {\n        address[] memory targetContracts = new address[](1);\n        targetContracts[0] = address(upgradeGovernor);\n        uint256[] memory values = new uint256[](1);\n        values[0] = 0;\n        bytes[] memory callDatas = new bytes[](1);\n        callDatas[0] = abi.encodeCall(upgradeGovernor.setVotingDelay, 10);\n        vm.prank(guardian1);\n        uint256 queuedId = upgradeGovernor.queue(\n            targetContracts,\n            values,\n            callDatas,\n            _hashDescription(\"test proposal\")\n        );\n        return queuedId;\n    }\n\n    function _execute() private returns (uint256) {\n        address[] memory targetContracts = new address[](1);\n        targetContracts[0] = address(upgradeGovernor);\n        uint256[] memory values = new uint256[](1);\n        values[0] = 0;\n        bytes[] memory callDatas = new bytes[](1);\n        callDatas[0] = abi.encodeCall(upgradeGovernor.setVotingDelay, 10);\n        vm.prank(guardian1);\n        uint256 executedId = upgradeGovernor.execute(\n            targetContracts,\n            values,\n            callDatas,\n            _hashDescription(\"test proposal\")\n        );\n        return executedId;\n    }\n\n    function _hashDescription(string memory desc) private pure returns (bytes32) {\n        return keccak256(bytes(desc));\n    }\n\n    function _roll(uint256 addBlockNumber) private {\n        blockNumber += addBlockNumber;\n        vm.roll(blockNumber);\n    }\n\n    function test_createProposal_tokenThreshold_reverts() external {\n        address[] memory targetContracts = new address[](1);\n        targetContracts[0] = address(upgradeGovernor);\n        uint256[] memory values = new uint256[](1);\n        values[0] = 0;\n        bytes[] memory callDatas = new bytes[](1);\n        callDatas[0] = abi.encodeCall(upgradeGovernor.setVotingDelay, 10);\n        vm.expectRevert(\"Governor: proposer votes below proposal threshold\");\n        vm.prank(notGuardian);\n        upgradeGovernor.propose(targetContracts, values, callDatas, \"test proposal\");\n    }\n\n    function test_createProposal_succeeds() external {\n        address[] memory targetContracts = new address[](1);\n        targetContracts[0] = address(upgradeGovernor);\n        uint256[] memory values = new uint256[](1);\n        values[0] = 0;\n        bytes[] memory callDatas = new bytes[](1);\n        callDatas[0] = abi.encodeCall(upgradeGovernor.setVotingDelay, 10);\n        vm.prank(guardian1);\n        uint256 proposalId = upgradeGovernor.propose(\n            targetContracts,\n            values,\n            callDatas,\n            \"test proposal\"\n        );\n        uint8 state = uint8(upgradeGovernor.state(proposalId));\n        assertEq(state, uint8(ProposalState.Pending));\n    }\n\n    function test_voteProposal_overPeriod_reverts() external {\n        uint256 proposalId = _createProposal();\n        _roll(initialVotingPeriod);\n        vm.prank(guardian1);\n        vm.expectRevert(\"Governor: vote not currently active\");\n        upgradeGovernor.castVote(proposalId, 1);\n        uint8 state = uint8(upgradeGovernor.state(proposalId));\n        assertEq(state, uint8(ProposalState.Defeated));\n    }\n\n    function test_voteProposal_succeeds() external {\n        uint256 proposalId = _createProposal();\n        vm.prank(guardian1);\n        uint256 voted = upgradeGovernor.castVote(proposalId, 1);\n        assertEq(voted, securityCouncilToken.balanceOf(guardian1));\n\n        uint8 state = uint8(upgradeGovernor.state(proposalId));\n        assertEq(state, uint8(ProposalState.Active));\n\n        _roll(initialVotingPeriod);\n        state = uint8(upgradeGovernor.state(proposalId));\n        assertEq(state, uint8(ProposalState.Succeeded));\n    }\n\n    function test_queueProposal_succeeds() external {\n        uint256 proposalId = _createProposal();\n\n        // vote\n        vm.prank(guardian1);\n        upgradeGovernor.castVote(proposalId, 1);\n        _roll(initialVotingPeriod);\n\n        uint256 queuedId = _queue();\n        assertEq(proposalId, queuedId);\n\n        uint8 state = uint8(upgradeGovernor.state(proposalId));\n        assertEq(state, uint8(ProposalState.Queued));\n    }\n\n    function test_executeProposal_succeeds() external {\n        uint256 proposalId = _createProposal();\n\n        // vote\n        vm.prank(guardian1);\n        upgradeGovernor.castVote(proposalId, 1);\n        _roll(initialVotingPeriod);\n\n        _queue();\n        vm.warp(minDelaySeconds + 1);\n        uint256 executedId = _execute();\n        assertEq(proposalId, executedId);\n\n        uint8 state = uint8(upgradeGovernor.state(proposalId));\n        assertEq(state, uint8(ProposalState.Executed));\n\n        uint256 votingDelay = upgradeGovernor.votingDelay();\n        assertEq(votingDelay, 10);\n    }\n}\n"
    },
    "contracts/test/ValidatorManager.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { IAssetManager } from \"../L1/interfaces/IAssetManager.sol\";\nimport { IValidatorManager } from \"../L1/interfaces/IValidatorManager.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { ValidatorManager } from \"../L1/ValidatorManager.sol\";\nimport { ValidatorPool } from \"../L1/ValidatorPool.sol\";\nimport { ValidatorSystemUpgrade_Initializer } from \"./CommonTest.t.sol\";\n\ncontract MockL2OutputOracle is L2OutputOracle {\n    constructor(\n        ValidatorPool _validatorPool,\n        ValidatorManager _validatorManager,\n        address _colosseum,\n        uint256 _submissionInterval,\n        uint256 _l2BlockTime,\n        uint256 _startingBlockNumber,\n        uint256 _startingTimestamp,\n        uint256 _finalizationPeriodSeconds\n    )\n        L2OutputOracle(\n            _validatorPool,\n            _validatorManager,\n            _colosseum,\n            _submissionInterval,\n            _l2BlockTime,\n            _startingBlockNumber,\n            _startingTimestamp,\n            _finalizationPeriodSeconds\n        )\n    {}\n\n    function addOutput(uint256 l2BlockNumber) external {\n        l2Outputs.push(\n            Types.CheckpointOutput({\n                submitter: msg.sender,\n                outputRoot: keccak256(abi.encode(l2BlockNumber)),\n                timestamp: uint128(block.timestamp),\n                l2BlockNumber: uint128(l2BlockNumber)\n            })\n        );\n    }\n\n    function replaceOutput(address validator, uint256 outputIndex) external {\n        l2Outputs[outputIndex].submitter = validator;\n        l2Outputs[outputIndex].outputRoot = bytes32(0);\n    }\n\n    function mockSetNextFinalizeOutputIndex(uint256 l2OutputIndex) external {\n        nextFinalizeOutputIndex = l2OutputIndex;\n    }\n}\n\ncontract MockValidatorManager is ValidatorManager {\n    constructor(ConstructorParams memory _constructorParams) ValidatorManager(_constructorParams) {}\n\n    function updatePriorityValidator(address validator) external {\n        _nextPriorityValidator = validator;\n    }\n\n    function setJailExpiresAt(address validator, uint128 expiresAt) external {\n        _jail[validator] = expiresAt;\n    }\n\n    function nextPriorityValidator() external view returns (address) {\n        return _nextPriorityValidator;\n    }\n\n    function getBoostedReward(address validator) external view returns (uint128) {\n        return _getBoostedReward(validator);\n    }\n}\n\ncontract ValidatorManagerTest is ValidatorSystemUpgrade_Initializer {\n    MockL2OutputOracle mockOracle;\n    MockValidatorManager mockValMgr;\n\n    event ValidatorRegistered(\n        address indexed validator,\n        bool activated,\n        uint8 commissionRate,\n        uint128 assets\n    );\n\n    event ValidatorActivated(address indexed validator, uint256 activatedAt);\n\n    event ValidatorStopped(address indexed validator, uint256 stopsAt);\n\n    event ValidatorCommissionChangeInitiated(\n        address indexed validator,\n        uint8 oldCommissionRate,\n        uint8 newCommissionRate\n    );\n\n    event ValidatorCommissionChangeFinalized(\n        address indexed validator,\n        uint8 oldCommissionRate,\n        uint8 newCommissionRate\n    );\n\n    event ValidatorJailed(address indexed validator, uint128 expiresAt);\n\n    event ValidatorUnjailed(address indexed validator);\n\n    event RewardDistributed(\n        uint256 indexed outputIndex,\n        address indexed validator,\n        uint128 validatorReward,\n        uint128 baseReward,\n        uint128 boostedReward\n    );\n\n    event Slashed(uint256 indexed outputIndex, address indexed loser, uint128 amount);\n\n    event SlashReverted(uint256 indexed outputIndex, address indexed loser, uint128 amount);\n\n    function _setUpKghDelegation(\n        address validator,\n        uint256 startingTokenId,\n        uint128 kghCounts\n    ) private {\n        uint256[] memory tokenIds = new uint256[](kghCounts);\n        for (uint256 i = startingTokenId; i < startingTokenId + kghCounts; i++) {\n            kgh.mint(validator, i);\n            vm.prank(validator);\n            kgh.approve(address(assetMgr), i);\n            tokenIds[i - startingTokenId] = i;\n        }\n        vm.prank(validator);\n        assetMgr.delegateKghBatch(validator, tokenIds);\n    }\n\n    function _withdraw(address validator, uint128 amount) private {\n        vm.warp(assetMgr.canWithdrawAt(validator) + 1);\n        vm.prank(withdrawAcc);\n        assetMgr.withdraw(validator, amount);\n    }\n\n    function setUp() public override {\n        super.setUp();\n\n        address oracleAddress = address(oracle);\n        MockL2OutputOracle mockOracleImpl = new MockL2OutputOracle(\n            pool,\n            valMgr,\n            address(colosseum),\n            submissionInterval,\n            l2BlockTime,\n            startingBlockNumber,\n            startingTimestamp,\n            finalizationPeriodSeconds\n        );\n        vm.prank(multisig);\n        Proxy(payable(oracleAddress)).upgradeTo(address(mockOracleImpl));\n        mockOracle = MockL2OutputOracle(oracleAddress);\n\n        address valMgrAddress = address(valMgr);\n        MockValidatorManager mockValMgrImpl = new MockValidatorManager(constructorParams);\n        vm.prank(multisig);\n        Proxy(payable(valMgrAddress)).upgradeTo(address(mockValMgrImpl));\n        mockValMgr = MockValidatorManager(valMgrAddress);\n\n        // Submit until terminateOutputIndex and set next output index to be finalized after it\n        vm.prank(trusted);\n        pool.deposit{ value: trusted.balance }();\n        for (uint256 i = oracle.nextOutputIndex(); i <= terminateOutputIndex; i++) {\n            _submitL2OutputV1();\n        }\n        vm.warp(oracle.finalizedAt(terminateOutputIndex));\n        mockOracle.mockSetNextFinalizeOutputIndex(terminateOutputIndex + 1);\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(address(valMgr.L2_ORACLE()), address(oracle));\n        assertEq(address(valMgr.ASSET_MANAGER()), address(assetMgr));\n        assertEq(valMgr.TRUSTED_VALIDATOR(), trusted);\n        assertEq(valMgr.MIN_REGISTER_AMOUNT(), minRegisterAmount);\n        assertEq(valMgr.MIN_ACTIVATE_AMOUNT(), minActivateAmount);\n        assertEq(valMgr.COMMISSION_CHANGE_DELAY_SECONDS(), commissionChangeDelaySeconds);\n        assertEq(valMgr.ROUND_DURATION_SECONDS(), roundDuration);\n        assertEq(valMgr.SOFT_JAIL_PERIOD_SECONDS(), softJailPeriodSeconds);\n        assertEq(valMgr.HARD_JAIL_PERIOD_SECONDS(), hardJailPeriodSeconds);\n        assertEq(valMgr.JAIL_THRESHOLD(), jailThreshold);\n        assertEq(valMgr.MAX_OUTPUT_FINALIZATIONS(), maxOutputFinalizations);\n        assertEq(valMgr.BASE_REWARD(), baseReward);\n    }\n\n    function test_constructor_smallMinActivateAmount_reverts() external {\n        constructorParams._minRegisterAmount = minActivateAmount + 1;\n        vm.expectRevert(IValidatorManager.InvalidConstructorParams.selector);\n        new MockValidatorManager(constructorParams);\n    }\n\n    function test_registerValidator_active_succeeds() external {\n        uint256 trustedBalance = assetToken.balanceOf(trusted);\n        uint32 count = valMgr.activatedValidatorCount();\n\n        uint128 assets = minActivateAmount;\n        uint8 commissionRate = 10;\n\n        vm.startPrank(trusted, trusted);\n        assetToken.approve(address(assetMgr), uint256(assets));\n        vm.expectEmit(true, false, false, true, address(valMgr));\n        emit ValidatorActivated(trusted, block.timestamp);\n        vm.expectEmit(true, true, false, true, address(valMgr));\n        emit ValidatorRegistered(trusted, true, commissionRate, assets);\n        valMgr.registerValidator(assets, commissionRate, withdrawAcc);\n        vm.stopPrank();\n\n        assertEq(assetToken.balanceOf(trusted), trustedBalance - assets);\n        assertEq(assetMgr.totalValidatorKro(trusted), assets);\n        assertEq(valMgr.getCommissionRate(trusted), commissionRate);\n        assertEq(assetMgr.getWithdrawAccount(trusted), withdrawAcc);\n\n        assertTrue(valMgr.getStatus(trusted) == IValidatorManager.ValidatorStatus.ACTIVE);\n        assertEq(valMgr.activatedValidatorCount(), count + 1);\n        assertEq(valMgr.getWeight(trusted), assets);\n    }\n\n    function test_registerValidator_registered_succeeds() external {\n        uint32 count = valMgr.activatedValidatorCount();\n\n        uint128 assets = minActivateAmount - 1;\n        uint8 commissionRate = 10;\n\n        vm.startPrank(trusted, trusted);\n        assetToken.approve(address(assetMgr), uint256(assets));\n        vm.expectEmit(true, true, false, true, address(valMgr));\n        emit ValidatorRegistered(trusted, false, commissionRate, assets);\n        valMgr.registerValidator(assets, commissionRate, withdrawAcc);\n        vm.stopPrank();\n\n        assertTrue(valMgr.getStatus(trusted) == IValidatorManager.ValidatorStatus.REGISTERED);\n        assertEq(valMgr.activatedValidatorCount(), count);\n        assertEq(valMgr.getWeight(trusted), 0);\n    }\n\n    function test_registerValidator_fromContract_reverts() external {\n        vm.prank(address(oracle), address(oracle));\n        vm.expectRevert(IValidatorManager.NotAllowedCaller.selector);\n        valMgr.registerValidator(minActivateAmount, 10, withdrawAcc);\n    }\n\n    function test_registerValidator_differentOrigin_reverts() external {\n        vm.prank(trusted, asserter);\n        vm.expectRevert(IValidatorManager.NotAllowedCaller.selector);\n        valMgr.registerValidator(minActivateAmount, 10, withdrawAcc);\n    }\n\n    function test_registerValidator_alreadyInitiated_reverts() external {\n        uint128 assets = minActivateAmount;\n\n        _registerValidator(trusted, assets);\n\n        vm.startPrank(trusted, trusted);\n        assetToken.approve(address(assetMgr), uint256(assets));\n        vm.expectRevert(IValidatorManager.ImproperValidatorStatus.selector);\n        valMgr.registerValidator(assets, 10, withdrawAcc);\n    }\n\n    function test_registerValidator_smallAsset_reverts() external {\n        uint128 assets = minRegisterAmount - 1;\n\n        vm.startPrank(trusted, trusted);\n        assetToken.approve(address(assetMgr), uint256(assets));\n        vm.expectRevert(IValidatorManager.InsufficientAsset.selector);\n        valMgr.registerValidator(assets, 10, withdrawAcc);\n    }\n\n    function test_registerValidator_largeCommissionRate_reverts() external {\n        uint128 assets = minRegisterAmount;\n\n        vm.startPrank(trusted, trusted);\n        assetToken.approve(address(assetMgr), uint256(assets));\n        vm.expectRevert(IValidatorManager.MaxCommissionRateExceeded.selector);\n        valMgr.registerValidator(assets, 101, withdrawAcc);\n    }\n\n    function test_registerValidator_withdrawZeroAddr_reverts() external {\n        uint128 assets = minRegisterAmount;\n\n        vm.startPrank(trusted, trusted);\n        assetToken.approve(address(assetMgr), uint256(assets));\n        vm.expectRevert(IAssetManager.ZeroAddress.selector);\n        valMgr.registerValidator(assets, 10, address(0));\n    }\n\n    function test_activateValidator_notValidator_reverts() external {\n        assertTrue(valMgr.getStatus(trusted) == IValidatorManager.ValidatorStatus.NONE);\n\n        vm.prank(trusted);\n        vm.expectRevert(IValidatorManager.ImproperValidatorStatus.selector);\n        valMgr.activateValidator();\n    }\n\n    function test_activateValidator_registered_reverts() external {\n        _registerValidator(trusted, minActivateAmount - 1);\n\n        vm.prank(trusted);\n        vm.expectRevert(IValidatorManager.ImproperValidatorStatus.selector);\n        valMgr.activateValidator();\n    }\n\n    function test_activateValidator_exited_reverts() external {\n        _registerValidator(trusted, minRegisterAmount);\n        assertTrue(valMgr.getStatus(trusted) == IValidatorManager.ValidatorStatus.REGISTERED);\n\n        _withdraw(trusted, 1);\n        assertTrue(valMgr.getStatus(trusted) == IValidatorManager.ValidatorStatus.EXITED);\n\n        vm.prank(trusted);\n        vm.expectRevert(IValidatorManager.ImproperValidatorStatus.selector);\n        valMgr.activateValidator();\n    }\n\n    function test_activateValidator_inJail_reverts() external {\n        test_afterSubmitL2Output_tryJail_succeeds();\n\n        // Withdraw all assets of jailed validator\n        uint128 validatorKro = assetMgr.totalValidatorKro(asserter);\n        _withdraw(asserter, validatorKro);\n        assertEq(assetMgr.totalValidatorKro(asserter), 0);\n        assertTrue(valMgr.getStatus(asserter) == IValidatorManager.ValidatorStatus.EXITED);\n\n        // Delegate to re-activate validator\n        vm.startPrank(asserter);\n        assetToken.approve(address(assetMgr), minActivateAmount);\n        assetMgr.deposit(minActivateAmount);\n        vm.stopPrank();\n        assertTrue(valMgr.getStatus(asserter) == IValidatorManager.ValidatorStatus.READY);\n\n        vm.prank(asserter);\n        vm.expectRevert(IValidatorManager.ImproperValidatorStatus.selector);\n        valMgr.activateValidator();\n    }\n\n    function test_activateValidator_alreadyActivated_reverts() external {\n        _registerValidator(trusted, minActivateAmount);\n\n        vm.prank(trusted);\n        vm.expectRevert(IValidatorManager.ImproperValidatorStatus.selector);\n        valMgr.activateValidator();\n    }\n\n    function test_tryActivateValidator_succeeds() external {\n        uint32 count = valMgr.activatedValidatorCount();\n\n        _registerValidator(trusted, minActivateAmount - 1);\n        assertTrue(valMgr.getStatus(trusted) == IValidatorManager.ValidatorStatus.REGISTERED);\n\n        vm.startPrank(trusted);\n        assetToken.approve(address(assetMgr), 1);\n        vm.expectEmit(true, false, false, true, address(valMgr));\n        emit ValidatorActivated(trusted, block.timestamp);\n        assetMgr.deposit(1);\n        vm.stopPrank();\n\n        assertTrue(valMgr.getStatus(trusted) == IValidatorManager.ValidatorStatus.ACTIVE);\n        assertEq(valMgr.activatedValidatorCount(), count + 1);\n        assertEq(valMgr.getWeight(trusted), minActivateAmount);\n    }\n\n    function test_afterSubmitL2Output_distributeReward_succeeds() external {\n        // Register validator with commission rate 10%\n        _registerValidator(trusted, minActivateAmount);\n\n        // Delegate 1 KGHs\n        uint128 kghCounts = 1;\n        _setUpKghDelegation(trusted, 1, 1);\n        assertEq(assetMgr.totalKghNum(trusted), kghCounts);\n\n        // Delegate KRO from 1 delegator\n        uint128 delegateAsset = minActivateAmount;\n        vm.startPrank(delegator);\n        assetToken.approve(address(assetMgr), uint256(delegateAsset));\n        assetMgr.delegate(trusted, delegateAsset);\n        vm.stopPrank();\n\n        assertEq(assetMgr.totalValidatorKro(trusted), minActivateAmount);\n        assertEq(assetMgr.totalKroAssets(trusted), delegateAsset);\n\n        // Submit the first output which interacts with ValidatorManager\n        _submitL2OutputV2(false);\n\n        // check KRO bonded\n        assertEq(assetMgr.totalValidatorKroBonded(trusted), bondAmount);\n\n        // Jump to the finalization time of the first output of ValidatorManager\n        vm.warp(oracle.finalizedAt(terminateOutputIndex + 1));\n\n        vm.startPrank(trusted);\n        _submitL2OutputV2(true); // distribute reward 1 time\n\n        uint128 expectedBaseReward = ((baseReward * 90) / 100) / 2; // delegator base reward\n        uint128 boostedReward = mockValMgr.getBoostedReward(trusted);\n        uint128 expectedBoostedReward = (boostedReward * 90) / 100;\n        uint128 expectedValidatorReward = (((baseReward + boostedReward) * 10) / 100) + // commission\n            ((baseReward * 90) / 100) /\n            2;\n\n        assertEq(assetMgr.totalKroAssets(trusted), delegateAsset + expectedBaseReward);\n        assertEq(assetMgr.getKghReward(trusted, trusted), expectedBoostedReward);\n        assertEq(assetMgr.totalValidatorKro(trusted), minActivateAmount + expectedValidatorReward);\n\n        // check KRO bonded\n        assertEq(assetMgr.totalValidatorKroBonded(trusted), bondAmount);\n\n        // Check validator tree updated with rewards\n        assertEq(\n            valMgr.getWeight(trusted),\n            minActivateAmount + delegateAsset + expectedBaseReward + expectedValidatorReward\n        );\n    }\n\n    function test_afterSubmitL2Output_distributeRewardToSC_succeeds() external {\n        // Register validator with commission rate 10%\n        _registerValidator(trusted, minActivateAmount);\n\n        // Submit the first output which interacts with ValidatorManager\n        _submitL2OutputV2(false);\n\n        // Change the output submitter to SC\n        uint256 firstOutputIndex = terminateOutputIndex + 1;\n        mockOracle.replaceOutput(assetMgr.SECURITY_COUNCIL(), firstOutputIndex);\n\n        // Jump to the finalization time of the first output of ValidatorManager\n        vm.warp(oracle.finalizedAt(firstOutputIndex));\n\n        vm.startPrank(trusted);\n        _submitL2OutputV2(true); // distribute reward 1 time\n\n        // Check if the reward is transferred to SC directly\n        assertEq(assetToken.balanceOf(assetMgr.SECURITY_COUNCIL()), baseReward);\n    }\n\n    function test_afterSubmitL2Output_updatePriorityValidator_succeeds() external {\n        // Register as a validator\n        _registerValidator(asserter, minActivateAmount);\n        _registerValidator(trusted, minActivateAmount);\n\n        // Check if next priority validator is not set in ValidatorManager\n        assertTrue(mockValMgr.nextPriorityValidator() == address(0));\n        assertEq(valMgr.nextValidator(), trusted);\n\n        // Submit the first output which interacts with ValidatorManager\n        _submitL2OutputV2(false);\n\n        // Check if next finalize output is not updated\n        assertEq(oracle.nextFinalizeOutputIndex(), terminateOutputIndex + 1);\n        // Check if next priority validator is set in ValidatorManager\n        address nextValidator = mockValMgr.nextPriorityValidator();\n        assertTrue(nextValidator != address(0));\n        assertTrue(valMgr.nextValidator() == nextValidator);\n\n        // Jump to the finalization time of the first output of ValidatorManager\n        vm.warp(oracle.finalizedAt(terminateOutputIndex + 1));\n        vm.startPrank(nextValidator);\n        _submitL2OutputV2(true);\n        vm.stopPrank();\n\n        // Check if next finalize output is updated\n        assertEq(oracle.nextFinalizeOutputIndex(), terminateOutputIndex + 2);\n\n        // Submit 10 outputs\n        uint256 tries = 10;\n        bool changed = false;\n        nextValidator = valMgr.nextValidator();\n\n        for (uint256 i; i < tries; i++) {\n            // Submit next output and finalize prev output\n            warpToSubmitTime();\n            _submitL2OutputV2(false);\n\n            // Check the next validator has changed\n            address newValidator = valMgr.nextValidator();\n            if (nextValidator != newValidator) {\n                changed = true;\n                break;\n            }\n        }\n\n        assertTrue(changed);\n    }\n\n    function test_afterSubmitL2Output_tryJail_succeeds() public {\n        // Register as a validator\n        _registerValidator(asserter, minActivateAmount);\n        _registerValidator(trusted, 10 * minActivateAmount);\n\n        vm.startPrank(trusted);\n        for (uint256 i; i < jailThreshold; i++) {\n            mockValMgr.updatePriorityValidator(asserter);\n\n            // Warp to public round\n            vm.warp(oracle.nextOutputMinL2Timestamp() + roundDuration + 1);\n            _submitL2OutputV2(true);\n\n            assertEq(valMgr.noSubmissionCount(asserter), i + 1);\n            assertFalse(valMgr.inJail(asserter));\n        }\n        vm.stopPrank();\n\n        mockValMgr.updatePriorityValidator(asserter);\n\n        // Warp to public round\n        vm.warp(oracle.nextOutputMinL2Timestamp() + roundDuration + 1);\n        vm.startPrank(trusted);\n        vm.expectEmit(true, false, false, true, address(valMgr));\n        emit ValidatorJailed(asserter, uint128(block.timestamp) + softJailPeriodSeconds);\n        vm.expectEmit(true, false, false, true, address(valMgr));\n        emit ValidatorStopped(asserter, block.timestamp);\n        _submitL2OutputV2(true);\n        vm.stopPrank();\n\n        assertEq(valMgr.noSubmissionCount(asserter), jailThreshold);\n        assertTrue(valMgr.inJail(asserter));\n        assertEq(valMgr.getWeight(asserter), 0);\n    }\n\n    function test_afterSubmitL2Output_resetNoSubmissionCount_succeeds() external {\n        // Register as a validator\n        _registerValidator(asserter, minActivateAmount);\n        _registerValidator(trusted, minActivateAmount);\n\n        mockValMgr.updatePriorityValidator(asserter);\n\n        // Warp to public round\n        vm.warp(oracle.nextOutputMinL2Timestamp() + roundDuration + 1);\n        assertEq(valMgr.nextValidator(), Constants.VALIDATOR_PUBLIC_ROUND_ADDRESS);\n        vm.startPrank(trusted);\n        _submitL2OutputV2(true);\n        vm.stopPrank();\n\n        assertEq(valMgr.noSubmissionCount(asserter), 1);\n        assertFalse(valMgr.inJail(asserter));\n\n        mockValMgr.updatePriorityValidator(asserter);\n\n        // Warp to priority round\n        warpToSubmitTime();\n        _submitL2OutputV2(false);\n\n        assertEq(valMgr.noSubmissionCount(asserter), 0);\n    }\n\n    function test_afterSubmitL2Output_senderNotL2OO_reverts() external {\n        vm.prank(trusted);\n        vm.expectRevert(IValidatorManager.NotAllowedCaller.selector);\n        valMgr.afterSubmitL2Output(0);\n    }\n\n    function test_initCommissionChange_succeeds() public {\n        _registerValidator(asserter, minActivateAmount);\n\n        uint8 commissionRate = valMgr.getCommissionRate(asserter);\n        uint8 newCommissionRate = commissionRate + 1;\n\n        vm.prank(asserter);\n        vm.expectEmit(true, false, false, true, address(valMgr));\n        emit ValidatorCommissionChangeInitiated(asserter, commissionRate, newCommissionRate);\n        valMgr.initCommissionChange(newCommissionRate);\n\n        assertEq(valMgr.getPendingCommissionRate(asserter), newCommissionRate);\n        assertEq(\n            valMgr.canFinalizeCommissionChangeAt(asserter),\n            block.timestamp + valMgr.COMMISSION_CHANGE_DELAY_SECONDS()\n        );\n    }\n\n    function test_initCommissionChange_exited_reverts() external {\n        _registerValidator(trusted, minActivateAmount);\n\n        uint128 validatorKro = assetMgr.totalValidatorKro(trusted);\n        _withdraw(trusted, validatorKro);\n        assertTrue(valMgr.getStatus(trusted) == IValidatorManager.ValidatorStatus.EXITED);\n\n        vm.prank(trusted);\n        vm.expectRevert(IValidatorManager.ImproperValidatorStatus.selector);\n        valMgr.initCommissionChange(15);\n    }\n\n    function test_initCommissionChange_inJail_reverts() external {\n        test_afterSubmitL2Output_tryJail_succeeds();\n\n        vm.prank(asserter);\n        vm.expectRevert(IValidatorManager.ImproperValidatorStatus.selector);\n        valMgr.initCommissionChange(15);\n    }\n\n    function test_initCommissionChange_largeCommissionRate_reverts() external {\n        _registerValidator(asserter, minActivateAmount);\n\n        vm.prank(asserter);\n        vm.expectRevert(IValidatorManager.MaxCommissionRateExceeded.selector);\n        valMgr.initCommissionChange(101);\n    }\n\n    function test_initCommissionChange_sameCommissionRate_reverts() external {\n        _registerValidator(asserter, minActivateAmount);\n\n        uint8 commissionRate = valMgr.getCommissionRate(asserter);\n        vm.prank(asserter);\n        vm.expectRevert(IValidatorManager.SameCommissionRate.selector);\n        valMgr.initCommissionChange(commissionRate);\n    }\n\n    function test_finalizeCommissionChange_succeeds() public {\n        test_initCommissionChange_succeeds();\n\n        uint8 oldCommissionRate = valMgr.getCommissionRate(asserter);\n        uint8 newCommissionRate = valMgr.getPendingCommissionRate(asserter);\n\n        vm.warp(valMgr.canFinalizeCommissionChangeAt(asserter));\n        vm.prank(asserter);\n        vm.expectEmit(true, false, false, true, address(valMgr));\n        emit ValidatorCommissionChangeFinalized(asserter, oldCommissionRate, newCommissionRate);\n        valMgr.finalizeCommissionChange();\n\n        assertEq(valMgr.getCommissionRate(asserter), newCommissionRate);\n        assertEq(valMgr.getPendingCommissionRate(asserter), 0);\n        assertEq(\n            valMgr.canFinalizeCommissionChangeAt(asserter),\n            valMgr.COMMISSION_CHANGE_DELAY_SECONDS()\n        );\n    }\n\n    function test_finalizeCommissionChange_exited_reverts() external {\n        _registerValidator(trusted, minActivateAmount);\n\n        vm.prank(trusted);\n        valMgr.initCommissionChange(15);\n\n        uint128 validatorKro = assetMgr.totalValidatorKro(trusted);\n        _withdraw(trusted, validatorKro);\n        assertTrue(valMgr.getStatus(trusted) == IValidatorManager.ValidatorStatus.EXITED);\n\n        vm.prank(trusted);\n        vm.expectRevert(IValidatorManager.ImproperValidatorStatus.selector);\n        valMgr.finalizeCommissionChange();\n    }\n\n    function test_finalizeCommissionChange_inJail_reverts() external {\n        test_afterSubmitL2Output_tryJail_succeeds();\n\n        vm.prank(asserter);\n        vm.expectRevert(IValidatorManager.ImproperValidatorStatus.selector);\n        valMgr.finalizeCommissionChange();\n    }\n\n    function test_finalizeCommissionChange_changeDelayNotElapsed_reverts() external {\n        test_initCommissionChange_succeeds();\n\n        vm.prank(asserter);\n        vm.expectRevert(IValidatorManager.NotElapsedCommissionChangeDelay.selector);\n        valMgr.finalizeCommissionChange();\n    }\n\n    function test_finalizeCommissionChange_notInitiated_reverts() external {\n        _registerValidator(trusted, minActivateAmount);\n\n        vm.prank(trusted);\n        vm.expectRevert(IValidatorManager.NotInitiatedCommissionChange.selector);\n        valMgr.finalizeCommissionChange();\n    }\n\n    function test_tryUnjail_succeeds() external {\n        test_afterSubmitL2Output_tryJail_succeeds();\n        assertTrue(valMgr.getStatus(asserter) == IValidatorManager.ValidatorStatus.READY);\n\n        vm.warp(valMgr.jailExpiresAt(asserter));\n        vm.prank(asserter);\n        vm.expectEmit(true, false, false, false, address(valMgr));\n        emit ValidatorUnjailed(asserter);\n        vm.expectEmit(true, false, false, true, address(valMgr));\n        emit ValidatorActivated(asserter, block.timestamp);\n        valMgr.tryUnjail();\n\n        assertEq(valMgr.noSubmissionCount(asserter), 0);\n        assertFalse(valMgr.inJail(asserter));\n        assertTrue(valMgr.getStatus(asserter) == IValidatorManager.ValidatorStatus.ACTIVE);\n    }\n\n    function test_tryUnjail_notInJail_reverts() external {\n        vm.prank(asserter);\n        vm.expectRevert(IValidatorManager.ImproperValidatorStatus.selector);\n        valMgr.tryUnjail();\n    }\n\n    function test_tryUnjail_senderNotSelf_reverts() external {\n        test_afterSubmitL2Output_tryJail_succeeds();\n\n        vm.prank(trusted);\n        vm.expectRevert(IValidatorManager.ImproperValidatorStatus.selector);\n        valMgr.tryUnjail();\n    }\n\n    function test_tryUnjail_periodNotElapsed_reverts() external {\n        test_afterSubmitL2Output_tryJail_succeeds();\n\n        vm.prank(asserter);\n        vm.expectRevert(IValidatorManager.NotElapsedJailPeriod.selector);\n        valMgr.tryUnjail();\n    }\n\n    function test_bondValidatorKro_succeeds() external {\n        _registerValidator(trusted, minActivateAmount);\n        assertEq(assetMgr.totalValidatorKroBonded(trusted), 0);\n\n        vm.prank(address(colosseum));\n        valMgr.bondValidatorKro(trusted);\n\n        assertEq(assetMgr.totalValidatorKroBonded(trusted), bondAmount);\n    }\n\n    function test_bondValidatorKro_notColosseum_reverts() external {\n        _registerValidator(trusted, minActivateAmount);\n\n        vm.prank(asserter);\n        vm.expectRevert(IValidatorManager.NotAllowedCaller.selector);\n        valMgr.bondValidatorKro(trusted);\n    }\n\n    function test_unbondValidatorKro_succeeds() external {\n        _registerValidator(trusted, minActivateAmount);\n\n        vm.prank(trusted);\n        _submitL2OutputV2(false);\n\n        assertEq(assetMgr.totalValidatorKroBonded(trusted), bondAmount);\n\n        vm.prank(address(colosseum));\n        valMgr.unbondValidatorKro(trusted);\n\n        assertEq(assetMgr.totalValidatorKroBonded(trusted), 0);\n    }\n\n    function test_unbondValidatorKro_notColosseum_reverts() external {\n        _registerValidator(trusted, minActivateAmount);\n\n        vm.prank(trusted);\n        _submitL2OutputV2(false);\n\n        assertEq(assetMgr.totalValidatorKroBonded(trusted), bondAmount);\n\n        vm.prank(asserter);\n        vm.expectRevert(IValidatorManager.NotAllowedCaller.selector);\n        valMgr.unbondValidatorKro(trusted);\n    }\n\n    function test_slash_succeeds() external {\n        uint32 count = valMgr.activatedValidatorCount();\n        // Register as a validator\n        _registerValidator(asserter, minActivateAmount);\n        _registerValidator(challenger, minActivateAmount);\n        assertEq(valMgr.activatedValidatorCount(), count + 2);\n\n        // Delegate KGHs\n        uint128 kghCounts = 1;\n        uint128 startingTokenId = 1;\n        _setUpKghDelegation(asserter, startingTokenId, kghCounts);\n        _setUpKghDelegation(challenger, startingTokenId + kghCounts, kghCounts);\n        assertEq(assetMgr.totalKghNum(asserter), kghCounts);\n        assertEq(assetMgr.totalKghNum(challenger), kghCounts);\n\n        // Submit the first output which interacts with ValidatorManager\n        mockValMgr.updatePriorityValidator(asserter);\n        warpToSubmitTime();\n        _submitL2OutputV2(false);\n        uint256 challengedOutputIndex = oracle.latestOutputIndex();\n\n        // Suppose that the challenge is successful, so the winner is challenger\n        uint128 slashingAmount = bondAmount;\n        vm.startPrank(address(colosseum));\n        valMgr.bondValidatorKro(challenger); // bond for creating challenge\n        vm.expectEmit(true, true, false, true, address(valMgr));\n        emit Slashed(challengedOutputIndex, asserter, slashingAmount);\n        vm.expectEmit(true, false, false, true, address(valMgr));\n        emit ValidatorJailed(asserter, uint128(block.timestamp) + hardJailPeriodSeconds);\n        vm.expectEmit(true, false, false, true, address(valMgr));\n        emit ValidatorStopped(asserter, block.timestamp);\n        valMgr.slash(challengedOutputIndex, challenger, asserter);\n        vm.stopPrank();\n\n        // This will be done by the l2 output oracle contract in the real environment\n        vm.prank(challenger);\n        mockOracle.replaceOutput(challenger, challengedOutputIndex);\n\n        // Jump to the finalization time of the challenged output\n        vm.warp(oracle.finalizedAt(challengedOutputIndex));\n        vm.startPrank(challenger);\n        // Submit one more output to distribute reward\n        _submitL2OutputV2(true);\n        vm.stopPrank();\n\n        // Asserter in jail after slashed\n        assertTrue(valMgr.inJail(asserter));\n        // Asserter removed from validator tree\n        assertEq(valMgr.activatedValidatorCount(), count + 1);\n        assertTrue(valMgr.getStatus(asserter) == IValidatorManager.ValidatorStatus.REGISTERED);\n\n        // Asserter asset decreased by slashingAmount\n        uint128 asserterTotalValidatorKro = assetMgr.totalValidatorKro(asserter);\n        assertEq(asserterTotalValidatorKro, minActivateAmount - slashingAmount);\n        assertEq(assetMgr.totalValidatorKroBonded(asserter), 0);\n\n        // Security council balance of asset token increased by tax\n        uint128 taxAmount = (slashingAmount * assetMgr.TAX_NUMERATOR()) /\n            assetMgr.TAX_DENOMINATOR();\n        assertEq(assetToken.balanceOf(assetMgr.SECURITY_COUNCIL()), taxAmount);\n\n        // Challenger asset increased by output reward and challenge reward\n        // Boosted reward with 1 kgh delegation\n        uint128 boostedReward = mockValMgr.getBoostedReward(challenger);\n        uint128 challengeReward = slashingAmount - taxAmount;\n        uint128 challengerKro = assetMgr.totalValidatorKro(challenger);\n        assertEq(\n            challengerKro,\n            minActivateAmount + baseReward + (boostedReward / 10) + challengeReward\n        );\n    }\n\n    function test_slash_alreadyInJail_succeeds() external {\n        _registerValidator(asserter, minActivateAmount);\n\n        // Submit the first output which interacts with ValidatorManager\n        mockValMgr.updatePriorityValidator(asserter);\n        warpToSubmitTime();\n        _submitL2OutputV2(false);\n        uint256 challengedOutputIndex = oracle.latestOutputIndex();\n\n        // Before slashed, send to jail\n        uint128 firstJailExpiresAt = uint128(block.timestamp) + softJailPeriodSeconds;\n        mockValMgr.setJailExpiresAt(asserter, firstJailExpiresAt);\n\n        // After jail expired, slash\n        vm.warp(firstJailExpiresAt + 1);\n        vm.prank(address(colosseum));\n        valMgr.slash(challengedOutputIndex, challenger, asserter);\n\n        assertEq(valMgr.jailExpiresAt(asserter), firstJailExpiresAt + 1 + hardJailPeriodSeconds);\n    }\n\n    function test_slash_notColosseum_reverts() external {\n        vm.prank(address(1));\n        vm.expectRevert(IValidatorManager.NotAllowedCaller.selector);\n        valMgr.slash(1, challenger, asserter);\n    }\n\n    function test_revertSlash_succeeds() external {\n        uint32 count = valMgr.activatedValidatorCount();\n        // Register as a validator\n        _registerValidator(asserter, minActivateAmount);\n        _registerValidator(challenger, minActivateAmount);\n        assertEq(valMgr.activatedValidatorCount(), count + 2);\n\n        // Delegate KGHs\n        uint128 kghCounts = 1;\n        uint128 startingTokenId = 1;\n        _setUpKghDelegation(asserter, startingTokenId, kghCounts);\n        _setUpKghDelegation(challenger, startingTokenId + kghCounts, kghCounts);\n        assertEq(assetMgr.totalKghNum(asserter), kghCounts);\n        assertEq(assetMgr.totalKghNum(challenger), kghCounts);\n\n        // Submit the first output which interacts with ValidatorManager\n        mockValMgr.updatePriorityValidator(asserter);\n        warpToSubmitTime();\n        _submitL2OutputV2(false);\n        uint256 challengedOutputIndex = oracle.latestOutputIndex();\n\n        // Suppose that the challenge is successful, so the winner is challenger\n        uint128 slashingAmount = bondAmount;\n        vm.startPrank(address(colosseum));\n        valMgr.bondValidatorKro(challenger); // bond for creating challenge\n        vm.expectEmit(true, true, false, true, address(valMgr));\n        emit Slashed(challengedOutputIndex, asserter, slashingAmount);\n        vm.expectEmit(true, false, false, true, address(valMgr));\n        emit ValidatorJailed(asserter, uint128(block.timestamp) + hardJailPeriodSeconds);\n        vm.expectEmit(true, false, false, true, address(valMgr));\n        emit ValidatorStopped(asserter, block.timestamp);\n        valMgr.slash(challengedOutputIndex, challenger, asserter);\n        vm.stopPrank();\n\n        // Asserter in jail after slashed\n        assertTrue(valMgr.inJail(asserter));\n\n        // Revert slash\n        vm.startPrank(address(colosseum));\n        vm.expectEmit(true, true, true, true, address(valMgr));\n        emit SlashReverted(challengedOutputIndex, asserter, slashingAmount);\n        vm.expectEmit(true, true, false, false, address(valMgr));\n        emit ValidatorUnjailed(asserter);\n        valMgr.revertSlash(challengedOutputIndex, asserter);\n\n        assertEq(assetMgr.totalValidatorKro(asserter), minActivateAmount);\n        assertEq(assetMgr.totalValidatorKroBonded(asserter), bondAmount);\n        assertFalse(valMgr.inJail(asserter));\n        assertTrue(valMgr.getStatus(asserter) == IValidatorManager.ValidatorStatus.ACTIVE);\n    }\n\n    function test_revertSlash_stillInJail_succeeds() external {\n        _registerValidator(asserter, minActivateAmount);\n\n        // Submit the first output which interacts with ValidatorManager\n        mockValMgr.updatePriorityValidator(asserter);\n        warpToSubmitTime();\n        _submitL2OutputV2(false);\n        uint256 challengedOutputIndex = oracle.latestOutputIndex();\n\n        // Before slashed, send to jail\n        uint128 firstJailExpiresAt = uint128(block.timestamp) + softJailPeriodSeconds;\n        mockValMgr.setJailExpiresAt(asserter, firstJailExpiresAt);\n\n        // Before jail expired, slash\n        vm.prank(address(colosseum));\n        valMgr.slash(challengedOutputIndex, challenger, asserter);\n\n        assertEq(valMgr.jailExpiresAt(asserter), firstJailExpiresAt + hardJailPeriodSeconds);\n\n        // Revert slash\n        vm.prank(address(colosseum));\n        valMgr.revertSlash(challengedOutputIndex, asserter);\n\n        assertEq(valMgr.jailExpiresAt(asserter), firstJailExpiresAt);\n    }\n\n    function test_revertSlash_notColosseum_reverts() external {\n        vm.prank(trusted);\n        vm.expectRevert(IValidatorManager.NotAllowedCaller.selector);\n        valMgr.revertSlash(1, trusted);\n    }\n\n    function test_checkSubmissionEligibility_priorityRound_succeeds() external {\n        address nextValidator = valMgr.nextValidator();\n        _registerValidator(nextValidator, minActivateAmount);\n\n        vm.prank(address(oracle));\n        valMgr.checkSubmissionEligibility(nextValidator);\n    }\n\n    function test_checkSubmissionEligibility_publicRound_succeeds() external {\n        mockValMgr.updatePriorityValidator(asserter);\n\n        _registerValidator(trusted, minActivateAmount);\n\n        // Warp to public round\n        vm.warp(oracle.nextOutputMinL2Timestamp() + roundDuration + 1);\n        vm.prank(address(oracle));\n        valMgr.checkSubmissionEligibility(trusted);\n    }\n\n    function test_checkSubmissionEligibility_senderNotL2OO_reverts() external {\n        vm.expectRevert(IValidatorManager.NotAllowedCaller.selector);\n        valMgr.checkSubmissionEligibility(trusted);\n    }\n\n    function test_checkSubmissionEligibility_notSelected_reverts() external {\n        mockValMgr.updatePriorityValidator(asserter);\n\n        warpToSubmitTime();\n        vm.prank(address(oracle));\n        vm.expectRevert(IValidatorManager.NotSelectedPriorityValidator.selector);\n        valMgr.checkSubmissionEligibility(trusted);\n    }\n\n    function test_checkSubmissionEligibility_notSatisfyCondition_reverts() external {\n        address nextValidator = valMgr.nextValidator();\n\n        vm.prank(address(oracle));\n        vm.expectRevert(IValidatorManager.ImproperValidatorStatus.selector);\n        valMgr.checkSubmissionEligibility(nextValidator);\n    }\n\n    function test_checkSubmissionEligibility_publicRound_notSatisfyCondition_reverts() external {\n        mockValMgr.updatePriorityValidator(asserter);\n\n        // Warp to public round\n        vm.warp(oracle.nextOutputMinL2Timestamp() + roundDuration + 1);\n        vm.prank(address(oracle));\n        vm.expectRevert(IValidatorManager.ImproperValidatorStatus.selector);\n        valMgr.checkSubmissionEligibility(trusted);\n    }\n\n    function test_checkSubmissionEligibility_inJail_reverts() external {\n        test_afterSubmitL2Output_tryJail_succeeds();\n\n        mockValMgr.updatePriorityValidator(asserter);\n\n        vm.prank(address(oracle));\n        vm.expectRevert(IValidatorManager.ImproperValidatorStatus.selector);\n        valMgr.checkSubmissionEligibility(asserter);\n    }\n\n    function test_checkSubmissionEligibility_publicRound_inJail_reverts() external {\n        test_afterSubmitL2Output_tryJail_succeeds();\n\n        mockValMgr.updatePriorityValidator(trusted);\n\n        // Warp to public round\n        vm.warp(oracle.nextOutputMinL2Timestamp() + roundDuration + 1);\n        vm.prank(address(oracle));\n        vm.expectRevert(IValidatorManager.ImproperValidatorStatus.selector);\n        valMgr.checkSubmissionEligibility(asserter);\n    }\n\n    function test_getStatus_registered_succeeds() external {\n        _registerValidator(trusted, minActivateAmount);\n        assertEq(valMgr.getWeight(trusted), minActivateAmount);\n\n        _withdraw(trusted, 1);\n        assertTrue(valMgr.getStatus(trusted) == IValidatorManager.ValidatorStatus.REGISTERED);\n        assertEq(valMgr.getWeight(trusted), 0);\n    }\n\n    function test_activatedValidatorTotalWeight_succeeds() external {\n        uint32 count = valMgr.activatedValidatorCount();\n        uint120 totalWeight = valMgr.activatedValidatorTotalWeight();\n        _registerValidator(trusted, minActivateAmount);\n        assertEq(valMgr.activatedValidatorCount(), count + 1);\n        assertEq(valMgr.activatedValidatorTotalWeight(), totalWeight + minActivateAmount);\n\n        count = valMgr.activatedValidatorCount();\n        totalWeight = valMgr.activatedValidatorTotalWeight();\n        _registerValidator(asserter, minActivateAmount);\n        assertEq(valMgr.activatedValidatorCount(), count + 1);\n        assertEq(valMgr.activatedValidatorTotalWeight(), totalWeight + minActivateAmount);\n\n        count = valMgr.activatedValidatorCount();\n        totalWeight = valMgr.activatedValidatorTotalWeight();\n        vm.startPrank(challenger);\n        assetToken.approve(address(assetMgr), 10);\n        assetMgr.delegate(asserter, 10);\n        vm.stopPrank();\n        assertEq(valMgr.activatedValidatorCount(), count);\n        assertEq(valMgr.activatedValidatorTotalWeight(), totalWeight + 10);\n    }\n}\n"
    },
    "contracts/test/ValidatorPool.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { IValidatorManager } from \"../L1/interfaces/IValidatorManager.sol\";\nimport { KromaPortal } from \"../L1/KromaPortal.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { ValidatorPool } from \"../L1/ValidatorPool.sol\";\nimport { ValidatorRewardVault } from \"../L2/ValidatorRewardVault.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { L2OutputOracle_Initializer, ValidatorSystemUpgrade_Initializer } from \"./CommonTest.t.sol\";\n\ncontract MockL2OutputOracle is L2OutputOracle {\n    constructor(\n        ValidatorPool _validatorPool,\n        IValidatorManager _validatorManager,\n        address _colosseum,\n        uint256 _submissionInterval,\n        uint256 _l2BlockTime,\n        uint256 _startingBlockNumber,\n        uint256 _startingTimestamp,\n        uint256 _finalizationPeriodSeconds\n    )\n        L2OutputOracle(\n            _validatorPool,\n            _validatorManager,\n            _colosseum,\n            _submissionInterval,\n            _l2BlockTime,\n            _startingBlockNumber,\n            _startingTimestamp,\n            _finalizationPeriodSeconds\n        )\n    {}\n\n    function addOutput(bytes32 _outputRoot, uint256 _l2BlockNumber) external payable {\n        l2Outputs.push(\n            Types.CheckpointOutput({\n                submitter: msg.sender,\n                outputRoot: _outputRoot,\n                timestamp: uint128(block.timestamp),\n                l2BlockNumber: uint128(_l2BlockNumber)\n            })\n        );\n    }\n\n    function replaceOutput(uint256 _outputIndex, bytes32 _outputRoot) external {\n        l2Outputs[_outputIndex] = Types.CheckpointOutput({\n            submitter: msg.sender,\n            outputRoot: _outputRoot,\n            timestamp: uint128(block.timestamp),\n            l2BlockNumber: l2Outputs[_outputIndex].l2BlockNumber\n        });\n    }\n}\n\ncontract MockValidatorPool is ValidatorPool {\n    constructor(\n        L2OutputOracle _l2OutputOracle,\n        KromaPortal _portal,\n        address _securityCouncil,\n        address _trustedValidator,\n        uint256 _requiredBondAmount,\n        uint256 _maxUnbond,\n        uint256 _roundDuration,\n        uint256 _terminateOutputIndex\n    )\n        ValidatorPool(\n            _l2OutputOracle,\n            _portal,\n            _securityCouncil,\n            _trustedValidator,\n            _requiredBondAmount,\n            _maxUnbond,\n            _roundDuration,\n            _terminateOutputIndex\n        )\n    {}\n\n    function getNextPriorityValidator() external view returns (address) {\n        return nextPriorityValidator;\n    }\n}\n\n// Test the implementations of the ValidatorPool\ncontract ValidatorPoolTest is L2OutputOracle_Initializer {\n    MockL2OutputOracle mockOracle;\n\n    event Bonded(\n        address indexed submitter,\n        uint256 indexed outputIndex,\n        uint128 amount,\n        uint128 expiresAt\n    );\n\n    event BondIncreased(uint256 indexed outputIndex, address indexed challenger, uint128 amount);\n    event PendingBondAdded(uint256 indexed outputIndex, address indexed challenger, uint128 amount);\n    event PendingBondReleased(\n        uint256 indexed outputIndex,\n        address indexed challenger,\n        address indexed recipient,\n        uint128 amount\n    );\n    event Unbonded(uint256 indexed outputIndex, address indexed recipient, uint128 amount);\n\n    function setUp() public override {\n        super.setUp();\n\n        address oracleAddress = address(oracle);\n        MockL2OutputOracle mockOracleImpl = new MockL2OutputOracle(\n            pool,\n            valMgr,\n            address(colosseum),\n            submissionInterval,\n            l2BlockTime,\n            startingBlockNumber,\n            startingTimestamp,\n            finalizationPeriodSeconds\n        );\n        vm.prank(multisig);\n        Proxy(payable(oracleAddress)).upgradeTo(address(mockOracleImpl));\n        mockOracle = MockL2OutputOracle(oracleAddress);\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(address(pool.L2_ORACLE()), address(oracle));\n        assertEq(pool.TRUSTED_VALIDATOR(), trusted);\n        assertEq(pool.REQUIRED_BOND_AMOUNT(), requiredBondAmount);\n        assertEq(pool.MAX_UNBOND(), maxUnbond);\n        assertEq(pool.TERMINATE_OUTPUT_INDEX(), terminateOutputIndex);\n        assertEq(pool.ROUND_DURATION(), roundDuration);\n    }\n\n    function test_deposit_succeeds() public {\n        uint256 trustedBalance = trusted.balance;\n\n        vm.prank(trusted);\n        pool.deposit{ value: requiredBondAmount }();\n        assertEq(pool.balanceOf(trusted), requiredBondAmount);\n        assertEq(trusted.balance, trustedBalance - requiredBondAmount);\n        assertTrue(pool.isValidator(trusted));\n        assertEq(pool.validatorCount(), 1);\n\n        vm.prank(asserter);\n        pool.deposit{ value: requiredBondAmount }();\n        assertEq(pool.balanceOf(asserter), requiredBondAmount);\n        assertTrue(pool.isValidator(asserter));\n        assertEq(pool.validatorCount(), 2);\n    }\n\n    function test_deposit_alreadyValidator_succeeds() external {\n        test_deposit_succeeds();\n\n        uint256 count = pool.validatorCount();\n        address nextValidator = pool.nextValidator();\n        uint256 deposits = pool.balanceOf(nextValidator);\n\n        uint256 prevBalance = nextValidator.balance;\n        uint256 depositAmount = 1;\n\n        vm.prank(nextValidator);\n        pool.deposit{ value: depositAmount }();\n        assertEq(pool.balanceOf(trusted), deposits + depositAmount);\n        assertEq(nextValidator.balance, prevBalance - depositAmount);\n        assertTrue(pool.isValidator(trusted));\n        assertEq(pool.validatorCount(), count);\n    }\n\n    function test_deposit_insufficientBalances_reverts() external {\n        vm.deal(asserter, 0);\n        vm.prank(asserter);\n        vm.expectRevert();\n        pool.deposit{ value: requiredBondAmount }();\n    }\n\n    function test_withdraw_loseValidatorEligibility_succeeds() external {\n        test_deposit_succeeds();\n\n        uint256 count = pool.validatorCount();\n        address nextValidator = pool.nextValidator();\n        uint256 deposits = pool.balanceOf(nextValidator);\n\n        uint256 prevBalance = nextValidator.balance;\n        uint256 withdrawalAmount = 1;\n\n        vm.prank(nextValidator);\n        pool.withdraw(withdrawalAmount);\n        assertEq(pool.balanceOf(nextValidator), deposits - withdrawalAmount);\n        assertEq(nextValidator.balance, prevBalance + withdrawalAmount);\n        assertFalse(pool.isValidator(nextValidator));\n        assertEq(pool.validatorCount(), count - 1);\n    }\n\n    function test_withdraw_all_succeeds() external {\n        test_deposit_succeeds();\n\n        uint256 count = pool.validatorCount();\n        address nextValidator = pool.nextValidator();\n        uint256 deposits = pool.balanceOf(nextValidator);\n\n        uint256 prevBalance = nextValidator.balance;\n\n        vm.prank(nextValidator);\n        pool.withdraw(deposits);\n        assertEq(pool.balanceOf(nextValidator), 0);\n        assertEq(nextValidator.balance, prevBalance + deposits);\n        assertFalse(pool.isValidator(nextValidator));\n        assertEq(pool.validatorCount(), count - 1);\n    }\n\n    function test_withdraw_to_succeeds() external {\n        test_deposit_succeeds();\n\n        address nextValidator = pool.nextValidator();\n        uint256 deposits = pool.balanceOf(nextValidator);\n\n        uint256 prevNextValidatorBalance = nextValidator.balance;\n        uint256 prevChallengerBalance = challenger.balance;\n\n        vm.prank(nextValidator);\n        pool.withdrawTo(challenger, deposits);\n        assertEq(pool.balanceOf(nextValidator), 0);\n        assertEq(nextValidator.balance, prevNextValidatorBalance);\n        assertEq(challenger.balance, prevChallengerBalance + deposits);\n    }\n\n    function test_withdraw_to_zero_address_reverts() external {\n        test_deposit_succeeds();\n\n        address nextValidator = pool.nextValidator();\n        uint256 deposits = pool.balanceOf(nextValidator);\n\n        vm.prank(nextValidator);\n        vm.expectRevert(\"ValidatorPool: cannot withdraw to the zero address\");\n        pool.withdrawTo(address(0), deposits);\n    }\n\n    function test_withdraw_maintainValidatorEligibility_succeeds() external {\n        uint256 trustedBalance = trusted.balance;\n        uint256 depositAmount = requiredBondAmount * 2;\n\n        vm.prank(trusted);\n        pool.deposit{ value: depositAmount }();\n        assertEq(pool.balanceOf(trusted), depositAmount);\n        assertEq(trusted.balance, trustedBalance - depositAmount);\n        assertTrue(pool.isValidator(trusted));\n        assertEq(pool.validatorCount(), 1);\n\n        trustedBalance = trusted.balance;\n        uint256 withdrawalAmount = requiredBondAmount;\n\n        vm.prank(trusted);\n        pool.withdraw(withdrawalAmount);\n        assertEq(pool.balanceOf(trusted), withdrawalAmount);\n        assertEq(trusted.balance, trustedBalance + withdrawalAmount);\n        assertTrue(pool.isValidator(trusted));\n        assertEq(pool.validatorCount(), 1);\n    }\n\n    function test_createBond_succeeds() public {\n        test_deposit_succeeds();\n\n        uint256 nextOutputIndex = oracle.nextOutputIndex();\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        bytes32 outputRoot = keccak256(abi.encode(nextBlockNumber));\n        address validator = pool.nextValidator();\n\n        warpToSubmitTime();\n\n        vm.prank(validator);\n        mockOracle.addOutput(outputRoot, nextBlockNumber);\n\n        uint128 expiresAt = uint128(block.timestamp + finalizationPeriodSeconds);\n        vm.prank(address(oracle));\n        vm.expectEmit(true, true, false, true, address(pool));\n        emit Bonded(validator, nextOutputIndex, uint128(requiredBondAmount), expiresAt);\n        pool.createBond(nextOutputIndex, expiresAt);\n        assertEq(pool.balanceOf(validator), 0);\n        assertFalse(pool.isValidator(validator));\n        assertEq(pool.getBond(nextOutputIndex).amount, uint128(requiredBondAmount));\n        assertEq(pool.getBond(nextOutputIndex).expiresAt, expiresAt);\n    }\n\n    function test_createBond_unbondBefore_succeeds() external {\n        test_createBond_succeeds();\n\n        Types.CheckpointOutput memory firstOutput = oracle.getL2Output(0);\n        Types.Bond memory firstBond = pool.getBond(0);\n        // warp to the expiration time of the first bond.\n        vm.warp(firstBond.expiresAt);\n\n        uint256 nextOutputIndex = oracle.nextOutputIndex();\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        bytes32 outputRoot = keccak256(abi.encode(nextBlockNumber));\n        address validator = pool.nextValidator();\n        if (validator == Constants.VALIDATOR_PUBLIC_ROUND_ADDRESS) {\n            validator = asserter;\n        }\n\n        // deposit again & append new output\n        vm.startPrank(validator);\n        mockOracle.addOutput(outputRoot, nextBlockNumber);\n        pool.deposit{ value: requiredBondAmount }();\n        vm.stopPrank();\n\n        uint128 expiresAt = uint128(block.timestamp + finalizationPeriodSeconds);\n        vm.prank(address(oracle));\n        vm.expectEmit(true, true, false, true, address(pool));\n        emit Unbonded(0, firstOutput.submitter, uint128(firstBond.amount));\n        vm.expectCall(\n            address(oracle),\n            abi.encodeWithSelector(L2OutputOracle.setNextFinalizeOutputIndex.selector, 1)\n        );\n        pool.createBond(nextOutputIndex, expiresAt);\n        assertEq(pool.balanceOf(firstOutput.submitter), requiredBondAmount);\n\n        // check whether bond is deleted\n        vm.expectRevert(\"ValidatorPool: the bond does not exist\");\n        pool.getBond(0);\n    }\n\n    function test_createBond_senderNotL2OO_reverts() external {\n        test_deposit_succeeds();\n\n        vm.prank(trusted);\n        vm.expectRevert(\"ValidatorPool: sender is not L2OutputOracle\");\n        pool.createBond(0, uint128(block.timestamp + finalizationPeriodSeconds));\n    }\n\n    function test_createBond_existsBond_reverts() external {\n        test_createBond_succeeds();\n\n        uint256 outputIndex = oracle.latestOutputIndex();\n        Types.Bond memory bond = pool.getBond(outputIndex);\n        assertTrue(bond.expiresAt > 0);\n\n        Types.CheckpointOutput memory output = oracle.getL2Output(outputIndex);\n\n        vm.prank(output.submitter);\n        pool.deposit{ value: requiredBondAmount }();\n\n        vm.prank(address(oracle));\n        vm.expectRevert(\"ValidatorPool: bond of the given output index already exists\");\n        pool.createBond(outputIndex, uint128(block.timestamp + finalizationPeriodSeconds));\n    }\n\n    function test_createBond_insufficientBalances_reverts() external {\n        uint256 nextOutputIndex = oracle.nextOutputIndex();\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        bytes32 outputRoot = keccak256(abi.encode(nextBlockNumber));\n        address validator = pool.nextValidator();\n\n        warpToSubmitTime();\n\n        vm.prank(validator);\n        mockOracle.addOutput(outputRoot, nextBlockNumber);\n\n        uint128 expiresAt = uint128(block.timestamp + finalizationPeriodSeconds);\n        vm.prank(address(oracle));\n        vm.expectRevert(\"ValidatorPool: insufficient balances\");\n        pool.createBond(nextOutputIndex, expiresAt);\n    }\n\n    function test_unbond_succeeds() external {\n        test_createBond_succeeds();\n\n        uint256 outputIndex = oracle.latestOutputIndex();\n        Types.CheckpointOutput memory output = oracle.getL2Output(outputIndex);\n        Types.Bond memory bond = pool.getBond(outputIndex);\n\n        // warp to the time the output is finalized and the bond is expires.\n        vm.warp(bond.expiresAt);\n\n        vm.expectEmit(true, true, false, true, address(pool));\n        emit Unbonded(outputIndex, output.submitter, bond.amount);\n        vm.expectCall(\n            address(pool.PORTAL()),\n            abi.encodeWithSelector(\n                KromaPortal.depositTransactionByValidatorPool.selector,\n                Predeploys.VALIDATOR_REWARD_VAULT,\n                pool.VAULT_REWARD_GAS_LIMIT(),\n                abi.encodeWithSelector(\n                    ValidatorRewardVault.reward.selector,\n                    output.submitter,\n                    output.l2BlockNumber\n                )\n            )\n        );\n        vm.expectCall(\n            address(oracle),\n            abi.encodeWithSelector(\n                L2OutputOracle.setNextFinalizeOutputIndex.selector,\n                outputIndex + 1\n            )\n        );\n        vm.prank(trusted);\n        pool.unbond();\n        assertEq(pool.balanceOf(output.submitter), uint256(bond.amount));\n    }\n\n    function test_unbond_multipleBonds_succeeds() external {\n        uint256 tries = 2;\n        uint256 deposit = requiredBondAmount * tries;\n        vm.prank(trusted);\n        pool.deposit{ value: deposit }();\n\n        // submit 2 outputs, only trusted can submit outputs before at least one unbond.\n        uint256 blockNumber = 0;\n        uint128 expiresAt = 0;\n        for (uint256 i = 0; i < tries; i++) {\n            blockNumber = oracle.nextBlockNumber();\n            warpToSubmitTime();\n            expiresAt = uint128(block.timestamp + finalizationPeriodSeconds);\n            assertEq(pool.nextValidator(), trusted);\n            vm.prank(trusted);\n            mockOracle.addOutput(keccak256(abi.encode(blockNumber)), blockNumber);\n            vm.prank(address(oracle));\n            pool.createBond(i, expiresAt);\n            assertEq(pool.balanceOf(trusted), deposit - requiredBondAmount * (i + 1));\n        }\n\n        uint256 firstOutputIndex = 0;\n        Types.CheckpointOutput memory firstOutput = oracle.getL2Output(firstOutputIndex);\n        Types.Bond memory firstBond = pool.getBond(firstOutputIndex);\n\n        uint256 secondOutputIndex = 1;\n        Types.CheckpointOutput memory secondOutput = oracle.getL2Output(secondOutputIndex);\n        Types.Bond memory secondBond = pool.getBond(secondOutputIndex);\n\n        // warp to the time the second output is finalized and the two bonds are expired.\n        vm.warp(secondBond.expiresAt);\n\n        vm.expectEmit(true, true, false, true, address(pool));\n        emit Unbonded(firstOutputIndex, firstOutput.submitter, firstBond.amount);\n        vm.expectCall(\n            address(pool.PORTAL()),\n            abi.encodeWithSelector(\n                KromaPortal.depositTransactionByValidatorPool.selector,\n                Predeploys.VALIDATOR_REWARD_VAULT,\n                pool.VAULT_REWARD_GAS_LIMIT(),\n                abi.encodeWithSelector(\n                    ValidatorRewardVault.reward.selector,\n                    firstOutput.submitter,\n                    firstOutput.l2BlockNumber\n                )\n            )\n        );\n        vm.expectEmit(true, true, false, true, address(pool));\n        emit Unbonded(secondOutputIndex, secondOutput.submitter, secondBond.amount);\n        vm.expectCall(\n            address(pool.PORTAL()),\n            abi.encodeWithSelector(\n                KromaPortal.depositTransactionByValidatorPool.selector,\n                Predeploys.VALIDATOR_REWARD_VAULT,\n                pool.VAULT_REWARD_GAS_LIMIT(),\n                abi.encodeWithSelector(\n                    ValidatorRewardVault.reward.selector,\n                    secondOutput.submitter,\n                    secondOutput.l2BlockNumber\n                )\n            )\n        );\n        vm.expectCall(\n            address(oracle),\n            abi.encodeWithSelector(\n                L2OutputOracle.setNextFinalizeOutputIndex.selector,\n                secondOutputIndex + 1\n            )\n        );\n        vm.prank(trusted);\n        pool.unbond();\n\n        // check whether bonds are deleted and trusted balance has increased.\n        for (uint256 i = 0; i < tries; i++) {\n            vm.expectRevert(\"ValidatorPool: the bond does not exist\");\n            pool.getBond(i);\n        }\n        assertEq(pool.balanceOf(trusted), deposit);\n    }\n\n    function test_unbond_maxUnbond_succeeds() external {\n        uint256 tries = maxUnbond + 1;\n        uint256 deposit = requiredBondAmount * tries;\n        vm.prank(trusted);\n        pool.deposit{ value: deposit }();\n\n        // submit (maxUnbond + 1) outputs, only trusted can submit outputs before at least one unbond.\n        uint256 blockNumber = 0;\n        uint128 expiresAt = 0;\n        for (uint256 i = 0; i < tries; i++) {\n            blockNumber = oracle.nextBlockNumber();\n            warpToSubmitTime();\n            expiresAt = uint128(block.timestamp + finalizationPeriodSeconds);\n            assertEq(pool.nextValidator(), trusted);\n            vm.prank(trusted);\n            mockOracle.addOutput(keccak256(abi.encode(blockNumber)), blockNumber);\n            vm.prank(address(oracle));\n            pool.createBond(i, expiresAt);\n            assertEq(pool.balanceOf(trusted), deposit - requiredBondAmount * (i + 1));\n        }\n\n        uint256 outputIndex = oracle.latestOutputIndex();\n        Types.Bond memory bond = pool.getBond(outputIndex);\n\n        // warp to the time the latest output is finalized and all bonds are expired.\n        vm.warp(bond.expiresAt);\n\n        vm.prank(trusted);\n        pool.unbond();\n\n        // check whether maxUnbond number of bonds are deleted and the last one is not.\n        for (uint256 i = 0; i < tries - 1; i++) {\n            vm.expectRevert(\"ValidatorPool: the bond does not exist\");\n            pool.getBond(i);\n        }\n        bond = pool.getBond(tries - 1);\n        assertEq(bond.amount, requiredBondAmount);\n\n        // check if next finalize output index is set correctly\n        assertEq(oracle.nextFinalizeOutputIndex(), outputIndex);\n    }\n\n    function test_unbond_notExpired_reverts() external {\n        test_createBond_succeeds();\n\n        vm.expectRevert(\"ValidatorPool: no bond that can be unbond\");\n        pool.unbond();\n    }\n\n    function test_unbond_noBond_reverts() external {\n        vm.expectRevert(\"ValidatorPool: no bond that can be unbond\");\n        pool.unbond();\n    }\n\n    function test_addPendingBond_succeeds() public {\n        test_createBond_succeeds();\n\n        uint256 outputIndex = oracle.latestOutputIndex();\n        Types.Bond memory bond = pool.getBond(outputIndex);\n\n        vm.prank(challenger);\n        pool.deposit{ value: bond.amount }();\n\n        vm.prank(oracle.COLOSSEUM());\n        vm.expectEmit(true, true, false, true, address(pool));\n        emit PendingBondAdded(outputIndex, challenger, bond.amount);\n        pool.addPendingBond(outputIndex, challenger);\n\n        // check bond state\n        assertEq(pool.getPendingBond(outputIndex, challenger), bond.amount);\n        assertEq(pool.balanceOf(challenger), 0);\n    }\n\n    function test_addPendingBond_noBond_reverts() external {\n        vm.prank(oracle.COLOSSEUM());\n        vm.expectRevert(\"ValidatorPool: the output is already finalized\");\n        pool.addPendingBond(0, challenger);\n    }\n\n    function test_addPendingBond_insufficientBalances_reverts() external {\n        test_createBond_succeeds();\n\n        uint256 outputIndex = oracle.latestOutputIndex();\n\n        vm.prank(oracle.COLOSSEUM());\n        vm.expectRevert(\"ValidatorPool: insufficient balances\");\n        pool.addPendingBond(outputIndex, challenger);\n    }\n\n    function test_increaseBond_succeeds() public {\n        test_addPendingBond_succeeds();\n\n        uint256 prevScBalance = pool.balanceOf(pool.SECURITY_COUNCIL());\n\n        uint256 outputIndex = oracle.latestOutputIndex();\n        Types.Bond memory prevBond = pool.getBond(outputIndex);\n        uint128 pendingBond = pool.getPendingBond(outputIndex, challenger);\n        uint128 tax = (pendingBond * 20) / 100; // 20% tax\n        uint128 increased = pendingBond - tax;\n\n        vm.prank(oracle.COLOSSEUM());\n        vm.expectEmit(true, true, false, false);\n        emit BondIncreased(outputIndex, challenger, increased);\n        pool.increaseBond(outputIndex, challenger);\n\n        // check bond state\n        assertEq(pool.getBond(outputIndex).amount, prevBond.amount + increased);\n        assertEq(pool.balanceOf(challenger), 0);\n\n        // check security council balance\n        assertEq(pool.balanceOf(pool.SECURITY_COUNCIL()), prevScBalance + tax);\n    }\n\n    function test_increaseBond_noBond_reverts() external {\n        vm.prank(oracle.COLOSSEUM());\n        vm.expectRevert(\"ValidatorPool: the output is already finalized\");\n        pool.increaseBond(0, challenger);\n    }\n\n    function test_increaseBond_noPendingBond_reverts() external {\n        test_createBond_succeeds();\n\n        vm.prank(oracle.COLOSSEUM());\n        vm.expectRevert(\"ValidatorPool: the pending bond does not exist\");\n        pool.increaseBond(0, challenger);\n    }\n\n    function test_releasePendingBond_succeeds() external {\n        test_addPendingBond_succeeds();\n\n        uint256 outputIndex = oracle.latestOutputIndex();\n        uint128 pendingBond = pool.getPendingBond(outputIndex, challenger);\n\n        vm.prank(oracle.COLOSSEUM());\n        vm.expectEmit(true, true, false, true, address(pool));\n        emit PendingBondReleased(outputIndex, challenger, challenger, pendingBond);\n        pool.releasePendingBond(outputIndex, challenger, challenger);\n\n        assertEq(pool.balanceOf(challenger), pendingBond);\n\n        vm.expectRevert(\"ValidatorPool: the pending bond does not exist\");\n        pool.getPendingBond(outputIndex, challenger);\n    }\n\n    function test_releasePendingBond_noPendingBond_succeeds() external {\n        vm.prank(oracle.COLOSSEUM());\n        vm.expectRevert(\"ValidatorPool: the pending bond does not exist\");\n        pool.releasePendingBond(0, challenger, challenger);\n    }\n\n    function test_getBond_succeeds() external {\n        test_createBond_succeeds();\n\n        uint256 outputIndex = oracle.latestOutputIndex();\n        Types.Bond memory bond = pool.getBond(outputIndex);\n\n        assertTrue(bond.amount > 0);\n        assertTrue(bond.expiresAt > block.timestamp);\n    }\n\n    function test_getBond_noBond_reverts() external {\n        vm.expectRevert(\"ValidatorPool: the bond does not exist\");\n        pool.getBond(0);\n    }\n\n    function test_balanceOf_succeeds() external {\n        vm.prank(trusted);\n        pool.deposit{ value: 1 }();\n\n        assertEq(pool.balanceOf(trusted), 1);\n        assertEq(pool.balanceOf(asserter), 0);\n        assertEq(pool.balanceOf(challenger), 0);\n    }\n\n    function test_isValidator_succeeds() external {\n        vm.prank(trusted);\n        pool.deposit{ value: requiredBondAmount }();\n        vm.prank(asserter);\n        pool.deposit{ value: requiredBondAmount - 1 }();\n\n        assertTrue(pool.isValidator(trusted));\n        assertFalse(pool.isValidator(asserter));\n        assertFalse(pool.isValidator(challenger));\n    }\n\n    function test_validatorCount_succeeds() external {\n        vm.prank(trusted);\n        pool.deposit{ value: requiredBondAmount }();\n        assertEq(pool.validatorCount(), 1);\n\n        vm.prank(asserter);\n        pool.deposit{ value: requiredBondAmount }();\n        assertEq(pool.validatorCount(), 2);\n\n        vm.prank(challenger);\n        pool.deposit{ value: requiredBondAmount - 1 }();\n        assertEq(pool.validatorCount(), 2);\n    }\n\n    function test_nextValidator_succeeds() external {\n        // deposit funds\n        vm.prank(trusted);\n        pool.deposit{ value: requiredBondAmount * 10 }();\n        vm.prank(asserter);\n        pool.deposit{ value: requiredBondAmount * 10 }();\n\n        address prev = pool.nextValidator();\n        assertEq(prev, trusted);\n\n        uint256 tries = 10;\n        uint256 outputIndex = 0;\n        uint256 blockNumber = 0;\n        uint128 expiresAt = 0;\n\n        // submit 10 outputs\n        for (uint256 i = 0; i < tries; i++) {\n            outputIndex = oracle.nextOutputIndex();\n            blockNumber = oracle.nextBlockNumber();\n            warpToSubmitTime();\n            expiresAt = uint128(block.timestamp + finalizationPeriodSeconds);\n            vm.prank(pool.nextValidator());\n            mockOracle.addOutput(keccak256(abi.encode(blockNumber)), blockNumber);\n            vm.prank(address(oracle));\n            pool.createBond(outputIndex, expiresAt);\n        }\n\n        // warp to first finalization time and submit new output\n        warpToSubmitTime();\n        outputIndex = oracle.nextOutputIndex();\n        blockNumber = (expiresAt / oracle.L2_BLOCK_TIME()) - 1;\n        vm.warp(expiresAt);\n        expiresAt = uint128(block.timestamp + finalizationPeriodSeconds);\n        vm.prank(pool.nextValidator());\n        mockOracle.addOutput(keccak256(abi.encode(blockNumber)), blockNumber);\n        vm.prank(address(oracle));\n        pool.createBond(outputIndex, expiresAt);\n\n        bool changed = false;\n        for (uint256 i = 0; i < tries - 1; i++) {\n            // check the next validator has changed\n            if (pool.nextValidator() != prev) {\n                changed = true;\n                break;\n            }\n\n            prev = pool.nextValidator();\n            // submit next output and finalize prev output\n            outputIndex = oracle.nextOutputIndex();\n            blockNumber = oracle.nextBlockNumber();\n            warpToSubmitTime();\n            expiresAt = uint128(block.timestamp + finalizationPeriodSeconds);\n            vm.prank(pool.nextValidator());\n            mockOracle.addOutput(keccak256(abi.encode(blockNumber)), blockNumber);\n            vm.prank(address(oracle));\n            pool.createBond(outputIndex, expiresAt);\n        }\n\n        assertTrue(changed, \"the next validator has not changed\");\n\n        // warp to public round\n        uint256 l2Timestamp = oracle.nextOutputMinL2Timestamp();\n        vm.warp(l2Timestamp + roundDuration + 1);\n        assertEq(pool.nextValidator(), Constants.VALIDATOR_PUBLIC_ROUND_ADDRESS);\n    }\n\n    function test_securityCouncilCannotBeValidator_succeeds() external {\n        address sc = pool.SECURITY_COUNCIL();\n        uint256 depositAmount = pool.REQUIRED_BOND_AMOUNT() * 100;\n        vm.deal(sc, depositAmount + 1 ether);\n\n        vm.prank(sc);\n        pool.deposit{ value: depositAmount }();\n        assertEq(pool.balanceOf(sc), depositAmount);\n        assertFalse(pool.isValidator(sc));\n    }\n}\n\ncontract ValidatorPool_SystemUpgrade_Test is ValidatorSystemUpgrade_Initializer {\n    MockL2OutputOracle mockOracle;\n    MockValidatorPool mockPool;\n\n    function setUp() public override {\n        super.setUp();\n\n        address oracleAddress = address(oracle);\n        MockL2OutputOracle mockOracleImpl = new MockL2OutputOracle(\n            pool,\n            valMgr,\n            address(colosseum),\n            submissionInterval,\n            l2BlockTime,\n            startingBlockNumber,\n            startingTimestamp,\n            finalizationPeriodSeconds\n        );\n        vm.prank(multisig);\n        Proxy(payable(oracleAddress)).upgradeTo(address(mockOracleImpl));\n        mockOracle = MockL2OutputOracle(oracleAddress);\n\n        address poolAddress = address(pool);\n        MockValidatorPool mockPoolImpl = new MockValidatorPool(\n            oracle,\n            mockPortal,\n            guardian,\n            trusted,\n            requiredBondAmount,\n            maxUnbond,\n            roundDuration,\n            terminateOutputIndex\n        );\n        vm.prank(multisig);\n        Proxy(payable(poolAddress)).upgradeTo(address(mockPoolImpl));\n        mockPool = MockValidatorPool(poolAddress);\n    }\n\n    function test_deposit_afterSystemUpgrade_reverts() external {\n        test_isTerminated_succeeds();\n\n        vm.deal(trusted, requiredBondAmount);\n\n        vm.prank(trusted);\n        vm.expectRevert(\"ValidatorPool: only can deposit to ValidatorPool before terminated\");\n        pool.deposit{ value: requiredBondAmount }();\n    }\n\n    function test_isTerminated_succeeds() public {\n        vm.prank(trusted);\n        pool.deposit{ value: trusted.balance }();\n\n        bool poolTerminated;\n        for (uint256 i; i <= terminateOutputIndex + 1; i++) {\n            uint256 nextOutputIndex = oracle.nextOutputIndex();\n            poolTerminated = pool.isTerminated(nextOutputIndex);\n            if (nextOutputIndex <= terminateOutputIndex) {\n                assertFalse(poolTerminated);\n            } else {\n                assertTrue(poolTerminated);\n            }\n\n            warpToSubmitTime();\n            uint256 nextBlockNumber = oracle.nextBlockNumber();\n            bytes32 outputRoot = keccak256(abi.encode(nextBlockNumber));\n            vm.prank(pool.nextValidator());\n            mockOracle.addOutput(outputRoot, nextBlockNumber);\n        }\n    }\n}\n"
    },
    "contracts/test/ValidatorRewardVault.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { ValidatorRewardVault } from \"../L2/ValidatorRewardVault.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\n\ncontract ValidatorRewardVault_Test is Bridge_Initializer {\n    ValidatorRewardVault internal vault =\n        ValidatorRewardVault(payable(Predeploys.VALIDATOR_REWARD_VAULT));\n    address internal constant recipient = address(256);\n    uint256 internal constant l2BlockNumber = 1800;\n\n    uint256 internal vaultBalance;\n    uint256 internal rewardDivider = 0;\n\n    event Rewarded(address indexed validator, uint256 indexed l2BlockNumber, uint256 amount);\n\n    event Withdrawal(uint256 value, address to, address from);\n\n    function setUp() public override {\n        super.setUp();\n\n        rewardDivider = oracle.FINALIZATION_PERIOD_SECONDS() / (submissionInterval * l2BlockTime);\n\n        vm.etch(\n            Predeploys.VALIDATOR_REWARD_VAULT,\n            address(new ValidatorRewardVault(address(pool), rewardDivider)).code\n        );\n        vm.label(Predeploys.VALIDATOR_REWARD_VAULT, \"ValidatorRewardVault\");\n\n        vaultBalance = rewardDivider * (vault.MIN_WITHDRAWAL_AMOUNT() + 10 ether);\n    }\n\n    function test_minWithdrawalAmount_succeeds() external {\n        assertEq(vault.MIN_WITHDRAWAL_AMOUNT(), 0);\n    }\n\n    function test_constructor_succeeds() external {\n        assertEq(vault.RECIPIENT(), address(0));\n        assertEq(vault.VALIDATOR_POOL(), address(pool));\n        assertEq(vault.REWARD_DIVIDER(), rewardDivider);\n    }\n\n    function test_receive_succeeds() external {\n        uint256 balance = address(vault).balance;\n\n        vm.prank(alice);\n        (bool success, ) = address(vault).call{ value: 100 }(hex\"\");\n\n        assertEq(success, true);\n        assertEq(address(vault).balance, balance + 100);\n    }\n\n    function test_reward_succeeds() external {\n        vm.deal(address(vault), vaultBalance);\n\n        uint256 reserved = vault.totalReserved();\n        uint256 balance = vault.balanceOf(recipient);\n        uint256 rewardAmount = (address(vault).balance - reserved) / rewardDivider;\n\n        vm.expectEmit(true, true, false, false, address(Predeploys.VALIDATOR_REWARD_VAULT));\n        emit Rewarded(recipient, l2BlockNumber, rewardAmount);\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(pool)));\n        vault.reward(recipient, l2BlockNumber);\n        // Check the balance was increased.\n        assertEq(vault.balanceOf(recipient), balance + rewardAmount);\n        assertEq(vault.totalReserved(), reserved + rewardAmount);\n    }\n\n    function test_reward_senderNotValidatorPool_reverts() external {\n        vm.expectRevert(\"ValidatorRewardVault: function can only be called from the ValidatorPool\");\n        vault.reward(address(0), 0);\n    }\n\n    function test_reward_zeroValidatorAddress_reverts() external {\n        vm.expectRevert(\"ValidatorRewardVault: validator address cannot be 0\");\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(pool)));\n        vault.reward(address(0), 0);\n    }\n\n    function test_reward_alreadyPaidBlockNumber_reverts() external {\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(pool)));\n        vault.reward(recipient, l2BlockNumber);\n\n        vm.expectRevert(\n            \"ValidatorRewardVault: the reward has already been paid for the L2 block number\"\n        );\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(pool)));\n        vault.reward(recipient, l2BlockNumber);\n    }\n\n    function test_withdraw_succeeds() external {\n        vm.deal(address(vault), vaultBalance);\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(pool)));\n        vault.reward(recipient, l2BlockNumber);\n\n        uint256 amount = vault.balanceOf(recipient);\n        uint256 reserved = vault.totalReserved();\n\n        // No ether has been withdrawn yet\n        assertEq(vault.totalProcessed(), 0);\n\n        vm.expectEmit(true, true, true, true, address(Predeploys.VALIDATOR_REWARD_VAULT));\n        emit Withdrawal(amount, recipient, recipient);\n\n        // The entire vault's balance is withdrawn\n        vm.expectCall(\n            Predeploys.L2_STANDARD_BRIDGE,\n            amount,\n            abi.encodeWithSelector(\n                StandardBridge.bridgeETHTo.selector,\n                recipient,\n                35_000,\n                bytes(\"\")\n            )\n        );\n\n        vm.prank(recipient);\n        vault.withdraw();\n        // The withdrawal was successful\n        assertEq(vault.totalProcessed(), amount);\n        // Check the total determined reward amount was decreased.\n        assertEq(vault.totalReserved(), reserved - amount);\n    }\n\n    function test_withdrawL2_succeeds() external {\n        vm.deal(address(vault), vaultBalance);\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(pool)));\n        vault.reward(recipient, l2BlockNumber);\n\n        uint256 amount = vault.balanceOf(recipient);\n        uint256 reserved = vault.totalReserved();\n\n        // No ether has been withdrawn yet\n        assertEq(vault.totalProcessed(), 0);\n\n        vm.expectEmit(true, true, true, true, address(Predeploys.VALIDATOR_REWARD_VAULT));\n        emit Withdrawal(amount, recipient, recipient);\n\n        uint256 prevBalance = recipient.balance;\n        vm.prank(recipient);\n        vault.withdrawToL2();\n        // The withdrawal was successful\n        assertEq(vault.totalProcessed(), amount);\n        // Check the total determined reward amount was decreased.\n        assertEq(vault.totalReserved(), reserved - amount);\n\n        assertEq(recipient.balance, prevBalance + amount);\n    }\n\n    function test_withdrawToProtocolVault_succeeds() external {\n        vm.deal(address(vault), vaultBalance);\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(pool)));\n        vault.reward(recipient, l2BlockNumber);\n\n        uint256 reserved = vault.totalReserved();\n        uint256 amount = vaultBalance - reserved;\n\n        // No ether has been withdrawn yet\n        assertEq(vault.totalProcessed(), 0);\n        assertGt(reserved, 0);\n\n        vm.expectEmit(true, true, true, true, address(Predeploys.VALIDATOR_REWARD_VAULT));\n        emit Withdrawal(amount, Predeploys.PROTOCOL_VAULT, recipient);\n\n        uint256 prevBalance = Predeploys.PROTOCOL_VAULT.balance;\n        vm.prank(recipient);\n        vault.withdrawToProtocolVault();\n\n        // The withdrawal was successful\n        assertEq(vault.totalProcessed(), amount);\n        assertEq(vault.totalReserved(), reserved);\n        assertEq(Predeploys.PROTOCOL_VAULT.balance, prevBalance + amount);\n    }\n\n    function test_balanceOf_succeeds() external {\n        vm.deal(address(vault), vaultBalance);\n        vm.prank(AddressAliasHelper.applyL1ToL2Alias(address(pool)));\n        vault.reward(recipient, l2BlockNumber);\n\n        uint256 expectedBalance = vaultBalance / vault.REWARD_DIVIDER();\n        assertEq(vault.balanceOf(recipient), expectedBalance);\n    }\n}\n"
    },
    "contracts/test/ZKMerkleTrie.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Portal_Initializer } from \"./CommonTest.t.sol\";\n\ncontract ZKMerkleTrie_Test is Portal_Initializer {\n    function test_verifyInclustionProof_valid_0() external {\n        bytes[] memory proofs = new bytes[](2);\n        proofs[\n            0\n        ] = hex\"012098f5fb9e239eab3ceac3f27b81e481dc3124d55ffed523a839ee8446b64864010100000000000000000000000000000000000000000000000000000000000000003039202098f5fb9e239eab3ceac3f27b81e481dc3124d55ffed523a839ee8446b64864\";\n        proofs[\n            1\n        ] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n        assertTrue(\n            zkMerkleTrie.verifyInclusionProof(\n                hex\"0000000000000000000000000000000000000000000000000000000000000000\",\n                hex\"0000000000000000000000000000000000000000000000000000000000003039\",\n                proofs,\n                hex\"1a71d0943087a54143a948ccb9d9f0bd07c99d3a4899c9ceeb890976c32186c1\"\n            )\n        );\n    }\n\n    function test_verifyInclustionProof_valid_1() external {\n        bytes[] memory proofs = new bytes[](8);\n        proofs[\n            0\n        ] = hex\"000ab62fdcebb5220c92b96d38cef426d805217d1760140b2b1eebecd436c8fcc50f3dcecebf602601ceb35f1996e70c802634bb3d7ccbc7ad6b923e00066e8b00\";\n        proofs[\n            1\n        ] = hex\"0006be779477fdea72fc037851ef2baa70afdeff1075cfaa3b4f385e9d2336afd42583e724fe0eb10e675ab6be869557ca5d2f9fc13de9274a0a1742236e349caf\";\n        proofs[\n            2\n        ] = hex\"000ded681649ba8fee8a5cb411c9a2d1c525e796ca2566cebf2c0244c2a66491662c67be5020784f6a1eb8d7f1bfc7d921455e231d9bd9f171dffa4202763e2d28\";\n        proofs[\n            3\n        ] = hex\"0009543051b94eaaf3560c2f33cd8bf9a9b93f712b1f9b41ab67cab4f12733a67d167c33ebb5960ce90cf4042434bc4f9cd75c5ecc46e250c5c4b06a76a4627b2b\";\n        proofs[\n            4\n        ] = hex\"0010c440dc7007099878005966c61e751fe67bafcdb37615213c8ff9d111b4f7251167fcaa928ceeb39b9318cea6306ac2cd6252f6ef8d96cfeffd937810b29b1a\";\n        proofs[\n            5\n        ] = hex\"00271dd669b4787c31020d57ee2b2e56ff139994b52bf56ecc9f7432a272ce5f78032d185fae0284cbf7292557e98dfd08dea8b108eb6e4289d803d2b7d2e74644\";\n        proofs[\n            6\n        ] = hex\"0109d279cfc7bcba04074acfebd9974c1d2c9516b2c1f18ec34ac3ed422158c8a8010100000000000000000000000000000000000000000000000000000000000000000018200e9449cefab8e4070797d09578e909e10a0ce4374ea5e4d4c608c2e11961af68\";\n        proofs[\n            7\n        ] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n        assertFalse(\n            zkMerkleTrie.verifyInclusionProof(\n                hex\"0000000000000000000000000000000000000000000000000000000000000005\",\n                hex\"0000000000000000000000000000000000000000000000000000000000000032\",\n                proofs,\n                hex\"0ef999685f185097340822d0b30f846398e641087ba3bcff823ed87538038943\"\n            )\n        );\n    }\n\n    function test_verifyInclustionProof_valid_2() external {\n        bytes[] memory proofs = new bytes[](8);\n        proofs[\n            0\n        ] = hex\"000ab62fdcebb5220c92b96d38cef426d805217d1760140b2b1eebecd436c8fcc50f3dcecebf602601ceb35f1996e70c802634bb3d7ccbc7ad6b923e00066e8b00\";\n        proofs[\n            1\n        ] = hex\"0006be779477fdea72fc037851ef2baa70afdeff1075cfaa3b4f385e9d2336afd42583e724fe0eb10e675ab6be869557ca5d2f9fc13de9274a0a1742236e349caf\";\n        proofs[\n            2\n        ] = hex\"0017c443967900c45fb5b11c7a40cfc8e4aa5c699f2f80add51e3cf998ed9872b80022374777da27caa6013c01e2cb3b2d974a998a4f38f2f25baa3c87ad12a007\";\n        proofs[\n            3\n        ] = hex\"0024622a111942a41d45c768f89da131621e0fa266b9b7e324d33e458702a2987e0e67ba58319668fa44fe1f5e20f5a7978e6577bcb1b9809e101224c2988edd38\";\n        proofs[\n            4\n        ] = hex\"00139b85edf9b10c2b2330eb06a1eeb66f2058a8d9cd6fea738157f951e8079905068c3814e7511d563e5bfea099e5368ee7a8e38e4856e85b45b33339621ff50c\";\n        proofs[\n            5\n        ] = hex\"000b1bb0d1d5eaa0e39a52d08db2e92b79294959ea25cef6757a4d54bff691fb902ee69c6f3bb0450146447b2f9865d2e396b7b9e7b37d7f2ff181c85941ef98cf\";\n        proofs[\n            6\n        ] = hex\"0117f011179feb4d1c750e4c139df9e5d1940dffa118c8d489c852389aa7afaf460101000000000000000000000000000000000000000000000000000000000000000000062017f011179feb4d1c750e4c139df9e5d1940dffa118c8d489c852389aa7afaf46\";\n        proofs[\n            7\n        ] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n        assertTrue(\n            zkMerkleTrie.verifyInclusionProof(\n                hex\"101e368776582e57ab3d116ffe2517c0a585cd5b23174b01e275c2d8329c3d83\",\n                hex\"0000000000000000000000000000000000000000000000000000000000000006\",\n                proofs,\n                hex\"0ef999685f185097340822d0b30f846398e641087ba3bcff823ed87538038943\"\n            )\n        );\n    }\n\n    function test_verifyInclustionProof_valid_3() external {\n        bytes[] memory proofs = new bytes[](9);\n        proofs[\n            0\n        ] = hex\"000ab62fdcebb5220c92b96d38cef426d805217d1760140b2b1eebecd436c8fcc50f3dcecebf602601ceb35f1996e70c802634bb3d7ccbc7ad6b923e00066e8b00\";\n        proofs[\n            1\n        ] = hex\"00064ef83727d84baa6f69e7b6d2aa09c06a0a684aee47027b0b364011ec29a61617909e79d23c9ffd920c6e0cb9929782348bcd170d8a5d806467fbcf9d56b437\";\n        proofs[\n            2\n        ] = hex\"0016b9762acc15c49266ff4561a8975cbd5e132ad5129caa0b811b374cff9480101152ad4e5c71d0348e3b9041315496011ab29e79a54851d0d79d7d03dd2423c8\";\n        proofs[\n            3\n        ] = hex\"0017ae8d541b010b836adb59a87754efee7740f33b96520754ca5f6f6ae9d3b73e09827fa4836bb60157a2e4e358d897b23d735c3b23f55490e76f2e6ae2b68b04\";\n        proofs[\n            4\n        ] = hex\"0016c3abb95e2baec8aab3dc244eac879d60ac0ef6275cd4fa5c3a526049fdeb8c11b76fb8c45df3936b13c24dff4da46b947a2844f06ac6221e8c8eb7feb32970\";\n        proofs[\n            5\n        ] = hex\"000ccffa8b08f54fc92c60c9c19f379d5759ecdd8fded0b24c2266be5a6fafb7c4295abf4ea1b55932420231efee9fe391a90b3fb077aee16e26ebba7997795e7f\";\n        proofs[\n            6\n        ] = hex\"0014ed76b6e85369cd2549423310e621bbcbcac05402162d085be4368168ca506b0000000000000000000000000000000000000000000000000000000000000000\";\n        proofs[7] = hex\"02\";\n        proofs[\n            8\n        ] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n        assertFalse(\n            zkMerkleTrie.verifyInclusionProof(\n                hex\"bc36789e7a1e281436464229828f817d6612f7b477d66591ff96a9e064bcc98a\",\n                hex\"0000000000000000000000000000000000000000000000000000000000000032\",\n                proofs,\n                hex\"0ef999685f185097340822d0b30f846398e641087ba3bcff823ed87538038943\"\n            )\n        );\n    }\n\n    function test_verifyInclustionProof_valid_4() external {\n        bytes[] memory proofs = new bytes[](13);\n        proofs[\n            0\n        ] = hex\"0007cbd8ed414f4c32c8f24bcd4a092ca1fc48c5dc95acb388fa3c08ec3422be2f11dd580249f54d7db79ee465707fa4e23c4287a4649248df30583903858aa90d\";\n        proofs[\n            1\n        ] = hex\"0023baa0bbc530f48f150951aa7670aa3c8f6570a5c763c05413a3e12a6c0b7cce10f98a7af3a8a73a3a20af4a000ef3663712967ec273a58e9ade9e661394c9d6\";\n        proofs[\n            2\n        ] = hex\"00284ac3e3a591145890ace584756f6ba06c701f395c8db9d0313adcdaf954270b006c473617966db462b9fd00299d683a15c0b74454ca7ac3ef2d8aa087ac7dac\";\n        proofs[\n            3\n        ] = hex\"00296063f48eb3a4f4ff8fdc10316f114be5bedfbf79c9c86d325f92ff877a1a532ff1456213f17f8b67c69ea1821714fc7fb5073bf7c1fc4f77adaec58d083c6e\";\n        proofs[\n            4\n        ] = hex\"002c58643b19811246202ac95ce7122cf63eb17687e12a670542c2bd76546184ef02acd9795883b244ab8c5c9b232c7a6f598ab360bcd5b6fdab4ca93250b74ce8\";\n        proofs[\n            5\n        ] = hex\"00015421c239dc34b78b2fa31b208aa368cd1eae4b98aa10ae03bc2c5b80cdd8ef2d6c19f2f3b16de567490f18819cae1e3f4ea29d2bc5c34400276cf57f0e3b63\";\n        proofs[\n            6\n        ] = hex\"002d961fc76c9c30673b93f089451bce1d3af8ada972ad8c735f60cd0e145751801962d7c2d9d222562ae4476172398601558339c4414a807d280ec23938fa6d78\";\n        proofs[\n            7\n        ] = hex\"0000000000000000000000000000000000000000000000000000000000000000000949fcaefea105109e6bd0c339373e06d8a7856fc82c3185041642ed42f07585\";\n        proofs[\n            8\n        ] = hex\"0014660f419e10516425d4f78bbf7457cfd1381fff1223606dc530792059176c3f20ae2c31258e0712e4e39ecd2eae272ec13fadb2f057027e7fad2b378fc249f6\";\n        proofs[\n            9\n        ] = hex\"00163340375c6665b9878b1443e55b943de727fd6ccb1647ec9ca2e09a0f6b81110000000000000000000000000000000000000000000000000000000000000000\";\n        proofs[\n            10\n        ] = hex\"00224e3507691f5789978473cf4a307908f5a08761112466f1cf970bc8fad921d9258216ceb8dffd636ddc9570e526bc6741d8f76e8f2d8cb843104656c8a93ae5\";\n        proofs[\n            11\n        ] = hex\"011fd5bbabb0ebd74c646925592018a1f5d06dd11a6b5be33f025241736e454087010100000000000000000000000000000000000000000000000000000000000000000005201fd5bbabb0ebd74c646925592018a1f5d06dd11a6b5be33f025241736e454087\";\n        proofs[\n            12\n        ] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n        assertTrue(\n            zkMerkleTrie.verifyInclusionProof(\n                hex\"2b232c97452f0950c94e2539fdc7e69d21166113cf7a9bcb99b220a3fe5d720a\",\n                hex\"0000000000000000000000000000000000000000000000000000000000000005\",\n                proofs,\n                hex\"122f20d691c10bf842b594733bdc73e6a67a131def85ef444ce58a18cc4cd757\"\n            )\n        );\n    }\n\n    function test_verifyInclustionProof_valid_5() external {\n        bytes[] memory proofs = new bytes[](11);\n        proofs[\n            0\n        ] = hex\"00284ec4ede7c4da8296ce6d515233c2eea76fd5c07116c56949fda88770fad4b811b40ba55c3d2ec14871670b38cec7c71ea67ddb0ceaa0fea936e8b6fd8e0511\";\n        proofs[\n            1\n        ] = hex\"000d12650b10e106a7644599be80c71ab31cf093d7f99c34d866315ca1c12972022409d4725c6af5e20a9e32a61d79e85571181d65c45dc10bfc11ba2857923830\";\n        proofs[\n            2\n        ] = hex\"00296bec9e31b0aa1c5128fca361dd3875609520c9b0c8e7dd73bda2a1313c18d72eed91ecfef85e13834fda24ddf9060a69eec25abba55115c517de9f8a4ee9ec\";\n        proofs[\n            3\n        ] = hex\"00131748240aea4f74ae3be5a6a9f11d6bbb3129241f36de98275c32423592de8b16c111e32818a1cdc9b30d4855817e3193945bbf2594291bb229d85d2ed81658\";\n        proofs[\n            4\n        ] = hex\"001cdea41e120cf4086d178996edcf44e2003f2d0225cbac864c7e60af23540f2f010f74b267d3bd19343889f0d2a525d7054c007e507c5ca0164be42f72215ff6\";\n        proofs[\n            5\n        ] = hex\"000ac5febcd01ab220937cef032f250f499fe68911bc094ebe5c7b8abb59e41dc6191416975dbc10cf89f6428771b2251e9023598fcbc59ad33be4f05c6e7b8eec\";\n        proofs[\n            6\n        ] = hex\"0026080a7dc62fc9fafc28adb4775111ee0d6818d6fc07375f751f602f0708a17f211fc5be39244df796912c7360f30219760366342a9c4306d710ec2bd2b5db39\";\n        proofs[\n            7\n        ] = hex\"0013867a8f88775425fc040b935515ce4966f9492956f96e7355fadfba44e1f67d0000000000000000000000000000000000000000000000000000000000000000\";\n        proofs[\n            8\n        ] = hex\"00233da726018d913514b4dd9398bc1a01c98b0a8ef4c33dc20efae3c38e1fe1912ef80e02108f98b180588ae6580404cfb5fb52b22ebfa1345da5654587b5aec5\";\n        proofs[\n            9\n        ] = hex\"012f6fdd1ad0dd1863abaa7b339f6f56b17a97720aeddd790f4507b95a5ef6df55010100000000000000000000000000000000000000000000000000000000000000000005202f6fdd1ad0dd1863abaa7b339f6f56b17a97720aeddd790f4507b95a5ef6df55\";\n        proofs[\n            10\n        ] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n        assertTrue(\n            zkMerkleTrie.verifyInclusionProof(\n                hex\"e2689cd4a84e23ad2f564004f1c9013e9589d260bde6380aba3ca7e09e4df40c\",\n                hex\"0000000000000000000000000000000000000000000000000000000000000005\",\n                proofs,\n                hex\"2f362a32462155cc2f9d2d7aa2f70c0c80cd3ff834c69de7bcc4fb2d493b0e9b\"\n            )\n        );\n    }\n\n    // Real withdrawal example\n    function test_verifyInclustionProof_valid_6() external {\n        bytes[] memory proofs = new bytes[](7);\n        proofs[\n            0\n        ] = hex\"002c4b1cef0d03c37f45c631f7fc85ea4b78eeb096708ea63bd810463e246f13d40eb41f1061285f9c13a21519bdb76cba404832d33945ad471fa215153d9b020d\";\n        proofs[\n            1\n        ] = hex\"0000000000000000000000000000000000000000000000000000000000000000001dc169aab556ca90e4a7c3365ab27ba5ca93d222cd9e25e3ae1e38b7bf3a9e94\";\n        proofs[\n            2\n        ] = hex\"0007dcec580d43183a7dbe05d3a5a1f8b3ce38d5bb22676dfa1439ab44219de2a0036b366d8dcd20a1872355bb66868eb50f78599e926963ca33d35b8535e9525b\";\n        proofs[\n            3\n        ] = hex\"0000000000000000000000000000000000000000000000000000000000000000001747ce9cfac94135832e7e7d983a44e894446ca8ff1e6bda10ebcdaae36eba3d\";\n        proofs[\n            4\n        ] = hex\"0020438463bdf532b3eaa113e69847b469b76425d47195ed7a41462a79ba6511f715cb3972fcd254f29388ca61de787fe3654d776941fb4eaf00a946e8d4c73720\";\n        proofs[\n            5\n        ] = hex\"0105a0af8df2be333495be279be0eb5ef7da41b240832f2d74d34631333cebc3ee0101000000000000000000000000000000000000000000000000000000000000000000012085359a58748add24fbe1c5aedbd158736f50a45baf8715b9f32c9432ea7c179a\";\n        proofs[\n            6\n        ] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n        assertTrue(\n            zkMerkleTrie.verifyInclusionProof(\n                hex\"85359a58748add24fbe1c5aedbd158736f50a45baf8715b9f32c9432ea7c179a\",\n                hex\"0000000000000000000000000000000000000000000000000000000000000001\",\n                proofs,\n                hex\"2830ab4d0fa292abe8f69ac23b8d98a9f9a950ace6ae50d0f77eefa01a644cb1\"\n            )\n        );\n    }\n}\n"
    },
    "contracts/test/invariants/CrossDomainMessenger.t.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { StdUtils } from \"forge-std/StdUtils.sol\";\nimport { Vm } from \"forge-std/Vm.sol\";\n\nimport { Constants } from \"../../libraries/Constants.sol\";\nimport { Encoding } from \"../../libraries/Encoding.sol\";\nimport { Hashing } from \"../../libraries/Hashing.sol\";\nimport { Predeploys } from \"../../libraries/Predeploys.sol\";\nimport { Types } from \"../../libraries/Types.sol\";\nimport { L1CrossDomainMessenger } from \"../../L1/L1CrossDomainMessenger.sol\";\nimport { KromaPortal } from \"../../L1/KromaPortal.sol\";\nimport { Messenger_Initializer } from \"../CommonTest.t.sol\";\n\ncontract RelayActor is StdUtils {\n    // Storage slot of the l2Sender\n    uint256 constant senderSlotIndex = 50;\n\n    uint256 public numHashes;\n    bytes32[] public hashes;\n    bool public reverted = false;\n\n    KromaPortal portal;\n    L1CrossDomainMessenger xdm;\n    Vm vm;\n    bool doFail;\n\n    constructor(\n        KromaPortal _portal,\n        L1CrossDomainMessenger _xdm,\n        Vm _vm,\n        bool _doFail\n    ) {\n        portal = _portal;\n        xdm = _xdm;\n        vm = _vm;\n        doFail = _doFail;\n    }\n\n    /**\n     * Relays a message to the `L1CrossDomainMessenger` with a random `_value`, and `_message`.\n     */\n    function relay(uint8 _value, bytes memory _message) external {\n        address target = address(0x04); // ID precompile\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        // Set the minimum gas limit to the cost of the identity precompile's execution for\n        // the given message.\n        // ID Precompile cost can be determined by calculating: 15 + 3 * data_word_length\n        uint32 minGasLimit = uint32(15 + 3 * ((_message.length + 31) / 32));\n\n        // set the value of portal.l2Sender() to be the L2 Cross Domain Messenger.\n        vm.store(address(portal), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n\n        // Restrict the value to the range of [0, 1]\n        // This is just so we get variance of calls with and without value. The ID precompile\n        // will not reject value being sent to it.\n        _value = _value % 2;\n\n        // If the message should succeed, supply it `baseGas`. If not, supply it an amount of\n        // gas that is too low to complete the call.\n        uint256 gas = doFail\n            ? bound(minGasLimit, 60_000, 80_000)\n            : xdm.baseGas(_message, minGasLimit);\n\n        // Compute the cross domain message hash and store it in `hashes`.\n        bytes32 _hash = Hashing.hashCrossDomainMessageV0(\n            Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n            sender,\n            target,\n            _value,\n            minGasLimit,\n            _message\n        );\n        hashes.push(_hash);\n        numHashes += 1;\n\n        // Make sure we've got a fresh message.\n        vm.assume(xdm.successfulMessages(_hash) == false && xdm.failedMessages(_hash) == false);\n\n        // Act as the kroma portal and call `relayMessage` on the `L1CrossDomainMessenger` with\n        // the outer min gas limit.\n        vm.startPrank(address(portal));\n        if (!doFail) {\n            vm.expectCallMinGas(address(0x04), _value, minGasLimit, _message);\n        }\n        try\n            xdm.relayMessage{ gas: gas, value: _value }(\n                Encoding.encodeVersionedNonce({ _nonce: 0, _version: 0 }),\n                sender,\n                target,\n                _value,\n                minGasLimit,\n                _message\n            )\n        {} catch {\n            // If any of these calls revert, set `reverted` to true to fail the invariant test.\n            // NOTE: This is to get around forge's invariant fuzzer ignoring reverted calls\n            // to this function.\n            reverted = true;\n        }\n        vm.stopPrank();\n    }\n}\n\ncontract XDM_MinGasLimits is Messenger_Initializer {\n    RelayActor actor;\n\n    function init(bool doFail) public virtual {\n        // Set up the `L1CrossDomainMessenger` and `KromaPortal` contracts.\n        super.setUp();\n\n        // Deploy a relay actor\n        actor = new RelayActor(portal, L1Messenger, vm, doFail);\n\n        // Give the portal some ether to send to `relayMessage`\n        vm.deal(address(portal), type(uint128).max);\n\n        // Target the `RelayActor` contract\n        targetContract(address(actor));\n\n        // Don't allow the estimation address to be the sender\n        excludeSender(Constants.ESTIMATION_ADDRESS);\n\n        // Target the actor's `relay` function\n        bytes4[] memory selectors = new bytes4[](1);\n        selectors[0] = actor.relay.selector;\n        targetSelector(FuzzSelector({ addr: address(actor), selectors: selectors }));\n    }\n}\n\ncontract XDM_MinGasLimits_Succeeds is XDM_MinGasLimits {\n    function setUp() public override {\n        // Don't fail\n        super.init(false);\n    }\n\n    /**\n     * @custom:invariant A call to `relayMessage` should succeed if at least the minimum gas limit\n     *                   can be supplied to the target context, there is enough gas to complete\n     *                   execution of `relayMessage` after the target context's execution is\n     *                   finished, and the target context did not revert.\n     *\n     * There are two minimum gas limits here:\n     *\n     * - The outer min gas limit is for the call from the `KromaPortal` to the\n     * `L1CrossDomainMessenger`,  and it can be retrieved by calling the xdm's `baseGas` function\n     * with the `message` and inner limit.\n     *\n     * - The inner min gas limit is for the call from the `L1CrossDomainMessenger` to the target\n     * contract.\n     */\n    function invariant_minGasLimits() external {\n        uint256 length = actor.numHashes();\n        for (uint256 i = 0; i < length; ++i) {\n            bytes32 hash = actor.hashes(i);\n            // The message hash is set in the successfulMessages mapping\n            assertTrue(L1Messenger.successfulMessages(hash));\n            // The message hash is not set in the failedMessages mapping\n            assertFalse(L1Messenger.failedMessages(hash));\n        }\n        assertFalse(actor.reverted());\n    }\n}\n\ncontract XDM_MinGasLimits_Reverts is XDM_MinGasLimits {\n    function setUp() public override {\n        // Do fail\n        super.init(true);\n    }\n\n    /**\n     * @custom:invariant A call to `relayMessage` should assign the message hash to the\n     *                   `failedMessages` mapping if not enough gas is supplied to forward\n     *                   `minGasLimit` to the target context or if there is not enough gas to\n     *                   complete execution of `relayMessage` after the target context's execution\n     *                   is finished.\n     *\n     * There are two minimum gas limits here:\n     *\n     * - The outer min gas limit is for the call from the `KromaPortal` to the\n     * `L1CrossDomainMessenger`,  and it can be retrieved by calling the xdm's `baseGas` function\n     * with the `message` and inner limit.\n     *\n     * - The inner min gas limit is for the call from the `L1CrossDomainMessenger` to the target\n     * contract.\n     */\n    function invariant_minGasLimits() external {\n        uint256 length = actor.numHashes();\n        for (uint256 i = 0; i < length; ++i) {\n            bytes32 hash = actor.hashes(i);\n            // The message hash is not set in the successfulMessages mapping\n            assertFalse(L1Messenger.successfulMessages(hash));\n            // The message hash is set in the failedMessages mapping\n            assertTrue(L1Messenger.failedMessages(hash));\n        }\n        assertFalse(actor.reverted());\n    }\n}\n"
    },
    "contracts/test/invariants/KromaPortal.t.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Types } from \"../../libraries/Types.sol\";\nimport { Portal_Initializer } from \"../CommonTest.t.sol\";\n\ncontract KromaPortal_Invariant_Harness is Portal_Initializer {\n    // Reusable default values for a test withdrawal\n    Types.WithdrawalTransaction _defaultTx;\n\n    uint256 _submittedOutputIndex;\n    uint256 _submittedBlockNumber;\n    bytes32 _stateRoot;\n    bytes32 _storageRoot;\n    bytes32 _outputRoot;\n    bytes32 _withdrawalHash;\n    bytes[] _withdrawalProof;\n    Types.OutputRootProof internal _outputRootProof;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        _defaultTx = Types.WithdrawalTransaction({\n            nonce: 0,\n            sender: alice,\n            target: bob,\n            value: 100,\n            gasLimit: 100_000,\n            data: hex\"\"\n        });\n        // Get withdrawal proof data we can use for testing.\n        (_stateRoot, _storageRoot, _outputRoot, _withdrawalHash, _withdrawalProof) = ffi\n            .getProveWithdrawalTransactionInputs(_defaultTx);\n\n        // Setup a dummy output root proof for reuse.\n        _outputRootProof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: _stateRoot,\n            messagePasserStorageRoot: _storageRoot,\n            blockHash: bytes32(uint256(0)),\n            nextBlockHash: bytes32(uint256(0))\n        });\n        _submittedBlockNumber = oracle.nextBlockNumber();\n        _submittedOutputIndex = oracle.nextOutputIndex();\n\n        // Configure the oracle to return the output root we've prepared.\n        warpToSubmitTime();\n        vm.prank(trusted);\n        oracle.submitL2Output(_outputRoot, _submittedBlockNumber, 0, 0);\n\n        // Warp beyond the finalization period for the block we've submitted.\n        vm.warp(\n            oracle.getL2Output(_submittedOutputIndex).timestamp +\n                oracle.FINALIZATION_PERIOD_SECONDS() +\n                1\n        );\n        // Fund the portal so that we can withdraw ETH.\n        vm.deal(address(portal), 0xFFFFFFFF);\n    }\n}\n\ncontract KromaPortal_CannotTimeTravel is KromaPortal_Invariant_Harness {\n    function setUp() public override {\n        super.setUp();\n\n        // Prove the withdrawal transaction\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Set the target contract to the portal proxy\n        targetContract(address(portal));\n        // Exclude the proxy multisig from the senders so that the proxy cannot be upgraded\n        excludeSender(address(multisig));\n    }\n\n    /**\n     * @custom:invariant `finalizeWithdrawalTransaction` should revert if the finalization\n     * period has not elapsed.\n     *\n     * A withdrawal that has been proven should not be able to be finalized until after\n     * the finalization period has elapsed.\n     */\n    function invariant_cannotFinalizeBeforePeriodHasPassed() external {\n        vm.expectRevert(\"KromaPortal: proven withdrawal finalization period has not elapsed\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n    }\n}\n\ncontract KromaPortal_CannotFinalizeTwice is KromaPortal_Invariant_Harness {\n    function setUp() public override {\n        super.setUp();\n\n        // Prove the withdrawal transaction\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Warp past the finalization period.\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Finalize the withdrawal transaction.\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        // Set the target contract to the portal proxy\n        targetContract(address(portal));\n        // Exclude the proxy multisig from the senders so that the proxy cannot be upgraded\n        excludeSender(address(multisig));\n    }\n\n    /**\n     * @custom:invariant `finalizeWithdrawalTransaction` should revert if the withdrawal\n     * has already been finalized.\n     *\n     * Ensures that there is no chain of calls that can be made that allows a withdrawal\n     * to be finalized twice.\n     */\n    function invariant_cannotFinalizeTwice() external {\n        vm.expectRevert(\"KromaPortal: withdrawal has already been finalized\");\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n    }\n}\n\ncontract KromaPortal_CanAlwaysFinalizeAfterWindow is KromaPortal_Invariant_Harness {\n    function setUp() public override {\n        super.setUp();\n\n        // Prove the withdrawal transaction\n        portal.proveWithdrawalTransaction(\n            _defaultTx,\n            _submittedOutputIndex,\n            _outputRootProof,\n            _withdrawalProof\n        );\n\n        // Warp past the finalization period.\n        vm.warp(block.timestamp + oracle.FINALIZATION_PERIOD_SECONDS() + 1);\n\n        // Set the target contract to the portal proxy\n        targetContract(address(portal));\n        // Exclude the proxy multisig from the senders so that the proxy cannot be upgraded\n        excludeSender(address(multisig));\n    }\n\n    /**\n     * @custom:invariant A withdrawal should **always** be able to be finalized\n     * `FINALIZATION_PERIOD_SECONDS` after it was successfully proven.\n     *\n     * This invariant asserts that there is no chain of calls that can be made that\n     * will prevent a withdrawal from being finalized exactly `FINALIZATION_PERIOD_SECONDS`\n     * after it was successfully proven.\n     */\n    function invariant_canAlwaysFinalize() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n\n        portal.finalizeWithdrawalTransaction(_defaultTx);\n\n        assertEq(address(bob).balance, bobBalanceBefore + _defaultTx.value);\n    }\n}\n"
    },
    "contracts/test/invariants/L2OutputOracle.t.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Vm } from \"forge-std/Vm.sol\";\n\nimport { L2OutputOracle } from \"../../L1/L2OutputOracle.sol\";\nimport { L2OutputOracle_Initializer } from \"../CommonTest.t.sol\";\n\ncontract L2OutputOracle_Validator {\n    L2OutputOracle internal oracle;\n    Vm internal vm;\n\n    constructor(L2OutputOracle _oracle, Vm _vm) {\n        oracle = _oracle;\n        vm = _vm;\n    }\n\n    /**\n     * @dev Allows the actor to submit an L2 output to the `L2OutputOracle`\n     */\n    function submitL2Output(\n        bytes32 _outputRoot,\n        uint256 _l2BlockNumber,\n        bytes32 _l1BlockHash,\n        uint256 _l1BlockNumber\n    ) external {\n        // Act as the validator and submit a new output.\n        vm.prank(oracle.VALIDATOR_POOL().nextValidator());\n        oracle.submitL2Output(_outputRoot, _l2BlockNumber, _l1BlockHash, _l1BlockNumber);\n    }\n}\n\ncontract L2OutputOracle_MonotonicBlockNumIncrease_Invariant is L2OutputOracle_Initializer {\n    L2OutputOracle_Validator internal actor;\n\n    function setUp() public override {\n        super.setUp();\n\n        // Create a sequencer actor.\n        actor = new L2OutputOracle_Validator(oracle, vm);\n\n        // Set the target contract to the validator actor\n        targetContract(address(actor));\n\n        // Set the target selector for `submitL2Output`\n        // `submitL2Output` is the only function we care about, as it is the only function\n        // that can modify the `l2Outputs` array in the oracle.\n        bytes4[] memory selectors = new bytes4[](1);\n        selectors[0] = actor.submitL2Output.selector;\n        FuzzSelector memory selector = FuzzSelector({ addr: address(actor), selectors: selectors });\n        targetSelector(selector);\n    }\n\n    /**\n     * @custom:invariant The block number of the checkpoint output should monotonically\n     * increase.\n     *\n     * When a new output is submitted, it should never be allowed to correspond to a block\n     * number that is less than the current output.\n     */\n    function invariant_monotonicBlockNumIncrease() external {\n        // Assert that the block number of checkpoint output must monotonically increase.\n        assertTrue(oracle.nextBlockNumber() >= oracle.latestBlockNumber());\n    }\n}\n"
    },
    "contracts/test/invariants/SafeCall.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { StdUtils } from \"forge-std/StdUtils.sol\";\nimport { Test } from \"forge-std/Test.sol\";\nimport { Vm } from \"forge-std/Vm.sol\";\n\nimport { SafeCall } from \"../../libraries/SafeCall.sol\";\n\ncontract SafeCall_Succeeds_Invariants is Test {\n    SafeCaller_Actor actor;\n\n    function setUp() public {\n        // Create a new safe caller actor.\n        actor = new SafeCaller_Actor(vm, false);\n\n        // Set the caller to this contract\n        targetSender(address(this));\n\n        // Target the safe caller actor.\n        targetContract(address(actor));\n\n        // Give the actor some ETH to work with\n        vm.deal(address(actor), type(uint128).max);\n    }\n\n    /**\n     * @custom:invariant If `callWithMinGas` performs a call, then it must always\n     * provide at least the specified minimum gas limit to the subcontext.\n     *\n     * If the check for remaining gas in `SafeCall.callWithMinGas` passes, the\n     * subcontext of the call below it must be provided at least `minGas` gas.\n     */\n    function invariant_callWithMinGas_alwaysForwardsMinGas_succeeds() public {\n        assertEq(actor.numCalls(), 0, \"no failed calls allowed\");\n    }\n\n    function performSafeCallMinGas(address to, uint64 minGas) external payable {\n        SafeCall.callWithMinGas(to, minGas, msg.value, hex\"\");\n    }\n}\n\ncontract SafeCall_Fails_Invariants is Test {\n    SafeCaller_Actor actor;\n\n    function setUp() public {\n        // Create a new safe caller actor.\n        actor = new SafeCaller_Actor(vm, true);\n\n        // Set the caller to this contract\n        targetSender(address(this));\n\n        // Target the safe caller actor.\n        targetContract(address(actor));\n\n        // Give the actor some ETH to work with\n        vm.deal(address(actor), type(uint128).max);\n    }\n\n    /**\n     * @custom:invariant `callWithMinGas` reverts if there is not enough gas to pass\n     * to the subcontext.\n     *\n     * If there is not enough gas in the callframe to ensure that `callWithMinGas`\n     * can provide the specified minimum gas limit to the subcontext of the call,\n     * then `callWithMinGas` must revert.\n     */\n    function invariant_callWithMinGas_neverForwardsMinGas_reverts() public {\n        assertEq(actor.numCalls(), 0, \"no successful calls allowed\");\n    }\n\n    function performSafeCallMinGas(address to, uint64 minGas) external payable {\n        SafeCall.callWithMinGas(to, minGas, msg.value, hex\"\");\n    }\n}\n\ncontract SafeCaller_Actor is StdUtils {\n    bool internal immutable FAILS;\n\n    Vm internal vm;\n    uint256 public numCalls;\n\n    constructor(Vm _vm, bool _fails) {\n        vm = _vm;\n        FAILS = _fails;\n    }\n\n    function performSafeCallMinGas(\n        uint64 gas,\n        uint64 minGas,\n        address to,\n        uint8 value\n    ) external {\n        // Only send to EOAs - we exclude the console as it has no code but reverts when called\n        // with a selector that doesn't exist due to the foundry hook.\n        vm.assume(to.code.length == 0 && to != 0x000000000000000000636F6e736F6c652e6c6f67);\n\n        // Bound the minimum gas amount to [2500, type(uint48).max]\n        minGas = uint64(bound(minGas, 2500, type(uint48).max));\n        if (FAILS) {\n            // Bound the gas passed to [minGas, ((minGas * 64) / 63)]\n            gas = uint64(bound(gas, minGas, (minGas * 64) / 63));\n        } else {\n            // Bound the gas passed to\n            // [((minGas * 64) / 63) + 40_000 + 1000, type(uint64).max]\n            // The extra 1000 gas is to account for the gas used by the `SafeCall.call` call\n            // itself.\n            gas = uint64(bound(gas, ((minGas * 64) / 63) + 40_000 + 1000, type(uint64).max));\n        }\n\n        vm.expectCallMinGas(to, value, minGas, hex\"\");\n        bool success = SafeCall.call(\n            msg.sender,\n            gas,\n            value,\n            abi.encodeWithSelector(\n                SafeCall_Succeeds_Invariants.performSafeCallMinGas.selector,\n                to,\n                minGas\n            )\n        );\n\n        if (success && FAILS) numCalls++;\n        if (!FAILS && !success) numCalls++;\n    }\n}\n"
    },
    "contracts/test/invariants/SystemConfig.t.sol": {
      "content": "pragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\n\nimport { SystemConfig } from \"../../L1/SystemConfig.sol\";\nimport { ResourceMetering } from \"../../L1/ResourceMetering.sol\";\nimport { Constants } from \"../../libraries/Constants.sol\";\n\ncontract SystemConfig_GasLimitLowerBound_Invariant is Test {\n    SystemConfig public config;\n\n    function setUp() public {\n        ResourceMetering.ResourceConfig memory cfg = Constants.DEFAULT_RESOURCE_CONFIG();\n\n        config = new SystemConfig({\n            _owner: address(0xbeef),\n            _overhead: 2100,\n            _scalar: 1000000,\n            _batcherHash: bytes32(hex\"abcd\"),\n            _gasLimit: 30_000_000,\n            _unsafeBlockSigner: address(1),\n            _config: cfg,\n            _validatorRewardScalar: 5000\n        });\n\n        // Set the target contract to the `config`\n        targetContract(address(config));\n        // Set the target sender to the `config`'s owner (0xbeef)\n        targetSender(address(0xbeef));\n        // Set the target selector for `setGasLimit`\n        // `setGasLimit` is the only function we care about, as it is the only function\n        // that can modify the gas limit within the SystemConfig.\n        bytes4[] memory selectors = new bytes4[](1);\n        selectors[0] = config.setGasLimit.selector;\n        FuzzSelector memory selector = FuzzSelector({\n            addr: address(config),\n            selectors: selectors\n        });\n        targetSelector(selector);\n    }\n\n    /**\n     * @custom:invariant The gas limit of the `SystemConfig` contract can never be lower\n     * than the hard-coded lower bound.\n     */\n    function invariant_gasLimitLowerBound() external {\n        assertTrue(config.gasLimit() >= config.minimumGasLimit());\n    }\n}\n"
    },
    "contracts/test/testdata/ColosseumTestData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport { Hashing } from \"../../libraries/Hashing.sol\";\nimport { Types } from \"../../libraries/Types.sol\";\nimport { RLPWriter } from \"../../libraries/rlp/RLPWriter.sol\";\nimport { Colosseum } from \"../../L1/Colosseum.sol\";\n\nlibrary ColosseumTestData {\n    uint256 internal constant INVALID_BLOCK_NUMBER = 21;\n    bytes32 internal constant PREV_OUTPUT_ROOT =\n        0xa6b4cc150f0c24daf8b5803491addbe102a388cf1ccec74fbe103a2deb5004e6;\n    bytes32 internal constant TARGET_OUTPUT_ROOT =\n        0x1ce4527b414c9e5d9edd26e488665f5f0f28c8e75dc622328c66776c93901e87;\n\n    function outputRootProof()\n        internal\n        pure\n        returns (Types.OutputRootProof memory, Types.OutputRootProof memory)\n    {\n        Types.OutputRootProof memory src = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: 0x263975548df46f3ffc739f602b503f32b4c522026c8c93204929ddd5b65ad202,\n            messagePasserStorageRoot: 0x24f53397bd92b66fda812b6e1191a00b60fc8e304033518006cbeedcab7f2127,\n            blockHash: 0x3392758b5bca8b8319df6180c145ca28152f1b6a3af977bc48ec67d2259dbcd2,\n            nextBlockHash: 0x4ecf76378ef03e3a417ac169cb052a879424345c59765aca05fe1fb6259375a9\n        });\n\n        Types.OutputRootProof memory dst = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: 0x0475b3d38492c9e58190616eaad4ab033942aa55747d49c5a614b9e751998d5e,\n            messagePasserStorageRoot: 0x24f53397bd92b66fda812b6e1191a00b60fc8e304033518006cbeedcab7f2127,\n            blockHash: 0x4ecf76378ef03e3a417ac169cb052a879424345c59765aca05fe1fb6259375a9,\n            nextBlockHash: 0x6c4e19b1fc27f6a075c67f35bd15b21c40025a892e32cdb8d9b5f5d5ec60093a\n        });\n\n        return (src, dst);\n    }\n\n    function publicInput() internal pure returns (Types.PublicInput memory) {\n        bytes32[] memory txHashes = new bytes32[](1);\n        txHashes[0] = 0x17deafc4c886b90706f3191fa8ecd152f34ce4fbc36ca35e6de899eb0fc7d86d;\n\n        return\n            Types.PublicInput({\n                blockHash: 0x4ecf76378ef03e3a417ac169cb052a879424345c59765aca05fe1fb6259375a9,\n                parentHash: 0x3392758b5bca8b8319df6180c145ca28152f1b6a3af977bc48ec67d2259dbcd2,\n                timestamp: 0x66471e21,\n                number: 0x15,\n                gasLimit: 0x1c9c380,\n                baseFee: 0x1,\n                transactionsRoot: 0xb01bdd77e9685c8341733f345113daa34c25a63a37cb76b81de492b36b0cc806,\n                stateRoot: 0x0475b3d38492c9e58190616eaad4ab033942aa55747d49c5a614b9e751998d5e,\n                withdrawalsRoot: 0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421,\n                txHashes: txHashes,\n                blobGasUsed: 0x0,\n                excessBlobGas: 0x0,\n                parentBeaconRoot: 0x3eeb016384502029f0dc9cc6188d4e5ca8b6547f755b7cfa3749d7512f98c41b\n            });\n    }\n\n    function blockHeaderRLP() internal pure returns (Types.BlockHeaderRLP memory) {\n        return\n            Types.BlockHeaderRLP({\n                uncleHash: RLPWriter.writeBytes(\n                    hex\"1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\"\n                ),\n                coinbase: RLPWriter.writeAddress(address(0)),\n                receiptsRoot: RLPWriter.writeBytes(\n                    hex\"886c02379eee108cab1ada4055c4f82b048b7e3bbce0d82bf532c95409d8ad81\"\n                ),\n                logsBloom: RLPWriter.writeBytes(\n                    hex\"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n                ),\n                difficulty: RLPWriter.writeUint(0),\n                gasUsed: RLPWriter.writeUint(0xc9f4),\n                extraData: RLPWriter.writeBytes(hex\"\"),\n                mixHash: RLPWriter.writeBytes(\n                    hex\"8bb2786563ea29f638e4e9758d9886e8a1af5b4f7688f4ee6622a6b53df87742\"\n                ),\n                nonce: RLPWriter.writeBytes(hex\"0000000000000000\")\n            });\n    }\n\n    struct ProofPair {\n        uint256[] proof;\n        uint256[] pair;\n    }\n\n    function proofAndPair() internal pure returns (ProofPair memory pp) {\n        pp.proof = new uint256[](145);\n        pp.proof[0] = 0x2fdc701e2fc2653e7cde260b104d358633ea35479f3566f37236e75706d54f33;\n        pp.proof[1] = 0x20e163bada0a37e8fa3deb9351bd0650666c4d647e53fe32b922ae1c9d101e51;\n        pp.proof[2] = 0x2ff90e2299ff8b41bd46c28886f942b13b3403ba00ce4e3508315bb2f0817d73;\n        pp.proof[3] = 0x1319ef5829fa99343eabdf8ec2c71ab7c90d1bc9ae4fc5b11997804ca774c094;\n        pp.proof[4] = 0x141c2b685b2f50ec83d52a949a12cdb4f68c16256c0a702d89c1213f7963ba83;\n        pp.proof[5] = 0x2f5ba8155cc1b933bf562e927360806745e091357004fbaf4ce48af303237dab;\n        pp.proof[6] = 0x1a9db5518083f55faaf5cf4a39ef6f8e807e2a552ed2497f625dc86cecfa9d96;\n        pp.proof[7] = 0x4381419865b3d502c7948d6e3386051cd3ca8ac2babb61114226cb656aadc40;\n        pp.proof[8] = 0x26bdb01d53248faa5f6be5f84261843bdf98d32663daea2a208368722e82041f;\n        pp.proof[9] = 0x10b113efa8cde6008d954837725d669f7fd871323630cd2215ab7f1e3f328dc6;\n        pp.proof[10] = 0x1060475bdb157d3408970d16783d31ade2c5e9a743083210edeeaf304139ec48;\n        pp.proof[11] = 0x2dfb8e2a8f6d25affde058ef2328e054049b1d2ae766f17ac776206132c5f4;\n        pp.proof[12] = 0x1f608debd4be61572a326a19889bc5bb262af977f71cc8c32da457d3d9c1dbb2;\n        pp.proof[13] = 0x241fcc502979e0fb4139840b856eb1a44b510b335c0150e9af78cdfacc0fa09b;\n        pp.proof[14] = 0x2b1d57c633994b351bc7801ec2195577ca30b6f98f7c77df377bbd18266483fd;\n        pp.proof[15] = 0xc0d2689f57f47d90dcb2e45d381469e7c6f80780591f2c2c43d59f6451ac010;\n        pp.proof[16] = 0x7bf445b712435740eec5b3efcc35f62c917e7b925d00542de540e046c91f8c6;\n        pp.proof[17] = 0x12c0b193bc80ea8e404ae09938fc5c5da4ee9dcb6798bae4e014c85fbab14258;\n        pp.proof[18] = 0x227783555f99aa8e7908858ab92eb31ebe282a172a84daf72fc1f30d4ade3d72;\n        pp.proof[19] = 0x22edfc50c8356b43de0aec9afca9f51f67dc8a971208a2a274ea507753b64e83;\n        pp.proof[20] = 0x2b63bdc3622cbaa0f3f3e863a3360176b3cf3eb5ccdff40fa7acfced95527199;\n        pp.proof[21] = 0x2f56d4df46eff6bdbe0f25410a5220b772a0a1894afae426d1ebe859bcd9e4e;\n        pp.proof[22] = 0x17781b72fe5e7f7dafaedf62df1f94623dd8abe939ce877d9e400a1d10fb3e40;\n        pp.proof[23] = 0x203019ca6ca965d10ec5abccbefd6abb484c7fc1ee42c921497f4e1c53718794;\n        pp.proof[24] = 0x25cae74ac841cf4235753c0fd94f88c672c102e4e75cea7c1606f5e58223cd2b;\n        pp.proof[25] = 0x24fad6f1bbbb053ec3a295cc29db23428ba6a33f2255beff698701ad0fb117b0;\n        pp.proof[26] = 0x456b2f41d1ec50c0683e5f98bebefe05cd44f916524ab960a0000fc208524e3;\n        pp.proof[27] = 0x216aa9d63e33e43130b2abc0a829e2e0fabf844d317856e2eb9005a7ff1d5849;\n        pp.proof[28] = 0x5d7f3f092ce02ada2e2c6d77726c1d720cc05030990ed1ecb62266c02cc0819;\n        pp.proof[29] = 0xc51b37fbab31153457b435bf059d8635692aa09ff4f97679176e141b5a82833;\n        pp.proof[30] = 0x8530008500b253bdc4c97b72cc03184f37b4bb8fac18408d4efec3951548bdc;\n        pp.proof[31] = 0x2712e1db9b893cf074456318e1eb5d32ccd823e0e90932af865d80892e9d147c;\n        pp.proof[32] = 0x18b0fd7ea5064b1dd2827b5ba99b68d1a622002c46b6ff1e22edb22cc296643;\n        pp.proof[33] = 0x26b4c4b2e4f1c1f5ff0d10d9b68b60710ed456841554c45391be0a91c0b66f1;\n        pp.proof[34] = 0x733daf05b53f092db2567b03f0cf6df2c195c258ca8893618719a2f5395e09e;\n        pp.proof[35] = 0x298fcccf5cb83a796f43906c6d8cd2202e8040b63cec6f66d4d9aec401461f3b;\n        pp.proof[36] = 0x2973feb364253d4217e068d4e3657b187fd6ec0009a665fa80295355addd23d7;\n        pp.proof[37] = 0x1ce601db03a8e98f2fa26bee2377d6f00ab229f8606dc97db0619567d19e1b6a;\n        pp.proof[38] = 0x169e40d328ea51375e431384cde7e81130730c0814a9e283ac32b09810ae374;\n        pp.proof[39] = 0x8a3453625b283e4a321a24fd24bc2b9b03bfc6dbf00a1f4741cb4ccc6fe2273;\n        pp.proof[40] = 0x1cf1ee4719170cc23d0a1287cc384c9be5fa566de5861d24cd6f4202f6a0d67e;\n        pp.proof[41] = 0x1af131d0b74c4a6b36b6d339edd46b184ef0d09c625f18c981c7cce975973c7b;\n        pp.proof[42] = 0x104c0df3e11629330e9dde22eca39f1b82c96dc18bab150c83bfc96de824613f;\n        pp.proof[43] = 0x6a5dca3e358382ff75fa88c8a383293d2b8dba8bff01e2b6df2fde3c88724f5;\n        pp.proof[44] = 0x26cf560f8fef9766dfaa33fa525ea92f77181903ae9464e3367c97c7574366a2;\n        pp.proof[45] = 0x3d4f9c9990c2045d8b84edf3076ec4cda1f63f5badb298a022079a934025012;\n        pp.proof[46] = 0x1ceb5ec3210e5e239cd464fedef910c22e0e7fb1d25b1c18f79eaa5ebd59eed9;\n        pp.proof[47] = 0x2b5011a3752039e5225664bb6c06d8ebef4a3672fb116561b52f817856e41cff;\n        pp.proof[48] = 0x156abfab2abf6cac084b854d79889247d305d4b1f63721006d6f6db717a23c40;\n        pp.proof[49] = 0x427ff2078978fbf3b042ba5f0f5b42a77ca1e519f240fa954102b430eda6a1b;\n        pp.proof[50] = 0x2e69577fc75810032736717b82449d7b0e0634b7a7ef0e68c5e67546f19882cf;\n        pp.proof[51] = 0x2af6acdde4a3f844f382cec882bed33276e30da371a9bcec34b9c56665c3eb49;\n        pp.proof[52] = 0x91c725d1a56e7c71473370e410f0233e42cc01e4919e126849bfdc7869015b6;\n        pp.proof[53] = 0x1afc040523ffdc20c41e9b0086f6df66881c5362fb762ff606d7bbef67dba411;\n        pp.proof[54] = 0x32912137bd17d268da4c0cf3e63809ff5dbfb2d50c51fc3a8193dbb3c32c9fd;\n        pp.proof[55] = 0x2633048356c7474beb41e70683501398ad590f3bb2a775c1396e8d87bdf4707b;\n        pp.proof[56] = 0x1;\n        pp.proof[57] = 0x2;\n        pp.proof[58] = 0x19298d85b22c5b64d151af4eec207d3118151bbd114f9e30895826c3e9470dc7;\n        pp.proof[59] = 0x2e9211c354feb0844ce9c26e3821565b4df0600692c897244b6fe435e509bf62;\n        pp.proof[60] = 0x15127a0bcac2120d31681d94be04b1aab00f275c7a26d9d6401515483597fd7a;\n        pp.proof[61] = 0x15e1889388505f334245ad0d8da8012d4b6526e3340acc49db00925d38fdb235;\n        pp.proof[62] = 0x2774408029a42a6d71d4c85900ee16d2331e17d7ce421cbdca566a7effe1edbd;\n        pp.proof[63] = 0x135916e1edf74f527c2eeb6930db2ff0203373615c5d1d425316ae1ac4101b4f;\n        pp.proof[64] = 0x167266dcde80b5d1c40449502c52f735df68fcab9234e5b6e7d1103c6556088a;\n        pp.proof[65] = 0xe362ea0a8a858e86087a9b82ad1f3fea26a6d1cedf664cb0b10a88a168650e1;\n        pp.proof[66] = 0x1abd7878d55ce08f61618d3e946ee81f00365aaf9e3b31a0945b4866a146958a;\n        pp.proof[67] = 0x1117c3b387d6a82ba670f0c75f0ea6dd970dd7bcf6d09f9abe6cec3f57699363;\n        pp.proof[68] = 0x2ae4acf945ce936cf5db0aef46a5e84d2d239bee157f3d71c8d9ad629dacbc6c;\n        pp.proof[69] = 0x2e3ddb4048d19c973d02097eb52ee61c8f3c0a66e23cd51b96df90fc30e48f67;\n        pp.proof[70] = 0x171b8ec0e608f6ee8c60e9ed6846b0131873183b0255041a4c32e4c072f0c607;\n        pp.proof[71] = 0x6b2f713fe8dbf616f7250105434d2bd1d7668801a9f0758f0286de930e74755;\n        pp.proof[72] = 0x1e8ff17e7e7685971522c73910148843c4b1e193e499976a98e42fcdfe9a66c7;\n        pp.proof[73] = 0x28130ff5a8302b3be6f879c29c4b3a911dfb591559e065f7863d7f2d4e20a06d;\n        pp.proof[74] = 0x203119f6880c100978e57a16928ceb499a338100280b77304fc2a683b875acf6;\n        pp.proof[75] = 0x2b6d77c422e3a09cf1195a9e06d72a42fa0b8756f3f7da1e3d6d73eda861ab21;\n        pp.proof[76] = 0x2995100f21ebbb0ed55238beff3fb1589fae216956799fb95c7d5c5bd8ad1062;\n        pp.proof[77] = 0x3392ab37e6cb61bcce3ef65baee748d182f82d416017bd1919da44e6cfa06c2;\n        pp.proof[78] = 0x21b7fb3ec98d689f8dbb33b8dc997fe519e6cf42842becb41bdd6207fbf31a15;\n        pp.proof[79] = 0x640ac8f555cfbd8187de1798619fb582166a4e2289c385b93458338345be1c9;\n        pp.proof[80] = 0x2934c513819aef27feab1675716a0f6778dbe068954910871502a053172a604a;\n        pp.proof[81] = 0x1328a5dccc432984b4ae5008071399613afc0b3b70bb69955e6102f6bb6dc755;\n        pp.proof[82] = 0x2a2d8b64cd5715da065355649dc8799193da4a80ba050f288b4fcf7e9d84ee55;\n        pp.proof[83] = 0xdf39890daa9d5f31323e8e5196aed99738d0b5befbb2d18b62a9321034475f6;\n        pp.proof[84] = 0x256544ba5be9d8b2baef20431320c6b6f7e350fda0251be39e3328c5252bbef7;\n        pp.proof[85] = 0x1ac46e3cfb0c48fe121e100c267fe5cd5bed9e325d068d80f0e7df372b5a07d3;\n        pp.proof[86] = 0x11e3e0c9ab14421c63ec40458035f91c0237f8ca73c71adce2a004a510a2c800;\n        pp.proof[87] = 0x1b9afdd0c11454697064ef251d763ec64b82661259c928dc8f9a24722ea2dcf7;\n        pp.proof[88] = 0x49196e14f0ec7e36775e83a47ff44f3ec5c78573d284b4ed37f281f3dcd68d6;\n        pp.proof[89] = 0x1ac46e3cfb0c48fe121e100c267fe5cd5bed9e325d068d80f0e7df372b5a07d3;\n        pp.proof[90] = 0x1;\n        pp.proof[91] = 0x283e4999955f4b48df712a2599b9773a0dc72af92ecca15a786b865aa81322c7;\n        pp.proof[92] = 0x293a14832e8589b63b2f9a7c90ab26731d2f564eaec101636312b6e008496681;\n        pp.proof[93] = 0xe34c528162fc030c699d9c2b92d66c1c3c8880f921ce4892a8ffacd1abc7736;\n        pp.proof[94] = 0x1a1637ca3fe047d061493a6086752183e0984950d56e96e9349652ccff8ba6f6;\n        pp.proof[95] = 0x21a7ccf6542418b4c3137090a176e8391ecd21c200765ce065275ca0823a6164;\n        pp.proof[96] = 0x125f2a84c0cdf4bbca74acebf16341d1e3bc69a3ff54cf27e391c9b895125ca4;\n        pp.proof[97] = 0x41e681ea154045a7344f8ac8186e2ebb97885a71ad4fef8738dc9780e1429c6;\n        pp.proof[98] = 0x214af2832141f344916986a9a37f2bbb64a53ab300270c27ac91748b7072aa7a;\n        pp.proof[99] = 0x1320806a17d2aece661ac2b64d3ecf15585b6f2feb8d4f812baa4a853273dcb1;\n        pp.proof[100] = 0xaa7605552a9438dc66fef0c8bdb400f22e97abfa0679c6657f16aab29648d80;\n        pp.proof[101] = 0xe40996061a05ca08f0bbdf22998bba471962fe8035631507266f354604438f6;\n        pp.proof[102] = 0xeaa81d869d44a2d7d889e4a2c17bf56b17a5bbbfa8ee5792328b45041727184;\n        pp.proof[103] = 0x1b7a626a3da725089f01592d17d933bef6798c800b1491d139c8bb084a6fa3c6;\n        pp.proof[104] = 0xe71f70e8fc50e98793f0e99edd7c98f66d2a00d8d152bcdd57d9d0a6639c84;\n        pp.proof[105] = 0x198f538b66a078bc1b6c28bb3276c529898fe3d662da97e90e528ea6ec357e47;\n        pp.proof[106] = 0x2afcd51a00412f766e15a29313c8038fdfe6e74b954a2ea99240710c7fd3edd8;\n        pp.proof[107] = 0x125dbe2f4583d7c90feb258e89ebd78a9cbe830e6443f77250dba013b349491a;\n        pp.proof[108] = 0x224f7469c7af9c46159d189820101084685d7c93b474eab074dfa299e0440364;\n        pp.proof[109] = 0x1deb5a29a5cb81d10c78d887370496b0af77ffc7b7ab8903884e63c10a464d80;\n        pp.proof[110] = 0x2942084a484b2a4cff51cf5a8142364fae513e6837541adccdf15df4969d2d94;\n        pp.proof[111] = 0x20bfb117e72a5f3bfbf444901d138f1cb9043883856d0030424f7a0863700783;\n        pp.proof[112] = 0x29e39f869cbf67f7fbeb6dc90f14b665e4f45983cd239f8ea6e28a1bc0c50e73;\n        pp.proof[113] = 0x1c75b6f9c84c01b98fbcad94d60857b1ee15e26292ff129f24af84ade45d57b6;\n        pp.proof[114] = 0x159a258bb6c9d0e374ab4210ea2f532792bce6a9a4644983dd1bd1f77e73944c;\n        pp.proof[115] = 0x46d0b1289d0bc8e29455d7f45723ad84fe4587eb80ae461f93bf06d30f4285e;\n        pp.proof[116] = 0x209eb6f96cfb673ead9408263d879bc946a7498615fe0cb34627ea7e3195b307;\n        pp.proof[117] = 0x7a58e80342271db0159527464587829f6ebe978de540ca1b7437b8641d34004;\n        pp.proof[118] = 0x221a16a594bd8b074d794a99a09d7595f0d697a86954c71db0760375339b05ea;\n        pp.proof[119] = 0x1b45b979933e8943040531bbf351faf94bdbd273be56b8e75a5fd2bd4afee36;\n        pp.proof[120] = 0xd64d1118820fe4e71ca22c358f1385094b6591f62d92654762f1a084a339e37;\n        pp.proof[121] = 0x113150b95a3f8e33fda003bddd14b8abe423af5ac52f48859ba5dfaed3b60af4;\n        pp.proof[122] = 0x14e6cabeaa32518e598b1ddf0111bd4d7a17535fa8cd3f4ee696b547f3caf133;\n        pp.proof[123] = 0x12e66ba628954b85a54b3355d3e8554c2b1bc7cd49cdec8c9b4661826de567d7;\n        pp.proof[124] = 0x287eecc8ae49ac791762ef603eb26f9fc3faf8bc63f93c36c129dc066f5e44cd;\n        pp.proof[125] = 0x2084548b3e2a9bb378150c271bba041244aa3fcb98a5bf08b4108843dd35abc6;\n        pp.proof[126] = 0x223671c02f7e06e05a348a48855f29dc994774a95d53170e92f08913c3289732;\n        pp.proof[127] = 0x2926305890a7b4e58dc6c95f62ed50af5a238b821c133c57cceb40ac68147073;\n        pp.proof[128] = 0xe06553ad4c2977e78505070e3bed99ba2c18e244dfa6d54acbd329846915387;\n        pp.proof[129] = 0x1fcee863cf9716df6598e069f7e3fa1ff5380756889606e4d4a58324c390b69d;\n        pp.proof[130] = 0x2f1e6c1f198dd99bf24ecbcddf54b5f2b524cf6965b90d908c3e3ec6c3e09cf2;\n        pp.proof[131] = 0x16344e152261742616dbcf2f1fb5d29a1b1e5ed651917f618a4f8733c96c5504;\n        pp.proof[132] = 0x23e956b4bde5235788ab1bd89ed6a4b9b87389c617516e929cdf13881078d57;\n        pp.proof[133] = 0x16586d1c98b070745c3627c826301bc09f8c0b8d45adc7a2a4cb752e0200e03;\n        pp.proof[134] = 0x2c8251b2ff135efe2751351d0efcd6fcba7ec7f386e0ced0f154421d3c16bcff;\n        pp.proof[135] = 0x241b9dd867478d9ada0e8dabc97236698f4fcb18ca172321f8306f8e2e6f5e14;\n        pp.proof[136] = 0x1bf0174f39de19422c6e6f5d828e9df5f6fabf91989fa438093bdb4e2906a84c;\n        pp.proof[137] = 0x719dc859db44b1be16f6320dc5de993b84a5ba229eff0492624446f1cc60bcd;\n        pp.proof[138] = 0x2ecaa202ea0326c1daba798c09c367cd30140d0a68d6012e9bfd938366c0043a;\n        pp.proof[139] = 0x1ee958c600a49cb9692e58acfeeb373b45f3768ec907c05c8dd44dd2af948065;\n        pp.proof[140] = 0xc8ba6f0b100a87339b98243fc084db0ecf2035d1ff45602eea0b44755c1ba8e;\n        pp.proof[141] = 0x112e334ea1529f733727c4969afcdd102f40571bff41d9b8fe4e006b89e8112d;\n        pp.proof[142] = 0x22d028a5168fc31ac986bd84ab578fb2a4d32e04a178ecf113953d4a840c57e1;\n        pp.proof[143] = 0x2677596fc15bb717a6c679e8a4be04fd4f7e75fca48f8904b9eb5bef67f673d3;\n        pp.proof[144] = 0x1e5af52b9b8b81cf029cff490d6d0b8596ce779a1b879de5736286cea386eabd;\n\n        pp.pair = new uint256[](4);\n        pp.pair[0] = 1439937077562332533928559358929951268199674421421171954406633361314021765471;\n        pp.pair[1] = 525991771894247758857595702512857049103382678372340463500401100215936874823;\n        pp.pair[2] = 16610762691051063341183748375589157509446274807887837367684010822518324280674;\n        pp.pair[3] = 2418211688952629122600292090656011756990119463711732129096727527695014522543;\n\n        return pp;\n    }\n\n    struct Account {\n        uint64 nonce;\n        uint256 balance;\n        bytes32 storageRoot;\n        bytes32 codeHash;\n    }\n\n    function merkleProof() internal pure returns (Account memory, bytes[] memory) {\n        Account memory account = Account({\n            nonce: 0,\n            balance: 0,\n            storageRoot: 0x24f53397bd92b66fda812b6e1191a00b60fc8e304033518006cbeedcab7f2127,\n            codeHash: 0x1f958654ab06a152993e7a0ae7b6dbb0d4b19265cc9337b8789fe1353bd9dc35\n        });\n        bytes[] memory proof = new bytes[](13);\n\n        proof[\n            0\n        ] = hex\"0027e039ebdf0f9e7c8a1481ebf7448aae44afec16b045969976d37555b364f6132d6654101a6881a48a968d5a257cc8dc8d980c0cc55d58e47833222a24b2230a\";\n        proof[\n            1\n        ] = hex\"002023945e0a0e2290059ca87427aa00e3d515d2e9144d8d3e69ee13b7c75615482cf819ee96fa5bf76e6ce7712caf6673df7fc3af269cfe193bed443eeb89527a\";\n        proof[\n            2\n        ] = hex\"0021d5edc847df9d20356a576c7a4b4b1bb992b427aa4e01412eb08864416db55b1c7c9c38ad18cc007a6e522b638fdf6010aef11727fcb7cdcbfb5edb96e3a74a\";\n        proof[\n            3\n        ] = hex\"0020140f1c792e0ff14d98ca78ed1c085501566b9917cc0792285ed265e6f8cd5b1e99968ab013de794c675a5f614b8a642294aa47612f1bb6173910a5cd7f0b16\";\n        proof[\n            4\n        ] = hex\"002b11bc4ac76ee779a652e7e93a9871fa88e780285d41c6ed2f1646ec8658b7450c158053a97ff3e327cfae62631e5878accd83e5803f044c90803d4579ae21ba\";\n        proof[\n            5\n        ] = hex\"00244f31e0a770ed9dbdf583a0e0dbe036f5f9476c3cc761e18b2a475a96bcc10814c463c1a53d595a21f22f3c5cafe495329c68087ab2601468f8fa7e11d88bf7\";\n        proof[\n            6\n        ] = hex\"0008f993e0df87a04e71f72a3a237c909e2381eacf176b279925d333ee7b1e36ed03c30671a87c81a313a035fdbe052cc592ae0a604bcf87a5cf163d5a43104574\";\n        proof[\n            7\n        ] = hex\"00202aa398b4bd976d7c165b2c7bfa6e4b695f18ff78e4cb544dbb0fbab8c6537e15c1089ff56ee758ec382a55a21b76c08ebf64d6a78d7e6ff442793536607510\";\n        proof[\n            8\n        ] = hex\"0000000000000000000000000000000000000000000000000000000000000000002e957b48192277673a8dde0549358d09d3f9ad6e8db14e08f4fed46f96021a74\";\n        proof[\n            9\n        ] = hex\"002325a334c56feef28306cece9e3867165ee117aab1c831fe04db286a1b4ff2c80000000000000000000000000000000000000000000000000000000000000000\";\n        proof[\n            10\n        ] = hex\"00218476186a36a2ddf003ef59459478f44e0cea1ac32870dafca118331259b05f23618448c7fab9e44d30c44be6777aa390c25ad138fde11d22bdefd05f43838b\";\n        proof[\n            11\n        ] = hex\"012de4ca10cb48fa7ae483633127295fecab2f03da9355f4ca12ca0c820096f9c304040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001f958654ab06a152993e7a0ae7b6dbb0d4b19265cc9337b8789fe1353bd9dc3524f53397bd92b66fda812b6e1191a00b60fc8e304033518006cbeedcab7f2127204200000000000000000000000000000000000003000000000000000000000000\";\n        proof[\n            12\n        ] = hex\"5448495320495320534f4d45204d4147494320425954455320464f5220534d54206d3172525867503278704449\";\n\n        return (account, proof);\n    }\n}\n"
    },
    "contracts/universal/CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    PausableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\n\n/**\n * @custom:upgradeable\n * @title CrossDomainMessenger\n * @notice CrossDomainMessenger is a base contract that provides the core logic for the L1 and L2\n *         cross-chain messenger contracts. It's designed to be a universal interface that only\n *         needs to be extended slightly to provide low-level message passing functionality on each\n *         chain it's deployed on. Currently only designed for message passing between two paired\n *         chains and does not support one-to-many interactions.\n *\n *         Any changes to this contract MUST result in a semver bump for contracts that inherit it.\n */\nabstract contract CrossDomainMessenger is PausableUpgradeable {\n    /**\n     * @notice Current message version identifier.\n     */\n    uint16 public constant MESSAGE_VERSION = 0;\n\n    /**\n     * @notice Constant overhead added to the base gas for a message.\n     */\n    uint64 public constant RELAY_CONSTANT_OVERHEAD = 200_000;\n\n    /**\n     * @notice Numerator for dynamic overhead added to the base gas for a message.\n     */\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR = 64;\n\n    /**\n     * @notice Denominator for dynamic overhead added to the base gas for a message.\n     */\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR = 63;\n\n    /**\n     * @notice Extra gas added to base gas for each byte of calldata in a message.\n     */\n    uint64 public constant MIN_GAS_CALLDATA_OVERHEAD = 16;\n\n    /**\n     * @notice Gas reserved for performing the external call in `relayMessage`.\n     */\n    uint64 public constant RELAY_CALL_OVERHEAD = 40_000;\n\n    /**\n     * @notice Gas reserved for finalizing the execution of `relayMessage` after the safe call.\n     */\n    uint64 public constant RELAY_RESERVED_GAS = 40_000;\n\n    /**\n     * @notice Gas reserved for the execution between the `hasMinGas` check and the external\n     *         call in `relayMessage`.\n     */\n    uint64 public constant RELAY_GAS_CHECK_BUFFER = 5_000;\n\n    /**\n     * @notice Address of the paired CrossDomainMessenger contract on the other chain.\n     */\n    address public immutable OTHER_MESSENGER;\n\n    /**\n     * @notice Mapping of message hashes to boolean receipt values. Note that a message will only\n     *         be present in this mapping if it has successfully been relayed on this chain, and\n     *         can therefore not be relayed again.\n     */\n    mapping(bytes32 => bool) public successfulMessages;\n\n    /**\n     * @notice Address of the sender of the currently executing message on the other chain. If the\n     *         value of this variable is the default value (0x00000000...dead) then no message is\n     *         currently being executed. Use the xDomainMessageSender getter which will throw an\n     *         error if this is the case.\n     */\n    address internal xDomainMsgSender;\n\n    /**\n     * @notice Nonce for the next message to be sent, without the message version applied. Use the\n     *         messageNonce getter which will insert the message version into the nonce to give you\n     *         the actual nonce to be used for the message.\n     */\n    uint240 internal msgNonce;\n\n    /**\n     * @notice Mapping of message hashes to a boolean if and only if the message has failed to be\n     *         executed at least once. A message will not be present in this mapping if it\n     *         successfully executed on the first attempt.\n     */\n    mapping(bytes32 => bool) public failedMessages;\n\n    /**\n     * @notice Reserve extra slots in the storage layout for future upgrades.\n     *         A gap size of 45 was chosen here, so that the first slot used in a child contract\n     *         would be a multiple of 50.\n     */\n    uint256[45] private __gap;\n\n    /**\n     * @notice Emitted whenever a message is sent to the other chain.\n     *\n     * @param target       Address of the recipient of the message.\n     * @param sender       Address of the sender of the message.\n     * @param value        ETH value sent along with the message to the recipient.\n     * @param message      Message to trigger the recipient address with.\n     * @param messageNonce Unique nonce attached to the message.\n     * @param gasLimit     Minimum gas limit that the message can be executed with.\n     */\n    event SentMessage(\n        address indexed target,\n        address indexed sender,\n        uint256 value,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n\n    /**\n     * @notice Emitted whenever a message is successfully relayed on this chain.\n     *\n     * @param msgHash Hash of the message that was relayed.\n     */\n    event RelayedMessage(bytes32 indexed msgHash);\n\n    /**\n     * @notice Emitted whenever a message fails to be relayed on this chain.\n     *\n     * @param msgHash Hash of the message that failed to be relayed.\n     */\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /**\n     * @param _otherMessenger Address of the messenger on the paired chain.\n     */\n    constructor(address _otherMessenger) {\n        OTHER_MESSENGER = _otherMessenger;\n    }\n\n    /**\n     * @notice Sends a message to some target address on the other chain. Note that if the call\n     *         always reverts, then the message will be unrelayable, and any ETH sent will be\n     *         permanently locked. The same will occur if the target on the other chain is\n     *         considered unsafe (see the _isUnsafeTarget() function).\n     *\n     * @param _target      Target contract or wallet address.\n     * @param _message     Message to trigger the target address with.\n     * @param _minGasLimit Minimum gas limit that the message can be executed with.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _minGasLimit\n    ) external payable {\n        // Triggers a message to the other messenger. Note that the amount of gas provided to the\n        // message is the amount of gas requested by the user PLUS the base gas value. We want to\n        // guarantee the property that the call to the target contract will always have at least\n        // the minimum gas limit specified by the user.\n        _sendMessage(\n            OTHER_MESSENGER,\n            baseGas(_message, _minGasLimit),\n            msg.value,\n            abi.encodeWithSelector(\n                this.relayMessage.selector,\n                messageNonce(),\n                msg.sender,\n                _target,\n                msg.value,\n                _minGasLimit,\n                _message\n            )\n        );\n\n        emit SentMessage(_target, msg.sender, msg.value, _message, messageNonce(), _minGasLimit);\n\n        unchecked {\n            ++msgNonce;\n        }\n    }\n\n    /**\n     * @notice Relays a message that was sent by the other CrossDomainMessenger contract. Can only\n     *         be executed via cross-chain call from the other messenger OR if the message was\n     *         already received once and is currently being replayed.\n     *\n     * @param _nonce       Nonce of the message being relayed.\n     * @param _sender      Address of the user who sent the message.\n     * @param _target      Address that the message is targeted at.\n     * @param _value       ETH value to send with the message.\n     * @param _minGasLimit Minimum amount of gas that the message can be executed with.\n     * @param _message     Message to send to the target.\n     */\n    function relayMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _minGasLimit,\n        bytes calldata _message\n    ) external payable {\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\n        require(\n            version < 1,\n            \"CrossDomainMessenger: only version 0 messages is supported at this time\"\n        );\n\n        // We use the v0 message hash as the unique identifier for the message because it commits\n        // to the value and minimum gas limit of the message.\n        bytes32 versionedHash = Hashing.hashCrossDomainMessageV0(\n            _nonce,\n            _sender,\n            _target,\n            _value,\n            _minGasLimit,\n            _message\n        );\n\n        if (_isOtherMessenger()) {\n            // These properties should always hold when the message is first submitted (as\n            // opposed to being replayed).\n            assert(msg.value == _value);\n            assert(!failedMessages[versionedHash]);\n        } else {\n            require(\n                msg.value == 0,\n                \"CrossDomainMessenger: value must be zero unless message is from a system address\"\n            );\n\n            require(\n                failedMessages[versionedHash],\n                \"CrossDomainMessenger: message cannot be replayed\"\n            );\n        }\n\n        require(\n            _isUnsafeTarget(_target) == false,\n            \"CrossDomainMessenger: cannot send message to blocked system address\"\n        );\n\n        require(\n            successfulMessages[versionedHash] == false,\n            \"CrossDomainMessenger: message has already been relayed\"\n        );\n\n        // If there is not enough gas left to perform the external call and finish the execution,\n        // return early and assign the message to the failedMessages mapping.\n        // We are asserting that we have enough gas to:\n        // 1. Call the target contract (_minGasLimit + RELAY_CALL_OVERHEAD + RELAY_GAS_CHECK_BUFFER)\n        //   1.a. The RELAY_CALL_OVERHEAD is included in `hasMinGas`.\n        // 2. Finish the execution after the external call (RELAY_RESERVED_GAS).\n        //\n        // If `xDomainMsgSender` is not the default L2 sender, this function\n        // is being re-entered. This marks the message as failed to allow it to be replayed.\n        if (\n            !SafeCall.hasMinGas(_minGasLimit, RELAY_RESERVED_GAS + RELAY_GAS_CHECK_BUFFER) ||\n            xDomainMsgSender != Constants.DEFAULT_L2_SENDER\n        ) {\n            failedMessages[versionedHash] = true;\n            emit FailedRelayedMessage(versionedHash);\n\n            // Revert in this case if the transaction was triggered by the estimation address. This\n            // should only be possible during gas estimation or we have bigger problems. Reverting\n            // here will make the behavior of gas estimation change such that the gas limit\n            // computed will be the amount required to relay the message, even if that amount is\n            // greater than the minimum gas limit specified by the user.\n            if (tx.origin == Constants.ESTIMATION_ADDRESS) {\n                revert(\"CrossDomainMessenger: failed to relay message\");\n            }\n\n            return;\n        }\n\n        xDomainMsgSender = _sender;\n        bool success = SafeCall.call(_target, gasleft() - RELAY_RESERVED_GAS, _value, _message);\n        xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\n\n        if (success) {\n            successfulMessages[versionedHash] = true;\n            emit RelayedMessage(versionedHash);\n        } else {\n            failedMessages[versionedHash] = true;\n            emit FailedRelayedMessage(versionedHash);\n\n            // Revert in this case if the transaction was triggered by the estimation address. This\n            // should only be possible during gas estimation or we have bigger problems. Reverting\n            // here will make the behavior of gas estimation change such that the gas limit\n            // computed will be the amount required to relay the message, even if that amount is\n            // greater than the minimum gas limit specified by the user.\n            if (tx.origin == Constants.ESTIMATION_ADDRESS) {\n                revert(\"CrossDomainMessenger: failed to relay message\");\n            }\n        }\n    }\n\n    /**\n     * @notice Retrieves the address of the contract or wallet that initiated the currently\n     *         executing message on the other chain. Will throw an error if there is no message\n     *         currently being executed. Allows the recipient of a call to see who triggered it.\n     *\n     * @return Address of the sender of the currently executing message on the other chain.\n     */\n    function xDomainMessageSender() external view returns (address) {\n        require(\n            xDomainMsgSender != Constants.DEFAULT_L2_SENDER,\n            \"CrossDomainMessenger: xDomainMessageSender is not set\"\n        );\n\n        return xDomainMsgSender;\n    }\n\n    /**\n     * @notice Retrieves the next message nonce. Message version will be added to the upper two\n     *         bytes of the message nonce. Message version allows us to treat messages as having\n     *         different structures.\n     *\n     * @return Nonce of the next message to be sent, with added message version.\n     */\n    function messageNonce() public view returns (uint256) {\n        return Encoding.encodeVersionedNonce(msgNonce, MESSAGE_VERSION);\n    }\n\n    /**\n     * @notice Computes the amount of gas required to guarantee that a given message will be\n     *         received on the other chain without running out of gas. Guaranteeing that a message\n     *         will not run out of gas is important because this ensures that a message can always\n     *         be replayed on the other chain if it fails to execute completely.\n     *\n     * @param _message     Message to compute the amount of required gas for.\n     * @param _minGasLimit Minimum desired gas limit when message goes to target.\n     *\n     * @return Amount of gas required to guarantee message receipt.\n     */\n    function baseGas(bytes calldata _message, uint32 _minGasLimit) public pure returns (uint64) {\n        return\n            // Constant overhead\n            RELAY_CONSTANT_OVERHEAD +\n            // Calldata overhead\n            (uint64(_message.length) * MIN_GAS_CALLDATA_OVERHEAD) +\n            // Dynamic overhead (EIP-150)\n            ((_minGasLimit * MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR) /\n                MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR) +\n            // Gas reserved for the worst-case cost of 3/5 of the `CALL` opcode's dynamic gas\n            // factors. (Conservative)\n            RELAY_CALL_OVERHEAD +\n            // Relay reserved gas (to ensure execution of `relayMessage` completes after the\n            // subcontext finishes executing) (Conservative)\n            RELAY_RESERVED_GAS +\n            // Gas reserved for the execution between the `hasMinGas` check and the `CALL`\n            // opcode. (Conservative)\n            RELAY_GAS_CHECK_BUFFER;\n    }\n\n    /**\n     * @notice Intializer.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __CrossDomainMessenger_init() internal onlyInitializing {\n        xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\n    }\n\n    /**\n     * @notice Sends a low-level message to the other messenger. Needs to be implemented by child\n     *         contracts because the logic for this depends on the network where the messenger is\n     *         being deployed.\n     *\n     * @param _to       Recipient of the message on the other chain.\n     * @param _gasLimit Minimum gas limit the message can be executed with.\n     * @param _value    Amount of ETH to send with the message.\n     * @param _data     Message data.\n     */\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal virtual;\n\n    /**\n     * @notice Checks whether the message is coming from the other messenger. Implemented by child\n     *         contracts because the logic for this depends on the network where the messenger is\n     *         being deployed.\n     *\n     * @return Whether the message is coming from the other messenger.\n     */\n    function _isOtherMessenger() internal view virtual returns (bool);\n\n    /**\n     * @notice Checks whether a given call target is a system address that could cause the\n     *         messenger to peform an unsafe action. This is NOT a mechanism for blocking user\n     *         addresses. This is ONLY used to prevent the execution of messages to specific\n     *         system addresses that could cause security issues, e.g., having the\n     *         CrossDomainMessenger send messages to itself.\n     *\n     * @param _target Address of the contract to check.\n     *\n     * @return Whether or not the address is an unsafe system address.\n     */\n    function _isUnsafeTarget(address _target) internal view virtual returns (bool);\n}\n"
    },
    "contracts/universal/ERC721Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { CrossDomainMessenger } from \"./CrossDomainMessenger.sol\";\n\n/**\n * @title ERC721Bridge\n * @notice ERC721Bridge is a base contract for the L1 and L2 ERC721 bridges.\n */\nabstract contract ERC721Bridge {\n    /**\n     * @notice Messenger contract on this domain.\n     */\n    CrossDomainMessenger public immutable MESSENGER;\n\n    /**\n     * @notice Address of the bridge on the other network.\n     */\n    address public immutable OTHER_BRIDGE;\n\n    /**\n     * @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\n     */\n    uint256[49] private __gap;\n\n    /**\n     * @notice Emitted when an ERC721 bridge to the other network is initiated.\n     *\n     * @param localToken  Address of the token on this domain.\n     * @param remoteToken Address of the token on the remote domain.\n     * @param from        Address that initiated bridging action.\n     * @param to          Address to receive the token.\n     * @param tokenId     ID of the specific token deposited.\n     * @param extraData   Extra data for use on the client-side.\n     */\n    event ERC721BridgeInitiated(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    /**\n     * @notice Emitted when an ERC721 bridge from the other network is finalized.\n     *\n     * @param localToken  Address of the token on this domain.\n     * @param remoteToken Address of the token on the remote domain.\n     * @param from        Address that initiated bridging action.\n     * @param to          Address to receive the token.\n     * @param tokenId     ID of the specific token deposited.\n     * @param extraData   Extra data for use on the client-side.\n     */\n    event ERC721BridgeFinalized(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 tokenId,\n        bytes extraData\n    );\n\n    /**\n     * @notice Ensures that the caller is a cross-chain message from the other bridge.\n     */\n    modifier onlyOtherBridge() {\n        require(\n            msg.sender == address(MESSENGER) && MESSENGER.xDomainMessageSender() == OTHER_BRIDGE,\n            \"ERC721Bridge: function can only be called from the other bridge\"\n        );\n        _;\n    }\n\n    /**\n     * @param _messenger   Address of the CrossDomainMessenger on this network.\n     * @param _otherBridge Address of the ERC721 bridge on the other network.\n     */\n    constructor(address _messenger, address _otherBridge) {\n        require(_messenger != address(0), \"ERC721Bridge: messenger cannot be address(0)\");\n        require(_otherBridge != address(0), \"ERC721Bridge: other bridge cannot be address(0)\");\n\n        MESSENGER = CrossDomainMessenger(_messenger);\n        OTHER_BRIDGE = _otherBridge;\n    }\n\n    /**\n     * @notice Initiates a bridge of an NFT to the caller's account on the other chain. Note that\n     *         this function can only be called by EOAs. Smart contract wallets should use the\n     *         `bridgeERC721To` function after ensuring that the recipient address on the remote\n     *         chain exists. Also note that the current owner of the token on this chain must\n     *         approve this contract to operate the NFT before it can be bridged.\n     *         **WARNING**: Do not bridge an ERC721 that was originally deployed on Kroma. This\n     *         bridge only supports ERC721s originally deployed on Ethereum. Users will need to\n     *         wait for the one-week challenge period to elapse before their Kroma-native NFT\n     *         can be refunded on L2.\n     *\n     * @param _localToken  Address of the ERC721 on this domain.\n     * @param _remoteToken Address of the ERC721 on the remote domain.\n     * @param _tokenId     Token ID to bridge.\n     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.\n     * @param _extraData   Optional data to forward to the other chain. Data supplied here will not\n     *                     be used to execute any code on the other chain and is only emitted as\n     *                     extra data for the convenience of off-chain tooling.\n     */\n    function bridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        uint256 _tokenId,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external {\n        // Modifier requiring sender to be EOA. This prevents against a user error that would occur\n        // if the sender is a smart contract wallet that has a different address on the remote chain\n        // (or doesn't have an address on the remote chain at all). The user would fail to receive\n        // the NFT if they use this function because it sends the NFT to the same address as the\n        // caller. This check could be bypassed by a malicious contract via initcode, but it takes\n        // care of the user error we want to avoid.\n        require(!Address.isContract(msg.sender), \"ERC721Bridge: account is not externally owned\");\n\n        _initiateBridgeERC721(\n            _localToken,\n            _remoteToken,\n            msg.sender,\n            msg.sender,\n            _tokenId,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @notice Initiates a bridge of an NFT to some recipient's account on the other chain. Note\n     *         that the current owner of the token on this chain must approve this contract to\n     *         operate the NFT before it can be bridged.\n     *         **WARNING**: Do not bridge an ERC721 that was originally deployed on Kroma. This\n     *         bridge only supports ERC721s originally deployed on Ethereum. Users will need to\n     *         wait for the one-week challenge period to elapse before their Kroma-native NFT\n     *         can be refunded on L2.\n     *\n     * @param _localToken  Address of the ERC721 on this domain.\n     * @param _remoteToken Address of the ERC721 on the remote domain.\n     * @param _to          Address to receive the token on the other domain.\n     * @param _tokenId     Token ID to bridge.\n     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.\n     * @param _extraData   Optional data to forward to the other chain. Data supplied here will not\n     *                     be used to execute any code on the other chain and is only emitted as\n     *                     extra data for the convenience of off-chain tooling.\n     */\n    function bridgeERC721To(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _tokenId,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external {\n        require(_to != address(0), \"ERC721Bridge: nft recipient cannot be address(0)\");\n\n        _initiateBridgeERC721(\n            _localToken,\n            _remoteToken,\n            msg.sender,\n            _to,\n            _tokenId,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @notice Internal function for initiating a token bridge to the other domain.\n     *\n     * @param _localToken  Address of the ERC721 on this domain.\n     * @param _remoteToken Address of the ERC721 on the remote domain.\n     * @param _from        Address of the sender on this domain.\n     * @param _to          Address to receive the token on the other domain.\n     * @param _tokenId     Token ID to bridge.\n     * @param _minGasLimit Minimum gas limit for the bridge message on the other domain.\n     * @param _extraData   Optional data to forward to the other domain. Data supplied here will\n     *                     not be used to execute any code on the other domain and is only emitted\n     *                     as extra data for the convenience of off-chain tooling.\n     */\n    function _initiateBridgeERC721(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) internal virtual;\n}\n"
    },
    "contracts/universal/FeeVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { L2StandardBridge } from \"../L2/L2StandardBridge.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\n\n/**\n * @title FeeVault\n * @notice The FeeVault contract contains the basic logic for the various different vault contracts\n *         used to hold fee revenue generated by the L2 system.\n */\nabstract contract FeeVault {\n    /**\n     * @notice Emits each time that a withdrawal occurs.\n     *\n     * @param value Amount that was withdrawn (in wei).\n     * @param to    Address that the funds were sent to.\n     * @param from  Address that triggered the withdrawal.\n     */\n    event Withdrawal(uint256 value, address to, address from);\n\n    /**\n     * @notice Minimum balance before a withdrawal can be triggered.\n     */\n    uint256 public immutable MIN_WITHDRAWAL_AMOUNT;\n\n    /**\n     * @notice Wallet that will receive the fees on L1.\n     */\n    address public immutable RECIPIENT;\n\n    /**\n     * @notice The minimum gas limit for the FeeVault withdrawal transaction.\n     */\n    uint32 internal constant WITHDRAWAL_MIN_GAS = 35_000;\n\n    /**\n     * @notice Total amount of wei processed by the contract.\n     */\n    uint256 public totalProcessed;\n\n    modifier onlyRecipient() {\n        require(msg.sender == RECIPIENT, \"FeeVault: the only recipient can call\");\n        _;\n    }\n\n    /**\n     * @param _recipient           Wallet that will receive the fees on L1.\n     * @param _minWithdrawalAmount Minimum balance before a withdrawal can be triggered.\n     */\n    constructor(address _recipient, uint256 _minWithdrawalAmount) {\n        MIN_WITHDRAWAL_AMOUNT = _minWithdrawalAmount;\n        RECIPIENT = _recipient;\n    }\n\n    /**\n     * @notice Allow the contract to receive ETH.\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Checks if the withdrawal is possible, and returns the withdrawal amount.\n     *         When a withdrawal is available, it resets the balance and updates the total processed amount.\n     */\n    function _processWithdrawal() internal virtual returns (uint256) {\n        require(\n            address(this).balance >= MIN_WITHDRAWAL_AMOUNT,\n            \"FeeVault: withdrawal amount must be greater than minimum withdrawal amount\"\n        );\n\n        uint256 amount = address(this).balance;\n        totalProcessed += amount;\n\n        emit Withdrawal(amount, RECIPIENT, msg.sender);\n        return amount;\n    }\n\n    /**\n     * @notice Triggers a withdrawal of funds to the recipient on L1.\n     */\n    function withdraw() external virtual onlyRecipient {\n        uint256 amount = _processWithdrawal();\n\n        L2StandardBridge(payable(Predeploys.L2_STANDARD_BRIDGE)).bridgeETHTo{ value: amount }(\n            RECIPIENT,\n            WITHDRAWAL_MIN_GAS,\n            bytes(\"\")\n        );\n    }\n\n    /**\n     * @notice Triggers a withdrawal of funds to the recipient on L2.\n     */\n    function withdrawToL2() external virtual onlyRecipient {\n        uint256 amount = _processWithdrawal();\n\n        bool success = SafeCall.call(RECIPIENT, gasleft(), amount, bytes(\"\"));\n        require(success, \"FeeVault: ETH transfer failed\");\n    }\n}\n"
    },
    "contracts/universal/IKromaMintableERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title IKromaMintableERC20\n * @notice This interface is available on the KromaMintableERC20 contract. We declare it as a\n *         separate interface so that it can be used in custom implementations of\n *         KromaMintableERC20.\n */\ninterface IKromaMintableERC20 {\n    function REMOTE_TOKEN() external view returns (address);\n\n    function BRIDGE() external view returns (address);\n\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n}\n"
    },
    "contracts/universal/IKromaMintableERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {\n    IERC721Enumerable\n} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\n\n/**\n * @title IKromaMintableERC721\n * @notice Interface for contracts that are compatible with the KromaMintableERC721 standard.\n *         Tokens that follow this standard can be easily transferred across the ERC721 bridge.\n */\ninterface IKromaMintableERC721 is IERC721Enumerable {\n    /**\n     * @notice Emitted when a token is minted.\n     *\n     * @param account Address of the account the token was minted to.\n     * @param tokenId Token ID of the minted token.\n     */\n    event Mint(address indexed account, uint256 tokenId);\n\n    /**\n     * @notice Emitted when a token is burned.\n     *\n     * @param account Address of the account the token was burned from.\n     * @param tokenId Token ID of the burned token.\n     */\n    event Burn(address indexed account, uint256 tokenId);\n\n    /**\n     * @notice Mints some token ID for a user, checking first that contract recipients\n     *         are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * @param _to      Address of the user to mint the token for.\n     * @param _tokenId Token ID to mint.\n     */\n    function safeMint(address _to, uint256 _tokenId) external;\n\n    /**\n     * @notice Burns a token ID from a user.\n     *\n     * @param _from    Address of the user to burn the token from.\n     * @param _tokenId Token ID to burn.\n     */\n    function burn(address _from, uint256 _tokenId) external;\n\n    /**\n     * @notice Chain ID of the chain where the remote token is deployed.\n     */\n    function REMOTE_CHAIN_ID() external view returns (uint256);\n\n    /**\n     * @notice Address of the token on the remote domain.\n     */\n    function REMOTE_TOKEN() external view returns (address);\n\n    /**\n     * @notice Address of the ERC721 bridge on this network.\n     */\n    function BRIDGE() external view returns (address);\n\n    /**\n     * @notice Chain ID of the chain where the remote token is deployed.\n     */\n    function remoteChainId() external view returns (uint256);\n\n    /**\n     * @notice Address of the token on the remote domain.\n     */\n    function remoteToken() external view returns (address);\n\n    /**\n     * @notice Address of the ERC721 bridge on this network.\n     */\n    function bridge() external view returns (address);\n}\n"
    },
    "contracts/universal/ISemver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title ISemver\n/// @notice ISemver is a simple contract for ensuring that contracts are\n///         versioned using semantic versioning.\ninterface ISemver {\n    /// @notice Getter for the semantic version of the contract. This is not\n    ///         meant to be used onchain but instead meant to be used by offchain\n    ///         tooling.\n    /// @return Semver contract version as a string.\n    function version() external view returns (string memory);\n}\n"
    },
    "contracts/universal/ITokenMultiSigWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title ITokenMultiSigWallet\n * @notice Interface for contracts of a token based multi-signature wallet.\n */\ninterface ITokenMultiSigWallet {\n    /**\n     * @notice Emitted when anyone submit a transaction.\n     *\n     * @param sender        Address of submitter.\n     * @param transactionId The ID of transaction submitted.\n     */\n    event TransactionSubmitted(address indexed sender, uint256 indexed transactionId);\n\n    /**\n     * @notice Emitted when anyone confirm a transaction.\n     *\n     * @param sender        Owner of address that confirm a transaction.\n     * @param transactionId The ID of transaction confirmed.\n     */\n    event TransactionConfirmed(address indexed sender, uint256 indexed transactionId);\n\n    /**\n     * @notice Emitted when transaction is executed.\n     *\n     * @param sender        Owner of address that execute a transaction.\n     * @param transactionId The ID of transaction executed.\n     */\n    event TransactionExecuted(address indexed sender, uint256 indexed transactionId);\n\n    /**\n     * @notice Emitted when anyone revoke a confirmation.\n     *\n     * @param sender        Owner of address that revoke a transaction.\n     * @param transactionId The ID of transaction to revoke.\n     */\n    event ConfirmationRevoked(address indexed sender, uint256 indexed transactionId);\n\n    /**\n     * @notice Allows an owner to submit and confirm a transaction.\n     *\n     * @param _target Transaction target address.\n     * @param _value  Transaction ether value.\n     * @param _data   Transaction data payload.\n     *\n     * @return Returns transaction ID.\n     */\n    function submitTransaction(\n        address _target,\n        uint256 _value,\n        bytes memory _data\n    ) external returns (uint256);\n\n    /**\n     * @notice Allows an owner to confirm a transaction.\n     *\n     * @param _transactionId Transaction ID.\n     */\n    function confirmTransaction(uint256 _transactionId) external;\n\n    /**\n     * @notice Allows an owner to revoke a transaction.\n     *\n     * @param _transactionId Transaction ID.\n     */\n    function revokeConfirmation(uint256 _transactionId) external;\n\n    /**\n     * @notice Allows anyone to execute a confirmed transaction.\n     *\n     * @param _transactionId Transaction ID.\n     */\n    function executeTransaction(uint256 _transactionId) external;\n\n    /**\n     * @notice Returns the confirmation status of a transaction.\n     *\n     * @param _transactionId Transaction ID.\n     *\n     * @return Confirmation status.\n     */\n    function isConfirmed(uint256 _transactionId) external view returns (bool);\n\n    /**\n     * @notice Returns the current quorum, in terms of number of votes.\n     *\n     * @return Current quorum, in terms of number of votes: `supply * quorumNumerator / quorumDenominator`.\n     */\n    function quorum() external view returns (uint256);\n\n    /**\n     * @notice Returns the number of votes.\n     *\n     * @param _account Account to check votes.\n     *\n     * @return Number of votes.\n     */\n    function getVotes(address _account) external view returns (uint256);\n\n    /**\n     * @notice Returns the number of confirmations that account has confirmed.\n     *\n     * @param _transactionId Transaction id to check.\n     *\n     * @return The number of confirmations.\n     */\n    function getConfirmationCount(uint256 _transactionId) external view returns (uint256);\n\n    /**\n     * @notice Returns whether the account has confirmed the transaction.\n     *\n     * @param _transactionId Transaction id to check.\n     * @param _account       Address to check.\n     *\n     * @return Confirmed status.\n     */\n    function isConfirmedBy(uint256 _transactionId, address _account) external view returns (bool);\n}\n"
    },
    "contracts/universal/KromaMintableERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport { ISemver } from \"../universal/ISemver.sol\";\nimport { IKromaMintableERC20 } from \"./IKromaMintableERC20.sol\";\n\n/**\n * @title KromaMintableERC20\n * @notice KromaMintableERC20 is a standard extension of the base ERC20 token contract designed\n *         to allow the StandardBridge contracts to mint and burn tokens. This makes it possible to\n *         use a KromaMintableRC20 as the L2 representation of an L1 token, or vice-versa.\n *         Designed to be backwards compatible with the older StandardL2ERC20 token which was only\n *         meant for use on L2.\n */\ncontract KromaMintableERC20 is IKromaMintableERC20, ERC20, ISemver {\n    /**\n     * @notice Address of the corresponding version of this token on the remote chain.\n     */\n    address public immutable REMOTE_TOKEN;\n\n    /**\n     * @notice Address of the StandardBridge on this network.\n     */\n    address public immutable BRIDGE;\n\n    /**\n     * @notice Emitted whenever tokens are minted for an account.\n     *\n     * @param account Address of the account tokens are being minted for.\n     * @param amount  Amount of tokens minted.\n     */\n    event Mint(address indexed account, uint256 amount);\n\n    /**\n     * @notice Emitted whenever tokens are burned from an account.\n     *\n     * @param account Address of the account tokens are being burned from.\n     * @param amount  Amount of tokens burned.\n     */\n    event Burn(address indexed account, uint256 amount);\n\n    /**\n     * @notice A modifier that only allows the bridge to call\n     */\n    modifier onlyBridge() {\n        require(msg.sender == BRIDGE, \"KromaMintableERC20: only bridge can mint and burn\");\n        _;\n    }\n\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.0.0\n     */\n    string public constant version = \"1.0.0\";\n\n    /**\n     * @notice Constructs the KromaMintableERC20 contract.\n     *\n     * @param _bridge      Address of the L2 standard bridge.\n     * @param _remoteToken Address of the corresponding L1 token.\n     * @param _name        ERC20 name.\n     * @param _symbol      ERC20 symbol.\n     */\n    constructor(\n        address _bridge,\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) {\n        REMOTE_TOKEN = _remoteToken;\n        BRIDGE = _bridge;\n    }\n\n    /**\n     * @notice Allows the StandardBridge on this network to mint tokens.\n     *\n     * @param _to     Address to mint tokens to.\n     * @param _amount Amount of tokens to mint.\n     */\n    function mint(address _to, uint256 _amount)\n        external\n        virtual\n        override(IKromaMintableERC20)\n        onlyBridge\n    {\n        _mint(_to, _amount);\n        emit Mint(_to, _amount);\n    }\n\n    /**\n     * @notice Allows the StandardBridge on this network to burn tokens.\n     *\n     * @param _from   Address to burn tokens from.\n     * @param _amount Amount of tokens to burn.\n     */\n    function burn(address _from, uint256 _amount)\n        external\n        virtual\n        override(IKromaMintableERC20)\n        onlyBridge\n    {\n        _burn(_from, _amount);\n        emit Burn(_from, _amount);\n    }\n\n    /**\n     * @notice ERC165 interface check function.\n     *\n     * @param _interfaceId Interface ID to check.\n     *\n     * @return Whether or not the interface is supported by this contract.\n     */\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool) {\n        bytes4 iface1 = type(IERC165).interfaceId;\n        // Interface corresponding to the updated KromaMintableERC20 (this contract).\n        bytes4 iface2 = type(IKromaMintableERC20).interfaceId;\n        return _interfaceId == iface1 || _interfaceId == iface2;\n    }\n}\n"
    },
    "contracts/universal/KromaMintableERC20Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/* Contract Imports */\nimport { KromaMintableERC20 } from \"../universal/KromaMintableERC20.sol\";\nimport { ISemver } from \"./ISemver.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeployed 0x420000000000000000000000000000000000000B\n * @title KromaMintableERC20Factory\n * @notice KromaMintableERC20Factory is a factory contract that generates KromaMintableERC20\n *         contracts on the network it's deployed to. Simplifies the deployment process for users\n *         who may be less familiar with deploying smart contracts. Designed to be backwards\n *         compatible with the older StandardL2ERC20Factory contract.\n */\ncontract KromaMintableERC20Factory is ISemver {\n    /**\n     * @notice Address of the StandardBridge on this chain.\n     */\n    address public immutable BRIDGE;\n\n    /**\n     * @notice Emitted whenever a new KromaMintableERC20 is created.\n     *\n     * @param localToken  Address of the created token on the local chain.\n     * @param remoteToken Address of the corresponding token on the remote chain.\n     * @param deployer    Address of the account that deployed the token.\n     */\n    event KromaMintableERC20Created(\n        address indexed localToken,\n        address indexed remoteToken,\n        address deployer\n    );\n\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.0.0\n     */\n    string public constant version = \"1.0.0\";\n\n    /**\n     * @notice Constructs the KromaMintableERC20Factory contract.@author\n     *\n     * @notice The semver MUST be bumped any time that there is a change in\n     *         the KromaMintableERC20 token contract since this contract\n     *         is responsible for deploying KromaMintableERC20 contracts.\n     *\n     * @param _bridge Address of the StandardBridge on this chain.\n     */\n    constructor(address _bridge) {\n        BRIDGE = _bridge;\n    }\n\n    /**\n     * @notice Creates an instance of the KromaMintableERC20 contract.\n     *\n     * @param _remoteToken Address of the token on the remote chain.\n     * @param _name        ERC20 name.\n     * @param _symbol      ERC20 symbol.\n     *\n     * @return Address of the newly created token.\n     */\n    function createKromaMintableERC20(\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) public returns (address) {\n        require(\n            _remoteToken != address(0),\n            \"KromaMintableERC20Factory: must provide remote token address\"\n        );\n\n        address localToken = address(\n            new KromaMintableERC20(BRIDGE, _remoteToken, _name, _symbol)\n        );\n\n        emit KromaMintableERC20Created(localToken, _remoteToken, msg.sender);\n\n        return localToken;\n    }\n}\n"
    },
    "contracts/universal/KromaMintableERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {\n    ERC721Enumerable\n} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport { ISemver } from \"../universal/ISemver.sol\";\nimport { IKromaMintableERC721 } from \"./IKromaMintableERC721.sol\";\n\n/**\n * @title KromaMintableERC721\n * @notice This contract is the remote representation for some token that lives on another network,\n *         typically a Kroma representation of an Ethereum-based token. Standard reference\n *         implementation that can be extended or modified according to your needs.\n */\ncontract KromaMintableERC721 is ERC721Enumerable, IKromaMintableERC721, ISemver {\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    uint256 public immutable REMOTE_CHAIN_ID;\n\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    address public immutable REMOTE_TOKEN;\n\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    address public immutable BRIDGE;\n\n    /**\n     * @notice Base token URI for this token.\n     */\n    string public baseTokenURI;\n\n    /**\n     * @notice Modifier that prevents callers other than the bridge from calling the function.\n     */\n    modifier onlyBridge() {\n        require(msg.sender == BRIDGE, \"KromaMintableERC721: only bridge can call this function\");\n        _;\n    }\n\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.0.0\n     */\n    string public constant version = \"1.0.0\";\n\n    /**\n     * @notice Constructs the KromaMintableERC721 contract.\n     *\n     * @param _bridge        Address of the bridge on this network.\n     * @param _remoteChainId Chain ID where the remote token is deployed.\n     * @param _remoteToken   Address of the corresponding token on the other network.\n     * @param _name          ERC721 name.\n     * @param _symbol        ERC721 symbol.\n     */\n    constructor(\n        address _bridge,\n        uint256 _remoteChainId,\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        require(_bridge != address(0), \"KromaMintableERC721: bridge cannot be address(0)\");\n        require(_remoteChainId != 0, \"KromaMintableERC721: remote chain id cannot be zero\");\n        require(\n            _remoteToken != address(0),\n            \"KromaMintableERC721: remote token cannot be address(0)\"\n        );\n\n        REMOTE_CHAIN_ID = _remoteChainId;\n        REMOTE_TOKEN = _remoteToken;\n        BRIDGE = _bridge;\n\n        // Creates a base URI in the format specified by EIP-681:\n        // https://eips.ethereum.org/EIPS/eip-681\n        baseTokenURI = string(\n            abi.encodePacked(\n                \"ethereum:\",\n                Strings.toHexString(uint160(_remoteToken), 20),\n                \"@\",\n                Strings.toString(_remoteChainId),\n                \"/tokenURI?uint256=\"\n            )\n        );\n    }\n\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    function remoteChainId() external view returns (uint256) {\n        return REMOTE_CHAIN_ID;\n    }\n\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    function remoteToken() external view returns (address) {\n        return REMOTE_TOKEN;\n    }\n\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    function bridge() external view returns (address) {\n        return BRIDGE;\n    }\n\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    function safeMint(address _to, uint256 _tokenId) external virtual onlyBridge {\n        _safeMint(_to, _tokenId);\n\n        emit Mint(_to, _tokenId);\n    }\n\n    /**\n     * @inheritdoc IKromaMintableERC721\n     */\n    function burn(address _from, uint256 _tokenId) external virtual onlyBridge {\n        _burn(_tokenId);\n\n        emit Burn(_from, _tokenId);\n    }\n\n    /**\n     * @notice Checks if a given interface ID is supported by this contract.\n     *\n     * @param _interfaceId The interface ID to check.\n     *\n     * @return True if the interface ID is supported, false otherwise.\n     */\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        override(ERC721Enumerable, IERC165)\n        returns (bool)\n    {\n        bytes4 iface1 = type(IERC165).interfaceId;\n        bytes4 iface2 = type(IKromaMintableERC721).interfaceId;\n        return\n            _interfaceId == iface1 ||\n            _interfaceId == iface2 ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /**\n     * @notice Returns the base token URI.\n     *\n     * @return Base token URI.\n     */\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseTokenURI;\n    }\n}\n"
    },
    "contracts/universal/KromaMintableERC721Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { KromaMintableERC721 } from \"./KromaMintableERC721.sol\";\nimport { ISemver } from \"./ISemver.sol\";\n\n/**\n * @title KromaMintableERC721Factory\n * @notice Factory contract for creating KromaMintableERC721 contracts.\n */\ncontract KromaMintableERC721Factory is ISemver {\n    /**\n     * @notice Address of the ERC721 bridge on this network.\n     */\n    address public immutable BRIDGE;\n\n    /**\n     * @notice Chain ID for the remote network.\n     */\n    uint256 public immutable REMOTE_CHAIN_ID;\n\n    /**\n     * @notice Tracks addresses created by this factory.\n     */\n    mapping(address => bool) public isKromaMintableERC721;\n\n    /**\n     * @notice Emitted whenever a new KromaMintableERC721 contract is created.\n     *\n     * @param localToken  Address of the token on the this domain.\n     * @param remoteToken Address of the token on the remote domain.\n     * @param deployer    Address of the initiator of the deployment\n     */\n    event KromaMintableERC721Created(\n        address indexed localToken,\n        address indexed remoteToken,\n        address deployer\n    );\n\n    /**\n     * @notice Semantic version.\n     * @custom:semver 1.0.0\n     */\n    string public constant version = \"1.0.0\";\n\n    /**\n     * @notice Constructs the KromaMintableERC721Factory contract.\n     *         The semver MUST be bumped any time that there is a change in\n     *         the KromaMintableERC721 token contract since this contract\n     *         is responsible for deploying KromaMintableERC721 contracts.\n     *\n     * @param _bridge Address of the ERC721 bridge on this network.\n     * @param _remoteChainId Chain ID for the remote network.\n     */\n    constructor(address _bridge, uint256 _remoteChainId) {\n        BRIDGE = _bridge;\n        REMOTE_CHAIN_ID = _remoteChainId;\n    }\n\n    /**\n     * @notice Creates an instance of the standard ERC721.\n     *\n     * @param _remoteToken Address of the corresponding token on the other domain.\n     * @param _name        ERC721 name.\n     * @param _symbol      ERC721 symbol.\n     */\n    function createKromaMintableERC721(\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) external returns (address) {\n        require(\n            _remoteToken != address(0),\n            \"KromaMintableERC721Factory: L1 token address cannot be address(0)\"\n        );\n\n        address localToken = address(\n            new KromaMintableERC721(BRIDGE, REMOTE_CHAIN_ID, _remoteToken, _name, _symbol)\n        );\n\n        isKromaMintableERC721[localToken] = true;\n        emit KromaMintableERC721Created(localToken, _remoteToken, msg.sender);\n\n        return localToken;\n    }\n}\n"
    },
    "contracts/universal/KromaSoulBoundERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721VotesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\";\n\n/**\n * @title IERC5192\n * @notice Interface for contracts that are compatible with the ERC721 standard.\n */\ninterface IERC5192 {\n    /**\n     * @notice Emitted when the locking status is changed to locked.\n     * @dev If a token is minted and the status is locked, this event should be emitted.\n     * @param tokenId The identifier for a token.\n     */\n    event Locked(uint256 tokenId);\n\n    /**\n     * @notice Emitted when the locking status is changed to unlocked.\n     * @dev If a token is minted and the status is unlocked, this event should be emitted.\n     * @param tokenId The identifier for a token.\n     */\n    event Unlocked(uint256 tokenId);\n\n    /**\n     * @notice Returns the locking status of an Soulbound Token\n     * @dev SBTs assigned to zero address are considered invalid, and queries about them do throw.\n     * @param tokenId The identifier for an SBT.\n     */\n    function locked(uint256 tokenId) external view returns (bool);\n}\n\nabstract contract KromaSoulBoundERC721 is\n    Initializable,\n    IERC5192,\n    ERC721Upgradeable,\n    ERC721EnumerableUpgradeable,\n    ERC721URIStorageUpgradeable,\n    PausableUpgradeable,\n    OwnableUpgradeable,\n    EIP712Upgradeable,\n    ERC721VotesUpgradeable\n{\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    CountersUpgradeable.Counter private _tokenIdCounter;\n    bool private isLocked;\n\n    error ErrLocked();\n    error ErrNotFound();\n\n    modifier checkLock() {\n        if (isLocked) revert ErrLocked();\n        _;\n    }\n\n    /**\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @param _name   ERC721 name.\n     * @param _symbol ERC721 symbol.\n     * @param _owner  Owner of token.\n     */\n    function __KromaSoulBoundERC721_init(\n        string memory _name,\n        string memory _symbol,\n        address _owner\n    ) internal onlyInitializing {\n        __KromaSoulBoundERC721_init_unchained(true);\n        __ERC721_init(_name, _symbol);\n        __ERC721Enumerable_init();\n        __ERC721URIStorage_init();\n        __Pausable_init();\n        __EIP712_init(_name, \"1\");\n        __ERC721Votes_init();\n        _transferOwnership(_owner);\n    }\n\n    function __KromaSoulBoundERC721_init_unchained(bool _isLocked) internal onlyInitializing {\n        isLocked = _isLocked;\n    }\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    function safeMint(address to, string memory uri) public onlyOwner {\n        uint256 tokenId = _tokenIdCounter.current();\n        _tokenIdCounter.increment();\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, uri);\n        _delegate(to, to);\n    }\n\n    function burn(uint256 tokenId) public onlyOwner {\n        _burn(tokenId);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 batchSize\n    ) internal override(ERC721Upgradeable, ERC721EnumerableUpgradeable) whenNotPaused {\n        super._beforeTokenTransfer(from, to, tokenId, batchSize);\n    }\n\n    function locked(uint256 tokenId) external view returns (bool) {\n        if (!_exists(tokenId)) revert ErrNotFound();\n        return isLocked;\n    }\n\n    // The following functions are overridden cause required by Solidity.\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 batchSize\n    ) internal override(ERC721Upgradeable, ERC721VotesUpgradeable) {\n        super._afterTokenTransfer(from, to, tokenId, batchSize);\n    }\n\n    function _burn(uint256 tokenId)\n        internal\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n    {\n        super._burn(tokenId);\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public override(IERC721Upgradeable, ERC721Upgradeable) checkLock {\n        super.safeTransferFrom(from, to, tokenId, data);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override(IERC721Upgradeable, ERC721Upgradeable) checkLock {\n        super.safeTransferFrom(from, to, tokenId);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override(IERC721Upgradeable, ERC721Upgradeable) checkLock {\n        super.transferFrom(from, to, tokenId);\n    }\n\n    function approve(address approved, uint256 tokenId)\n        public\n        virtual\n        override(IERC721Upgradeable, ERC721Upgradeable)\n        checkLock\n    {\n        super.approve(approved, tokenId);\n    }\n\n    function setApprovalForAll(address operator, bool approved)\n        public\n        override(IERC721Upgradeable, ERC721Upgradeable)\n        checkLock\n    {\n        super.setApprovalForAll(operator, approved);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, ERC721EnumerableUpgradeable, ERC721URIStorageUpgradeable)\n        returns (bool)\n    {\n        return interfaceId == type(IERC5192).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/universal/KromaVestingWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts-upgradeable/finance/VestingWalletUpgradeable.sol\";\n\n/**\n * @custom:proxied\n * @title KromaVestingWallet\n * @notice KromaVestingWallet vests funds equally every `vestingCycle` for the duration from the\n *         start timestamp. `totalAllocation / cliffDivider` amount of the tokens will be vested at\n *         the start timestamp, and after that remaining tokens will be vested every `vestingCycle`\n *         for the duration.\n */\ncontract KromaVestingWallet is VestingWalletUpgradeable {\n    /**\n     * @notice The divider of total allocation to calculate the cliff amount to be vested at the\n     *         start timestamp.\n     */\n    uint256 public immutable CLIFF_DIVIDER;\n\n    /**\n     * @notice The cycle that represents how often the funds are vested (unit: seconds).\n     */\n    uint256 public immutable VESTING_CYCLE;\n\n    /**\n     * @notice A modifier that only allows beneficiary to call.\n     */\n    modifier onlyBeneficiary() {\n        require(msg.sender == beneficiary(), \"KromaVestingWallet: caller is not beneficiary\");\n        _;\n    }\n\n    /**\n     * @notice Constructs the KromaVestingWallet contract.\n     *\n     * @param _cliffDivider        The divider to calculate the cliff amount at start timestamp.\n     * @param _vestingCycleSeconds The cycle that represents how often funds are vested.\n     */\n    constructor(uint64 _cliffDivider, uint64 _vestingCycleSeconds) {\n        require(_cliffDivider > 0, \"KromaVestingWallet: cliff divider is zero\");\n        require(_vestingCycleSeconds > 0, \"KromaVestingWallet: vesting cycle is zero\");\n\n        CLIFF_DIVIDER = _cliffDivider;\n        VESTING_CYCLE = _vestingCycleSeconds;\n\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializer.\n     *\n     * @param _beneficiary     Address that can release funds and receives released funds.\n     * @param _startTimestamp  The timestamp to start vesting.\n     * @param _durationSeconds The time period for funds to fully vest.\n     */\n    function initialize(\n        address _beneficiary,\n        uint64 _startTimestamp,\n        uint64 _durationSeconds\n    ) public initializer {\n        require(\n            _durationSeconds % VESTING_CYCLE == 0,\n            \"KromaVestingWallet: duration should be multiple of vesting cycle\"\n        );\n\n        __VestingWallet_init(_beneficiary, _startTimestamp, _durationSeconds);\n    }\n\n    /**\n     * @notice Releases the tokens that have already vested; only beneficiary can call.\n     *\n     * @param token Address of ERC20 token to release.\n     */\n    function release(address token) public override onlyBeneficiary {\n        super.release(token);\n    }\n\n    /**\n     * @notice Releases the native token (ether) that have already vested; only beneficiary can call.\n     */\n    function release() public override onlyBeneficiary {\n        super.release();\n    }\n\n    /**\n     * @notice Overrides vesting formula. This returns the amount vested, as a function of time, for\n     *         an asset given its total historical allocation.\n     *\n     * @param totalAllocation Total historical allocation of the asset.\n     * @param timestamp       Timestamp to be used to calculate the vested amount.\n     *\n     * @return The amount vested, as a function of time, for an asset given its total historical\n     *         allocation.\n     */\n    function _vestingSchedule(\n        uint256 totalAllocation,\n        uint64 timestamp\n    ) internal view override returns (uint256) {\n        if (timestamp < start()) {\n            return 0;\n        } else if (timestamp >= start() + duration()) {\n            return totalAllocation;\n        } else {\n            // At the start date, cliff amount of the assets are immediately vested.\n            // After, the assets will be vested proportionally every vesting cycle for the duration.\n            uint256 cliffAmount = totalAllocation / CLIFF_DIVIDER;\n\n            // Since vested in units of cycle, remove any seconds over the end of last cycle.\n            uint256 vestedSeconds = timestamp - start();\n            uint256 vestedSecondsFloored = vestedSeconds - (vestedSeconds % VESTING_CYCLE);\n            uint256 afterVestedAmount = ((totalAllocation - cliffAmount) * vestedSecondsFloored) /\n                duration();\n\n            return cliffAmount + afterVestedAmount;\n        }\n    }\n}\n"
    },
    "contracts/universal/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title Proxy\n * @notice Proxy is a transparent proxy that passes through the call if the caller is the owner or\n *         if the caller is address(0), meaning that the call originated from an off-chain\n *         simulation.\n */\ncontract Proxy {\n    /**\n     * @notice The storage slot that holds the address of the implementation.\n     *         bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\n     */\n    bytes32 internal constant IMPLEMENTATION_KEY =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @notice The storage slot that holds the address of the owner.\n     *         bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\n     */\n    bytes32 internal constant OWNER_KEY =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @notice An event that is emitted each time the implementation is changed. This event is part\n     *         of the EIP-1967 specification.\n     *\n     * @param implementation The address of the implementation contract\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @notice An event that is emitted each time the owner is upgraded. This event is part of the\n     *         EIP-1967 specification.\n     *\n     * @param previousAdmin The previous owner of the contract\n     * @param newAdmin      The new owner of the contract\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @notice A modifier that reverts if not called by the owner or by address(0) to allow\n     *         eth_call to interact with this proxy without needing to use low-level storage\n     *         inspection. We assume that nobody is able to trigger calls from address(0) during\n     *         normal EVM execution.\n     */\n    modifier proxyCallIfNotAdmin() {\n        if (msg.sender == _getAdmin() || msg.sender == address(0)) {\n            _;\n        } else {\n            // This WILL halt the call frame on completion.\n            _doProxyCall();\n        }\n    }\n\n    /**\n     * @notice Sets the initial admin during contract deployment. Admin address is stored at the\n     *         EIP-1967 admin storage slot so that accidental storage collision with the\n     *         implementation is not possible.\n     *\n     * @param _admin Address of the initial contract admin. Admin as the ability to access the\n     *               transparent proxy interface.\n     */\n    constructor(address _admin) {\n        _changeAdmin(_admin);\n    }\n\n    // slither-disable-next-line locked-ether\n    receive() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    // slither-disable-next-line locked-ether\n    fallback() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    /**\n     * @notice Set the implementation contract address. The code at the given address will execute\n     *         when this contract is called.\n     *\n     * @param _implementation Address of the implementation contract.\n     */\n    function upgradeTo(address _implementation) public virtual proxyCallIfNotAdmin {\n        _setImplementation(_implementation);\n    }\n\n    /**\n     * @notice Set the implementation and call a function in a single transaction. Useful to ensure\n     *         atomic execution of initialization-based upgrades.\n     *\n     * @param _implementation Address of the implementation contract.\n     * @param _data           Calldata to delegatecall the new implementation with.\n     */\n    function upgradeToAndCall(\n        address _implementation,\n        bytes calldata _data\n    ) public payable virtual proxyCallIfNotAdmin returns (bytes memory) {\n        _setImplementation(_implementation);\n        (bool success, bytes memory returndata) = _implementation.delegatecall(_data);\n        require(success, \"Proxy: delegatecall to new implementation contract failed\");\n        return returndata;\n    }\n\n    /**\n     * @notice Changes the owner of the proxy contract. Only callable by the owner.\n     *\n     * @param _admin New owner of the proxy contract.\n     */\n    function changeAdmin(address _admin) public virtual proxyCallIfNotAdmin {\n        _changeAdmin(_admin);\n    }\n\n    /**\n     * @notice Gets the owner of the proxy contract.\n     *\n     * @return Owner address.\n     */\n    function admin() public virtual proxyCallIfNotAdmin returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @notice Queries the implementation address.\n     *\n     * @return Implementation address.\n     */\n    function implementation() public virtual proxyCallIfNotAdmin returns (address) {\n        return _getImplementation();\n    }\n\n    /**\n     * @notice Sets the implementation address.\n     *\n     * @param _implementation New implementation address.\n     */\n    function _setImplementation(address _implementation) internal {\n        assembly {\n            sstore(IMPLEMENTATION_KEY, _implementation)\n        }\n        emit Upgraded(_implementation);\n    }\n\n    /**\n     * @notice Changes the owner of the proxy contract.\n     *\n     * @param _admin New owner of the proxy contract.\n     */\n    function _changeAdmin(address _admin) internal {\n        address previous = _getAdmin();\n        assembly {\n            sstore(OWNER_KEY, _admin)\n        }\n        emit AdminChanged(previous, _admin);\n    }\n\n    /**\n     * @notice Performs the proxy call via a delegatecall.\n     */\n    function _doProxyCall() internal {\n        address impl = _getImplementation();\n        require(impl != address(0), \"Proxy: implementation not initialized\");\n\n        assembly {\n            // Copy calldata into memory at 0x0....calldatasize.\n            calldatacopy(0x0, 0x0, calldatasize())\n\n            // Perform the delegatecall, make sure to pass all available gas.\n            let success := delegatecall(gas(), impl, 0x0, calldatasize(), 0x0, 0x0)\n\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\n            // overwrite the calldata that we just copied into memory but that doesn't really\n            // matter because we'll be returning in a second anyway.\n            returndatacopy(0x0, 0x0, returndatasize())\n\n            // Success == 0 means a revert. We'll revert too and pass the data up.\n            if iszero(success) {\n                revert(0x0, returndatasize())\n            }\n\n            // Otherwise we'll just return and pass the data up.\n            return(0x0, returndatasize())\n        }\n    }\n\n    /**\n     * @notice Queries the implementation address.\n     *\n     * @return Implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        address impl;\n        assembly {\n            impl := sload(IMPLEMENTATION_KEY)\n        }\n        return impl;\n    }\n\n    /**\n     * @notice Queries the owner of the proxy contract.\n     *\n     * @return Owner address.\n     */\n    function _getAdmin() internal view returns (address) {\n        address owner;\n        assembly {\n            owner := sload(OWNER_KEY)\n        }\n        return owner;\n    }\n}\n"
    },
    "contracts/universal/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { Proxy } from \"./Proxy.sol\";\n\n/**\n * @title IStaticERC1967Proxy\n * @notice IStaticERC1967Proxy is a static version of the ERC1967 proxy interface.\n */\ninterface IStaticERC1967Proxy {\n    function implementation() external view returns (address);\n\n    function admin() external view returns (address);\n}\n\n/**\n * @title ProxyAdmin\n * @notice This is an auxiliary contract meant to be assigned as the admin of an ERC1967 Proxy,\n *         based on the OpenZeppelin implementation.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @param _owner Address of the initial owner of this contract.\n     */\n    constructor(address _owner) Ownable() {\n        _transferOwnership(_owner);\n    }\n\n    /**\n     * @notice Returns the implementation of the given proxy address.\n     *\n     * @param _proxy Address of the proxy to get the implementation of.\n     *\n     * @return Address of the implementation of the proxy.\n     */\n    function getProxyImplementation(address _proxy) external view returns (address) {\n        return IStaticERC1967Proxy(_proxy).implementation();\n    }\n\n    /**\n     * @notice Returns the admin of the given proxy address.\n     *\n     * @param _proxy Address of the proxy to get the admin of.\n     *\n     * @return Address of the admin of the proxy.\n     */\n    function getProxyAdmin(address payable _proxy) external view returns (address) {\n        return IStaticERC1967Proxy(_proxy).admin();\n    }\n\n    /**\n     * @notice Updates the admin of the given proxy address.\n     *\n     * @param _proxy    Address of the proxy to update.\n     * @param _newAdmin Address of the new proxy admin.\n     */\n    function changeProxyAdmin(address payable _proxy, address _newAdmin) external onlyOwner {\n        Proxy(_proxy).changeAdmin(_newAdmin);\n    }\n\n    /**\n     * @notice Changes a proxy's implementation contract.\n     *\n     * @param _proxy          Address of the proxy to upgrade.\n     * @param _implementation Address of the new implementation address.\n     */\n    function upgrade(address payable _proxy, address _implementation) public onlyOwner {\n        Proxy(_proxy).upgradeTo(_implementation);\n    }\n\n    /**\n     * @notice Changes a proxy's implementation contract and delegatecalls the new implementation\n     *         with some given data. Useful for atomic upgrade-and-initialize calls.\n     *\n     * @param _proxy          Address of the proxy to upgrade.\n     * @param _implementation Address of the new implementation address.\n     * @param _data           Data to trigger the new implementation with.\n     */\n    function upgradeAndCall(\n        address payable _proxy,\n        address _implementation,\n        bytes memory _data\n    ) external payable onlyOwner {\n        Proxy(_proxy).upgradeToAndCall{ value: msg.value }(_implementation, _data);\n    }\n}\n"
    },
    "contracts/universal/StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { CrossDomainMessenger } from \"./CrossDomainMessenger.sol\";\nimport { IKromaMintableERC20 } from \"./IKromaMintableERC20.sol\";\nimport { KromaMintableERC20 } from \"./KromaMintableERC20.sol\";\n\n/**\n * @custom:upgradeable\n * @title StandardBridge\n * @notice StandardBridge is a base contract for the L1 and L2 standard ERC20 bridges. It handles\n *         the core bridging logic, including escrowing tokens that are native to the local chain\n *         and minting/burning tokens that are native to the remote chain.\n */\nabstract contract StandardBridge {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice The L2 gas limit set when eth is depoisited using the receive() function.\n     */\n    uint32 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 200_000;\n\n    /**\n     * @notice Messenger contract on this domain.\n     */\n    CrossDomainMessenger public immutable MESSENGER;\n\n    /**\n     * @notice Corresponding bridge on the other domain.\n     */\n    StandardBridge public immutable OTHER_BRIDGE;\n\n    /**\n     * @notice Mapping that stores deposits for a given pair of local and remote tokens.\n     */\n    mapping(address => mapping(address => uint256)) public deposits;\n\n    /**\n     * @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\n     *         A gap size of 49 was chosen here, so that the first slot used in a child contract\n     *         would be a multiple of 50.\n     */\n    uint256[49] private __gap;\n\n    /**\n     * @notice Emitted when an ETH bridge is initiated to the other chain.\n     *\n     * @param from      Address of the sender.\n     * @param to        Address of the receiver.\n     * @param amount    Amount of ETH sent.\n     * @param extraData Extra data sent with the transaction.\n     */\n    event ETHBridgeInitiated(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @notice Emitted when an ETH bridge is finalized on this chain.\n     *\n     * @param from      Address of the sender.\n     * @param to        Address of the receiver.\n     * @param amount    Amount of ETH sent.\n     * @param extraData Extra data sent with the transaction.\n     */\n    event ETHBridgeFinalized(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @notice Emitted when an ERC20 bridge is initiated to the other chain.\n     *\n     * @param localToken  Address of the ERC20 on this chain.\n     * @param remoteToken Address of the ERC20 on the remote chain.\n     * @param from        Address of the sender.\n     * @param to          Address of the receiver.\n     * @param amount      Amount of the ERC20 sent.\n     * @param extraData   Extra data sent with the transaction.\n     */\n    event ERC20BridgeInitiated(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @notice Emitted when an ERC20 bridge is finalized on this chain.\n     *\n     * @param localToken  Address of the ERC20 on this chain.\n     * @param remoteToken Address of the ERC20 on the remote chain.\n     * @param from        Address of the sender.\n     * @param to          Address of the receiver.\n     * @param amount      Amount of the ERC20 sent.\n     * @param extraData   Extra data sent with the transaction.\n     */\n    event ERC20BridgeFinalized(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @notice Only allow EOAs to call the functions. Note that this is not safe against contracts\n     *         calling code within their constructors, but also doesn't really matter since we're\n     *         just trying to prevent users accidentally depositing with smart contract wallets.\n     */\n    modifier onlyEOA() {\n        require(\n            !Address.isContract(msg.sender),\n            \"StandardBridge: function can only be called from an EOA\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Ensures that the caller is a cross-chain message from the other bridge.\n     */\n    modifier onlyOtherBridge() {\n        require(\n            msg.sender == address(MESSENGER) &&\n                MESSENGER.xDomainMessageSender() == address(OTHER_BRIDGE),\n            \"StandardBridge: function can only be called from the other bridge\"\n        );\n        _;\n    }\n\n    /**\n     * @param _messenger   Address of CrossDomainMessenger on this network.\n     * @param _otherBridge Address of the other StandardBridge contract.\n     */\n    constructor(address payable _messenger, address payable _otherBridge) {\n        MESSENGER = CrossDomainMessenger(_messenger);\n        OTHER_BRIDGE = StandardBridge(_otherBridge);\n    }\n\n    /**\n     * @notice Allows EOAs to bridge ETH by sending directly to the bridge.\n     *         Must be implemented by contracts that inherit.\n     */\n    receive() external payable virtual;\n\n    /**\n     * @notice Sends ETH to the sender's address on the other chain.\n     *\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function bridgeETH(uint32 _minGasLimit, bytes calldata _extraData) public payable onlyEOA {\n        _initiateBridgeETH(msg.sender, msg.sender, msg.value, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @notice Sends ETH to a receiver's address on the other chain. Note that if ETH is sent to a\n     *         smart contract and the call fails, the ETH will be temporarily locked in the\n     *         StandardBridge on the other chain until the call is replayed. If the call cannot be\n     *         replayed with any amount of gas (call always reverts), then the ETH will be\n     *         permanently locked in the StandardBridge on the other chain. ETH will also\n     *         be locked if the receiver is the other bridge, because finalizeBridgeETH will revert\n     *         in that case.\n     *\n     * @param _to          Address of the receiver.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function bridgeETHTo(\n        address _to,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) public payable {\n        _initiateBridgeETH(msg.sender, _to, msg.value, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @notice Sends ERC20 tokens to the sender's address on the other chain. Note that if the\n     *         ERC20 token on the other chain does not recognize the local token as the correct\n     *         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\n     *         this chain.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _amount      Amount of local tokens to deposit.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function bridgeERC20(\n        address _localToken,\n        address _remoteToken,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) public onlyEOA {\n        _initiateBridgeERC20(\n            _localToken,\n            _remoteToken,\n            msg.sender,\n            msg.sender,\n            _amount,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @notice Sends ERC20 tokens to a receiver's address on the other chain. Note that if the\n     *         ERC20 token on the other chain does not recognize the local token as the correct\n     *         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\n     *         this chain.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of local tokens to deposit.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function bridgeERC20To(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) public {\n        _initiateBridgeERC20(\n            _localToken,\n            _remoteToken,\n            msg.sender,\n            _to,\n            _amount,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @notice Finalizes an ETH bridge on this chain. Can only be triggered by the other\n     *         StandardBridge contract on the remote chain.\n     *\n     * @param _from      Address of the sender.\n     * @param _to        Address of the receiver.\n     * @param _amount    Amount of ETH being bridged.\n     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will\n     *                   not be triggered with this data, but it will be emitted and can be used\n     *                   to identify the transaction.\n     */\n    function finalizeBridgeETH(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _extraData\n    ) public payable onlyOtherBridge {\n        require(msg.value == _amount, \"StandardBridge: amount sent does not match amount required\");\n        require(_to != address(this), \"StandardBridge: cannot send to self\");\n        require(_to != address(MESSENGER), \"StandardBridge: cannot send to messenger\");\n\n        emit ETHBridgeFinalized(_from, _to, _amount, _extraData);\n\n        bool success = SafeCall.call(_to, gasleft(), _amount, hex\"\");\n        require(success, \"StandardBridge: ETH transfer failed\");\n    }\n\n    /**\n     * @notice Finalizes an ERC20 bridge on this chain. Can only be triggered by the other\n     *         StandardBridge contract on the remote chain.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _from        Address of the sender.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of the ERC20 being bridged.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function finalizeBridgeERC20(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _extraData\n    ) public onlyOtherBridge {\n        if (_isKromaMintableERC20(_localToken)) {\n            require(\n                _isCorrectTokenPair(_localToken, _remoteToken),\n                \"StandardBridge: wrong remote token for Kroma Mintable ERC20 local token\"\n            );\n\n            KromaMintableERC20(_localToken).mint(_to, _amount);\n        } else {\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] - _amount;\n            IERC20(_localToken).safeTransfer(_to, _amount);\n        }\n\n        emit ERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n    }\n\n    /**\n     * @notice Initiates a bridge of ETH through the CrossDomainMessenger.\n     *\n     * @param _from        Address of the sender.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of ETH being bridged.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function _initiateBridgeETH(\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes memory _extraData\n    ) internal {\n        require(\n            msg.value == _amount,\n            \"StandardBridge: bridging ETH must include sufficient ETH value\"\n        );\n\n        emit ETHBridgeInitiated(_from, _to, _amount, _extraData);\n\n        MESSENGER.sendMessage{ value: _amount }(\n            address(OTHER_BRIDGE),\n            abi.encodeWithSelector(\n                this.finalizeBridgeETH.selector,\n                _from,\n                _to,\n                _amount,\n                _extraData\n            ),\n            _minGasLimit\n        );\n    }\n\n    /**\n     * @notice Sends ERC20 tokens to a receiver's address on the other chain.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of local tokens to deposit.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function _initiateBridgeERC20(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes memory _extraData\n    ) internal {\n        if (_isKromaMintableERC20(_localToken)) {\n            require(\n                _isCorrectTokenPair(_localToken, _remoteToken),\n                \"StandardBridge: wrong remote token for Kroma Mintable ERC20 local token\"\n            );\n\n            KromaMintableERC20(_localToken).burn(_from, _amount);\n        } else {\n            IERC20(_localToken).safeTransferFrom(_from, address(this), _amount);\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] + _amount;\n        }\n\n        emit ERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n\n        MESSENGER.sendMessage(\n            address(OTHER_BRIDGE),\n            abi.encodeWithSelector(\n                this.finalizeBridgeERC20.selector,\n                // Because this call will be executed on the remote chain, we reverse the order of\n                // the remote and local token addresses relative to their order in the\n                // finalizeBridgeERC20 function.\n                _remoteToken,\n                _localToken,\n                _from,\n                _to,\n                _amount,\n                _extraData\n            ),\n            _minGasLimit\n        );\n    }\n\n    /**\n     * @notice Checks if a given address is a KromaMintableERC20. Not perfect, but good enough.\n     *         Just the way we like it.\n     *\n     * @param _token Address of the token to check.\n     *\n     * @return True if the token is a KromaMintableERC20.\n     */\n    function _isKromaMintableERC20(address _token) internal view returns (bool) {\n        return ERC165Checker.supportsInterface(_token, type(IKromaMintableERC20).interfaceId);\n    }\n\n    /**\n     * @notice Checks if the \"other token\" is the correct pair token for the KromaMintableERC20.\n     *\n     * @param _mintableToken KromaMintableERC20 to check against.\n     * @param _otherToken    Pair token to check.\n     *\n     * @return True if the other token is the correct pair token for the KromaMintableERC20.\n     */\n    function _isCorrectTokenPair(address _mintableToken, address _otherToken)\n        internal\n        view\n        returns (bool)\n    {\n        return _otherToken == KromaMintableERC20(_mintableToken).REMOTE_TOKEN();\n    }\n}\n"
    },
    "contracts/universal/TokenMultiSigWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC5805Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\n\nimport { UpgradeGovernor } from \"../governance/UpgradeGovernor.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { ITokenMultiSigWallet } from \"./ITokenMultiSigWallet.sol\";\n\n/**\n * @custom:upgradeable\n * @title TokenMultiSigWallet\n * @notice This contract implements `ITokenMultiSigWallet`.\n *         Allows multiple parties to agree on transactions before execution.\n */\nabstract contract TokenMultiSigWallet is ITokenMultiSigWallet, ReentrancyGuardUpgradeable {\n    /**\n     * @notice The address of the governor contract. Can be updated via upgrade.\n     */\n    UpgradeGovernor public immutable GOVERNOR;\n\n    /**\n     * @notice A mapping of transactions submitted.\n     */\n    mapping(uint256 => Types.MultiSigTransaction) public transactions;\n\n    /**\n     * @notice A mapping of confirmations.\n     */\n    mapping(uint256 => Types.MultiSigConfirmation) public confirmations;\n\n    /**\n     * @notice Spacer for backwards compatibility.\n     */\n    uint256[3] private spacer_53_0_96;\n\n    /**\n     * @notice The number of transactions submitted.\n     */\n    uint256 public transactionCount;\n\n    /**\n     * @notice Only allow the owner of governance token to call the functions.\n     *         This ensures that function is only executed by governance.\n     */\n    modifier onlyTokenOwner(address _address) {\n        require(\n            getVotes(_address) > 0,\n            \"TokenMultiSigWallet: only allowed to governance token owner\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Ensure that the transaction exists.\n     *\n     * @param _transactionId The ID of submitted transaction requested.\n     */\n    modifier transactionExists(uint256 _transactionId) {\n        require(\n            transactions[_transactionId].target != address(0),\n            \"TokenMultiSigWallet: transaction does not exist\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Ensure that the transaction not exceuted.\n     *\n     * @param _transactionId The ID of transaction to check.\n     */\n    modifier transactionNotExcuted(uint256 _transactionId) {\n        require(!transactions[_transactionId].executed, \"TokenMultiSigWallet: already executed\");\n        _;\n    }\n\n    /**\n     * @notice Ensure that the address is not zero address.\n     *\n     * @param _address Address resource requested.\n     */\n    modifier validAddress(address _address) {\n        require(_address != address(0), \"TokenMultiSigWallet: address is not valid\");\n        _;\n    }\n\n    /**\n     * @param _governor Address of the Governor contract.\n     */\n    constructor(address payable _governor) {\n        GOVERNOR = UpgradeGovernor(_governor);\n    }\n\n    /**\n     * @inheritdoc ITokenMultiSigWallet\n     */\n    function submitTransaction(\n        address _target,\n        uint256 _value,\n        bytes memory _data\n    ) public onlyTokenOwner(msg.sender) returns (uint256) {\n        return _submitTransaction(_target, _value, _data);\n    }\n\n    function _submitTransaction(\n        address _target,\n        uint256 _value,\n        bytes memory _data\n    ) internal validAddress(_target) returns (uint256) {\n        uint256 transactionId = generateTransactionId(_target, _value, _data);\n        require(\n            transactions[transactionId].target == address(0),\n            \"TokenMultiSigWallet: transaction already exists\"\n        );\n\n        transactions[transactionId] = Types.MultiSigTransaction({\n            target: _target,\n            value: _value,\n            data: _data,\n            executed: false\n        });\n\n        unchecked {\n            ++transactionCount;\n        }\n\n        emit TransactionSubmitted(msg.sender, transactionId);\n        return transactionId;\n    }\n\n    /**\n     * @inheritdoc ITokenMultiSigWallet\n     */\n    function confirmTransaction(uint256 _transactionId)\n        public\n        onlyTokenOwner(msg.sender)\n        transactionExists(_transactionId)\n    {\n        Types.MultiSigConfirmation storage confirms = confirmations[_transactionId];\n        require(!confirms.confirmedBy[msg.sender], \"TokenMultiSigWallet: already confirmed\");\n        confirms.confirmedBy[msg.sender] = true;\n        confirms.confirmationCount += getVotes(msg.sender);\n        emit TransactionConfirmed(msg.sender, _transactionId);\n\n        // execute transaction if condition is met.\n        if (confirmations[_transactionId].confirmationCount >= quorum()) {\n            executeTransaction(_transactionId);\n        }\n    }\n\n    /**\n     * @inheritdoc ITokenMultiSigWallet\n     */\n    function revokeConfirmation(uint256 _transactionId)\n        public\n        onlyTokenOwner(msg.sender)\n        transactionExists(_transactionId)\n        transactionNotExcuted(_transactionId)\n    {\n        require(\n            isConfirmedBy(_transactionId, msg.sender),\n            \"TokenMultiSigWallet: not confirmed yet\"\n        );\n\n        Types.MultiSigConfirmation storage confirms = confirmations[_transactionId];\n        confirms.confirmedBy[msg.sender] = false;\n        confirms.confirmationCount -= getVotes(msg.sender);\n        emit ConfirmationRevoked(msg.sender, _transactionId);\n    }\n\n    /**\n     * @inheritdoc ITokenMultiSigWallet\n     */\n    function executeTransaction(uint256 _transactionId)\n        public\n        nonReentrant\n        transactionExists(_transactionId)\n        transactionNotExcuted(_transactionId)\n    {\n        require(isConfirmed(_transactionId), \"TokenMultiSigWallet: quorum not reached\");\n\n        Types.MultiSigTransaction storage txn = transactions[_transactionId];\n        txn.executed = true;\n        bool success = SafeCall.call(txn.target, gasleft(), txn.value, txn.data);\n        require(success, \"TokenMultiSigWallet: call transaction failed\");\n        emit TransactionExecuted(msg.sender, _transactionId);\n    }\n\n    /**\n     * @inheritdoc ITokenMultiSigWallet\n     */\n    function isConfirmed(uint256 _transactionId) public view returns (bool) {\n        return confirmations[_transactionId].confirmationCount >= quorum();\n    }\n\n    /**\n     * @inheritdoc ITokenMultiSigWallet\n     */\n    function quorum() public view returns (uint256) {\n        uint256 currentTimepoint = clock() - 1;\n        return\n            (IERC5805Upgradeable(address(GOVERNOR.token())).getPastTotalSupply(currentTimepoint) *\n                GOVERNOR.quorumNumerator(currentTimepoint)) / GOVERNOR.quorumDenominator();\n    }\n\n    /**\n     * @inheritdoc ITokenMultiSigWallet\n     */\n    function getVotes(address account) public view returns (uint256) {\n        return IERC5805Upgradeable(address(GOVERNOR.token())).getVotes(account);\n    }\n\n    /**\n     * @inheritdoc ITokenMultiSigWallet\n     */\n    function isConfirmedBy(uint256 _transactionId, address _account) public view returns (bool) {\n        return confirmations[_transactionId].confirmedBy[_account];\n    }\n\n    /**\n     * @inheritdoc ITokenMultiSigWallet\n     */\n    function getConfirmationCount(uint256 _transactionId) public view returns (uint256) {\n        return confirmations[_transactionId].confirmationCount;\n    }\n\n    /**\n     * @notice Generate id of the transaction.\n     *\n     * @param _target Transaction target address.\n     * @param _value  Transaction ether value.\n     * @param _data   Transaction data payload.\n     *\n     * @return Generated transaction id.\n     */\n    function generateTransactionId(\n        address _target,\n        uint256 _value,\n        bytes memory _data\n    ) public view validAddress(_target) returns (uint256) {\n        return uint256(keccak256(abi.encode(_target, _value, _data, clock())));\n    }\n\n    /**\n     * @dev Clock (as specified in EIP-6372) is set to match the token's clock.\n     *      Fallback to block numbers if the token does not implement EIP-6372.\n     */\n    function clock() public view returns (uint48) {\n        try IERC5805Upgradeable(address(GOVERNOR.token())).clock() returns (uint48 timepoint) {\n            return timepoint;\n        } catch {\n            return SafeCastUpgradeable.toUint48(block.number);\n        }\n    }\n}\n"
    },
    "contracts/vendor/AddressAliasHelper.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nlibrary AddressAliasHelper {\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + offset);\n        }\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        unchecked {\n            l1Address = address(uint160(l2Address) - offset);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/governance/utils/IVotes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/utils/IVotes.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n *\n * _Available since v4.5._\n */\ninterface IVotes {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     */\n    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "node_modules/@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "node_modules/@openzeppelin/contracts/interfaces/IERC5805.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5805.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../governance/utils/IVotes.sol\";\nimport \"./IERC6372.sol\";\n\ninterface IERC5805 is IERC6372, IVotes {}\n"
    },
    "node_modules/@openzeppelin/contracts/interfaces/IERC6372.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC6372.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC6372 {\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() external view returns (uint48);\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() external view returns (string memory);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/cryptography/EIP712.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Votes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20Permit.sol\";\nimport \"../../../interfaces/IERC5805.sol\";\nimport \"../../../utils/math/Math.sol\";\nimport \"../../../utils/math/SafeCast.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20Votes is ERC20Permit, IERC5805 {\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() public view virtual override returns (uint48) {\n        return SafeCast.toUint48(block.number);\n    }\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual override returns (string memory) {\n        // Check that the clock was not modified\n        require(clock() == block.number, \"ERC20Votes: broken clock mode\");\n        return \"mode=blocknumber&from=default\";\n    }\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        unchecked {\n            return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n        }\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `timepoint`.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past\n     */\n    function getPastVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {\n        require(timepoint < clock(), \"ERC20Votes: future lookup\");\n        return _checkpointsLookup(_checkpoints[account], timepoint);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `timepoint`. Note, this value is the sum of all balances.\n     * It is NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past\n     */\n    function getPastTotalSupply(uint256 timepoint) public view virtual override returns (uint256) {\n        require(timepoint < clock(), \"ERC20Votes: future lookup\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, timepoint);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 timepoint) private view returns (uint256) {\n        // We run a binary search to look for the last (most recent) checkpoint taken before (or at) `timepoint`.\n        //\n        // Initially we check if the block is recent to narrow the search range.\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `timepoint`, we look in [low, mid)\n        // - If the middle checkpoint is before or equal to `timepoint`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `timepoint`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `timepoint`, but it works out\n        // the same.\n        uint256 length = ckpts.length;\n\n        uint256 low = 0;\n        uint256 high = length;\n\n        if (length > 5) {\n            uint256 mid = length - Math.sqrt(length);\n            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        unchecked {\n            return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;\n        }\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {IVotes-DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(address src, address dst, uint256 amount) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n\n        unchecked {\n            Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);\n\n            oldWeight = oldCkpt.votes;\n            newWeight = op(oldWeight, delta);\n\n            if (pos > 0 && oldCkpt.fromBlock == clock()) {\n                _unsafeAccess(ckpts, pos - 1).votes = SafeCast.toUint224(newWeight);\n            } else {\n                ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(clock()), votes: SafeCast.toUint224(newWeight)}));\n            }\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(Checkpoint[] storage ckpts, uint256 pos) private pure returns (Checkpoint storage result) {\n        assembly {\n            mstore(0, ckpts.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n\n        if (batchSize > 1) {\n            // Will only trigger during construction. Batch transferring (minting) is not available afterwards.\n            revert(\"ERC721Enumerable: consecutive transfers not supported\");\n        }\n\n        uint256 tokenId = firstTokenId;\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(_FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./ECDSA.sol\";\nimport \"../ShortStrings.sol\";\nimport \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * _Available since v3.4._\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {EIP-5267}.\n     *\n     * _Available since v4.9._\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _name.toStringWithFallback(_nameFallback),\n            _version.toStringWithFallback(_versionFallback),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./OwnableUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\n    function __Ownable2Step_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\n    }\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/finance/VestingWalletUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (finance/VestingWallet.sol)\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"../utils/AddressUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @title VestingWallet\n * @dev This contract handles the vesting of Eth and ERC20 tokens for a given beneficiary. Custody of multiple tokens\n * can be given to this contract, which will release the token to the beneficiary following a given vesting schedule.\n * The vesting schedule is customizable through the {vestedAmount} function.\n *\n * Any token transferred to this contract will follow the vesting schedule as if they were locked from the beginning.\n * Consequently, if the vesting has already started, any amount of tokens sent to this contract will (at least partly)\n * be immediately releasable.\n *\n * @custom:storage-size 52\n */\ncontract VestingWalletUpgradeable is Initializable, ContextUpgradeable {\n    event EtherReleased(uint256 amount);\n    event ERC20Released(address indexed token, uint256 amount);\n\n    uint256 private _released;\n    mapping(address => uint256) private _erc20Released;\n    address private _beneficiary;\n    uint64 private _start;\n    uint64 private _duration;\n\n    /**\n     * @dev Set the beneficiary, start timestamp and vesting duration of the vesting wallet.\n     */\n    function __VestingWallet_init(address beneficiaryAddress, uint64 startTimestamp, uint64 durationSeconds) internal onlyInitializing {\n        __VestingWallet_init_unchained(beneficiaryAddress, startTimestamp, durationSeconds);\n    }\n\n    function __VestingWallet_init_unchained(address beneficiaryAddress, uint64 startTimestamp, uint64 durationSeconds) internal onlyInitializing {\n        require(beneficiaryAddress != address(0), \"VestingWallet: beneficiary is zero address\");\n        _beneficiary = beneficiaryAddress;\n        _start = startTimestamp;\n        _duration = durationSeconds;\n    }\n\n    /**\n     * @dev The contract should be able to receive Eth.\n     */\n    receive() external payable virtual {}\n\n    /**\n     * @dev Getter for the beneficiary address.\n     */\n    function beneficiary() public view virtual returns (address) {\n        return _beneficiary;\n    }\n\n    /**\n     * @dev Getter for the start timestamp.\n     */\n    function start() public view virtual returns (uint256) {\n        return _start;\n    }\n\n    /**\n     * @dev Getter for the vesting duration.\n     */\n    function duration() public view virtual returns (uint256) {\n        return _duration;\n    }\n\n    /**\n     * @dev Amount of eth already released\n     */\n    function released() public view virtual returns (uint256) {\n        return _released;\n    }\n\n    /**\n     * @dev Amount of token already released\n     */\n    function released(address token) public view virtual returns (uint256) {\n        return _erc20Released[token];\n    }\n\n    /**\n     * @dev Getter for the amount of releasable eth.\n     */\n    function releasable() public view virtual returns (uint256) {\n        return vestedAmount(uint64(block.timestamp)) - released();\n    }\n\n    /**\n     * @dev Getter for the amount of releasable `token` tokens. `token` should be the address of an\n     * IERC20 contract.\n     */\n    function releasable(address token) public view virtual returns (uint256) {\n        return vestedAmount(token, uint64(block.timestamp)) - released(token);\n    }\n\n    /**\n     * @dev Release the native token (ether) that have already vested.\n     *\n     * Emits a {EtherReleased} event.\n     */\n    function release() public virtual {\n        uint256 amount = releasable();\n        _released += amount;\n        emit EtherReleased(amount);\n        AddressUpgradeable.sendValue(payable(beneficiary()), amount);\n    }\n\n    /**\n     * @dev Release the tokens that have already vested.\n     *\n     * Emits a {ERC20Released} event.\n     */\n    function release(address token) public virtual {\n        uint256 amount = releasable(token);\n        _erc20Released[token] += amount;\n        emit ERC20Released(token, amount);\n        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(token), beneficiary(), amount);\n    }\n\n    /**\n     * @dev Calculates the amount of ether that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(uint64 timestamp) public view virtual returns (uint256) {\n        return _vestingSchedule(address(this).balance + released(), timestamp);\n    }\n\n    /**\n     * @dev Calculates the amount of tokens that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(address token, uint64 timestamp) public view virtual returns (uint256) {\n        return _vestingSchedule(IERC20Upgradeable(token).balanceOf(address(this)) + released(token), timestamp);\n    }\n\n    /**\n     * @dev Virtual implementation of the vesting formula. This returns the amount vested, as a function of time, for\n     * an asset given its total historical allocation.\n     */\n    function _vestingSchedule(uint256 totalAllocation, uint64 timestamp) internal view virtual returns (uint256) {\n        if (timestamp < start()) {\n            return 0;\n        } else if (timestamp > start() + duration()) {\n            return totalAllocation;\n        } else {\n            return (totalAllocation * (timestamp - start())) / duration();\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.1) (governance/Governor.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"../token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\nimport \"../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../utils/cryptography/EIP712Upgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../utils/math/SafeCastUpgradeable.sol\";\nimport \"../utils/structs/DoubleEndedQueueUpgradeable.sol\";\nimport \"../utils/AddressUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"./IGovernorUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Core of the governance system, designed to be extended though various modules.\n *\n * This contract is abstract and requires several functions to be implemented in various modules:\n *\n * - A counting module must implement {quorum}, {_quorumReached}, {_voteSucceeded} and {_countVote}\n * - A voting module must implement {_getVotes}\n * - Additionally, {votingPeriod} must also be implemented\n *\n * _Available since v4.3._\n */\nabstract contract GovernorUpgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, EIP712Upgradeable, IGovernorUpgradeable, IERC721ReceiverUpgradeable, IERC1155ReceiverUpgradeable {\n    using DoubleEndedQueueUpgradeable for DoubleEndedQueueUpgradeable.Bytes32Deque;\n\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\n    bytes32 public constant EXTENDED_BALLOT_TYPEHASH =\n        keccak256(\"ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params)\");\n\n    // solhint-disable var-name-mixedcase\n    struct ProposalCore {\n        // --- start retyped from Timers.BlockNumber at offset 0x00 ---\n        uint64 voteStart;\n        address proposer;\n        bytes4 __gap_unused0;\n        // --- start retyped from Timers.BlockNumber at offset 0x20 ---\n        uint64 voteEnd;\n        bytes24 __gap_unused1;\n        // --- Remaining fields starting at offset 0x40 ---------------\n        bool executed;\n        bool canceled;\n    }\n    // solhint-enable var-name-mixedcase\n\n    string private _name;\n\n    /// @custom:oz-retyped-from mapping(uint256 => Governor.ProposalCore)\n    mapping(uint256 => ProposalCore) private _proposals;\n\n    // This queue keeps track of the governor operating on itself. Calls to functions protected by the\n    // {onlyGovernance} modifier needs to be whitelisted in this queue. Whitelisting is set in {_beforeExecute},\n    // consumed by the {onlyGovernance} modifier and eventually reset in {_afterExecute}. This ensures that the\n    // execution of {onlyGovernance} protected calls can only be achieved through successful proposals.\n    DoubleEndedQueueUpgradeable.Bytes32Deque private _governanceCall;\n\n    /**\n     * @dev Restricts a function so it can only be executed through governance proposals. For example, governance\n     * parameter setters in {GovernorSettings} are protected using this modifier.\n     *\n     * The governance executing address may be different from the Governor's own address, for example it could be a\n     * timelock. This can be customized by modules by overriding {_executor}. The executor is only able to invoke these\n     * functions during the execution of the governor's {execute} function, and not under any other circumstances. Thus,\n     * for example, additional timelock proposers are not able to change governance parameters without going through the\n     * governance protocol (since v4.6).\n     */\n    modifier onlyGovernance() {\n        require(_msgSender() == _executor(), \"Governor: onlyGovernance\");\n        if (_executor() != address(this)) {\n            bytes32 msgDataHash = keccak256(_msgData());\n            // loop until popping the expected operation - throw if deque is empty (operation not authorized)\n            while (_governanceCall.popFront() != msgDataHash) {}\n        }\n        _;\n    }\n\n    /**\n     * @dev Sets the value for {name} and {version}\n     */\n    function __Governor_init(string memory name_) internal onlyInitializing {\n        __EIP712_init_unchained(name_, version());\n        __Governor_init_unchained(name_);\n    }\n\n    function __Governor_init_unchained(string memory name_) internal onlyInitializing {\n        _name = name_;\n    }\n\n    /**\n     * @dev Function to receive ETH that will be handled by the governor (disabled if executor is a third party contract)\n     */\n    receive() external payable virtual {\n        require(_executor() == address(this), \"Governor: must send to executor\");\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC165Upgradeable) returns (bool) {\n        bytes4 governorCancelId = this.cancel.selector ^ this.proposalProposer.selector;\n\n        bytes4 governorParamsId = this.castVoteWithReasonAndParams.selector ^\n            this.castVoteWithReasonAndParamsBySig.selector ^\n            this.getVotesWithParams.selector;\n\n        // The original interface id in v4.3.\n        bytes4 governor43Id = type(IGovernorUpgradeable).interfaceId ^\n            type(IERC6372Upgradeable).interfaceId ^\n            governorCancelId ^\n            governorParamsId;\n\n        // An updated interface id in v4.6, with params added.\n        bytes4 governor46Id = type(IGovernorUpgradeable).interfaceId ^ type(IERC6372Upgradeable).interfaceId ^ governorCancelId;\n\n        // For the updated interface id in v4.9, we use governorCancelId directly.\n\n        return\n            interfaceId == governor43Id ||\n            interfaceId == governor46Id ||\n            interfaceId == governorCancelId ||\n            interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IGovernor-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IGovernor-version}.\n     */\n    function version() public view virtual override returns (string memory) {\n        return \"1\";\n    }\n\n    /**\n     * @dev See {IGovernor-hashProposal}.\n     *\n     * The proposal id is produced by hashing the ABI encoded `targets` array, the `values` array, the `calldatas` array\n     * and the descriptionHash (bytes32 which itself is the keccak256 hash of the description string). This proposal id\n     * can be produced from the proposal data which is part of the {ProposalCreated} event. It can even be computed in\n     * advance, before the proposal is submitted.\n     *\n     * Note that the chainId and the governor address are not part of the proposal id computation. Consequently, the\n     * same proposal (with same operation and same description) will have the same id if submitted on multiple governors\n     * across multiple networks. This also means that in order to execute the same operation twice (on the same\n     * governor) the proposer will have to change the description in order to avoid proposal id conflicts.\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual override returns (uint256) {\n        return uint256(keccak256(abi.encode(targets, values, calldatas, descriptionHash)));\n    }\n\n    /**\n     * @dev See {IGovernor-state}.\n     */\n    function state(uint256 proposalId) public view virtual override returns (ProposalState) {\n        ProposalCore storage proposal = _proposals[proposalId];\n\n        if (proposal.executed) {\n            return ProposalState.Executed;\n        }\n\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        }\n\n        uint256 snapshot = proposalSnapshot(proposalId);\n\n        if (snapshot == 0) {\n            revert(\"Governor: unknown proposal id\");\n        }\n\n        uint256 currentTimepoint = clock();\n\n        if (snapshot >= currentTimepoint) {\n            return ProposalState.Pending;\n        }\n\n        uint256 deadline = proposalDeadline(proposalId);\n\n        if (deadline >= currentTimepoint) {\n            return ProposalState.Active;\n        }\n\n        if (_quorumReached(proposalId) && _voteSucceeded(proposalId)) {\n            return ProposalState.Succeeded;\n        } else {\n            return ProposalState.Defeated;\n        }\n    }\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.\n     */\n    function proposalThreshold() public view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev See {IGovernor-proposalSnapshot}.\n     */\n    function proposalSnapshot(uint256 proposalId) public view virtual override returns (uint256) {\n        return _proposals[proposalId].voteStart;\n    }\n\n    /**\n     * @dev See {IGovernor-proposalDeadline}.\n     */\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return _proposals[proposalId].voteEnd;\n    }\n\n    /**\n     * @dev Returns the account that created a given proposal.\n     */\n    function proposalProposer(uint256 proposalId) public view virtual override returns (address) {\n        return _proposals[proposalId].proposer;\n    }\n\n    /**\n     * @dev Amount of votes already cast passes the threshold limit.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Is the proposal successful or not.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Get the voting weight of `account` at a specific `timepoint`, for a vote as described by `params`.\n     */\n    function _getVotes(address account, uint256 timepoint, bytes memory params) internal view virtual returns (uint256);\n\n    /**\n     * @dev Register a vote for `proposalId` by `account` with a given `support`, voting `weight` and voting `params`.\n     *\n     * Note: Support is generic and can represent various things depending on the voting system used.\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory params\n    ) internal virtual;\n\n    /**\n     * @dev Default additional encoded parameters used by castVote methods that don't include them\n     *\n     * Note: Should be overridden by specific implementations to use an appropriate value, the\n     * meaning of the additional params, in the context of that implementation\n     */\n    function _defaultParams() internal view virtual returns (bytes memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IGovernor-propose}. This function has opt-in frontrunning protection, described in {_isValidDescriptionForProposer}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override returns (uint256) {\n        address proposer = _msgSender();\n        require(_isValidDescriptionForProposer(proposer, description), \"Governor: proposer restricted\");\n\n        uint256 currentTimepoint = clock();\n        require(\n            getVotes(proposer, currentTimepoint - 1) >= proposalThreshold(),\n            \"Governor: proposer votes below proposal threshold\"\n        );\n\n        uint256 proposalId = hashProposal(targets, values, calldatas, keccak256(bytes(description)));\n\n        require(targets.length == values.length, \"Governor: invalid proposal length\");\n        require(targets.length == calldatas.length, \"Governor: invalid proposal length\");\n        require(targets.length > 0, \"Governor: empty proposal\");\n        require(_proposals[proposalId].voteStart == 0, \"Governor: proposal already exists\");\n\n        uint256 snapshot = currentTimepoint + votingDelay();\n        uint256 deadline = snapshot + votingPeriod();\n\n        _proposals[proposalId] = ProposalCore({\n            proposer: proposer,\n            voteStart: SafeCastUpgradeable.toUint64(snapshot),\n            voteEnd: SafeCastUpgradeable.toUint64(deadline),\n            executed: false,\n            canceled: false,\n            __gap_unused0: 0,\n            __gap_unused1: 0\n        });\n\n        emit ProposalCreated(\n            proposalId,\n            proposer,\n            targets,\n            values,\n            new string[](targets.length),\n            calldatas,\n            snapshot,\n            deadline,\n            description\n        );\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-execute}.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        ProposalState currentState = state(proposalId);\n        require(\n            currentState == ProposalState.Succeeded || currentState == ProposalState.Queued,\n            \"Governor: proposal not successful\"\n        );\n        _proposals[proposalId].executed = true;\n\n        emit ProposalExecuted(proposalId);\n\n        _beforeExecute(proposalId, targets, values, calldatas, descriptionHash);\n        _execute(proposalId, targets, values, calldatas, descriptionHash);\n        _afterExecute(proposalId, targets, values, calldatas, descriptionHash);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-cancel}.\n     */\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n        require(state(proposalId) == ProposalState.Pending, \"Governor: too late to cancel\");\n        require(_msgSender() == _proposals[proposalId].proposer, \"Governor: only proposer can cancel\");\n        return _cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    /**\n     * @dev Internal execution mechanism. Can be overridden to implement different execution mechanism\n     */\n    function _execute(\n        uint256 /* proposalId */,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        string memory errorMessage = \"Governor: call reverted without message\";\n        for (uint256 i = 0; i < targets.length; ++i) {\n            (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]);\n            AddressUpgradeable.verifyCallResult(success, returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Hook before execution is triggered.\n     */\n    function _beforeExecute(\n        uint256 /* proposalId */,\n        address[] memory targets,\n        uint256[] memory /* values */,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        if (_executor() != address(this)) {\n            for (uint256 i = 0; i < targets.length; ++i) {\n                if (targets[i] == address(this)) {\n                    _governanceCall.pushBack(keccak256(calldatas[i]));\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Hook after execution is triggered.\n     */\n    function _afterExecute(\n        uint256 /* proposalId */,\n        address[] memory /* targets */,\n        uint256[] memory /* values */,\n        bytes[] memory /* calldatas */,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        if (_executor() != address(this)) {\n            if (!_governanceCall.empty()) {\n                _governanceCall.clear();\n            }\n        }\n    }\n\n    /**\n     * @dev Internal cancel mechanism: locks up the proposal timer, preventing it from being re-submitted. Marks it as\n     * canceled to allow distinguishing it from executed proposals.\n     *\n     * Emits a {IGovernor-ProposalCanceled} event.\n     */\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        ProposalState currentState = state(proposalId);\n\n        require(\n            currentState != ProposalState.Canceled &&\n                currentState != ProposalState.Expired &&\n                currentState != ProposalState.Executed,\n            \"Governor: proposal not active\"\n        );\n        _proposals[proposalId].canceled = true;\n\n        emit ProposalCanceled(proposalId);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-getVotes}.\n     */\n    function getVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {\n        return _getVotes(account, timepoint, _defaultParams());\n    }\n\n    /**\n     * @dev See {IGovernor-getVotesWithParams}.\n     */\n    function getVotesWithParams(\n        address account,\n        uint256 timepoint,\n        bytes memory params\n    ) public view virtual override returns (uint256) {\n        return _getVotes(account, timepoint, params);\n    }\n\n    /**\n     * @dev See {IGovernor-castVote}.\n     */\n    function castVote(uint256 proposalId, uint8 support) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReason}.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason);\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReasonAndParams}.\n     */\n    function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params\n    ) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason, params);\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteBySig}.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override returns (uint256) {\n        address voter = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\n            v,\n            r,\n            s\n        );\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReasonAndParamsBySig}.\n     */\n    function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override returns (uint256) {\n        address voter = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(\n                keccak256(\n                    abi.encode(\n                        EXTENDED_BALLOT_TYPEHASH,\n                        proposalId,\n                        support,\n                        keccak256(bytes(reason)),\n                        keccak256(params)\n                    )\n                )\n            ),\n            v,\n            r,\n            s\n        );\n\n        return _castVote(proposalId, voter, support, reason, params);\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function. Uses the _defaultParams().\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason\n    ) internal virtual returns (uint256) {\n        return _castVote(proposalId, account, support, reason, _defaultParams());\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function.\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual returns (uint256) {\n        ProposalCore storage proposal = _proposals[proposalId];\n        require(state(proposalId) == ProposalState.Active, \"Governor: vote not currently active\");\n\n        uint256 weight = _getVotes(account, proposal.voteStart, params);\n        _countVote(proposalId, account, support, weight, params);\n\n        if (params.length == 0) {\n            emit VoteCast(account, proposalId, support, weight, reason);\n        } else {\n            emit VoteCastWithParams(account, proposalId, support, weight, reason, params);\n        }\n\n        return weight;\n    }\n\n    /**\n     * @dev Relays a transaction or function call to an arbitrary target. In cases where the governance executor\n     * is some contract other than the governor itself, like when using a timelock, this function can be invoked\n     * in a governance proposal to recover tokens or Ether that was sent to the governor contract by mistake.\n     * Note that if the executor is simply the governor itself, use of `relay` is redundant.\n     */\n    function relay(address target, uint256 value, bytes calldata data) external payable virtual onlyGovernance {\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        AddressUpgradeable.verifyCallResult(success, returndata, \"Governor: relay reverted without message\");\n    }\n\n    /**\n     * @dev Address through which the governor executes action. Will be overloaded by module that execute actions\n     * through another contract such as a timelock.\n     */\n    function _executor() internal view virtual returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155Received}.\n     */\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @dev Check if the proposer is authorized to submit a proposal with the given description.\n     *\n     * If the proposal description ends with `#proposer=0x???`, where `0x???` is an address written as a hex string\n     * (case insensitive), then the submission of this proposal will only be authorized to said address.\n     *\n     * This is used for frontrunning protection. By adding this pattern at the end of their proposal, one can ensure\n     * that no other address can submit the same proposal. An attacker would have to either remove or change that part,\n     * which would result in a different proposal id.\n     *\n     * If the description does not match this pattern, it is unrestricted and anyone can submit it. This includes:\n     * - If the `0x???` part is not a valid hex string.\n     * - If the `0x???` part is a valid hex string, but does not contain exactly 40 hex digits.\n     * - If it ends with the expected suffix followed by newlines or other whitespace.\n     * - If it ends with some other similar suffix, e.g. `#other=abc`.\n     * - If it does not end with any such suffix.\n     */\n    function _isValidDescriptionForProposer(\n        address proposer,\n        string memory description\n    ) internal view virtual returns (bool) {\n        uint256 len = bytes(description).length;\n\n        // Length is too short to contain a valid proposer suffix\n        if (len < 52) {\n            return true;\n        }\n\n        // Extract what would be the `#proposer=0x` marker beginning the suffix\n        bytes12 marker;\n        assembly {\n            // - Start of the string contents in memory = description + 32\n            // - First character of the marker = len - 52\n            //   - Length of \"#proposer=0x0000000000000000000000000000000000000000\" = 52\n            // - We read the memory word starting at the first character of the marker:\n            //   - (description + 32) + (len - 52) = description + (len - 20)\n            // - Note: Solidity will ignore anything past the first 12 bytes\n            marker := mload(add(description, sub(len, 20)))\n        }\n\n        // If the marker is not found, there is no proposer suffix to check\n        if (marker != bytes12(\"#proposer=0x\")) {\n            return true;\n        }\n\n        // Parse the 40 characters following the marker as uint160\n        uint160 recovered = 0;\n        for (uint256 i = len - 40; i < len; ++i) {\n            (bool isHex, uint8 value) = _tryHexToUint(bytes(description)[i]);\n            // If any of the characters is not a hex digit, ignore the suffix entirely\n            if (!isHex) {\n                return true;\n            }\n            recovered = (recovered << 4) | value;\n        }\n\n        return recovered == uint160(proposer);\n    }\n\n    /**\n     * @dev Try to parse a character from a string as a hex value. Returns `(true, value)` if the char is in\n     * `[0-9a-fA-F]` and `(false, 0)` otherwise. Value is guaranteed to be in the range `0 <= value < 16`\n     */\n    function _tryHexToUint(bytes1 char) private pure returns (bool, uint8) {\n        uint8 c = uint8(char);\n        unchecked {\n            // Case 0-9\n            if (47 < c && c < 58) {\n                return (true, c - 48);\n            }\n            // Case A-F\n            else if (64 < c && c < 71) {\n                return (true, c - 55);\n            }\n            // Case a-f\n            else if (96 < c && c < 103) {\n                return (true, c - 87);\n            }\n            // Else: not a hex char\n            else {\n                return (false, 0);\n            }\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/governance/IGovernorUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/IGovernor.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC165Upgradeable.sol\";\nimport \"../interfaces/IERC6372Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Interface of the {Governor} core.\n *\n * _Available since v4.3._\n */\nabstract contract IGovernorUpgradeable is Initializable, IERC165Upgradeable, IERC6372Upgradeable {\n    function __IGovernor_init() internal onlyInitializing {\n    }\n\n    function __IGovernor_init_unchained() internal onlyInitializing {\n    }\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    /**\n     * @dev Emitted when a proposal is created.\n     */\n    event ProposalCreated(\n        uint256 proposalId,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 voteStart,\n        uint256 voteEnd,\n        string description\n    );\n\n    /**\n     * @dev Emitted when a proposal is canceled.\n     */\n    event ProposalCanceled(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a proposal is executed.\n     */\n    event ProposalExecuted(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a vote is cast without params.\n     *\n     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.\n     */\n    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 weight, string reason);\n\n    /**\n     * @dev Emitted when a vote is cast with params.\n     *\n     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.\n     * `params` are additional encoded parameters. Their interpepretation also depends on the voting module used.\n     */\n    event VoteCastWithParams(\n        address indexed voter,\n        uint256 proposalId,\n        uint8 support,\n        uint256 weight,\n        string reason,\n        bytes params\n    );\n\n    /**\n     * @notice module:core\n     * @dev Name of the governor instance (used in building the ERC712 domain separator).\n     */\n    function name() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Version of the governor instance (used in building the ERC712 domain separator). Default: \"1\"\n     */\n    function version() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev See {IERC6372}\n     */\n    function clock() public view virtual override returns (uint48);\n\n    /**\n     * @notice module:core\n     * @dev See EIP-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual override returns (string memory);\n\n    /**\n     * @notice module:voting\n     * @dev A description of the possible `support` values for {castVote} and the way these votes are counted, meant to\n     * be consumed by UIs to show correct vote options and interpret the results. The string is a URL-encoded sequence of\n     * key-value pairs that each describe one aspect, for example `support=bravo&quorum=for,abstain`.\n     *\n     * There are 2 standard keys: `support` and `quorum`.\n     *\n     * - `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in `GovernorBravo`.\n     * - `quorum=bravo` means that only For votes are counted towards quorum.\n     * - `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.\n     *\n     * If a counting module makes use of encoded `params`, it should  include this under a `params` key with a unique\n     * name that describes the behavior. For example:\n     *\n     * - `params=fractional` might refer to a scheme where votes are divided fractionally between for/against/abstain.\n     * - `params=erc721` might refer to a scheme where specific NFTs are delegated to vote.\n     *\n     * NOTE: The string can be decoded by the standard\n     * https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams[`URLSearchParams`]\n     * JavaScript class.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Hashing function used to (re)build the proposal id from the proposal details..\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Current state of a proposal, following Compound's convention\n     */\n    function state(uint256 proposalId) public view virtual returns (ProposalState);\n\n    /**\n     * @notice module:core\n     * @dev Timepoint used to retrieve user's votes and quorum. If using block number (as per Compound's Comp), the\n     * snapshot is performed at the end of this block. Hence, voting for this proposal starts at the beginning of the\n     * following block.\n     */\n    function proposalSnapshot(uint256 proposalId) public view virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Timepoint at which votes close. If using block number, votes close at the end of this block, so it is\n     * possible to cast a vote during this block.\n     */\n    function proposalDeadline(uint256 proposalId) public view virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev The account that created a proposal.\n     */\n    function proposalProposer(uint256 proposalId) public view virtual returns (address);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay, between the proposal is created and the vote starts. The unit this duration is expressed in depends\n     * on the clock (see EIP-6372) this contract uses.\n     *\n     * This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a\n     * proposal starts.\n     */\n    function votingDelay() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay between the vote start and vote end. The unit this duration is expressed in depends on the clock\n     * (see EIP-6372) this contract uses.\n     *\n     * NOTE: The {votingDelay} can delay the start of the vote. This must be considered when setting the voting\n     * duration compared to the voting delay.\n     */\n    function votingPeriod() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Minimum number of cast voted required for a proposal to be successful.\n     *\n     * NOTE: The `timepoint` parameter corresponds to the snapshot used for counting vote. This allows to scale the\n     * quorum depending on values such as the totalSupply of a token at this timepoint (see {ERC20Votes}).\n     */\n    function quorum(uint256 timepoint) public view virtual returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `account` at a specific `timepoint`.\n     *\n     * Note: this can be implemented in a number of ways, for example by reading the delegated balance from one (or\n     * multiple), {ERC20Votes} tokens.\n     */\n    function getVotes(address account, uint256 timepoint) public view virtual returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `account` at a specific `timepoint` given additional encoded parameters.\n     */\n    function getVotesWithParams(\n        address account,\n        uint256 timepoint,\n        bytes memory params\n    ) public view virtual returns (uint256);\n\n    /**\n     * @notice module:voting\n     * @dev Returns whether `account` has cast a vote on `proposalId`.\n     */\n    function hasVoted(uint256 proposalId, address account) public view virtual returns (bool);\n\n    /**\n     * @dev Create a new proposal. Vote start after a delay specified by {IGovernor-votingDelay} and lasts for a\n     * duration specified by {IGovernor-votingPeriod}.\n     *\n     * Emits a {ProposalCreated} event.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Execute a successful proposal. This requires the quorum to be reached, the vote to be successful, and the\n     * deadline to be reached.\n     *\n     * Emits a {ProposalExecuted} event.\n     *\n     * Note: some module can modify the requirements for execution, for example by adding an additional timelock.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Cancel a proposal. A proposal is cancellable by the proposer, but only while it is Pending state, i.e.\n     * before the vote starts.\n     *\n     * Emits a {ProposalCanceled} event.\n     */\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Cast a vote\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVote(uint256 proposalId, uint8 support) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason and additional encoded parameters\n     *\n     * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.\n     */\n    function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote using the user's cryptographic signature.\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason and additional encoded parameters using the user's cryptographic signature.\n     *\n     * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.\n     */\n    function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/TimelockController.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../access/AccessControlUpgradeable.sol\";\nimport \"../token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"../token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\ncontract TimelockControllerUpgradeable is Initializable, AccessControlUpgradeable, IERC721ReceiverUpgradeable, IERC1155ReceiverUpgradeable {\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELLER_ROLE = keccak256(\"CANCELLER_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when new proposal is scheduled with non-zero salt.\n     */\n    event CallSalt(bytes32 indexed id, bytes32 salt);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with the following parameters:\n     *\n     * - `minDelay`: initial minimum delay for operations\n     * - `proposers`: accounts to be granted proposer and canceller roles\n     * - `executors`: accounts to be granted executor role\n     * - `admin`: optional account to be granted admin role; disable with zero address\n     *\n     * IMPORTANT: The optional admin can aid with initial configuration of roles after deployment\n     * without being subject to delay, but this role should be subsequently renounced in favor of\n     * administration through timelocked proposals. Previous versions of this contract would assign\n     * this admin to the deployer automatically and should be renounced as well.\n     */\n    function __TimelockController_init(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) internal onlyInitializing {\n        __TimelockController_init_unchained(minDelay, proposers, executors, admin);\n    }\n\n    function __TimelockController_init_unchained(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) internal onlyInitializing {\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(CANCELLER_ROLE, TIMELOCK_ADMIN_ROLE);\n\n        // self administration\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n        // optional admin\n        if (admin != address(0)) {\n            _setupRole(TIMELOCK_ADMIN_ROLE, admin);\n        }\n\n        // register proposers and cancellers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _setupRole(PROPOSER_ROLE, proposers[i]);\n            _setupRole(CANCELLER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, AccessControlUpgradeable) returns (bool) {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns whether an id correspond to a registered operation. This\n     * includes both Pending, Ready and Done operations.\n     */\n    function isOperation(bytes32 id) public view virtual returns (bool) {\n        return getTimestamp(id) > 0;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not. Note that a \"pending\" operation may also be \"ready\".\n     */\n    function isOperationPending(bytes32 id) public view virtual returns (bool) {\n        return getTimestamp(id) > _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready for execution. Note that a \"ready\" operation is also \"pending\".\n     */\n    function isOperationReady(bytes32 id) public view virtual returns (bool) {\n        uint256 timestamp = getTimestamp(id);\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view virtual returns (bool) {\n        return getTimestamp(id) == _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns the timestamp at which an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256) {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns the minimum delay for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32) {\n        return keccak256(abi.encode(targets, values, payloads, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits {CallSalt} if salt is nonzero, and {CallScheduled}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n        if (salt != bytes32(0)) {\n            emit CallSalt(id, salt);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits {CallSalt} if salt is nonzero, and one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == payloads.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);\n        }\n        if (salt != bytes32(0)) {\n            emit CallSalt(id, salt);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to become valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        require(!isOperation(id), \"TimelockController: operation already scheduled\");\n        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'canceller' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {\n        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata payload,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, payload, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        _execute(target, value, payload);\n        emit CallExecuted(id, 0, target, value, payload);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == payloads.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            address target = targets[i];\n            uint256 value = values[i];\n            bytes calldata payload = payloads[i];\n            _execute(target, value, payload);\n            emit CallExecuted(id, i, target, value, payload);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     */\n    function _execute(address target, uint256 value, bytes calldata data) internal virtual {\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155Received}.\n     */\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/governance/extensions/GovernorCountingSimpleUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/extensions/GovernorCountingSimple.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../GovernorUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for simple, 3 options, vote counting.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorCountingSimpleUpgradeable is Initializable, GovernorUpgradeable {\n    function __GovernorCountingSimple_init() internal onlyInitializing {\n    }\n\n    function __GovernorCountingSimple_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Supported vote types. Matches Governor Bravo ordering.\n     */\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => bool) hasVoted;\n    }\n\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    /**\n     * @dev See {IGovernor-COUNTING_MODE}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    /**\n     * @dev See {IGovernor-hasVoted}.\n     */\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n\n    /**\n     * @dev Accessor to the internal vote counts.\n     */\n    function proposalVotes(\n        uint256 proposalId\n    ) public view virtual returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n        return (proposalVote.againstVotes, proposalVote.forVotes, proposalVote.abstainVotes);\n    }\n\n    /**\n     * @dev See {Governor-_quorumReached}.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n\n        return quorum(proposalSnapshot(proposalId)) <= proposalVote.forVotes + proposalVote.abstainVotes;\n    }\n\n    /**\n     * @dev See {Governor-_voteSucceeded}. In this module, the forVotes must be strictly over the againstVotes.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n\n        return proposalVote.forVotes > proposalVote.againstVotes;\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo).\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory // params\n    ) internal virtual override {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n\n        require(!proposalVote.hasVoted[account], \"GovernorVotingSimple: vote already cast\");\n        proposalVote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalVote.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalVote.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalVote.abstainVotes += weight;\n        } else {\n            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/extensions/GovernorSettings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../GovernorUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for settings updatable through governance.\n *\n * _Available since v4.4._\n */\nabstract contract GovernorSettingsUpgradeable is Initializable, GovernorUpgradeable {\n    uint256 private _votingDelay;\n    uint256 private _votingPeriod;\n    uint256 private _proposalThreshold;\n\n    event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);\n    event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\n    event ProposalThresholdSet(uint256 oldProposalThreshold, uint256 newProposalThreshold);\n\n    /**\n     * @dev Initialize the governance parameters.\n     */\n    function __GovernorSettings_init(uint256 initialVotingDelay, uint256 initialVotingPeriod, uint256 initialProposalThreshold) internal onlyInitializing {\n        __GovernorSettings_init_unchained(initialVotingDelay, initialVotingPeriod, initialProposalThreshold);\n    }\n\n    function __GovernorSettings_init_unchained(uint256 initialVotingDelay, uint256 initialVotingPeriod, uint256 initialProposalThreshold) internal onlyInitializing {\n        _setVotingDelay(initialVotingDelay);\n        _setVotingPeriod(initialVotingPeriod);\n        _setProposalThreshold(initialProposalThreshold);\n    }\n\n    /**\n     * @dev See {IGovernor-votingDelay}.\n     */\n    function votingDelay() public view virtual override returns (uint256) {\n        return _votingDelay;\n    }\n\n    /**\n     * @dev See {IGovernor-votingPeriod}.\n     */\n    function votingPeriod() public view virtual override returns (uint256) {\n        return _votingPeriod;\n    }\n\n    /**\n     * @dev See {Governor-proposalThreshold}.\n     */\n    function proposalThreshold() public view virtual override returns (uint256) {\n        return _proposalThreshold;\n    }\n\n    /**\n     * @dev Update the voting delay. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {VotingDelaySet} event.\n     */\n    function setVotingDelay(uint256 newVotingDelay) public virtual onlyGovernance {\n        _setVotingDelay(newVotingDelay);\n    }\n\n    /**\n     * @dev Update the voting period. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {VotingPeriodSet} event.\n     */\n    function setVotingPeriod(uint256 newVotingPeriod) public virtual onlyGovernance {\n        _setVotingPeriod(newVotingPeriod);\n    }\n\n    /**\n     * @dev Update the proposal threshold. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {ProposalThresholdSet} event.\n     */\n    function setProposalThreshold(uint256 newProposalThreshold) public virtual onlyGovernance {\n        _setProposalThreshold(newProposalThreshold);\n    }\n\n    /**\n     * @dev Internal setter for the voting delay.\n     *\n     * Emits a {VotingDelaySet} event.\n     */\n    function _setVotingDelay(uint256 newVotingDelay) internal virtual {\n        emit VotingDelaySet(_votingDelay, newVotingDelay);\n        _votingDelay = newVotingDelay;\n    }\n\n    /**\n     * @dev Internal setter for the voting period.\n     *\n     * Emits a {VotingPeriodSet} event.\n     */\n    function _setVotingPeriod(uint256 newVotingPeriod) internal virtual {\n        // voting period must be at least one block long\n        require(newVotingPeriod > 0, \"GovernorSettings: voting period too low\");\n        emit VotingPeriodSet(_votingPeriod, newVotingPeriod);\n        _votingPeriod = newVotingPeriod;\n    }\n\n    /**\n     * @dev Internal setter for the proposal threshold.\n     *\n     * Emits a {ProposalThresholdSet} event.\n     */\n    function _setProposalThreshold(uint256 newProposalThreshold) internal virtual {\n        emit ProposalThresholdSet(_proposalThreshold, newProposalThreshold);\n        _proposalThreshold = newProposalThreshold;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/extensions/GovernorTimelockControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IGovernorTimelockUpgradeable.sol\";\nimport \"../GovernorUpgradeable.sol\";\nimport \"../TimelockControllerUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} that binds the execution process to an instance of {TimelockController}. This adds a\n * delay, enforced by the {TimelockController} to all successful proposal (in addition to the voting duration). The\n * {Governor} needs the proposer (and ideally the executor) roles for the {Governor} to work properly.\n *\n * Using this model means the proposal will be operated by the {TimelockController} and not by the {Governor}. Thus,\n * the assets and permissions must be attached to the {TimelockController}. Any asset sent to the {Governor} will be\n * inaccessible.\n *\n * WARNING: Setting up the TimelockController to have additional proposers besides the governor is very risky, as it\n * grants them powers that they must be trusted or known not to use: 1) {onlyGovernance} functions like {relay} are\n * available to them through the timelock, and 2) approved governance proposals can be blocked by them, effectively\n * executing a Denial of Service attack. This risk will be mitigated in a future release.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorTimelockControlUpgradeable is Initializable, IGovernorTimelockUpgradeable, GovernorUpgradeable {\n    TimelockControllerUpgradeable private _timelock;\n    mapping(uint256 => bytes32) private _timelockIds;\n\n    /**\n     * @dev Emitted when the timelock controller used for proposal execution is modified.\n     */\n    event TimelockChange(address oldTimelock, address newTimelock);\n\n    /**\n     * @dev Set the timelock.\n     */\n    function __GovernorTimelockControl_init(TimelockControllerUpgradeable timelockAddress) internal onlyInitializing {\n        __GovernorTimelockControl_init_unchained(timelockAddress);\n    }\n\n    function __GovernorTimelockControl_init_unchained(TimelockControllerUpgradeable timelockAddress) internal onlyInitializing {\n        _updateTimelock(timelockAddress);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, GovernorUpgradeable) returns (bool) {\n        return interfaceId == type(IGovernorTimelockUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Overridden version of the {Governor-state} function with added support for the `Queued` state.\n     */\n    function state(uint256 proposalId) public view virtual override(IGovernorUpgradeable, GovernorUpgradeable) returns (ProposalState) {\n        ProposalState currentState = super.state(proposalId);\n\n        if (currentState != ProposalState.Succeeded) {\n            return currentState;\n        }\n\n        // core tracks execution, so we just have to check if successful proposal have been queued.\n        bytes32 queueid = _timelockIds[proposalId];\n        if (queueid == bytes32(0)) {\n            return currentState;\n        } else if (_timelock.isOperationDone(queueid)) {\n            return ProposalState.Executed;\n        } else if (_timelock.isOperationPending(queueid)) {\n            return ProposalState.Queued;\n        } else {\n            return ProposalState.Canceled;\n        }\n    }\n\n    /**\n     * @dev Public accessor to check the address of the timelock\n     */\n    function timelock() public view virtual override returns (address) {\n        return address(_timelock);\n    }\n\n    /**\n     * @dev Public accessor to check the eta of a queued proposal\n     */\n    function proposalEta(uint256 proposalId) public view virtual override returns (uint256) {\n        uint256 eta = _timelock.getTimestamp(_timelockIds[proposalId]);\n        return eta == 1 ? 0 : eta; // _DONE_TIMESTAMP (1) should be replaced with a 0 value\n    }\n\n    /**\n     * @dev Function to queue a proposal to the timelock.\n     */\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        require(state(proposalId) == ProposalState.Succeeded, \"Governor: proposal not successful\");\n\n        uint256 delay = _timelock.getMinDelay();\n        _timelockIds[proposalId] = _timelock.hashOperationBatch(targets, values, calldatas, 0, descriptionHash);\n        _timelock.scheduleBatch(targets, values, calldatas, 0, descriptionHash, delay);\n\n        emit ProposalQueued(proposalId, block.timestamp + delay);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Overridden execute function that run the already queued proposal through the timelock.\n     */\n    function _execute(\n        uint256 /* proposalId */,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override {\n        _timelock.executeBatch{value: msg.value}(targets, values, calldatas, 0, descriptionHash);\n    }\n\n    /**\n     * @dev Overridden version of the {Governor-_cancel} function to cancel the timelocked proposal if it as already\n     * been queued.\n     */\n    // This function can reenter through the external call to the timelock, but we assume the timelock is trusted and\n    // well behaved (according to TimelockController) and this will not happen.\n    // slither-disable-next-line reentrancy-no-eth\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override returns (uint256) {\n        uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash);\n\n        if (_timelockIds[proposalId] != 0) {\n            _timelock.cancel(_timelockIds[proposalId]);\n            delete _timelockIds[proposalId];\n        }\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Address through which the governor executes action. In this case, the timelock.\n     */\n    function _executor() internal view virtual override returns (address) {\n        return address(_timelock);\n    }\n\n    /**\n     * @dev Public endpoint to update the underlying timelock instance. Restricted to the timelock itself, so updates\n     * must be proposed, scheduled, and executed through governance proposals.\n     *\n     * CAUTION: It is not recommended to change the timelock while there are other queued governance proposals.\n     */\n    function updateTimelock(TimelockControllerUpgradeable newTimelock) external virtual onlyGovernance {\n        _updateTimelock(newTimelock);\n    }\n\n    function _updateTimelock(TimelockControllerUpgradeable newTimelock) private {\n        emit TimelockChange(address(_timelock), address(newTimelock));\n        _timelock = newTimelock;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/extensions/GovernorVotesQuorumFraction.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./GovernorVotesUpgradeable.sol\";\nimport \"../../utils/CheckpointsUpgradeable.sol\";\nimport \"../../utils/math/SafeCastUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token and a quorum expressed as a\n * fraction of the total supply.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorVotesQuorumFractionUpgradeable is Initializable, GovernorVotesUpgradeable {\n    using CheckpointsUpgradeable for CheckpointsUpgradeable.Trace224;\n\n    uint256 private _quorumNumerator; // DEPRECATED in favor of _quorumNumeratorHistory\n\n    /// @custom:oz-retyped-from Checkpoints.History\n    CheckpointsUpgradeable.Trace224 private _quorumNumeratorHistory;\n\n    event QuorumNumeratorUpdated(uint256 oldQuorumNumerator, uint256 newQuorumNumerator);\n\n    /**\n     * @dev Initialize quorum as a fraction of the token's total supply.\n     *\n     * The fraction is specified as `numerator / denominator`. By default the denominator is 100, so quorum is\n     * specified as a percent: a numerator of 10 corresponds to quorum being 10% of total supply. The denominator can be\n     * customized by overriding {quorumDenominator}.\n     */\n    function __GovernorVotesQuorumFraction_init(uint256 quorumNumeratorValue) internal onlyInitializing {\n        __GovernorVotesQuorumFraction_init_unchained(quorumNumeratorValue);\n    }\n\n    function __GovernorVotesQuorumFraction_init_unchained(uint256 quorumNumeratorValue) internal onlyInitializing {\n        _updateQuorumNumerator(quorumNumeratorValue);\n    }\n\n    /**\n     * @dev Returns the current quorum numerator. See {quorumDenominator}.\n     */\n    function quorumNumerator() public view virtual returns (uint256) {\n        return _quorumNumeratorHistory._checkpoints.length == 0 ? _quorumNumerator : _quorumNumeratorHistory.latest();\n    }\n\n    /**\n     * @dev Returns the quorum numerator at a specific timepoint. See {quorumDenominator}.\n     */\n    function quorumNumerator(uint256 timepoint) public view virtual returns (uint256) {\n        // If history is empty, fallback to old storage\n        uint256 length = _quorumNumeratorHistory._checkpoints.length;\n        if (length == 0) {\n            return _quorumNumerator;\n        }\n\n        // Optimistic search, check the latest checkpoint\n        CheckpointsUpgradeable.Checkpoint224 memory latest = _quorumNumeratorHistory._checkpoints[length - 1];\n        if (latest._key <= timepoint) {\n            return latest._value;\n        }\n\n        // Otherwise, do the binary search\n        return _quorumNumeratorHistory.upperLookupRecent(SafeCastUpgradeable.toUint32(timepoint));\n    }\n\n    /**\n     * @dev Returns the quorum denominator. Defaults to 100, but may be overridden.\n     */\n    function quorumDenominator() public view virtual returns (uint256) {\n        return 100;\n    }\n\n    /**\n     * @dev Returns the quorum for a timepoint, in terms of number of votes: `supply * numerator / denominator`.\n     */\n    function quorum(uint256 timepoint) public view virtual override returns (uint256) {\n        return (token.getPastTotalSupply(timepoint) * quorumNumerator(timepoint)) / quorumDenominator();\n    }\n\n    /**\n     * @dev Changes the quorum numerator.\n     *\n     * Emits a {QuorumNumeratorUpdated} event.\n     *\n     * Requirements:\n     *\n     * - Must be called through a governance proposal.\n     * - New numerator must be smaller or equal to the denominator.\n     */\n    function updateQuorumNumerator(uint256 newQuorumNumerator) external virtual onlyGovernance {\n        _updateQuorumNumerator(newQuorumNumerator);\n    }\n\n    /**\n     * @dev Changes the quorum numerator.\n     *\n     * Emits a {QuorumNumeratorUpdated} event.\n     *\n     * Requirements:\n     *\n     * - New numerator must be smaller or equal to the denominator.\n     */\n    function _updateQuorumNumerator(uint256 newQuorumNumerator) internal virtual {\n        require(\n            newQuorumNumerator <= quorumDenominator(),\n            \"GovernorVotesQuorumFraction: quorumNumerator over quorumDenominator\"\n        );\n\n        uint256 oldQuorumNumerator = quorumNumerator();\n\n        // Make sure we keep track of the original numerator in contracts upgraded from a version without checkpoints.\n        if (oldQuorumNumerator != 0 && _quorumNumeratorHistory._checkpoints.length == 0) {\n            _quorumNumeratorHistory._checkpoints.push(\n                CheckpointsUpgradeable.Checkpoint224({_key: 0, _value: SafeCastUpgradeable.toUint224(oldQuorumNumerator)})\n            );\n        }\n\n        // Set new quorum for future proposals\n        _quorumNumeratorHistory.push(SafeCastUpgradeable.toUint32(clock()), SafeCastUpgradeable.toUint224(newQuorumNumerator));\n\n        emit QuorumNumeratorUpdated(oldQuorumNumerator, newQuorumNumerator);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/extensions/GovernorVotes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../GovernorUpgradeable.sol\";\nimport \"../../interfaces/IERC5805Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token, or since v4.5 an {ERC721Votes} token.\n *\n * _Available since v4.3._\n *\n * @custom:storage-size 51\n */\nabstract contract GovernorVotesUpgradeable is Initializable, GovernorUpgradeable {\n    IERC5805Upgradeable public token;\n\n    function __GovernorVotes_init(IVotesUpgradeable tokenAddress) internal onlyInitializing {\n        __GovernorVotes_init_unchained(tokenAddress);\n    }\n\n    function __GovernorVotes_init_unchained(IVotesUpgradeable tokenAddress) internal onlyInitializing {\n        token = IERC5805Upgradeable(address(tokenAddress));\n    }\n\n    /**\n     * @dev Clock (as specified in EIP-6372) is set to match the token's clock. Fallback to block numbers if the token\n     * does not implement EIP-6372.\n     */\n    function clock() public view virtual override returns (uint48) {\n        try token.clock() returns (uint48 timepoint) {\n            return timepoint;\n        } catch {\n            return SafeCastUpgradeable.toUint48(block.number);\n        }\n    }\n\n    /**\n     * @dev Machine-readable description of the clock as specified in EIP-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual override returns (string memory) {\n        try token.CLOCK_MODE() returns (string memory clockmode) {\n            return clockmode;\n        } catch {\n            return \"mode=blocknumber&from=default\";\n        }\n    }\n\n    /**\n     * Read the voting weight from the token's built in snapshot mechanism (see {Governor-_getVotes}).\n     */\n    function _getVotes(\n        address account,\n        uint256 timepoint,\n        bytes memory /*params*/\n    ) internal view virtual override returns (uint256) {\n        return token.getPastVotes(account, timepoint);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/governance/extensions/IGovernorTimelockUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/extensions/IGovernorTimelock.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IGovernorUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of the {IGovernor} for timelock supporting modules.\n *\n * _Available since v4.3._\n */\nabstract contract IGovernorTimelockUpgradeable is Initializable, IGovernorUpgradeable {\n    function __IGovernorTimelock_init() internal onlyInitializing {\n    }\n\n    function __IGovernorTimelock_init_unchained() internal onlyInitializing {\n    }\n    event ProposalQueued(uint256 proposalId, uint256 eta);\n\n    function timelock() public view virtual returns (address);\n\n    function proposalEta(uint256 proposalId) public view virtual returns (uint256);\n\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256 proposalId);\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/governance/utils/IVotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/utils/IVotes.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n *\n * _Available since v4.5._\n */\ninterface IVotesUpgradeable {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     */\n    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/governance/utils/VotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/utils/Votes.sol)\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/IERC5805Upgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/CountersUpgradeable.sol\";\nimport \"../../utils/CheckpointsUpgradeable.sol\";\nimport \"../../utils/cryptography/EIP712Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This is a base abstract contract that tracks voting units, which are a measure of voting power that can be\n * transferred, and provides a system of vote delegation, where an account can delegate its voting units to a sort of\n * \"representative\" that will pool delegated voting units from different accounts and can then use it to vote in\n * decisions. In fact, voting units _must_ be delegated in order to count as actual votes, and an account has to\n * delegate those votes to itself if it wishes to participate in decisions and does not have a trusted representative.\n *\n * This contract is often combined with a token contract such that voting units correspond to token units. For an\n * example, see {ERC721Votes}.\n *\n * The full history of delegate votes is tracked on-chain so that governance protocols can consider votes as distributed\n * at a particular block number to protect against flash loans and double voting. The opt-in delegate system makes the\n * cost of this history tracking optional.\n *\n * When using this module the derived contract must implement {_getVotingUnits} (for example, make it return\n * {ERC721-balanceOf}), and can use {_transferVotingUnits} to track a change in the distribution of those units (in the\n * previous example, it would be included in {ERC721-_beforeTokenTransfer}).\n *\n * _Available since v4.5._\n */\nabstract contract VotesUpgradeable is Initializable, ContextUpgradeable, EIP712Upgradeable, IERC5805Upgradeable {\n    function __Votes_init() internal onlyInitializing {\n    }\n\n    function __Votes_init_unchained() internal onlyInitializing {\n    }\n    using CheckpointsUpgradeable for CheckpointsUpgradeable.Trace224;\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegation;\n\n    /// @custom:oz-retyped-from mapping(address => Checkpoints.History)\n    mapping(address => CheckpointsUpgradeable.Trace224) private _delegateCheckpoints;\n\n    /// @custom:oz-retyped-from Checkpoints.History\n    CheckpointsUpgradeable.Trace224 private _totalCheckpoints;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based\n     * checkpoints (and voting), in which case {CLOCK_MODE} should be overridden as well to match.\n     */\n    function clock() public view virtual override returns (uint48) {\n        return SafeCastUpgradeable.toUint48(block.number);\n    }\n\n    /**\n     * @dev Machine-readable description of the clock as specified in EIP-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual override returns (string memory) {\n        // Check that the clock was not modified\n        require(clock() == block.number, \"Votes: broken clock mode\");\n        return \"mode=blocknumber&from=default\";\n    }\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) public view virtual override returns (uint256) {\n        return _delegateCheckpoints[account].latest();\n    }\n\n    /**\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.\n     */\n    function getPastVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {\n        require(timepoint < clock(), \"Votes: future lookup\");\n        return _delegateCheckpoints[account].upperLookupRecent(SafeCastUpgradeable.toUint32(timepoint));\n    }\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.\n     */\n    function getPastTotalSupply(uint256 timepoint) public view virtual override returns (uint256) {\n        require(timepoint < clock(), \"Votes: future lookup\");\n        return _totalCheckpoints.upperLookupRecent(SafeCastUpgradeable.toUint32(timepoint));\n    }\n\n    /**\n     * @dev Returns the current total supply of votes.\n     */\n    function _getTotalSupply() internal view virtual returns (uint256) {\n        return _totalCheckpoints.latest();\n    }\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegation[account];\n    }\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual override {\n        address account = _msgSender();\n        _delegate(account, delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"Votes: signature expired\");\n        address signer = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Delegate all of `account`'s voting units to `delegatee`.\n     *\n     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.\n     */\n    function _delegate(address account, address delegatee) internal virtual {\n        address oldDelegate = delegates(account);\n        _delegation[account] = delegatee;\n\n        emit DelegateChanged(account, oldDelegate, delegatee);\n        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));\n    }\n\n    /**\n     * @dev Transfers, mints, or burns voting units. To register a mint, `from` should be zero. To register a burn, `to`\n     * should be zero. Total supply of voting units will be adjusted with mints and burns.\n     */\n    function _transferVotingUnits(address from, address to, uint256 amount) internal virtual {\n        if (from == address(0)) {\n            _push(_totalCheckpoints, _add, SafeCastUpgradeable.toUint224(amount));\n        }\n        if (to == address(0)) {\n            _push(_totalCheckpoints, _subtract, SafeCastUpgradeable.toUint224(amount));\n        }\n        _moveDelegateVotes(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Moves delegated votes from one delegate to another.\n     */\n    function _moveDelegateVotes(address from, address to, uint256 amount) private {\n        if (from != to && amount > 0) {\n            if (from != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    _delegateCheckpoints[from],\n                    _subtract,\n                    SafeCastUpgradeable.toUint224(amount)\n                );\n                emit DelegateVotesChanged(from, oldValue, newValue);\n            }\n            if (to != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    _delegateCheckpoints[to],\n                    _add,\n                    SafeCastUpgradeable.toUint224(amount)\n                );\n                emit DelegateVotesChanged(to, oldValue, newValue);\n            }\n        }\n    }\n\n    function _push(\n        CheckpointsUpgradeable.Trace224 storage store,\n        function(uint224, uint224) view returns (uint224) op,\n        uint224 delta\n    ) private returns (uint224, uint224) {\n        return store.push(SafeCastUpgradeable.toUint32(clock()), op(store.latest(), delta));\n    }\n\n    function _add(uint224 a, uint224 b) private pure returns (uint224) {\n        return a + b;\n    }\n\n    function _subtract(uint224 a, uint224 b) private pure returns (uint224) {\n        return a - b;\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n\n    /**\n     * @dev Returns an address nonce.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev Returns the contract's {EIP712} domain separator.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev Must return the voting units held by an account.\n     */\n    function _getVotingUnits(address) internal view virtual returns (uint256);\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/interfaces/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165Upgradeable.sol\";\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/interfaces/IERC4906Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4906.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"./IERC721Upgradeable.sol\";\n\n/// @title EIP-721 Metadata Update Extension\ninterface IERC4906Upgradeable is IERC165Upgradeable, IERC721Upgradeable {\n    /// @dev This event emits when the metadata of a token is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFT.\n    event MetadataUpdate(uint256 _tokenId);\n\n    /// @dev This event emits when the metadata of a range of tokens is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFTs.\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/interfaces/IERC5267Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC5267Upgradeable {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/interfaces/IERC5805Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5805.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../governance/utils/IVotesUpgradeable.sol\";\nimport \"./IERC6372Upgradeable.sol\";\n\ninterface IERC5805Upgradeable is IERC6372Upgradeable, IVotesUpgradeable {}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/interfaces/IERC6372Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC6372.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC6372Upgradeable {\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() external view returns (uint48);\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() external view returns (string memory);\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/interfaces/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721Upgradeable.sol\";\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[44] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"./IERC721EnumerableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721EnumerableUpgradeable {\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721EnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Upgradeable.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721EnumerableUpgradeable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n\n        if (batchSize > 1) {\n            // Will only trigger during construction. Batch transferring (minting) is not available afterwards.\n            revert(\"ERC721Enumerable: consecutive transfers not supported\");\n        }\n\n        uint256 tokenId = firstTokenId;\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721Upgradeable.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../interfaces/IERC4906Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorageUpgradeable is Initializable, IERC4906Upgradeable, ERC721Upgradeable {\n    function __ERC721URIStorage_init() internal onlyInitializing {\n    }\n\n    function __ERC721URIStorage_init_unchained() internal onlyInitializing {\n    }\n    using StringsUpgradeable for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC165-supportsInterface}\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, IERC165Upgradeable) returns (bool) {\n        return interfaceId == bytes4(0x49064906) || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Emits {MetadataUpdate}.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n\n        emit MetadataUpdate(tokenId);\n    }\n\n    /**\n     * @dev See {ERC721-_burn}. This override additionally checks to see if a\n     * token-specific URI was set for the token, and if so, it deletes the token URI from\n     * the storage mapping.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721VotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/extensions/ERC721Votes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../governance/utils/VotesUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of ERC721 to support voting and delegation as implemented by {Votes}, where each individual NFT counts\n * as 1 vote unit.\n *\n * Tokens do not count as votes until they are delegated, because votes must be tracked which incurs an additional cost\n * on every transfer. Token holders can either delegate to a trusted representative who will decide how to make use of\n * the votes in governance decisions, or they can delegate to themselves to be their own representative.\n *\n * _Available since v4.5._\n */\nabstract contract ERC721VotesUpgradeable is Initializable, ERC721Upgradeable, VotesUpgradeable {\n    function __ERC721Votes_init() internal onlyInitializing {\n    }\n\n    function __ERC721Votes_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {ERC721-_afterTokenTransfer}. Adjusts votes when tokens are transferred.\n     *\n     * Emits a {IVotes-DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override {\n        _transferVotingUnits(from, to, batchSize);\n        super._afterTokenTransfer(from, to, firstTokenId, batchSize);\n    }\n\n    /**\n     * @dev Returns the balance of `account`.\n     *\n     * WARNING: Overriding this function will likely result in incorrect vote tracking.\n     */\n    function _getVotingUnits(address account) internal view virtual override returns (uint256) {\n        return balanceOf(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/CheckpointsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Checkpoints.sol)\n// This file was procedurally generated from scripts/generate/templates/Checkpoints.js.\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SafeCastUpgradeable.sol\";\n\n/**\n * @dev This library defines the `History` struct, for checkpointing values as they change at different points in\n * time, and later looking up past values by block number. See {Votes} as an example.\n *\n * To create a history of checkpoints define a variable type `Checkpoints.History` in your contract, and store a new\n * checkpoint for the current transaction block using the {push} function.\n *\n * _Available since v4.5._\n */\nlibrary CheckpointsUpgradeable {\n    struct History {\n        Checkpoint[] _checkpoints;\n    }\n\n    struct Checkpoint {\n        uint32 _blockNumber;\n        uint224 _value;\n    }\n\n    /**\n     * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one\n     * before it is returned, or zero otherwise. Because the number returned corresponds to that at the end of the\n     * block, the requested block number must be in the past, excluding the current block.\n     */\n    function getAtBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {\n        require(blockNumber < block.number, \"Checkpoints: block not yet mined\");\n        uint32 key = SafeCastUpgradeable.toUint32(blockNumber);\n\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one\n     * before it is returned, or zero otherwise. Similar to {upperLookup} but optimized for the case when the searched\n     * checkpoint is probably \"recent\", defined as being among the last sqrt(N) checkpoints where N is the number of\n     * checkpoints.\n     */\n    function getAtProbablyRecentBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {\n        require(blockNumber < block.number, \"Checkpoints: block not yet mined\");\n        uint32 key = SafeCastUpgradeable.toUint32(blockNumber);\n\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - MathUpgradeable.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Pushes a value onto a History so that it is stored as the checkpoint for the current block.\n     *\n     * Returns previous value and new value.\n     */\n    function push(History storage self, uint256 value) internal returns (uint256, uint256) {\n        return _insert(self._checkpoints, SafeCastUpgradeable.toUint32(block.number), SafeCastUpgradeable.toUint224(value));\n    }\n\n    /**\n     * @dev Pushes a value onto a History, by updating the latest value using binary operation `op`. The new value will\n     * be set to `op(latest, delta)`.\n     *\n     * Returns previous value and new value.\n     */\n    function push(\n        History storage self,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) internal returns (uint256, uint256) {\n        return push(self, op(latest(self), delta));\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(History storage self) internal view returns (uint224) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(\n        History storage self\n    ) internal view returns (bool exists, uint32 _blockNumber, uint224 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._blockNumber, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(History storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            require(last._blockNumber <= key, \"Checkpoint: decreasing keys\");\n\n            // Update or push new checkpoint\n            if (last._blockNumber == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint({_blockNumber: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint({_blockNumber: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._blockNumber > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._blockNumber < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(Checkpoint[] storage self, uint256 pos) private pure returns (Checkpoint storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace224 {\n        Checkpoint224[] _checkpoints;\n    }\n\n    struct Checkpoint224 {\n        uint32 _key;\n        uint224 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace224 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     */\n    function push(Trace224 storage self, uint32 key, uint224 value) internal returns (uint224, uint224) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if there is none.\n     */\n    function lowerLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     */\n    function upperLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high keys).\n     */\n    function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - MathUpgradeable.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace224 storage self) internal view returns (uint224) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace224 storage self) internal view returns (bool exists, uint32 _key, uint224 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint224 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace224 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint224[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint224 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            require(last._key <= key, \"Checkpoint: decreasing keys\");\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint224({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint224({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint224[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint224 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace160 {\n        Checkpoint160[] _checkpoints;\n    }\n\n    struct Checkpoint160 {\n        uint96 _key;\n        uint160 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace160 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     */\n    function push(Trace160 storage self, uint96 key, uint160 value) internal returns (uint160, uint160) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if there is none.\n     */\n    function lowerLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     */\n    function upperLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high keys).\n     */\n    function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - MathUpgradeable.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace160 storage self) internal view returns (uint160) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace160 storage self) internal view returns (bool exists, uint96 _key, uint160 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint160 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace160 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint160[] storage self, uint96 key, uint160 value) private returns (uint160, uint160) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint160 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            require(last._key <= key, \"Checkpoint: decreasing keys\");\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint160({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint160({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint160[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint160 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SignedMathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../interfaces/IERC5267Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 52\n */\nabstract contract EIP712Upgradeable is Initializable, IERC5267Upgradeable {\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /// @custom:oz-renamed-from _HASHED_NAME\n    bytes32 private _hashedName;\n    /// @custom:oz-renamed-from _HASHED_VERSION\n    bytes32 private _hashedVersion;\n\n    string private _name;\n    string private _version;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        _name = name;\n        _version = version;\n\n        // Reset prior values in storage if upgrading\n        _hashedName = 0;\n        _hashedVersion = 0;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {EIP-5267}.\n     *\n     * _Available since v4.9._\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        // If the hashed name and version in storage are non-zero, the contract hasn't been properly initialized\n        // and the EIP712 domain is not reliable, as it will be missing name and version.\n        require(_hashedName == 0 && _hashedVersion == 0, \"EIP712: Uninitialized\");\n\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Name() internal virtual view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Version() internal virtual view returns (string memory) {\n        return _version;\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.\n     */\n    function _EIP712NameHash() internal view returns (bytes32) {\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            // If the name is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.\n            bytes32 hashedName = _hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.\n     */\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            // If the version is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.\n            bytes32 hashedVersion = _hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMathUpgradeable {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/structs/DoubleEndedQueueUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/DoubleEndedQueue.sol)\npragma solidity ^0.8.4;\n\nimport \"../math/SafeCastUpgradeable.sol\";\n\n/**\n * @dev A sequence of items with the ability to efficiently push and pop items (i.e. insert and remove) on both ends of\n * the sequence (called front and back). Among other access patterns, it can be used to implement efficient LIFO and\n * FIFO queues. Storage use is optimized, and all operations are O(1) constant time. This includes {clear}, given that\n * the existing queue contents are left in storage.\n *\n * The struct is called `Bytes32Deque`. Other types can be cast to and from `bytes32`. This data structure can only be\n * used in storage, and not in memory.\n * ```solidity\n * DoubleEndedQueue.Bytes32Deque queue;\n * ```\n *\n * _Available since v4.6._\n */\nlibrary DoubleEndedQueueUpgradeable {\n    /**\n     * @dev An operation (e.g. {front}) couldn't be completed due to the queue being empty.\n     */\n    error Empty();\n\n    /**\n     * @dev An operation (e.g. {at}) couldn't be completed due to an index being out of bounds.\n     */\n    error OutOfBounds();\n\n    /**\n     * @dev Indices are signed integers because the queue can grow in any direction. They are 128 bits so begin and end\n     * are packed in a single storage slot for efficient access. Since the items are added one at a time we can safely\n     * assume that these 128-bit indices will not overflow, and use unchecked arithmetic.\n     *\n     * Struct members have an underscore prefix indicating that they are \"private\" and should not be read or written to\n     * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and\n     * lead to unexpected behavior.\n     *\n     * Indices are in the range [begin, end) which means the first item is at data[begin] and the last item is at\n     * data[end - 1].\n     */\n    struct Bytes32Deque {\n        int128 _begin;\n        int128 _end;\n        mapping(int128 => bytes32) _data;\n    }\n\n    /**\n     * @dev Inserts an item at the end of the queue.\n     */\n    function pushBack(Bytes32Deque storage deque, bytes32 value) internal {\n        int128 backIndex = deque._end;\n        deque._data[backIndex] = value;\n        unchecked {\n            deque._end = backIndex + 1;\n        }\n    }\n\n    /**\n     * @dev Removes the item at the end of the queue and returns it.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function popBack(Bytes32Deque storage deque) internal returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 backIndex;\n        unchecked {\n            backIndex = deque._end - 1;\n        }\n        value = deque._data[backIndex];\n        delete deque._data[backIndex];\n        deque._end = backIndex;\n    }\n\n    /**\n     * @dev Inserts an item at the beginning of the queue.\n     */\n    function pushFront(Bytes32Deque storage deque, bytes32 value) internal {\n        int128 frontIndex;\n        unchecked {\n            frontIndex = deque._begin - 1;\n        }\n        deque._data[frontIndex] = value;\n        deque._begin = frontIndex;\n    }\n\n    /**\n     * @dev Removes the item at the beginning of the queue and returns it.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function popFront(Bytes32Deque storage deque) internal returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 frontIndex = deque._begin;\n        value = deque._data[frontIndex];\n        delete deque._data[frontIndex];\n        unchecked {\n            deque._begin = frontIndex + 1;\n        }\n    }\n\n    /**\n     * @dev Returns the item at the beginning of the queue.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function front(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 frontIndex = deque._begin;\n        return deque._data[frontIndex];\n    }\n\n    /**\n     * @dev Returns the item at the end of the queue.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function back(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 backIndex;\n        unchecked {\n            backIndex = deque._end - 1;\n        }\n        return deque._data[backIndex];\n    }\n\n    /**\n     * @dev Return the item at a position in the queue given by `index`, with the first item at 0 and last item at\n     * `length(deque) - 1`.\n     *\n     * Reverts with `OutOfBounds` if the index is out of bounds.\n     */\n    function at(Bytes32Deque storage deque, uint256 index) internal view returns (bytes32 value) {\n        // int256(deque._begin) is a safe upcast\n        int128 idx = SafeCastUpgradeable.toInt128(int256(deque._begin) + SafeCastUpgradeable.toInt256(index));\n        if (idx >= deque._end) revert OutOfBounds();\n        return deque._data[idx];\n    }\n\n    /**\n     * @dev Resets the queue back to being empty.\n     *\n     * NOTE: The current items are left behind in storage. This does not affect the functioning of the queue, but misses\n     * out on potential gas refunds.\n     */\n    function clear(Bytes32Deque storage deque) internal {\n        deque._begin = 0;\n        deque._end = 0;\n    }\n\n    /**\n     * @dev Returns the number of items in the queue.\n     */\n    function length(Bytes32Deque storage deque) internal view returns (uint256) {\n        // The interface preserves the invariant that begin <= end so we assume this will not overflow.\n        // We also assume there are at most int256.max items in the queue.\n        unchecked {\n            return uint256(int256(deque._end) - int256(deque._begin));\n        }\n    }\n\n    /**\n     * @dev Returns true if the queue is empty.\n     */\n    function empty(Bytes32Deque storage deque) internal view returns (bool) {\n        return deque._end <= deque._begin;\n    }\n}\n"
    },
    "node_modules/@rari-capital/solmate/src/utils/Bytes32AddressLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Library for converting between addresses and bytes32 values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\nlibrary Bytes32AddressLib {\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue));\n    }\n}\n"
    },
    "node_modules/@rari-capital/solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\n        return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.\n    }\n\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is < 0.5 we return zero. This happens when\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n            if (x <= -42139678854452767551) return 0;\n\n            // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\n            // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\n            if (x >= 135305999368893231589) revert(\"EXP_OVERFLOW\");\n\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5**18;\n\n            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // k is in the range [-61, 195].\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // p is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range (0.09, 0.25) * 2**96.\n\n            // We now need to multiply r by:\n            // * the scale factor s = ~6.031367120.\n            // * the 2**k factor from the range reduction.\n            // * the 1e18 / 2**96 factor for base conversion.\n            // We do this all at once, with an intermediate result in 2**213\n            // basis, so the final right shift is always by a positive amount.\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n        }\n    }\n\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            require(x > 0, \"UNDEFINED\");\n\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n            // We do this by multiplying by 2**96 / 10**18. But since\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n            // and add ln(2**96 / 10**18) at the end.\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            int256 k = int256(log2(uint256(x))) - 96;\n            x <<= uint256(159 - k);\n            x = int256(uint256(x) >> 159);\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // p is made monic, we will multiply by a scale factor later.\n            int256 p = x + 3273285459638523848632254066296;\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\n            p = p * x - (795164235651350426258249787498 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            // q is monic by convention.\n            int256 q = x + 5573035233440673466300451813936;\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial is known not to have zeros in the domain.\n                // No scaling required because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r is in the range (0, 0.125) * 2**96\n\n            // Finalization, we need to:\n            // * multiply by the scale factor s = 5.549…\n            // * add ln(2**96 / 10**18)\n            // * add k * ln(2)\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\n\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n            r *= 1677202110996718588342820967067443963516166;\n            // add ln(2) * k * 5e18 * 2**192\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n            // base conversion: mul 2**18 / 2**192\n            r >>= 174;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        require(x > 0, \"UNDEFINED\");\n\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\n            r := or(r, lt(0x1, shr(r, x)))\n        }\n    }\n}\n"
    },
    "node_modules/ds-test/src/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.0;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool private _failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function failed() public returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            bool globalFailed = false;\n            if (hasHEVMContext()) {\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\n                    abi.encodePacked(\n                        bytes4(keccak256(\"load(address,bytes32)\")),\n                        abi.encode(HEVM_ADDRESS, bytes32(\"failed\"))\n                    )\n                );\n                globalFailed = abi.decode(retdata, (bool));\n            }\n            return globalFailed;\n        }\n    } \n\n    function fail() internal {\n        if (hasHEVMContext()) {\n            (bool status, ) = HEVM_ADDRESS.call(\n                abi.encodePacked(\n                    bytes4(keccak256(\"store(address,bytes32,bytes32)\")),\n                    abi.encode(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x01)))\n                )\n            );\n            status; // Silence compiler warnings\n        }\n        _failed = true;\n    }\n\n    function hasHEVMContext() internal view returns (bool) {\n        uint256 hevmCodeSize = 0;\n        assembly {\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\n        }\n        return hevmCodeSize > 0;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Expected\", b);\n            emit log_named_string(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", b);\n            emit log_named_bytes(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "node_modules/forge-std/src/Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {StdStorage} from \"./StdStorage.sol\";\nimport {Vm, VmSafe} from \"./Vm.sol\";\n\nabstract contract CommonBase {\n    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.\n    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(\"hevm cheat code\"))));\n    // console.sol and console2.sol work by executing a staticcall to this address.\n    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;\n    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.\n    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(\"foundry default caller\"))));\n    // Address of the test contract, deployed by the DEFAULT_SENDER.\n    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\n    // Deterministic deployment address of the Multicall3 contract.\n    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    Vm internal constant vm = Vm(VM_ADDRESS);\n    StdStorage internal stdstore;\n}\n\nabstract contract TestBase is CommonBase {}\n\nabstract contract ScriptBase is CommonBase {\n    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);\n}\n"
    },
    "node_modules/forge-std/src/StdAssertions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {DSTest} from \"ds-test/test.sol\";\nimport {stdMath} from \"./StdMath.sol\";\n\nabstract contract StdAssertions is DSTest {\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertFalse(bool data, string memory err) internal virtual {\n        assertTrue(!data, err);\n    }\n\n    function assertEq(bool a, bool b) internal virtual {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bool]\");\n            emit log_named_string(\"      Left\", a ? \"true\" : \"false\");\n            emit log_named_string(\"     Right\", b ? \"true\" : \"false\");\n            fail();\n        }\n    }\n\n    function assertEq(bool a, bool b, string memory err) internal virtual {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes memory a, bytes memory b) internal virtual {\n        assertEq0(a, b);\n    }\n\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal virtual {\n        assertEq0(a, b, err);\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [uint[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [int[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [address[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    // Legacy helper\n    function assertEqUint(uint256 a, uint256 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"      Left\", a);\n            emit log_named_uint(\"     Right\", b);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_decimal_uint(\"      Left\", a, decimals);\n            emit log_named_decimal_uint(\"     Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max Delta\", maxDelta, decimals);\n            emit log_named_decimal_uint(\"     Delta\", delta, decimals);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\n        }\n    }\n\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int(\"       Left\", a);\n            emit log_named_int(\"      Right\", b);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_decimal_int(\"      Left\", a, decimals);\n            emit log_named_decimal_int(\"     Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max Delta\", maxDelta, decimals);\n            emit log_named_decimal_uint(\"     Delta\", delta, decimals);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"        Left\", a);\n            emit log_named_uint(\"       Right\", b);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_decimal_uint(\"        Left\", a, decimals);\n            emit log_named_decimal_uint(\"       Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals,\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\n        }\n    }\n\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int(\"        Left\", a);\n            emit log_named_int(\"       Right\", b);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_decimal_int(\"        Left\", a, decimals);\n            emit log_named_decimal_int(\"       Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\n        }\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {\n        assertEqCall(target, callDataA, target, callDataB, true);\n    }\n\n    function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)\n        internal\n        virtual\n    {\n        assertEqCall(targetA, callDataA, targetB, callDataB, true);\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)\n        internal\n        virtual\n    {\n        assertEqCall(target, callDataA, target, callDataB, strictRevertData);\n    }\n\n    function assertEqCall(\n        address targetA,\n        bytes memory callDataA,\n        address targetB,\n        bytes memory callDataB,\n        bool strictRevertData\n    ) internal virtual {\n        (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);\n        (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);\n\n        if (successA && successB) {\n            assertEq(returnDataA, returnDataB, \"Call return data does not match\");\n        }\n\n        if (!successA && !successB && strictRevertData) {\n            assertEq(returnDataA, returnDataB, \"Call revert data does not match\");\n        }\n\n        if (!successA && successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call revert data\", returnDataA);\n            emit log_named_bytes(\" Right call return data\", returnDataB);\n            fail();\n        }\n\n        if (successA && !successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call return data\", returnDataA);\n            emit log_named_bytes(\" Right call revert data\", returnDataB);\n            fail();\n        }\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdChains.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n/**\n * StdChains provides information about EVM compatible chains that can be used in scripts/tests.\n * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are\n * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of\n * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the\n * alias used in this contract, which can be found as the first argument to the\n * `setChainWithDefaultRpcUrl` call in the `initialize` function.\n *\n * There are two main ways to use this contract:\n *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or\n *      `setChain(string memory chainAlias, Chain memory chain)`\n *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.\n *\n * The first time either of those are used, chains are initialized with the default set of RPC URLs.\n * This is done in `initialize`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in\n * `defaultRpcUrls`.\n *\n * The `setChain` function is straightforward, and it simply saves off the given chain data.\n *\n * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say\n * we want to retrieve `mainnet`'s RPC URL:\n *   - If you haven't set any mainnet chain info with `setChain`, you haven't specified that\n *     chain in `foundry.toml` and no env var is set, the default data and RPC URL will be returned.\n *   - If you have set a mainnet RPC URL in `foundry.toml` it will return that, if valid (e.g. if\n *     a URL is given or if an environment variable is given and that environment variable exists).\n *     Otherwise, the default data is returned.\n *   - If you specified data with `setChain` it will return that.\n *\n * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.\n */\nabstract contract StdChains {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private initialized;\n\n    struct ChainData {\n        string name;\n        uint256 chainId;\n        string rpcUrl;\n    }\n\n    struct Chain {\n        // The chain name.\n        string name;\n        // The chain's Chain ID.\n        uint256 chainId;\n        // The chain's alias. (i.e. what gets specified in `foundry.toml`).\n        string chainAlias;\n        // A default RPC endpoint for this chain.\n        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and\n        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy\n        // usage as you will be throttled and this is a disservice to others who need this endpoint.\n        string rpcUrl;\n    }\n\n    // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.\n    mapping(string => Chain) private chains;\n    // Maps from the chain's alias to it's default RPC URL.\n    mapping(string => string) private defaultRpcUrls;\n    // Maps from a chain ID to it's alias.\n    mapping(uint256 => string) private idToAlias;\n\n    bool private fallbackToDefaultRpcUrls = true;\n\n    // The RPC URL will be fetched from config or defaultRpcUrls if possible.\n    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {\n        require(bytes(chainAlias).length != 0, \"StdChains getChain(string): Chain alias cannot be the empty string.\");\n\n        initialize();\n        chain = chains[chainAlias];\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(string): Chain with alias \\\"\", chainAlias, \"\\\" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {\n        require(chainId != 0, \"StdChains getChain(uint256): Chain ID cannot be 0.\");\n        initialize();\n        string memory chainAlias = idToAlias[chainId];\n\n        chain = chains[chainAlias];\n\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(uint256): Chain with ID \", vm.toString(chainId), \" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {\n        require(\n            bytes(chainAlias).length != 0,\n            \"StdChains setChain(string,ChainData): Chain alias cannot be the empty string.\"\n        );\n\n        require(chain.chainId != 0, \"StdChains setChain(string,ChainData): Chain ID cannot be 0.\");\n\n        initialize();\n        string memory foundAlias = idToAlias[chain.chainId];\n\n        require(\n            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),\n            string(\n                abi.encodePacked(\n                    \"StdChains setChain(string,ChainData): Chain ID \",\n                    vm.toString(chain.chainId),\n                    \" already used by \\\"\",\n                    foundAlias,\n                    \"\\\".\"\n                )\n            )\n        );\n\n        uint256 oldChainId = chains[chainAlias].chainId;\n        delete idToAlias[oldChainId];\n\n        chains[chainAlias] =\n            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});\n        idToAlias[chain.chainId] = chainAlias;\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, Chain memory chain) internal virtual {\n        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));\n    }\n\n    function _toUpper(string memory str) private pure returns (string memory) {\n        bytes memory strb = bytes(str);\n        bytes memory copy = new bytes(strb.length);\n        for (uint256 i = 0; i < strb.length; i++) {\n            bytes1 b = strb[i];\n            if (b >= 0x61 && b <= 0x7A) {\n                copy[i] = bytes1(uint8(b) - 32);\n            } else {\n                copy[i] = b;\n            }\n        }\n        return string(copy);\n    }\n\n    // lookup rpcUrl, in descending order of priority:\n    // current -> config (foundry.toml) -> environment variable -> default\n    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain) private returns (Chain memory) {\n        if (bytes(chain.rpcUrl).length == 0) {\n            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {\n                chain.rpcUrl = configRpcUrl;\n            } catch (bytes memory err) {\n                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), \"_RPC_URL\"));\n                if (fallbackToDefaultRpcUrls) {\n                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);\n                } else {\n                    chain.rpcUrl = vm.envString(envName);\n                }\n                // distinguish 'not found' from 'cannot read'\n                bytes memory notFoundError =\n                    abi.encodeWithSignature(\"CheatCodeError\", string(abi.encodePacked(\"invalid rpc url \", chainAlias)));\n                if (keccak256(notFoundError) != keccak256(err) || bytes(chain.rpcUrl).length == 0) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, err), mload(err))\n                    }\n                }\n            }\n        }\n        return chain;\n    }\n\n    function setFallbackToDefaultRpcUrls(bool useDefault) internal {\n        fallbackToDefaultRpcUrls = useDefault;\n    }\n\n    function initialize() private {\n        if (initialized) return;\n\n        initialized = true;\n\n        // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`\n        setChainWithDefaultRpcUrl(\"anvil\", ChainData(\"Anvil\", 31337, \"http://127.0.0.1:8545\"));\n        setChainWithDefaultRpcUrl(\n            \"mainnet\", ChainData(\"Mainnet\", 1, \"https://mainnet.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"goerli\", ChainData(\"Goerli\", 5, \"https://goerli.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"sepolia\", ChainData(\"Sepolia\", 11155111, \"https://sepolia.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b\")\n        );\n        setChainWithDefaultRpcUrl(\"optimism\", ChainData(\"Optimism\", 10, \"https://mainnet.optimism.io\"));\n        setChainWithDefaultRpcUrl(\"optimism_goerli\", ChainData(\"Optimism Goerli\", 420, \"https://goerli.optimism.io\"));\n        setChainWithDefaultRpcUrl(\"arbitrum_one\", ChainData(\"Arbitrum One\", 42161, \"https://arb1.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"arbitrum_one_goerli\", ChainData(\"Arbitrum One Goerli\", 421613, \"https://goerli-rollup.arbitrum.io/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\"arbitrum_nova\", ChainData(\"Arbitrum Nova\", 42170, \"https://nova.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\"polygon\", ChainData(\"Polygon\", 137, \"https://polygon-rpc.com\"));\n        setChainWithDefaultRpcUrl(\n            \"polygon_mumbai\", ChainData(\"Polygon Mumbai\", 80001, \"https://rpc-mumbai.maticvigil.com\")\n        );\n        setChainWithDefaultRpcUrl(\"avalanche\", ChainData(\"Avalanche\", 43114, \"https://api.avax.network/ext/bc/C/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"avalanche_fuji\", ChainData(\"Avalanche Fuji\", 43113, \"https://api.avax-test.network/ext/bc/C/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain\", ChainData(\"BNB Smart Chain\", 56, \"https://bsc-dataseed1.binance.org\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain_testnet\",\n            ChainData(\"BNB Smart Chain Testnet\", 97, \"https://rpc.ankr.com/bsc_testnet_chapel\")\n        );\n        setChainWithDefaultRpcUrl(\"gnosis_chain\", ChainData(\"Gnosis Chain\", 100, \"https://rpc.gnosischain.com\"));\n    }\n\n    // set chain info, with priority to chainAlias' rpc url in foundry.toml\n    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {\n        string memory rpcUrl = chain.rpcUrl;\n        defaultRpcUrls[chainAlias] = rpcUrl;\n        chain.rpcUrl = \"\";\n        setChain(chainAlias, chain);\n        chain.rpcUrl = rpcUrl; // restore argument\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdCheats.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {Vm} from \"./Vm.sol\";\n\nabstract contract StdCheatsSafe {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private gasMeteringOff;\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawTx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        // json value name = function\n        string functionSig;\n        bytes32 hash;\n        // json value name = tx\n        RawTx1559Detail txDetail;\n        // json value name = type\n        string opcode;\n    }\n\n    struct RawTx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        bytes gas;\n        bytes nonce;\n        address to;\n        bytes txType;\n        bytes value;\n    }\n\n    struct Tx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        bytes32 hash;\n        Tx1559Detail txDetail;\n        string opcode;\n    }\n\n    struct Tx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 nonce;\n        address to;\n        uint256 txType;\n        uint256 value;\n    }\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct TxLegacy {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        string hash;\n        string opcode;\n        TxDetailLegacy transaction;\n    }\n\n    struct TxDetailLegacy {\n        AccessList[] accessList;\n        uint256 chainId;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 gasPrice;\n        bytes32 hash;\n        uint256 nonce;\n        bytes1 opcode;\n        bytes32 r;\n        bytes32 s;\n        uint256 txType;\n        address to;\n        uint8 v;\n        uint256 value;\n    }\n\n    struct AccessList {\n        address accessAddress;\n        bytes32[] storageKeys;\n    }\n\n    // Data structures to parse Receipt objects from the broadcast artifact.\n    // The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawReceipt {\n        bytes32 blockHash;\n        bytes blockNumber;\n        address contractAddress;\n        bytes cumulativeGasUsed;\n        bytes effectiveGasPrice;\n        address from;\n        bytes gasUsed;\n        RawReceiptLog[] logs;\n        bytes logsBloom;\n        bytes status;\n        address to;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n    }\n\n    struct Receipt {\n        bytes32 blockHash;\n        uint256 blockNumber;\n        address contractAddress;\n        uint256 cumulativeGasUsed;\n        uint256 effectiveGasPrice;\n        address from;\n        uint256 gasUsed;\n        ReceiptLog[] logs;\n        bytes logsBloom;\n        uint256 status;\n        address to;\n        bytes32 transactionHash;\n        uint256 transactionIndex;\n    }\n\n    // Data structures to parse the entire broadcast artifact, assuming the\n    // transactions conform to EIP1559.\n\n    struct EIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        Receipt[] receipts;\n        uint256 timestamp;\n        Tx1559[] transactions;\n        TxReturn[] txReturns;\n    }\n\n    struct RawEIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        RawReceipt[] receipts;\n        TxReturn[] txReturns;\n        uint256 timestamp;\n        RawTx1559[] transactions;\n    }\n\n    struct RawReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        bytes blockNumber;\n        bytes data;\n        bytes logIndex;\n        bool removed;\n        bytes32[] topics;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n        bytes transactionLogIndex;\n    }\n\n    struct ReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        uint256 blockNumber;\n        bytes data;\n        uint256 logIndex;\n        bytes32[] topics;\n        uint256 transactionIndex;\n        uint256 transactionLogIndex;\n        bool removed;\n    }\n\n    struct TxReturn {\n        string internalType;\n        string value;\n    }\n\n    function assumeNoPrecompiles(address addr) internal virtual {\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        assumeNoPrecompiles(addr, chainId);\n    }\n\n    function assumeNoPrecompiles(address addr, uint256 chainId) internal pure virtual {\n        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific\n        // address), but the same rationale for excluding them applies so we include those too.\n\n        // These should be present on all EVM-compatible chains.\n        vm.assume(addr < address(0x1) || addr > address(0x9));\n\n        // forgefmt: disable-start\n        if (chainId == 10 || chainId == 420) {\n            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21\n            vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));\n        } else if (chainId == 42161 || chainId == 421613) {\n            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains\n            vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));\n        } else if (chainId == 43114 || chainId == 43113) {\n            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59\n            vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));\n            vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));\n            vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));\n        }\n        // forgefmt: disable-end\n    }\n\n    function readEIP1559ScriptArtifact(string memory path)\n        internal\n        view\n        virtual\n        returns (EIP1559ScriptArtifact memory)\n    {\n        string memory data = vm.readFile(path);\n        bytes memory parsedData = vm.parseJson(data);\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\n        EIP1559ScriptArtifact memory artifact;\n        artifact.libraries = rawArtifact.libraries;\n        artifact.path = rawArtifact.path;\n        artifact.timestamp = rawArtifact.timestamp;\n        artifact.pending = rawArtifact.pending;\n        artifact.txReturns = rawArtifact.txReturns;\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\n        return artifact;\n    }\n\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\n        for (uint256 i; i < rawTxs.length; i++) {\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\n        }\n        return txs;\n    }\n\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {\n        Tx1559 memory transaction;\n        transaction.arguments = rawTx.arguments;\n        transaction.contractName = rawTx.contractName;\n        transaction.functionSig = rawTx.functionSig;\n        transaction.hash = rawTx.hash;\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\n        transaction.opcode = rawTx.opcode;\n        return transaction;\n    }\n\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\n        internal\n        pure\n        virtual\n        returns (Tx1559Detail memory)\n    {\n        Tx1559Detail memory txDetail;\n        txDetail.data = rawDetail.data;\n        txDetail.from = rawDetail.from;\n        txDetail.to = rawDetail.to;\n        txDetail.nonce = _bytesToUint(rawDetail.nonce);\n        txDetail.txType = _bytesToUint(rawDetail.txType);\n        txDetail.value = _bytesToUint(rawDetail.value);\n        txDetail.gas = _bytesToUint(rawDetail.gas);\n        txDetail.accessList = rawDetail.accessList;\n        return txDetail;\n    }\n\n    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".transactions\");\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\n        return rawToConvertedEIPTx1559s(rawTxs);\n    }\n\n    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".transactions[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\n        return rawToConvertedEIPTx1559(rawTx);\n    }\n\n    // Analogous to readTransactions, but for receipts.\n    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".receipts\");\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\n        return rawToConvertedReceipts(rawReceipts);\n    }\n\n    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".receipts[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\n        return rawToConvertedReceipt(rawReceipt);\n    }\n\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\n        for (uint256 i; i < rawReceipts.length; i++) {\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\n        }\n        return receipts;\n    }\n\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {\n        Receipt memory receipt;\n        receipt.blockHash = rawReceipt.blockHash;\n        receipt.to = rawReceipt.to;\n        receipt.from = rawReceipt.from;\n        receipt.contractAddress = rawReceipt.contractAddress;\n        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);\n        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);\n        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);\n        receipt.status = _bytesToUint(rawReceipt.status);\n        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);\n        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\n        receipt.logsBloom = rawReceipt.logsBloom;\n        receipt.transactionHash = rawReceipt.transactionHash;\n        return receipt;\n    }\n\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\n        internal\n        pure\n        virtual\n        returns (ReceiptLog[] memory)\n    {\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\n        for (uint256 i; i < rawLogs.length; i++) {\n            logs[i].logAddress = rawLogs[i].logAddress;\n            logs[i].blockHash = rawLogs[i].blockHash;\n            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);\n            logs[i].data = rawLogs[i].data;\n            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);\n            logs[i].topics = rawLogs[i].topics;\n            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);\n            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);\n            logs[i].removed = rawLogs[i].removed;\n        }\n        return logs;\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes): Deployment failed.\");\n    }\n\n    function deployCode(string memory what) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string): Deployment failed.\");\n    }\n\n    /// @dev deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes,uint256): Deployment failed.\");\n    }\n\n    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,uint256): Deployment failed.\");\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal virtual returns (address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    function deriveRememberKey(string memory mnemonic, uint32 index)\n        internal\n        virtual\n        returns (address who, uint256 privateKey)\n    {\n        privateKey = vm.deriveKey(mnemonic, index);\n        who = vm.rememberKey(privateKey);\n    }\n\n    function _bytesToUint(bytes memory b) private pure returns (uint256) {\n        require(b.length <= 32, \"StdCheats _bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    function isFork() internal view virtual returns (bool status) {\n        try vm.activeFork() {\n            status = true;\n        } catch (bytes memory) {}\n    }\n\n    modifier skipWhenForking() {\n        if (!isFork()) {\n            _;\n        }\n    }\n\n    modifier skipWhenNotForking() {\n        if (isFork()) {\n            _;\n        }\n    }\n\n    modifier noGasMetering() {\n        vm.pauseGasMetering();\n        // To prevent turning gas monitoring back on with nested functions that use this modifier,\n        // we check if gasMetering started in the off position. If it did, we don't want to turn\n        // it back on until we exit the top level function that used the modifier\n        //\n        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.\n        // funcA will have `gasStartedOff` as false, funcB will have it as true,\n        // so we only turn metering back on at the end of the funcA\n        bool gasStartedOff = gasMeteringOff;\n        gasMeteringOff = true;\n\n        _;\n\n        // if gas metering was on when this modifier was called, turn it back on at the end\n        if (!gasStartedOff) {\n            gasMeteringOff = false;\n            vm.resumeGasMetering();\n        }\n    }\n\n    // a cheat for fuzzing addresses that are payable only\n    // see https://github.com/foundry-rs/foundry/issues/3631\n    function assumePayable(address addr) internal virtual {\n        (bool success,) = payable(addr).call{value: 0}(\"\");\n        vm.assume(success);\n    }\n}\n\n// Wrappers around cheatcodes to avoid footguns\nabstract contract StdCheats is StdCheatsSafe {\n    using stdStorage for StdStorage;\n\n    StdStorage private stdstore;\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal virtual {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) internal virtual {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender, origin);\n    }\n\n    function hoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender);\n    }\n\n    function startHoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function startHoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function changePrank(address msgSender) internal virtual {\n        vm.stopPrank();\n        vm.startPrank(msgSender);\n    }\n\n    function changePrank(address msgSender, address txOrigin) internal virtual {\n        vm.stopPrank();\n        vm.startPrank(msgSender, txOrigin);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal virtual {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal virtual {\n        deal(token, to, give, false);\n    }\n\n    // Set the balance of an account for any ERC1155 token\n    // Use the alternative signature to update `totalSupply`\n    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {\n        dealERC1155(token, to, id, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);\n        }\n    }\n\n    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x00fdd58e, to, id));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0xbd85b039, id));\n            require(\n                totSupData.length != 0,\n                \"StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.\"\n            );\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);\n        }\n    }\n\n    function dealERC721(address token, address to, uint256 id) internal virtual {\n        // check if token id is already minted and the actual owner.\n        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));\n        require(successMinted, \"StdCheats deal(address,address,uint,bool): id not minted.\");\n\n        // get owner current balance\n        (, bytes memory fromBalData) = token.call(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));\n        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));\n\n        // get new user current balance\n        (, bytes memory toBalData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 toPrevBal = abi.decode(toBalData, (uint256));\n\n        // update balances\n        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);\n\n        // update owner\n        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdError.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n}\n"
    },
    "node_modules/forge-std/src/StdInvariant.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\ncontract StdInvariant {\n    struct FuzzSelector {\n        address addr;\n        bytes4[] selectors;\n    }\n\n    address[] private _excludedContracts;\n    address[] private _excludedSenders;\n    address[] private _targetedContracts;\n    address[] private _targetedSenders;\n\n    string[] private _excludedArtifacts;\n    string[] private _targetedArtifacts;\n\n    FuzzSelector[] private _targetedArtifactSelectors;\n    FuzzSelector[] private _targetedSelectors;\n\n    // Functions for users:\n    // These are intended to be called in tests.\n\n    function excludeContract(address newExcludedContract_) internal {\n        _excludedContracts.push(newExcludedContract_);\n    }\n\n    function excludeSender(address newExcludedSender_) internal {\n        _excludedSenders.push(newExcludedSender_);\n    }\n\n    function excludeArtifact(string memory newExcludedArtifact_) internal {\n        _excludedArtifacts.push(newExcludedArtifact_);\n    }\n\n    function targetArtifact(string memory newTargetedArtifact_) internal {\n        _targetedArtifacts.push(newTargetedArtifact_);\n    }\n\n    function targetArtifactSelector(FuzzSelector memory newTargetedArtifactSelector_) internal {\n        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);\n    }\n\n    function targetContract(address newTargetedContract_) internal {\n        _targetedContracts.push(newTargetedContract_);\n    }\n\n    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {\n        _targetedSelectors.push(newTargetedSelector_);\n    }\n\n    function targetSender(address newTargetedSender_) internal {\n        _targetedSenders.push(newTargetedSender_);\n    }\n\n    // Functions for forge:\n    // These are called by forge to run invariant tests and don't need to be called in tests.\n\n    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {\n        excludedArtifacts_ = _excludedArtifacts;\n    }\n\n    function excludeContracts() public view returns (address[] memory excludedContracts_) {\n        excludedContracts_ = _excludedContracts;\n    }\n\n    function excludeSenders() public view returns (address[] memory excludedSenders_) {\n        excludedSenders_ = _excludedSenders;\n    }\n\n    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {\n        targetedArtifacts_ = _targetedArtifacts;\n    }\n\n    function targetArtifactSelectors() public view returns (FuzzSelector[] memory targetedArtifactSelectors_) {\n        targetedArtifactSelectors_ = _targetedArtifactSelectors;\n    }\n\n    function targetContracts() public view returns (address[] memory targetedContracts_) {\n        targetedContracts_ = _targetedContracts;\n    }\n\n    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {\n        targetedSelectors_ = _targetedSelectors;\n    }\n\n    function targetSenders() public view returns (address[] memory targetedSenders_) {\n        targetedSenders_ = _targetedSenders;\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdJson.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n// Helpers for parsing and writing JSON files\n// To parse:\n// ```\n// using stdJson for string;\n// string memory json = vm.readFile(\"some_peth\");\n// json.parseUint(\"<json_path>\");\n// ```\n// To write:\n// ```\n// using stdJson for string;\n// string memory json = \"deploymentArtifact\";\n// Contract contract = new Contract();\n// json.serialize(\"contractAddress\", address(contract));\n// json = json.serialize(\"deploymentTimes\", uint(1));\n// // store the stringified JSON to the 'json' variable we have been using as a key\n// // as we won't need it any longer\n// string memory json2 = \"finalArtifact\";\n// string memory final = json2.serialize(\"depArtifact\", json);\n// final.write(\"<some_path>\");\n// ```\n\nlibrary stdJson {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {\n        return vm.parseJson(json, key);\n    }\n\n    function readUint(string memory json, string memory key) internal returns (uint256) {\n        return vm.parseJsonUint(json, key);\n    }\n\n    function readUintArray(string memory json, string memory key) internal returns (uint256[] memory) {\n        return vm.parseJsonUintArray(json, key);\n    }\n\n    function readInt(string memory json, string memory key) internal returns (int256) {\n        return vm.parseJsonInt(json, key);\n    }\n\n    function readIntArray(string memory json, string memory key) internal returns (int256[] memory) {\n        return vm.parseJsonIntArray(json, key);\n    }\n\n    function readBytes32(string memory json, string memory key) internal returns (bytes32) {\n        return vm.parseJsonBytes32(json, key);\n    }\n\n    function readBytes32Array(string memory json, string memory key) internal returns (bytes32[] memory) {\n        return vm.parseJsonBytes32Array(json, key);\n    }\n\n    function readString(string memory json, string memory key) internal returns (string memory) {\n        return vm.parseJsonString(json, key);\n    }\n\n    function readStringArray(string memory json, string memory key) internal returns (string[] memory) {\n        return vm.parseJsonStringArray(json, key);\n    }\n\n    function readAddress(string memory json, string memory key) internal returns (address) {\n        return vm.parseJsonAddress(json, key);\n    }\n\n    function readAddressArray(string memory json, string memory key) internal returns (address[] memory) {\n        return vm.parseJsonAddressArray(json, key);\n    }\n\n    function readBool(string memory json, string memory key) internal returns (bool) {\n        return vm.parseJsonBool(json, key);\n    }\n\n    function readBoolArray(string memory json, string memory key) internal returns (bool[] memory) {\n        return vm.parseJsonBoolArray(json, key);\n    }\n\n    function readBytes(string memory json, string memory key) internal returns (bytes memory) {\n        return vm.parseJsonBytes(json, key);\n    }\n\n    function readBytesArray(string memory json, string memory key) internal returns (bytes[] memory) {\n        return vm.parseJsonBytesArray(json, key);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function write(string memory jsonKey, string memory path) internal {\n        vm.writeJson(jsonKey, path);\n    }\n\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\n        vm.writeJson(jsonKey, path, valueKey);\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN) {\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n        }\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nstruct StdStorage {\n    mapping(address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping(address => mapping(bytes4 => mapping(bytes32 => bool))) finds;\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\nlibrary stdStorageSafe {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);\n    event WARNING_UninitedSlot(address who, uint256 slot);\n\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(StdStorage storage self) internal returns (uint256) {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        vm.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\n        }\n\n        (bytes32[] memory reads,) = vm.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = vm.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(\n                    false,\n                    \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\"\n                );\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                // store\n                vm.store(who, reads[i], bytes32(hex\"1337\"));\n                bool success;\n                bytes memory rdat;\n                {\n                    (success, rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32 * field_depth);\n                }\n\n                if (success && fdat == bytes32(hex\"1337\")) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    vm.store(who, reads[i], prev);\n                    break;\n                }\n                vm.store(who, reads[i], prev);\n            }\n        } else {\n            revert(\"stdStorage find(StdStorage): No storage use detected for target.\");\n        }\n\n        require(\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],\n            \"stdStorage find(StdStorage): Slot(s) not found.\"\n        );\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        address t = self._target;\n        uint256 s = find(self);\n        return abi.encode(vm.load(t, bytes32(s)));\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n\nlibrary stdStorage {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return stdStorageSafe.sigs(sigStr);\n    }\n\n    function find(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.find(self);\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        return stdStorageSafe.target(self, _target);\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, who);\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, amt);\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, key);\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        return stdStorageSafe.depth(self, _depth);\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(StdStorage storage self, bytes32 set) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\n        }\n        bytes32 curr = vm.load(who, slot);\n\n        if (fdat != curr) {\n            require(\n                false,\n                \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\"\n            );\n        }\n        vm.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return stdStorageSafe.read_bytes32(self);\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        return stdStorageSafe.read_bool(self);\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return stdStorageSafe.read_address(self);\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.read_uint(self);\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return stdStorageSafe.read_int(self);\n    }\n\n    // Private function so needs to be copied over\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    // Private function so needs to be copied over\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdStyle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nlibrary StdStyle {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    string constant RED = \"\\u001b[91m\";\n    string constant GREEN = \"\\u001b[92m\";\n    string constant YELLOW = \"\\u001b[93m\";\n    string constant BLUE = \"\\u001b[94m\";\n    string constant MAGENTA = \"\\u001b[95m\";\n    string constant CYAN = \"\\u001b[96m\";\n    string constant BOLD = \"\\u001b[1m\";\n    string constant DIM = \"\\u001b[2m\";\n    string constant ITALIC = \"\\u001b[3m\";\n    string constant UNDERLINE = \"\\u001b[4m\";\n    string constant INVERSE = \"\\u001b[7m\";\n    string constant RESET = \"\\u001b[0m\";\n\n    function styleConcat(string memory style, string memory self) private pure returns (string memory) {\n        return string(abi.encodePacked(style, self, RESET));\n    }\n\n    function red(string memory self) internal pure returns (string memory) {\n        return styleConcat(RED, self);\n    }\n\n    function red(uint256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(int256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(address self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(bool self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes(bytes memory self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes32(bytes32 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function green(string memory self) internal pure returns (string memory) {\n        return styleConcat(GREEN, self);\n    }\n\n    function green(uint256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(int256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(address self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(bool self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes(bytes memory self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes32(bytes32 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function yellow(string memory self) internal pure returns (string memory) {\n        return styleConcat(YELLOW, self);\n    }\n\n    function yellow(uint256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(int256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(address self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(bool self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes(bytes memory self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes32(bytes32 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function blue(string memory self) internal pure returns (string memory) {\n        return styleConcat(BLUE, self);\n    }\n\n    function blue(uint256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(int256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(address self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(bool self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes(bytes memory self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes32(bytes32 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function magenta(string memory self) internal pure returns (string memory) {\n        return styleConcat(MAGENTA, self);\n    }\n\n    function magenta(uint256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(int256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(address self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(bool self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes(bytes memory self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes32(bytes32 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function cyan(string memory self) internal pure returns (string memory) {\n        return styleConcat(CYAN, self);\n    }\n\n    function cyan(uint256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(int256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(address self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(bool self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes(bytes memory self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes32(bytes32 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function bold(string memory self) internal pure returns (string memory) {\n        return styleConcat(BOLD, self);\n    }\n\n    function bold(uint256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(int256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(address self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(bool self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes(bytes memory self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes32(bytes32 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function dim(string memory self) internal pure returns (string memory) {\n        return styleConcat(DIM, self);\n    }\n\n    function dim(uint256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(int256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(address self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(bool self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes(bytes memory self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes32(bytes32 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function italic(string memory self) internal pure returns (string memory) {\n        return styleConcat(ITALIC, self);\n    }\n\n    function italic(uint256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(int256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(address self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(bool self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes(bytes memory self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes32(bytes32 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function underline(string memory self) internal pure returns (string memory) {\n        return styleConcat(UNDERLINE, self);\n    }\n\n    function underline(uint256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(int256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(address self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(bool self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes(bytes memory self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes32(bytes32 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function inverse(string memory self) internal pure returns (string memory) {\n        return styleConcat(INVERSE, self);\n    }\n\n    function inverse(uint256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(int256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(address self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(bool self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes(bytes memory self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes32(bytes32 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n}\n"
    },
    "node_modules/forge-std/src/StdUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {IMulticall3} from \"./interfaces/IMulticall3.sol\";\n// TODO Remove import.\nimport {VmSafe} from \"./Vm.sol\";\n\nabstract contract StdUtils {\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTANTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n    uint256 private constant INT256_MIN_ABS =\n        57896044618658097711785492504343953926634992332820282019728792003956564819968;\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\n        require(min <= max, \"StdUtils bound(uint256,uint256,uint256): Max is less than min.\");\n        // If x is between min and max, return x directly. This is to ensure that dictionary values\n        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188\n        if (x >= min && x <= max) return x;\n\n        uint256 size = max - min + 1;\n\n        // If the value is 0, 1, 2, 3, warp that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.\n        // This helps ensure coverage of the min/max values.\n        if (x <= 3 && size > x) return min + x;\n        if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);\n\n        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.\n        if (x > max) {\n            uint256 diff = x - max;\n            uint256 rem = diff % size;\n            if (rem == 0) return max;\n            result = min + rem - 1;\n        } else if (x < min) {\n            uint256 diff = min - x;\n            uint256 rem = diff % size;\n            if (rem == 0) return min;\n            result = max - rem + 1;\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal view virtual returns (uint256 result) {\n        result = _bound(x, min, max);\n        console2_log(\"Bound Result\", result);\n    }\n\n    function bound(int256 x, int256 min, int256 max) internal view virtual returns (int256 result) {\n        require(min <= max, \"StdUtils bound(int256,int256,int256): Max is less than min.\");\n\n        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:\n        // int256 : -(2**255) ~ (2**255 - 1)\n        // uint256:     0     ~ (2**256 - 1)\n        // So, add 2**255, INT256_MIN_ABS to the integer values.\n        //\n        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.\n        // So, use `~uint256(x) + 1` instead.\n        uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);\n        uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);\n        uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);\n\n        uint256 y = _bound(_x, _min, _max);\n\n        // To move it back to int256 value, subtract INT256_MIN_ABS at here.\n        result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);\n        console2_log(\"Bound result\", vm.toString(result));\n    }\n\n    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {\n        require(b.length <= 32, \"StdUtils bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\n    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {\n        // forgefmt: disable-start\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\n        // A one byte integer uses its own value as its length prefix, there is no additional \"0x80 + length\" prefix that comes before it.\n        if (nonce == 0x00)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));\n        if (nonce <= 0x7f)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));\n\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\n        if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));\n        if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));\n        if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));\n        // forgefmt: disable-end\n\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\n        return addressFromLast20Bytes(\n            keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce)))\n        );\n    }\n\n    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)\n        internal\n        pure\n        virtual\n        returns (address)\n    {\n        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initcodeHash)));\n    }\n\n    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {\n        return computeCreate2Address(salt, initCodeHash, CREATE2_FACTORY);\n    }\n\n    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {\n        return hashInitCode(creationCode, \"\");\n    }\n\n    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    /// @param args the ABI-encoded arguments to the constructor of C\n    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(creationCode, args));\n    }\n\n    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.\n    function getTokenBalances(address token, address[] memory addresses)\n        internal\n        virtual\n        returns (uint256[] memory balances)\n    {\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdUtils getTokenBalances(address,address[]): Token address is not a contract.\");\n\n        // ABI encode the aggregate call to Multicall3.\n        uint256 length = addresses.length;\n        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            // 0x70a08231 = bytes4(\"balanceOf(address)\"))\n            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});\n        }\n\n        // Make the aggregate call.\n        (, bytes[] memory returnData) = multicall.aggregate(calls);\n\n        // ABI decode the return data and return the balances.\n        balances = new uint256[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            balances[i] = abi.decode(returnData[i], (uint256));\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.\n\n    function console2_log(string memory p0, uint256 p1) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n        status;\n    }\n\n    function console2_log(string memory p0, string memory p1) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n        status;\n    }\n}\n"
    },
    "node_modules/forge-std/src/Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n// 💬 ABOUT\n// Standard Library's default Test\n\n// 🧩 MODULES\nimport {console} from \"./console.sol\";\nimport {console2} from \"./console2.sol\";\nimport {StdAssertions} from \"./StdAssertions.sol\";\nimport {StdChains} from \"./StdChains.sol\";\nimport {StdCheats} from \"./StdCheats.sol\";\nimport {stdError} from \"./StdError.sol\";\nimport {StdInvariant} from \"./StdInvariant.sol\";\nimport {stdJson} from \"./StdJson.sol\";\nimport {stdMath} from \"./StdMath.sol\";\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {StdUtils} from \"./StdUtils.sol\";\nimport {Vm} from \"./Vm.sol\";\nimport {StdStyle} from \"./StdStyle.sol\";\n\n// 📦 BOILERPLATE\nimport {TestBase} from \"./Base.sol\";\nimport {DSTest} from \"ds-test/test.sol\";\n\n// ⭐️ TEST\nabstract contract Test is DSTest, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils, TestBase {\n// Note: IS_TEST() must return true.\n// Note: Must have failure system, https://github.com/dapphub/ds-test/blob/cd98eff28324bfac652e63a239a60632a761790b/src/test.sol#L39-L76.\n}\n"
    },
    "node_modules/forge-std/src/Vm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n// Cheatcodes are marked as view/pure/none using the following rules:\n// 0. A call's observable behaviour includes its return value, logs, reverts and state writes,\n// 1. If you can influence a later call's observable behaviour, you're neither `view` nor `pure (you are modifying some state be it the EVM, interpreter, filesystem, etc),\n// 2. Otherwise if you can be influenced by an earlier call, or if reading some state, you're `view`,\n// 3. Otherwise you're `pure`.\n\ninterface VmSafe {\n    struct Log {\n        bytes32[] topics;\n        bytes data;\n        address emitter;\n    }\n\n    struct Rpc {\n        string key;\n        string url;\n    }\n\n    struct FsMetadata {\n        bool isDir;\n        bool isSymlink;\n        uint256 length;\n        bool readOnly;\n        uint256 modified;\n        uint256 accessed;\n        uint256 created;\n    }\n\n    // Loads a storage slot from an address\n    function load(address target, bytes32 slot) external view returns (bytes32 data);\n    // Signs data\n    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n    // Gets the address for a given private key\n    function addr(uint256 privateKey) external pure returns (address keyAddr);\n    // Gets the nonce of an account\n    function getNonce(address account) external view returns (uint64 nonce);\n    // Performs a foreign function call via the terminal\n    function ffi(string[] calldata commandInput) external returns (bytes memory result);\n    // Sets environment variables\n    function setEnv(string calldata name, string calldata value) external;\n    // Reads environment variables, (name) => (value)\n    function envBool(string calldata name) external view returns (bool value);\n    function envUint(string calldata name) external view returns (uint256 value);\n    function envInt(string calldata name) external view returns (int256 value);\n    function envAddress(string calldata name) external view returns (address value);\n    function envBytes32(string calldata name) external view returns (bytes32 value);\n    function envString(string calldata name) external view returns (string memory value);\n    function envBytes(string calldata name) external view returns (bytes memory value);\n    // Reads environment variables as arrays\n    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);\n    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);\n    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);\n    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);\n    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);\n    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);\n    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);\n    // Read environment variables with default value\n    function envOr(string calldata name, bool defaultValue) external returns (bool value);\n    function envOr(string calldata name, uint256 defaultValue) external returns (uint256 value);\n    function envOr(string calldata name, int256 defaultValue) external returns (int256 value);\n    function envOr(string calldata name, address defaultValue) external returns (address value);\n    function envOr(string calldata name, bytes32 defaultValue) external returns (bytes32 value);\n    function envOr(string calldata name, string calldata defaultValue) external returns (string memory value);\n    function envOr(string calldata name, bytes calldata defaultValue) external returns (bytes memory value);\n    // Read environment variables as arrays with default value\n    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)\n        external\n        returns (bool[] memory value);\n    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)\n        external\n        returns (uint256[] memory value);\n    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)\n        external\n        returns (int256[] memory value);\n    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)\n        external\n        returns (address[] memory value);\n    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)\n        external\n        returns (bytes32[] memory value);\n    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)\n        external\n        returns (string[] memory value);\n    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)\n        external\n        returns (bytes[] memory value);\n    // Records all storage reads and writes\n    function record() external;\n    // Gets all accessed reads and write slot from a recording session, for a given address\n    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);\n    // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);\n    // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);\n    // Labels an address in call traces\n    function label(address account, string calldata newLabel) external;\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n    function broadcast() external;\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n    function broadcast(address signer) external;\n    // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain\n    function broadcast(uint256 privateKey) external;\n    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast() external;\n    // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain\n    function startBroadcast(address signer) external;\n    // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain\n    function startBroadcast(uint256 privateKey) external;\n    // Stops collecting onchain transactions\n    function stopBroadcast() external;\n    // Reads the entire content of file to string\n    function readFile(string calldata path) external view returns (string memory data);\n    // Reads the entire content of file as binary. Path is relative to the project root.\n    function readFileBinary(string calldata path) external view returns (bytes memory data);\n    // Get the path of the current project root\n    function projectRoot() external view returns (string memory path);\n    // Get the metadata for a file/directory\n    function fsMetadata(string calldata fileOrDir) external returns (FsMetadata memory metadata);\n    // Reads next line of file to string\n    function readLine(string calldata path) external view returns (string memory line);\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    function writeFile(string calldata path, string calldata data) external;\n    // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // Path is relative to the project root.\n    function writeFileBinary(string calldata path, bytes calldata data) external;\n    // Writes line to file, creating a file if it does not exist.\n    function writeLine(string calldata path, string calldata data) external;\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    function closeFile(string calldata path) external;\n    // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - Path points to a directory.\n    // - The file doesn't exist.\n    // - The user lacks permissions to remove the file.\n    function removeFile(string calldata path) external;\n    // Convert values to a string\n    function toString(address value) external pure returns (string memory stringifiedValue);\n    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);\n    function toString(bytes32 value) external pure returns (string memory stringifiedValue);\n    function toString(bool value) external pure returns (string memory stringifiedValue);\n    function toString(uint256 value) external pure returns (string memory stringifiedValue);\n    function toString(int256 value) external pure returns (string memory stringifiedValue);\n    // Convert values from a string\n    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);\n    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);\n    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);\n    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);\n    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);\n    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);\n    // Record all the transaction logs\n    function recordLogs() external;\n    // Gets all the recorded logs\n    function getRecordedLogs() external returns (Log[] memory logs);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at {derivationPath}{index}\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)\n        external\n        pure\n        returns (uint256 privateKey);\n    // Adds a private key to the local forge wallet and returns the address\n    function rememberKey(uint256 privateKey) external returns (address keyAddr);\n    //\n    // parseJson\n    //\n    // ----\n    // In case the returned value is a JSON object, it's encoded as a ABI-encoded tuple. As JSON objects\n    // don't have the notion of ordered, but tuples do, they JSON object is encoded with it's fields ordered in\n    // ALPHABETICAL order. That means that in order to successfully decode the tuple, we need to define a tuple that\n    // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded\n    // as tuples, with the attributes in the order in which they are defined.\n    // For example: json = { 'a': 1, 'b': 0xa4tb......3xs}\n    // a: uint256\n    // b: address\n    // To decode that json, we need to define a struct or a tuple as follows:\n    // struct json = { uint256 a; address b; }\n    // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to\n    // decode the tuple in that order, and thus fail.\n    // ----\n    // Given a string of JSON, return it as ABI-encoded\n    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);\n    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);\n\n    // The following parseJson cheatcodes will do type coercion, for the type that they indicate.\n    // For example, parseJsonUint will coerce all values to a uint256. That includes stringified numbers '12'\n    // and hex numbers '0xEF'.\n    // Type coercion works ONLY for discrete values or arrays. That means that the key must return a value or array, not\n    // a JSON object.\n    function parseJsonUint(string calldata, string calldata) external returns (uint256);\n    function parseJsonUintArray(string calldata, string calldata) external returns (uint256[] memory);\n    function parseJsonInt(string calldata, string calldata) external returns (int256);\n    function parseJsonIntArray(string calldata, string calldata) external returns (int256[] memory);\n    function parseJsonBool(string calldata, string calldata) external returns (bool);\n    function parseJsonBoolArray(string calldata, string calldata) external returns (bool[] memory);\n    function parseJsonAddress(string calldata, string calldata) external returns (address);\n    function parseJsonAddressArray(string calldata, string calldata) external returns (address[] memory);\n    function parseJsonString(string calldata, string calldata) external returns (string memory);\n    function parseJsonStringArray(string calldata, string calldata) external returns (string[] memory);\n    function parseJsonBytes(string calldata, string calldata) external returns (bytes memory);\n    function parseJsonBytesArray(string calldata, string calldata) external returns (bytes[] memory);\n    function parseJsonBytes32(string calldata, string calldata) external returns (bytes32);\n    function parseJsonBytes32Array(string calldata, string calldata) external returns (bytes32[] memory);\n\n    // Serialize a key and value to a JSON object stored in-memory that can be later written to a file\n    // It returns the stringified version of the specific JSON file up to that moment.\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)\n        external\n        returns (string memory json);\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)\n        external\n        returns (string memory json);\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)\n        external\n        returns (string memory json);\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)\n        external\n        returns (string memory json);\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)\n        external\n        returns (string memory json);\n    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)\n        external\n        returns (string memory json);\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)\n        external\n        returns (string memory json);\n\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)\n        external\n        returns (string memory json);\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)\n        external\n        returns (string memory json);\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)\n        external\n        returns (string memory json);\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)\n        external\n        returns (string memory json);\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)\n        external\n        returns (string memory json);\n    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)\n        external\n        returns (string memory json);\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)\n        external\n        returns (string memory json);\n\n    //\n    // writeJson\n    //\n    // ----\n    // Write a serialized JSON object to a file. If the file exists, it will be overwritten.\n    // Let's assume we want to write the following JSON to a file:\n    //\n    // { \"boolean\": true, \"number\": 342, \"object\": { \"title\": \"finally json serialization\" } }\n    //\n    // ```\n    //  string memory json1 = \"some key\";\n    //  vm.serializeBool(json1, \"boolean\", true);\n    //  vm.serializeBool(json1, \"number\", uint256(342));\n    //  json2 = \"some other key\";\n    //  string memory output = vm.serializeString(json2, \"title\", \"finally json serialization\");\n    //  string memory finalJson = vm.serialize(json1, \"object\", output);\n    //  vm.writeJson(finalJson, \"./output/example.json\");\n    // ```\n    // The critical insight is that every invocation of serialization will return the stringified version of the JSON\n    // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version\n    // to serialize them as values to another JSON object.\n    //\n    // json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)\n    // will find the object in-memory that is keyed by \"some key\".\n    function writeJson(string calldata json, string calldata path) external;\n    // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key>\n    // This is useful to replace a specific value of a JSON file, without having to parse the entire thing\n    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;\n    // Returns the RPC url for the given alias\n    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);\n    // Returns all rpc urls and their aliases `[alias, url][]`\n    function rpcUrls() external view returns (string[2][] memory urls);\n    // Returns all rpc urls and their aliases as structs.\n    function rpcUrlStructs() external view returns (Rpc[] memory urls);\n    // If the condition is false, discard this run's fuzz inputs and generate new ones.\n    function assume(bool condition) external pure;\n    // Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.\n    function pauseGasMetering() external;\n    // Resumes gas metering (i.e. gas usage is counted again). Noop if already on.\n    function resumeGasMetering() external;\n}\n\ninterface Vm is VmSafe {\n    // Sets block.timestamp\n    function warp(uint256 newTimestamp) external;\n    // Sets block.height\n    function roll(uint256 newHeight) external;\n    // Sets block.basefee\n    function fee(uint256 newBasefee) external;\n    // Sets block.difficulty\n    function difficulty(uint256 newDifficulty) external;\n    // Sets block.chainid\n    function chainId(uint256 newChainId) external;\n    // Stores a value to an address' storage slot.\n    function store(address target, bytes32 slot, bytes32 value) external;\n    // Sets the nonce of an account; must be higher than the current nonce of the account\n    function setNonce(address account, uint64 newNonce) external;\n    // Sets the *next* call's msg.sender to be the input address\n    function prank(address msgSender) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n    function startPrank(address msgSender) external;\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n    function prank(address msgSender, address txOrigin) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n    function startPrank(address msgSender, address txOrigin) external;\n    // Resets subsequent calls' msg.sender to be `address(this)`\n    function stopPrank() external;\n    // Sets an address' balance\n    function deal(address account, uint256 newBalance) external;\n    // Sets an address' code\n    function etch(address target, bytes calldata newRuntimeBytecode) external;\n    // Expects an error on next call\n    function expectRevert(bytes calldata revertData) external;\n    function expectRevert(bytes4 revertData) external;\n    function expectRevert() external;\n\n    // Prepare an expected log with all four checks enabled.\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data.\n    // Second form also checks supplied address against emitting contract.\n    function expectEmit() external;\n    function expectEmit(address emitter) external;\n\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n    // Second form also checks supplied address against emitting contract.\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)\n        external;\n\n    // Mocks a call to an address, returning specified data.\n    // Calldata can either be strict or a partial match, e.g. if you only\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\n    // function will be mocked.\n    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;\n    // Mocks a call to an address with a specific msg.value, returning specified data.\n    // Calldata match takes precedence over msg.value in case of ambiguity.\n    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;\n    // Clears all mocked calls\n    function clearMockedCalls() external;\n    // Expects a call to an address with the specified calldata.\n    // Calldata can either be a strict or a partial match\n    function expectCall(address callee, bytes calldata data) external;\n    // Expects a call to an address with the specified msg.value and calldata\n    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;\n    // Expect a call to an address with the specified msg.value, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;\n    // Expect a call to an address with the specified msg.value and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;\n    // Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the current subcontext. If any other\n    // memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.\n    function expectSafeMemory(uint64 min, uint64 max) external;\n    // Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the next created subcontext.\n    // If any other memory is written to, the test will fail. Can be called multiple times to add more ranges\n    // to the set.\n    function expectSafeMemoryCall(uint64 min, uint64 max) external;\n    // Sets block.coinbase\n    function coinbase(address newCoinbase) external;\n    // Snapshot the current state of the evm.\n    // Returns the id of the snapshot that was created.\n    // To revert a snapshot use `revertTo`\n    function snapshot() external returns (uint256 snapshotId);\n    // Revert the state of the EVM to a previous snapshot\n    // Takes the snapshot id to revert to.\n    // This deletes the snapshot and all snapshots taken after the given snapshot id.\n    function revertTo(uint256 snapshotId) external returns (bool success);\n    // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);\n    // Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction,\n    // and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n    // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before\n    // the transaction, returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);\n    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256 forkId) external;\n    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.\n    function activeFork() external view returns (uint256 forkId);\n    // Updates the currently active fork to given block number\n    // This is similar to `roll` but for the currently active fork\n    function rollFork(uint256 blockNumber) external;\n    // Updates the currently active fork to given transaction\n    // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block\n    function rollFork(bytes32 txHash) external;\n    // Updates the given fork to given block number\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n    // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block\n    function rollFork(uint256 forkId, bytes32 txHash) external;\n    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    // Meaning, changes made to the state of this account will be kept when switching forks\n    function makePersistent(address account) external;\n    function makePersistent(address account0, address account1) external;\n    function makePersistent(address account0, address account1, address account2) external;\n    function makePersistent(address[] calldata accounts) external;\n    // Revokes persistent status from the address, previously added via `makePersistent`\n    function revokePersistent(address account) external;\n    function revokePersistent(address[] calldata accounts) external;\n    // Returns true if the account is marked as persistent\n    function isPersistent(address account) external view returns (bool persistent);\n    // In forking mode, explicitly grant the given address cheatcode access\n    function allowCheatcodes(address account) external;\n    // Fetches the given transaction from the active fork and executes it on the current state\n    function transact(bytes32 txHash) external;\n    // Fetches the given transaction from the given fork and executes it on the current state\n    function transact(uint256 forkId, bytes32 txHash) external;\n}\n"
    },
    "node_modules/forge-std/src/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "node_modules/forge-std/src/console2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n/// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should\n/// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n/// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n/// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n/// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, int256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,int256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "node_modules/forge-std/src/interfaces/IMulticall3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\ninterface IMulticall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    function aggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes[] memory returnData);\n\n    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function blockAndAggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n\n    function getBasefee() external view returns (uint256 basefee);\n\n    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);\n\n    function getBlockNumber() external view returns (uint256 blockNumber);\n\n    function getChainId() external view returns (uint256 chainid);\n\n    function getCurrentBlockCoinbase() external view returns (address coinbase);\n\n    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);\n\n    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);\n\n    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);\n\n    function getEthBalance(address addr) external view returns (uint256 balance);\n\n    function getLastBlockHash() external view returns (bytes32 blockHash);\n\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (Result[] memory returnData);\n\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@openzeppelin/contracts-upgradeable/=node_modules/@openzeppelin/contracts-upgradeable/",
      "@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/",
      "@rari-capital/solmate/=node_modules/@rari-capital/solmate/",
      "forge-std/=node_modules/forge-std/src/",
      "ds-test/=node_modules/ds-test/src/",
      "hardhat-deploy/=node_modules/hardhat-deploy/",
      "hardhat/=node_modules/hardhat/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "none"
    },
    "outputSelection": {
      "*": {
        "": [
          "ast"
        ],
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc"
        ]
      }
    },
    "evmVersion": "london",
    "viaIR": false,
    "libraries": {}
  }
}